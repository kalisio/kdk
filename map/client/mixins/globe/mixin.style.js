import { Transforms, Math as CesiumMath, HeadingPitchRoll, Ellipsoid } from 'cesium'
import _ from 'lodash'
import chroma from 'chroma-js'
import moment from 'moment'
import { Time, Units } from '../../../../core/client/index.js'
import { convertToCesiumFromSimpleStyle, convertToCesiumObjects, CesiumEntityTypes } from '../../utils.globe.js'

export const style = {
  methods: {
    applyStyle (entities, options) {
      for (let i = 0; i < entities.values.length; i++) {
        const entity = entities.values[i]
        const style = this.generateStyle('entityStyle', entity, options)
        // Loop over possible types
        CesiumEntityTypes.forEach(type => {
          if (entity[type] && style[type]) {
            _.merge(entity[type], style[type])
          }
        })
        // Specific case of 3D models that can be used to replace default billboards generated by cesium
        if (style.model && entity.billboard) {
          entity.billboard = undefined
          entity.model = style.model
        }
        // Handle specific case of orientation
        if (style.orientation) entity.orientation = style.orientation
        // Handle specific case of visibility
        if (_.has(style, 'visibility')) entity.show = style.visibility
      }
    },
    applyClusterStyle (entities, cluster, options) {
      const style = this.generateStyle('clusterStyle', entities, cluster, options)
      // Loop over possible styles
      const featureTypes = ['billboard', 'label', 'point']
      featureTypes.forEach(type => {
        if (_.has(cluster, type)) {
          _.merge(cluster[type], style[type])
        }
      })
    },
    // Alias to ease development
    convertFromSimpleStyle (style, inPlace) {
      return convertToCesiumFromSimpleStyle(style, inPlace)
    },
    // Alias to ease development
    convertToCesiumObjects (style) {
      return convertToCesiumObjects(style)
    },
    getDefaultEntityStyle (entity, options) {
      const properties = (entity.properties ? entity.properties.getValue(0) : null)
      const cesiumOptions = options.cesium || options
      let style = _.merge({}, _.get(this, 'activityOptions.engine.entityStyle'))
      // We allow to template entity style properties according to feature,
      // because it can be slow you have to specify a subset of properties
      const entityStyleTemplate = _.get(cesiumOptions, 'entityStyleTemplate')
      if (entityStyleTemplate) {
        const entityStyle = _.cloneDeep(cesiumOptions.entityStyle)
        entityStyleTemplate.forEach(entry => {
          // Perform templating, set using simple spec mapping first then raw if property not found
          // The whole feature is lost by Cesium so that top-level properties have disappeared
          // but we try to keep track of it eg in GeoJson layers
          let value = entry.compiler({ feature: entity.feature || { properties }, properties, chroma, moment, Units, Time })
          const property = entry.property
          // Handle specific case of orientation
          if ((property === 'orientation') && entity.position) {
            const localFrameAxes = _.get(entityStyle, 'localFrameAxes', ['east', 'north'])
            const localFrame = Transforms.localFrameToFixedFrameGenerator(...localFrameAxes)
            const position = entity.position.getValue(this.viewer.clock.currentTime)
            // From heading, pitch, roll as templated string to quaternion
            value = value.split(',').map(angle => CesiumMath.toRadians(parseFloat(angle)))
            value = new HeadingPitchRoll(...value)
            // Then from local to position frame
            value = Transforms.headingPitchRollQuaternion(position, value, Ellipsoid.WGS84, localFrame)
          }
          _.set(entityStyle, property, value)
        })
        // In this case we perform conversion to Cesium objects once templating has occured
        style = _.merge(style, this.convertToCesiumObjects(entityStyle))
      } else {
        // In this case the conversion to Cesium objects has already occured on layer creation
        style = _.merge(style, _.cloneDeep(cesiumOptions.entityStyle) || {})
      }

      // Orientation special case, when not templated
      // Orientation can be specified with an array of 3 angles in degrees [heading, pitch, roll]
      // or with properties names (e.g ['track', 0, 0] to specify track from properties and 0 for pitch and roll)
      const templatedProperties = _.get(cesiumOptions, 'entityStyleTemplate', []).map(t => t.property)
      if (_.has(cesiumOptions, 'entityStyle.orientation') && !templatedProperties.includes('orientation')) {
        const localFrameAxes = _.get(cesiumOptions, 'entityStyle.localFrameAxes', ['east', 'north'])
        const localFrame = Transforms.localFrameToFixedFrameGenerator(...localFrameAxes)
        const position = entity.position.getValue(this.viewer.clock.currentTime)
        let orientation = _.get(properties, 'entityStyle.orientation', _.get(entity, 'feature.properties.orientation'))
        if (!orientation) orientation = _.get(cesiumOptions, 'entityStyle.orientation', [])
        orientation = orientation.map(angle => {
          if (_.isString(angle)) return CesiumMath.toRadians(_.get(properties, angle, 0))
          return CesiumMath.toRadians(angle)
        })
        if (orientation.length === 3) {
          orientation = new HeadingPitchRoll(...orientation)
          orientation = Transforms.headingPitchRollQuaternion(position, orientation, Ellipsoid.WGS84, localFrame)
          _.set(style, 'orientation', orientation)
        }
      }

      if (properties && properties.entityStyle) _.merge(style, this.convertToCesiumObjects(properties.entityStyle))
      return style
    },
    getDefaultClusterStyle (entities, cluster, options) {
      const cesiumOptions = options.cesium || options
      const style = _.merge({},
        _.get(this, 'activityOptions.engine.clusterStyle'),
        cesiumOptions.clusterStyle || {})
      // Look for templated options
      if (_.has(style, 'label.text')) {
        const compiler = _.template(_.get(style, 'label.text'))
        // To avoid erasing of initial value due to reference, duplicate
        const labelStyle = _.cloneDeep(_.get(style, 'label'))
        _.set(labelStyle, 'text', compiler({ entities, cluster, $t: this.$t }))
        _.set(style, 'label', labelStyle)
      }
      return style
    }
  },
  created () {
    this.registerStyle('entityStyle', this.getDefaultEntityStyle)
    this.registerStyle('clusterStyle', this.getDefaultClusterStyle)
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount () {
    // Perform required conversion from JSON to Cesium objects
    if (_.has(this, 'activityOptions.engine.entityStyle')) {
      _.set(this, 'activityOptions.engine.entityStyle', this.convertToCesiumObjects(_.get(this, 'activityOptions.engine.entityStyle')))
    }
    if (_.has(this, 'activityOptions.engine.clusterStyle')) {
      _.set(this, 'activityOptions.engine.clusterStyle', this.convertToCesiumObjects(_.get(this, 'activityOptions.engine.clusterStyle')))
    }
  }
}
