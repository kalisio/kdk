import Cesium from 'cesium/Source/Cesium.js'
import _ from 'lodash'
import chroma from 'chroma-js'
import { CesiumStyleMappings, CesiumEntityTypes } from '../../utils.js'

export const style = {
  methods: {
    applyStyle (entities, options) {
      for (let i = 0; i < entities.values.length; i++) {
        const entity = entities.values[i]
        const style = this.generateStyle('entityStyle', entity, options)
        // Loop over possible types
        CesiumEntityTypes.forEach(type => {
          if (entity[type] && style[type]) {
            _.merge(entity[type], style[type])
          }
        })
        // Specific case of 3D models that can be used to replace default billboards generated by cesium
        if (style.model && entity.billboard) {
          entity.billboard = undefined
          entity.model = style.model
        }
        // Handle specific case of orientation
        if (style.orientation) entity.orientation = style.orientation
      }
    },
    applyClusterStyle (entities, cluster, options) {
      const style = this.generateStyle('clusterStyle', entities, cluster, options)
      // Loop over possible styles
      const featureTypes = ['billboard', 'label', 'point']
      featureTypes.forEach(type => {
        if (_.has(cluster, type)) {
          _.merge(cluster[type], style[type])
        }
      })
    },
    convertFromSimpleStyleSpec (style, inPlace = false) {
      if (!style) return {}
      const convertedStyle = (inPlace ? style : {})
      _.forOwn(style, (value, key) => {
        if (_.has(CesiumStyleMappings, key)) {
          const mapping = _.get(CesiumStyleMappings, key)
          _.set(convertedStyle, mapping, value)
          if (inPlace) _.unset(style, key)
          // Convert from string to color object as required by cesium
          if ((typeof value === 'string') && ['markerColor', 'fill', 'stroke'].includes(mapping)) {
            _.set(convertedStyle, mapping, Cesium.Color.fromCssColorString(value))
          }
        }
      })
      return convertedStyle
    },
    convertToCesiumObjects (style) {
      // Helper to convert from string to objects
      function createCesiumObject () {
        const args = Array.from(arguments)
        const constructor = args[0]
        args.shift()
        const Class = _.get(Cesium, constructor)
        // Can be callable, constructable or constant
        let object
        if (typeof Class === 'function') {
          try { object = Class(...args) } catch (error) { /* Simply avoid raising any error */ }
          try { object = new Class(...args) } catch (error) { /* Simply avoid raising any error */ }
        } else object = Class
        return object
      }
      const mapValue = (value) => {
        if (typeof value === 'object') {
          const type = value.type
          const options = value.options
          if (type && options) {
            const constructor = type.replace('Cesium.', '')
            // Take care to nested objects as constructor arguments
            let args
            if (options.type) {
              // Create argument object
              args = this.convertToCesiumObjects({ object: options })
              args = args.object
            } else {
              args = this.convertToCesiumObjects(options)
            }
            if (Array.isArray(options)) return createCesiumObject(constructor, ...args)
            else return createCesiumObject(constructor, args)
          } else return this.convertToCesiumObjects(value)
        } else if (typeof value === 'string') {
          if (value.startsWith('Cesium.')) {
            const constructor = value.replace('Cesium.', '')
            return createCesiumObject(constructor)
          }
          const n = _.toNumber(value)
          if (_.isFinite(n)) value = n
        }
        return value
      }
      if (typeof style === 'object') {
        if (Array.isArray(style)) return style.map(mapValue)
        else return _.mapValues(style, mapValue)
      } else {
        return _.mapValues({ value: style }, mapValue).value
      }
    },
    getDefaultEntityStyle (entity, options) {
      const properties = (entity.properties ? entity.properties.getValue(0) : null)
      const cesiumOptions = options.cesium || options
      let style = _.merge({}, _.get(this, 'activityOptions.engine.entityStyle'))
      // We allow to template entity style properties according to feature,
      // because it can be slow you have to specify a subset of properties
      const entityStyleTemplate = _.get(cesiumOptions, 'entityStyleTemplate')
      if (entityStyleTemplate) {
        const entityStyle = _.cloneDeep(cesiumOptions.entityStyle)
        entityStyleTemplate.forEach(entry => {
          // Perform templating, set using simple spec mapping first then raw if property not found
          let value = entry.compiler({ properties, chroma })
          const property = entry.property
          // Handle specific case of orientation
          if ((property === 'orientation') && entity.position) {
            const localFrameAxes = _.get(entityStyle, 'localFrameAxes', ['east', 'north'])
            const localFrame = Cesium.Transforms.localFrameToFixedFrameGenerator(...localFrameAxes)
            const position = entity.position.getValue(this.viewer.clock.currentTime)
            // From heading, pitch, roll as templated string to quaternion
            value = value.split(',').map(angle => Cesium.Math.toRadians(parseFloat(angle)))
            value = new Cesium.HeadingPitchRoll(...value)
            // Then from local to position frame
            value = Cesium.Transforms.headingPitchRollQuaternion(position, value, Cesium.Ellipsoid.WGS84, localFrame)
          }
          _.set(entityStyle, property, value)
        })
        // In this case we perform conversion to Cesium objects once templating has occured
        style = _.merge(style, this.convertToCesiumObjects(entityStyle))
      } else {
        // In this case the conversion to Cesium objects has already occured on layer creation
        style = _.merge(style, cesiumOptions.entityStyle || {})
      }
      if (properties && properties.entityStyle) _.merge(style, this.convertToCesiumObjects(properties.entityStyle))
      return style
    },
    getDefaultClusterStyle (entities, cluster, options) {
      const cesiumOptions = options.cesium || options
      const style = _.merge({},
        _.get(this, 'activityOptions.engine.clusterStyle'),
        cesiumOptions.clusterStyle || {})
      // Look for templated options
      if (_.has(style, 'label.text')) {
        const compiler = _.template(_.get(style, 'label.text'))
        // To avoid erasing of initial value due to reference, duplicate
        const labelStyle = _.cloneDeep(_.get(style, 'label'))
        _.set(labelStyle, 'text', compiler({ entities, cluster, $t: this.$t }))
        _.set(style, 'label', labelStyle)
      }
      return style
    }
  },
  created () {
    this.registerStyle('entityStyle', this.getDefaultEntityStyle)
    this.registerStyle('clusterStyle', this.getDefaultClusterStyle)
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount () {
    // Perform required conversion from JSON to Cesium objects
    if (_.has(this, 'activityOptions.engine.entityStyle')) {
      _.set(this, 'activityOptions.engine.entityStyle', this.convertToCesiumObjects(_.get(this, 'activityOptions.engine.entityStyle')))
    }
    if (_.has(this, 'activityOptions.engine.clusterStyle')) {
      _.set(this, 'activityOptions.engine.clusterStyle', this.convertToCesiumObjects(_.get(this, 'activityOptions.engine.clusterStyle')))
    }
  }
}
