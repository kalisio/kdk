import kf from "ajv";
import Ff from "ajv-formats";
import Df from "ajv-keywords";
import a from "lodash";
import { FeathersError as Ml } from "@feathersjs/errors";
import wi from "@turf/bbox";
import I from "loglevel";
import me from "config";
import { getFingerprint as Af, getFingerprintData as Of } from "@thumbmarkjs/thumbmarkjs";
import Bf, { LocalForage as Rf } from "@kalisio/feathers-localforage";
import { getClientService as $f } from "@kalisio/feathers-s3/client.js";
import { reactive as Rt, toRef as Ks, ref as ue, createApp as If, computed as W, markRaw as Ar, defineComponent as zf, getCurrentInstance as qe, h as K, onBeforeUnmount as je, Transition as hn, withDirectives as Nf, TransitionGroup as qf, onDeactivated as Gs, nextTick as xt, watch as _e, onMounted as Vt, onUnmounted as jf, Teleport as Uf, inject as kl, onBeforeUpdate as Vf, onActivated as Kf, toRaw as $t, defineAsyncComponent as Gf, shallowReactive as Hf, shallowRef as Fl, readonly as gi, watchEffect as Dl, onBeforeMount as Cn, unref as Bi } from "vue";
import { createI18n as Wf } from "vue-i18n";
import vt from "moment-timezone/builds/moment-timezone-with-data-10-year-range.js";
import * as Ei from "mathjs";
import Te from "sift";
import ns from "sanitize-html";
import he from "moment";
import zt from "path-browserify";
import { useRouter as Hs, useRoute as Ws } from "vue-router";
import Al from "debug";
import Zf from "papaparse";
import Es from "formatcoords";
import { image as Qf } from "@pdfme/schemas";
import { generate as Jf } from "@pdfme/generator";
import Or from "@mapbox/sphericalmercator";
import { PMTiles as Ol, zxyToTileId as Yf, findTile as Xf } from "pmtiles";
import * as Bl from "protomaps-leaflet";
import { sourcesToViews as Rl } from "protomaps-leaflet";
import Xt from "chroma-js";
import B from "leaflet";
import $l from "iso8601-js-period";
import eh from "jwt-decode";
import sn from "@feathersjs/client";
import { io as th } from "socket.io-client";
import { rx as ih } from "feathers-reactive";
import { createAliasResolver as nh, AbilityBuilder as rh, Ability as sh } from "@casl/ability";
import { toMongoQuery as oh } from "@casl/mongoose";
import ah from "email-validator";
import Vo from "ajv-i18n";
import "leaflet-realtime";
import "leaflet.markercluster/dist/MarkerCluster.css";
import "leaflet.markercluster/dist/MarkerCluster.Default.css";
import "leaflet.markercluster";
import { lineOffset as lh, point as ar, rhumbDistance as Il, rhumbBearing as zl, rhumbDestination as Nl, getType as ch } from "@turf/turf";
import * as Ee from "pixi.js";
import "leaflet-pixi-overlay";
import Cs from "jsdap/src/parser.js";
import uh from "jsdap/src/xdr.js";
import * as ql from "geotiff";
import lr from "xml2js";
import { memory as dh } from "@feathersjs/memory";
import { kml as fh, gpx as hh } from "@tmcw/togeojson";
import Ht from "shpjs";
import "leaflet/dist/leaflet.css";
import "leaflet-fullscreen";
import "leaflet-fullscreen/dist/leaflet.fullscreen.css";
import "@kalisio/leaflet.donutcluster/src/Leaflet.DonutCluster.css";
import "@kalisio/leaflet.donutcluster";
import "leaflet.geodesic";
import "@kalisio/leaflet-graphicscale";
import "@kalisio/leaflet-graphicscale/dist/Leaflet.GraphicScale.min.css";
import "leaflet.locatecontrol";
import "leaflet.locatecontrol/dist/L.Control.Locate.css";
import "leaflet-wms-header";
import "leaflet-timedimension/dist/leaflet.timedimension.control.css";
import "@geoman-io/leaflet-geoman-free";
import "@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css";
import "leaflet-velocity";
import mh from "leaflet-heatmap";
import { mapbox_style as gh } from "@kalisio/leaflet-pmtiles";
const Nn = {};
function Ft(e, t) {
  a.has(Nn, e) || a.set(Nn, e, Rt(t || {}));
  const i = a.get(Nn, e);
  function n() {
    a.forOwn(i, function(u, d) {
      a.unset(i, d);
    });
  }
  function r(u, d) {
    a.set(i, u, d);
  }
  function s(u, d) {
    return u ? a.get(i, u, d) : i;
  }
  function o(u) {
    a.unset(i, u);
  }
  function l(u) {
    return a.has(i, u);
  }
  function c(u) {
    a.forOwn(i, function(d, f) {
      u(d, f);
    });
  }
  return {
    Store: Nn,
    store: i,
    clear: n,
    set: r,
    get: s,
    unset: o,
    has: l,
    forOwn: c
  };
}
class jl {
  constructor() {
    this.__stack = {};
  }
  on(t, i, n) {
    return (this.__stack[t] || (this.__stack[t] = [])).push({
      fn: i,
      ctx: n
    }), this;
  }
  once(t, i, n) {
    const r = () => {
      this.off(t, r), i.apply(n, arguments);
    };
    return r.__callback = i, this.on(t, r, n);
  }
  emit(t) {
    const i = this.__stack[t];
    if (i !== void 0) {
      const n = [].slice.call(arguments, 1);
      i.forEach((r) => {
        r.fn.apply(r.ctx, n);
      });
    }
    return this;
  }
  off(t, i) {
    const n = this.__stack[t];
    if (n === void 0)
      return this;
    if (i === void 0)
      return delete this.__stack[t], this;
    const r = n.filter(
      (s) => s.fn !== i && s.fn.__callback !== i
    );
    return r.length !== 0 ? this.__stack[t] = r : delete this.__stack[t], this;
  }
}
const ne = new jl(), { store: Ko, set: ph, get: qn, unset: yh, has: vh } = Ft("store"), j = Object.assign(Ko, {
  get: qn,
  has: vh,
  // Override write methods to send events
  set(e, t) {
    const i = qn(e);
    ph(e, t);
    const n = a.kebabCase(`${e}-changed`);
    ne.emit(n, t, i), ne.emit("store-changed", e, t, i);
  },
  patch(e, t) {
    const i = qn(e);
    i && (Object.assign(i, t), this.set(e, i));
  },
  unset(e) {
    yh(e);
    const t = a.kebabCase(`${e}-changed`);
    ne.emit(t, void 0);
  },
  getRef(e) {
    const t = e.lastIndexOf("."), i = e.substring(t + 1), n = t < 0 ? Ko : qn(e.replace(`.${i}`, ""));
    return Ks(n, i);
  }
}), bh = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function Br({ r: e, g: t, b: i, a: n }) {
  const r = n !== void 0;
  if (e = Math.round(e), t = Math.round(t), i = Math.round(i), e > 255 || t > 255 || i > 255 || r && n > 100)
    throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
  return n = r ? (Math.round(255 * n / 100) | 256).toString(16).slice(1) : "", "#" + (i | t << 8 | e << 16 | 1 << 24).toString(16).slice(1) + n;
}
function Ul(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  e = e.replace(/^#/, ""), e.length === 3 ? e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] : e.length === 4 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]);
  const t = parseInt(e, 16);
  return e.length > 6 ? { r: t >> 24 & 255, g: t >> 16 & 255, b: t >> 8 & 255, a: Math.round((t & 255) / 2.55) } : { r: t >> 16, g: t >> 8 & 255, b: t & 255 };
}
function wh({ h: e, s: t, v: i, a: n }) {
  let r, s, o;
  t = t / 100, i = i / 100, e = e / 360;
  const l = Math.floor(e * 6), c = e * 6 - l, u = i * (1 - t), d = i * (1 - c * t), f = i * (1 - (1 - c) * t);
  switch (l % 6) {
    case 0:
      r = i, s = f, o = u;
      break;
    case 1:
      r = d, s = i, o = u;
      break;
    case 2:
      r = u, s = i, o = f;
      break;
    case 3:
      r = u, s = d, o = i;
      break;
    case 4:
      r = f, s = u, o = i;
      break;
    case 5:
      r = i, s = u, o = d;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(s * 255),
    b: Math.round(o * 255),
    a: n
  };
}
function _h({ r: e, g: t, b: i, a: n }) {
  const r = Math.max(e, t, i), s = Math.min(e, t, i), o = r - s, l = r === 0 ? 0 : o / r, c = r / 255;
  let u;
  switch (r) {
    case s:
      u = 0;
      break;
    case e:
      u = t - i + o * (t < i ? 6 : 0), u /= 6 * o;
      break;
    case t:
      u = i - e + o * 2, u /= 6 * o;
      break;
    case i:
      u = e - t + o * 4, u /= 6 * o;
      break;
  }
  return {
    h: Math.round(u * 360),
    s: Math.round(l * 100),
    v: Math.round(c * 100),
    a: n
  };
}
function ei(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  const t = e.replace(/ /g, ""), i = bh.exec(t);
  if (i === null)
    return Ul(t);
  const n = {
    r: Math.min(255, parseInt(i[2], 10)),
    g: Math.min(255, parseInt(i[3], 10)),
    b: Math.min(255, parseInt(i[4], 10))
  };
  if (i[1]) {
    const r = parseFloat(i[5]);
    n.a = Math.min(1, isNaN(r) === !0 ? 1 : r) * 100;
  }
  return n;
}
function Lh(e, t) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  if (typeof t != "number")
    throw new TypeError("Expected a numeric percent");
  const i = ei(e), n = t < 0 ? 0 : 255, r = Math.abs(t) / 100, s = i.r, o = i.g, l = i.b;
  return "#" + (16777216 + (Math.round((n - s) * r) + s) * 65536 + (Math.round((n - o) * r) + o) * 256 + (Math.round((n - l) * r) + l)).toString(16).slice(1);
}
function xh(e) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  const t = typeof e == "string" ? ei(e) : e, i = t.r / 255, n = t.g / 255, r = t.b / 255, s = i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4), o = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4), l = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
  return 0.2126 * s + 0.7152 * o + 0.0722 * l;
}
function Sh(e) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  const t = typeof e == "string" ? ei(e) : e;
  return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
}
function Eh(e, t) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as fgColor");
  if (typeof t != "string" && (!t || t.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as bgColor");
  const i = typeof e == "string" ? ei(e) : e, n = i.r / 255, r = i.g / 255, s = i.b / 255, o = i.a !== void 0 ? i.a / 100 : 1, l = typeof t == "string" ? ei(t) : t, c = l.r / 255, u = l.g / 255, d = l.b / 255, f = l.a !== void 0 ? l.a / 100 : 1, m = o + f * (1 - o), g = Math.round((n * o + c * f * (1 - o)) / m * 255), v = Math.round((r * o + u * f * (1 - o)) / m * 255), x = Math.round((s * o + d * f * (1 - o)) / m * 255), S = { r: g, g: v, b: x, a: Math.round(m * 100) };
  return typeof e == "string" ? Br(S) : S;
}
function Ch(e, t) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  if (t === void 0 || t < -1 || t > 1)
    throw new TypeError("Expected offset to be between -1 and 1");
  const { r: i, g: n, b: r, a: s } = ei(e), o = s !== void 0 ? s / 100 : 0;
  return Br({
    r: i,
    g: n,
    b: r,
    a: Math.round(Math.min(1, Math.max(0, o + t)) * 100)
  });
}
function Th(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  const t = document.createElement("div");
  t.className = `text-${e} invisible fixed no-pointer-events`, document.body.appendChild(t);
  const i = getComputedStyle(t).getPropertyValue("color");
  return t.remove(), Br(ei(i));
}
const Mt = {
  rgbToHex: Br,
  hexToRgb: Ul,
  hsvToRgb: wh,
  rgbToHsv: _h,
  textToRgb: ei,
  lighten: Lh,
  luminosity: xh,
  brightness: Sh,
  blend: Eh,
  changeAlpha: Ch,
  getPaletteColor: Th
};
function Vl(e, t = document.body) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as propName");
  if (!(t instanceof Element))
    throw new TypeError("Expected a DOM element");
  return getComputedStyle(t).getPropertyValue(`--q-${e}`).trim() || null;
}
function wt(e, t, i = document.body) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as propName");
  if (typeof t != "string")
    throw new TypeError("Expected a string as value");
  if (!(i instanceof Element))
    throw new TypeError("Expected a DOM element");
  i.style.setProperty(`--q-${e}`, t);
}
const rs = ["primary", "secondary", "accent", "dark", "info", "positive", "negative", "warning"], Ph = {
  primary: "#bf360c",
  secondary: "#bf360",
  accent: "#bf360c",
  dark: "#bf360c",
  info: "#bf360c",
  positive: "#7bb946",
  negative: "#c74a4a",
  warning: "#d09931"
}, Kl = {
  initialize() {
    this.default || (this.default = {}, rs.forEach((e) => {
      this.default[e] = Vl(e) || Ph[e];
    }));
  },
  apply(e) {
    typeof e == "string" ? (wt("primary", e), wt("secondary", Mt.lighten(e, 75)), wt("accent", Mt.lighten(e, 25)), wt("dark", Mt.lighten(e, -25)), wt("info", Mt.lighten(e, 25)), wt("positive", this.default.positive), wt("negative", this.default.negative), wt("warning", this.default.warning)) : rs.forEach((t) => {
      wt(t, a.get(e, t, this.default[t]));
    });
  },
  restore() {
    rs.forEach((e) => {
      wt(e, this.default[e]);
    });
  }
};
class Gl extends Error {
}
const Mh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KError: Gl
}, Symbol.toStringTag, { value: "Module" })), kh = nh({
  update: ["patch"],
  read: ["get", "find"],
  remove: ["delete"],
  all: ["read", "create", "update", "remove"]
}), rt = {
  member: 0,
  manager: 1,
  owner: 2
}, Rr = [
  "member",
  "manager",
  "owner"
];
let mn = [];
const Hl = "type", Zs = Symbol.for(Hl);
function Fh(e, t, i, n) {
  const r = rt[t.permissions];
  r >= rt.member && n("read", i, { _id: t._id }), r >= rt.manager && (n("update", i, { _id: t._id }), n(["create", "remove"], "authorisations", { resource: t._id })), r >= rt.owner && n("remove", i, { _id: t._id });
}
function Dh(e, t, i) {
  t("service", "users"), t("create", "users"), t("service", "account"), t(["create", "verifyEmail"], "account"), t("service", "import-export"), t("create", "import-export"), t("service", "push"), t("create", "push"), t("service", "tags"), t("create", "tags"), e && e._id && (t("read", "users"), t(["update", "remove"], "users", { _id: e._id }), t("service", "authorisations"), t("service", "storage"), t("create", "storage", { id: "avatars/" + e._id.toString() }), t("create", "storage", { id: "avatars/" + e._id.toString() + ".thumbnail" }), t(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + e._id.toString() }), t(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + e._id.toString() + ".thumbnail" }), t("remove", "storage", { _id: "avatars/" + e._id.toString() }), t("remove", "storage", { _id: "avatars/" + e._id.toString() + ".thumbnail" }), t("read", "storage", { _id: { $regex: "^avatars/*" } }));
}
async function $r(e, ...t) {
  const { build: i, can: n, cannot: r } = new rh(sh);
  return await Promise.all(mn.map(async (s) => {
    await s(e, n, r, ...t);
  })), i({
    detectSubjectType: (s) => !s || typeof s == "string" ? s : s[Zs],
    resolveAction: kh
  });
}
$r.registerHook = function(e) {
  mn.includes(e) || mn.push(e);
};
$r.unregisterHook = function(e) {
  mn = mn.filter((t) => t !== e);
};
function Wl(e, t) {
  if (!e) return !1;
  const i = typeof t == "string" ? t : t.getPath(), n = a.replace(i, /^.*\//, "*/");
  return e.can("service", i) || e.can("service", `*/${i}`) || e.can("service", n);
}
function Zl(e, t, i, n, r) {
  if (!e) return !1;
  const s = Object.assign({}, r);
  return s[Zs] = i, n && (s.context = typeof n == "object" ? n._id.toString() : n.toString()), e.can(t, s);
}
function cr(e) {
  return a.forOwn(e, (t, i) => {
    i === "context" ? delete e.context : Array.isArray(t) ? (t.forEach((n) => cr(n)), a.isEmpty(t) && delete e[i]) : typeof t == "object" && (cr(t), a.isEmpty(t) && delete e[i]);
  }), e;
}
function Ah(e, t, i) {
  if (!e) return null;
  const n = oh(e, i, t);
  return n ? cr(a.cloneDeep(n)) : null;
}
function Ql(e, t, i) {
  const n = { [e]: { $elemMatch: { _id: t } } };
  return i && a.set(n[e], "$elemMatch.permissions", typeof i == "string" ? i : Rr[i]), n;
}
function Oh(e, t, i, n) {
  const r = Ql(t, i, n);
  return e.find({ query: r });
}
function Bh(e, t, i, n) {
  const r = Ql(t, i, n);
  return r.$limit = 0, e.find({ query: r });
}
function Rh(e, t) {
  return rt[e] >= rt[t];
}
function $h(e, t) {
  return rt[e] < rt[t];
}
function Ih(e) {
  const t = [];
  return a.forEach(rt, (i) => {
    rt[e] < i && t.push(Rr[i]);
  }), t;
}
function zh(e) {
  const t = [];
  return a.forEach(rt, (i) => {
    rt[e] >= i && t.push(Rr[i]);
  }), t;
}
const Nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RESOURCE_TYPE: Hl,
  RESOURCE_TYPE_KEY: Zs,
  RoleNames: Rr,
  Roles: rt,
  countSubjectsForResource: Bh,
  defineAbilities: $r,
  defineResourceRules: Fh,
  defineUserAbilities: Dh,
  findSubjectsForResource: Oh,
  getJuniorRoles: zh,
  getQueryForAbilities: Ah,
  getSeniorRoles: Ih,
  hasResourceAbilities: Zl,
  hasServiceAbilities: Wl,
  isJuniorRole: $h,
  isSeniorRole: Rh,
  removeContext: cr
}, Symbol.toStringTag, { value: "Module" })), qh = {
  allErrors: !0,
  strict: !1,
  $data: !0,
  keywords: ["field"]
}, Qs = {
  initialize(e) {
    this.ajv = new kf(e || qh), Df(this.ajv), Ff(this.ajv);
  },
  register(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    if (!e.$id) throw new Error("the schema must have an `$id` property");
    return this.ajv.getSchema(e.$id) || this.ajv.compile(e);
  },
  addKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.addKeyword(e);
  },
  getKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    return this.ajv.getKeyword(e);
  },
  removeKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.removeKeyword(e);
  }
}, Go = Al("kdk:core:offline");
async function Jl(e, t) {
  let { baseQuery: i, baseQueries: n, offlineService: r, dataPath: s = "data" } = t, o = [];
  n || (n = [i]);
  for (let l = 0; l < n.length; l++) {
    const c = Object.assign({ $skip: 0 }, n[l]);
    Go(`[KDK] making service snapshot with query ${JSON.stringify(c)}`), r && a.get(t, "clear", !0) && await r.remove(null, { query: a.omit(n[l], ["$limit"]) });
    let u = await e.find({ query: c }), d = a.get(u, s) || u;
    if (r && await r.create(d, { addId: !1, snapshot: !0 }), o = o.concat(d), !a.get(u, s)) return o;
    const { total: f, limit: m } = u;
    for (; c.$skip + d.length < f; )
      c.$skip += m, Go(`[KDK] getting service ${e.name} next page with query ${JSON.stringify(c)}`), u = await e.find({ query: c }), d = a.get(u, s), r ? await r.create(d, { addId: !1, snapshot: !0 }) : o = o.concat(d);
  }
  return o;
}
function Yl(e, t, i) {
  const n = e.includes("?") ? "&" : "?";
  return `${e}${n}${t}=${Array.isArray(i) ? JSON.stringify(i) : i}`;
}
function Tn(e, t) {
  let i = e;
  return a.forOwn(t, function(n, r) {
    i = Yl(i, r, n);
  }), i;
}
function Xl(e, t) {
  return encodeURI(Xl());
}
function jh(e, t = {}) {
  const i = ["a,á,à,ä,â,ã", "e,é,ë,è,ê", "i,í,ï,ì,î", "o,ó,ö,ò,õ,ô", "u,ü,ú,ù,û", "c,ç"];
  let n = "";
  for (const r of e) {
    const s = i.find((o) => t.reverse ? o.includes(r) : o[0] === r);
    s ? n += `[${s}]` : n += r;
  }
  return n;
}
const Se = {
  initialize() {
    const e = { name: "offline_cache", storeName: "cache_entries" };
    this.storage = Rf.createInstance(e), I.debug("[KDK] LocalForage initialized with configuration:", e);
  },
  getStorage() {
    return this.storage;
  },
  async getItem(e) {
    return await this.storage.getItem(e);
  },
  async setItem(e, t) {
    await this.storage.setItem(e, t);
  },
  async removeItem(e) {
    return await this.storage.removeItem(e);
  },
  async createCache(e) {
    return await caches.open(e);
  },
  async getCache(e) {
    return await caches.open(e);
  },
  async removeCache(e) {
    await caches.delete(e);
  },
  async has(e) {
    return !a.isNil(this.getCount(e));
  },
  async getCount(e) {
    return await this.storage.getItem(e);
  },
  async setCount(e, t) {
    await this.storage.setItem(e, t);
  },
  async set(e, t, i, n = {}) {
    const r = await this.getCount(t);
    if (!a.isNil(r))
      await this.setCount(t, r + 1);
    else {
      const s = await this.getCache(e);
      let o = await fetch(i, n);
      o.status === 206 && (o = new Response(o.body, { status: 200, headers: o.headers })), await s.put(t, o), await this.storage.setItem(t, 1);
    }
  },
  async unset(e, t) {
    const i = await this.getCache(e), n = await this.getCount(t);
    a.isNil(n) || (n <= 1 ? (i.delete(t), await this.storage.removeItem(t)) : await this.setCount(t, n - 1));
  }
};
function Uh(e) {
  a.get(e, `params.skip-${e.type}-event`) || ne.emit(e.type + "-hook", e);
}
function Vh(e) {
  let t = `[KDK] ${e.type}: ${e.path} - Method: ${e.method}`;
  e.type === "error" && (t += `: ${e.error.message}`), I.debug(t), e.error && I.error(e.error), e.data && I.trace(e.data), e.params && I.trace(e.params), e.result && I.trace(e.result);
}
let ss, jn = 0;
const Ve = new Array(256);
for (let e = 0; e < 256; e++)
  Ve[e] = (e + 256).toString(16).substring(1);
const Kh = (() => {
  const e = typeof crypto < "u" ? crypto : typeof window < "u" ? window.crypto || window.msCrypto : void 0;
  if (e !== void 0) {
    if (e.randomBytes !== void 0)
      return e.randomBytes;
    if (e.getRandomValues !== void 0)
      return (t) => {
        const i = new Uint8Array(t);
        return e.getRandomValues(i), i;
      };
  }
  return (t) => {
    const i = [];
    for (let n = t; n > 0; n--)
      i.push(Math.floor(Math.random() * 256));
    return i;
  };
})(), Ho = 4096;
function ti() {
  (ss === void 0 || jn + 16 > Ho) && (jn = 0, ss = Kh(Ho));
  const e = Array.prototype.slice.call(ss, jn, jn += 16);
  return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, Ve[e[0]] + Ve[e[1]] + Ve[e[2]] + Ve[e[3]] + "-" + Ve[e[4]] + Ve[e[5]] + "-" + Ve[e[6]] + Ve[e[7]] + "-" + Ve[e[8]] + Ve[e[9]] + "-" + Ve[e[10]] + Ve[e[11]] + Ve[e[12]] + Ve[e[13]] + Ve[e[14]] + Ve[e[15]];
}
function Js(e) {
  const t = e.params;
  a.unset(t, "query.$locale"), a.unset(t, "query.$collation"), a.unset(t, "query.populate"), a.has(t, "query.upsert") && (a.set(t, "upsert", a.get(t, "query.upsert")), a.unset(t, "query.upsert"));
}
function Ys(e) {
  if (e.params.snapshot) return;
  (Array.isArray(e.data) ? e.data : [e.data]).filter((n) => !n._id).forEach((n) => {
    n._id = ti().toString();
  });
}
function Xs(e) {
  e.data && (e.data = a.cloneDeep(e.data));
}
async function Gh(e) {
  const t = e.app.getService("account");
  try {
    await t.create({
      action: "checkUnique",
      value: { email: e.data.email }
    }, {
      // As we manage error we make this call transparent from the client perspective
      // This will avoid displaying an error message twice
      "skip-before-event": !0,
      "skip-after-event": !0,
      "skip-error-event": !0
    });
  } catch (i) {
    throw i.code === 400 && (i.data.translation = { key: "EMAIL_ALREADY_TAKEN" }), i;
  }
  return e;
}
const Hh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkUnique: Gh,
  emit: Uh,
  ensureSerializable: Xs,
  generateId: Ys,
  log: Vh,
  removeServerSideParameters: Js
}, Symbol.toStringTag, { value: "Module" }));
sn.authentication.AuthenticationClient.prototype.handleSocket = () => {
};
async function eo(e) {
  a.get(me, "logs.level") ? I.setLevel(a.get(me, "logs.level"), !1) : I.setLevel("info");
  const t = sn();
  t.isDisconnected = !navigator.onLine, addEventListener("online", () => {
    t.isDisconnected = !1, ne.emit("navigator-reconnected", t);
  }), addEventListener("offline", () => {
    t.isDisconnected = !0, ne.emit("navigator-disconnected", t);
  }), t.useLocalFirst = e.useLocalFirst, t.setLocalFirstEnabled = function(s) {
    t.useLocalFirst = s;
  };
  let i = [];
  function n(s) {
    const o = Object.keys(s).filter((c) => c.charCodeAt(0) === 36);
    let l = a.omit(s, ...o);
    a.forOwn(l, (c, u) => {
      typeof c == "object" && a.has(c, "$search") && (l[u] = { $regex: new RegExp(a.get(c, "$search"), "i") });
    });
    for (const c of i)
      l = c(l);
    return Te(l);
  }
  t.registerMatcher = function(s) {
    i.includes(s) || i.push(s);
  }, t.unregisterMatcher = function(s) {
    i = i.filter((o) => o !== s);
  }, t.matcher = n, t.getServicePath = function(s, o, l = !0) {
    let c = s;
    return a.isEmpty(o) || (typeof o == "string" ? o !== "global" && (c = o + "/" + s) : o._id && (c = o._id + "/" + s)), l && (c = e.apiPath + "/" + c), c.startsWith("/") && (c = c.substr(1)), c;
  }, t.getServiceInstance = function(s, o, l = {}) {
    let c;
    if (a.isEmpty(o)) {
      const u = j.get("context"), d = t.getServicePath(s, u), f = t.services[d], m = t.getServicePath(s), g = t.services[m];
      c = f || g, !c && l.create && (c = t.service(m));
    } else {
      const u = t.getServicePath(s, o);
      c = l.create ? t.service(u) : t.services[u];
    }
    return c;
  }, t.getOnlineService = function(s, o, l = {}) {
    return t.getServiceInstance(s, o, Object.assign({ create: !0 }, l));
  }, t.getOfflineService = function(s, o, l = {}) {
    return t.getServiceInstance(`${s}-offline`, o, Object.assign({ create: !1 }, l));
  }, t.getService = function(s, o, l = {}) {
    let c;
    if ((t.isDisconnected || t.useLocalFirst) && (c = t.getOfflineService(s, o, l), !c && !t.useLocalFirst && I.warn("[KDK] Cannot retrieve offline service " + s + " for context " + (typeof o == "object" ? o._id : o))), !c && (c = t.getOnlineService(s, o, l), !c))
      throw new Error("Cannot retrieve service " + s + " for context " + (typeof o == "object" ? o._id : o));
    return c;
  }, t.createService = function(s, o = {}) {
    const l = t.getServicePath(s, o.context);
    let c = o.service;
    return typeof c == "function" && (c = c(s, t, o)), c || (c = t.transporter.service(l)), t.use(l, c, o), c = t.service(l), o.hooks && c.hooks(o.hooks), o.context && (c.context = o.context), c.path = l, c;
  }, t.createOfflineService = async function(s, o = {}) {
    const l = `${s}-offline`;
    let c = t.getOfflineService(s);
    if (!c) {
      const u = a.omit(o, ["hooks", "snapshot", "clear", "baseQuery", "baseQueries", "dataPath"]), d = await Se.getItem("services") || {};
      a.set(d, s, u), await Se.setItem("services", d), c = t.createService(l, {
        service: Bf({
          id: "_id",
          name: "offline_services",
          storeName: s,
          multi: !0,
          storage: ["IndexedDB"],
          // FIXME: this should not be hard-coded as it depends on the service
          // For now we set it at the max value but if a component
          // does not explicitly set the limit it will get a lot of data
          paginate: { default: 5e3, max: 5e3 }
        }),
        // Set required default hooks
        hooks: a.defaultsDeep(a.get(o, "hooks"), {
          before: {
            all: [Xs, Js],
            create: [Ys]
          }
        }),
        ...u
      });
    }
    if (a.get(o, "snapshot", !0)) {
      const u = t.getOnlineService(s);
      await Jl(u, Object.assign({ offlineService: c }, o));
    }
    return c;
  }, t.removeService = function(s, o) {
    const l = t.getServicePath(s, o);
    t.unuse(l);
  }, t.getConfig = function(s) {
    return s ? a.get(e, s) : e;
  }, t.setConfig = function(s, o) {
    a.set(e, s, o);
  }, t.hasConfig = function(s, o) {
    return a.has(e, s, o);
  }, t.can = function() {
    let s, o, l;
    const c = arguments[arguments.length - 1], u = a.has(c, "abilities"), d = u ? arguments.length - 1 : arguments.length, f = arguments[0];
    s = arguments[1], d === 4 ? (o = arguments[2], l = arguments[3]) : typeof arguments[2] == "string" ? o = arguments[2] : l = arguments[2], a.has(s, "abilities") && (s = void 0), a.has(o, "abilities") && (o = void 0), a.has(l, "abilities") && (l = void 0);
    const m = u ? a.get(c, "abilities") : j.get("user.abilities");
    if (I.debug("[KDK] Check for abilities ", f, s, o, l, m), !m)
      return I.debug("[KDK] Access denied without abilities"), !1;
    let g;
    if (s) {
      const v = t.getServicePath(s, o, !1);
      if (g = Wl(m, v), g) {
        if (f === "service")
          return !0;
      } else return I.debug("[KDK] Access to service path " + v + " denied"), !1;
      g = Zl(m, f, s, o, l);
    } else
      g = m.can(f);
    return g ? I.debug("[KDK] Access to resource granted") : I.debug("[KDK] Access to resource denied"), g;
  };
  const r = t.getConfig("domain");
  if (e.transport === "http" ? (t.transporter = sn.rest(r).fetch(window.fetch.bind(window)), t.configure(t.transporter)) : (t.socket = th(r, {
    transports: ["websocket"],
    path: (e.apiPath || "/") + "ws"
  }), t.transporter = sn.socketio(t.socket, { timeout: e.apiTimeout || 1e4 }), t.configure(t.transporter), t.socket.on("rate-limit", (s) => ne.emit("error", s)), t.socket.io.on("reconnect", async () => {
    t.isDisconnected = !1, t.socket.sendBuffer = [], await t.reAuthenticate(!0), ne.emit("websocket-reconnected", t), I.info("[KDK] Socket has been reconnected");
  }), t.socket.io.on("reconnect_error", () => {
    t.isDisconnected = !0, ne.emit("websocket-disconnected", t), I.error(new Error("[KDK] Socket has been disconnected"));
  })), t.configure(sn.authentication({
    storage: window.localStorage,
    storageKey: e.apiJwt || "feathers-jwt",
    path: e.apiPath + "/authentication"
  })), t.configure(ih({
    idField: "_id",
    matcher: n
    // Our custom matcher to handle fuzzy search
  })), t.renewJwtOnExpiration = function(s) {
    const { accessToken: o } = s, l = eh(o);
    if (!l.exp) return;
    const c = he(), d = he.unix(l.exp).diff(c) - 2e3;
    setTimeout(() => {
      t.reAuthenticate(!0);
    }, d);
  }, a.get(e, "renewJwt", !0) && t.on("login", t.renewJwtOnExpiration), t.configure = async function(s) {
    return await s.call(this, this), this;
  }, t.getConfig("domain") || t.setConfig("domain", window.location.origin), !t.isDisconnected)
    try {
      const s = new URL(t.getConfig("domain") + e.apiPath + "/capabilities");
      s.searchParams.set("random", Math.random().toFixed(18).substring(2, 18)), await window.fetch(s.toString(), { method: "HEAD" });
    } catch (s) {
      t.isDisconnected = !0, ne.emit("navigator-disconnected", t), I.warn(`[KDK] Cannot request target domain ${t.getConfig("domain")}, setting state to offline`, s);
    }
  return t;
}
let G;
async function Wh(e) {
  return G = await eo(me), e && e.call(G, me), G;
}
const nt = {
  serviceName: null,
  service: null,
  initialize() {
    this.serviceName = a.get(me, "context.service"), a.isEmpty(this.serviceName) || (j.set("context", null), I.debug(`[KDK] Context configured with service '${this.serviceName}'`));
  },
  get() {
    return j.get("context");
  },
  getId() {
    return a.get(this.get(), "_id");
  },
  getRef() {
    return j.getRef("context");
  },
  getService() {
    if (a.isEmpty(this.serviceName)) throw new Error("[KDK] Context service undefined !");
    if (this.service) return this.service;
    if (this.service = G.getService(this.serviceName), a.isNil(this.service)) throw new Error("[KDK] Context service not found !");
    return this.service;
  },
  set(e) {
    j.set("context", e);
  }
};
function Ui(e, t, i, n) {
  return Object.defineProperty(e, t, {
    get: i,
    set: n,
    enumerable: !0
  }), e;
}
const ii = ue(
  !1
);
let Ir;
function Zh(e, t) {
  const i = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(vivaldi)[\/]([\w.]+)/.exec(e) || /(chrome|crios)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(firefox|fxios)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(e) || [];
  return {
    browser: i[5] || i[3] || i[1] || "",
    version: i[2] || i[4] || "0",
    versionNumber: i[4] || i[2] || "0",
    platform: t[0] || ""
  };
}
function Qh(e) {
  return /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(silk)/.exec(e) || /(android)/.exec(e) || /(win)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || /(playbook)/.exec(e) || /(bb)/.exec(e) || /(blackberry)/.exec(e) || [];
}
const ec = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function Jh(e) {
  Ir = { is: { ...e } }, delete e.mac, delete e.desktop;
  const t = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(e, {
    mobile: !0,
    ios: !0,
    platform: t,
    [t]: !0
  });
}
function Yh(e) {
  const t = e.toLowerCase(), i = Qh(t), n = Zh(t, i), r = {};
  n.browser && (r[n.browser] = !0, r.version = n.version, r.versionNumber = parseInt(n.versionNumber, 10)), n.platform && (r[n.platform] = !0);
  const s = r.android || r.ios || r.bb || r.blackberry || r.ipad || r.iphone || r.ipod || r.kindle || r.playbook || r.silk || r["windows phone"];
  return s === !0 || t.indexOf("mobile") > -1 ? (r.mobile = !0, r.edga || r.edgios ? (r.edge = !0, n.browser = "edge") : r.crios ? (r.chrome = !0, n.browser = "chrome") : r.fxios && (r.firefox = !0, n.browser = "firefox")) : r.desktop = !0, (r.ipod || r.ipad || r.iphone) && (r.ios = !0), r["windows phone"] && (r.winphone = !0, delete r["windows phone"]), (r.chrome || r.opr || r.safari || r.vivaldi || r.mobile === !0 && r.ios !== !0 && s !== !0) && (r.webkit = !0), r.edg && (n.browser = "edgechromium", r.edgeChromium = !0), (r.safari && r.blackberry || r.bb) && (n.browser = "blackberry", r.blackberry = !0), r.safari && r.playbook && (n.browser = "playbook", r.playbook = !0), r.opr && (n.browser = "opera", r.opera = !0), r.safari && r.android && (n.browser = "android", r.android = !0), r.safari && r.kindle && (n.browser = "kindle", r.kindle = !0), r.safari && r.silk && (n.browser = "silk", r.silk = !0), r.vivaldi && (n.browser = "vivaldi", r.vivaldi = !0), r.name = n.browser, r.platform = n.platform, t.indexOf("electron") > -1 ? r.electron = !0 : document.location.href.indexOf("-extension://") > -1 ? r.bex = !0 : (window.Capacitor !== void 0 ? (r.capacitor = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "capacitor") : (window._cordovaNative !== void 0 || window.cordova !== void 0) && (r.cordova = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "cordova"), ec === !0 && r.mac === !0 && (r.desktop === !0 && r.safari === !0 || r.nativeMobile === !0 && r.android !== !0 && r.ios !== !0 && r.ipad !== !0) && Jh(r)), r;
}
const Wo = navigator.userAgent || navigator.vendor || window.opera, Xh = {
  has: {
    touch: !1,
    webStorage: !1
  },
  within: { iframe: !1 }
}, ke = {
  userAgent: Wo,
  is: Yh(Wo),
  has: {
    touch: ec
  },
  within: {
    iframe: window.self !== window.top
  }
}, pi = {
  install(e) {
    const { $q: t } = e;
    ii.value === !0 ? (e.onSSRHydrated.push(() => {
      Object.assign(t.platform, ke), ii.value = !1, Ir = void 0;
    }), t.platform = Rt(this)) : t.platform = this;
  }
};
{
  let e;
  Ui(ke.has, "webStorage", () => {
    if (e !== void 0)
      return e;
    try {
      if (window.localStorage)
        return e = !0, !0;
    } catch {
    }
    return e = !1, !1;
  }), ke.is.ios === !0 && window.navigator.vendor.toLowerCase().indexOf("apple"), ii.value === !0 ? Object.assign(pi, ke, Ir, Xh) : Object.assign(pi, ke);
}
const It = {
  async initialize() {
    a.merge(this, a.omit(pi, ["install", "__installed"])), this.fingerprint = await Af(), this.fingerprintData = await Of(), this.is.pwa = a.get(me, "buildMode", "spa") === "pwa", I.debug("[KDK] Platform initialized with:", this);
  },
  getData(e) {
    const t = {
      userAgent: this.userAgent,
      application: {
        mode: this.is.pwa ? "PWA" : "SPA",
        iframe: this.within.iframe,
        permissions: a.get(this.fingerprintData, "permissions")
      },
      browser: Object.assign(
        {},
        a.get(this.fingerprintData, "system.browser"),
        { locale: a.get(this.fingerprintData, "locales") },
        { webgl: a.get(this.fingerprintData, "hardware.videocard") }
      ),
      system: {
        os: a.get(this.fingerprintData, "system.platform"),
        desktop: this.is.desktop || !1,
        mobile: this.is.mobile || !1,
        touch: this.is.touch || !1
      }
    };
    return a.isEmpty(e) ? t : a.get(t, e);
  }
}, ur = {
  async initialize() {
    if ((G.isDisconnected || G.useLocalFirst) && (this.content = await Se.getItem("capabilities")), !this.content) {
      const e = await window.fetch(G.getConfig("domain") + a.get(me, "apiPath") + "/capabilities");
      this.content = await e.json(), await Se.setItem("capabilities", this.content);
    }
    I.debug("[KDK] Capabilities initialized with content:", this.content), this.content && (a.forOwn(a.pick(this.content, ["gateway"]), (e, t) => {
      G.setConfig(t, e);
    }), j.set("capabilities.api", this.content), j.set("capabilities.client", a.pick(me, ["version", "buildNumber"])));
  },
  get(e, t) {
    if (!this.content) I.error(new Error("[KDK] Capabilities must be initialized first"));
    else return a.get(this.content, e, t);
  }
}, Xe = {
  initialize() {
    this.prefix = a.get(me, "appSlug", a.kebabCase(a.get(me, "appName", "kdk"))), I.debug(`[KDK] LocalStorage initialized with prefix: '${this.prefix}'`);
  },
  localKey(e) {
    const t = `${this.prefix}-`;
    return a.startsWith(t) ? e : `${t}${e}`;
  },
  set(e, t) {
    const i = JSON.stringify(t);
    window.localStorage.setItem(this.localKey(e), i);
  },
  has(e) {
    const t = window.localStorage.getItem(this.localKey(e));
    return !a.isNil(t);
  },
  get(e, t) {
    const i = window.localStorage.getItem(this.localKey(e));
    return a.isNil(i) ? (I.debug(`[KDK] Cannot find local storage value with key '${e}'. Returning default value '${t}'`), t) : JSON.parse(i);
  },
  clear(e) {
    window.localStorage.removeItem(this.localKey(e));
  }
}, tc = {
  initialize() {
    this.channelName = a.get(me, "appSlug", a.kebabCase(a.get(me, "appName", "kdk"))), this.channel = new BroadcastChannel(this.channelName), I.debug(`[KDK] Broadcaster initialized with channel '${this.channelName}'`);
  },
  getChannelName() {
    return this.channelName;
  },
  getChannel() {
    return this.channel;
  },
  post(e) {
    this.channel.postMessage(e);
  }
}, Vi = (e, t) => {
  const i = Rt(e);
  for (const n in e)
    Ui(
      t,
      n,
      () => i[n],
      (r) => {
        i[n] = r;
      }
    );
  return t;
}, ct = {
  hasPassive: !1,
  passiveCapture: !0,
  notPassiveCapture: !0
};
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(ct, {
        hasPassive: !0,
        passive: { passive: !0 },
        notPassive: { passive: !1 },
        passiveCapture: { passive: !0, capture: !0 },
        notPassiveCapture: { passive: !1, capture: !0 }
      });
    }
  });
  window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e);
} catch {
}
function Ri() {
}
function em(e) {
  return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), {
    top: e.clientY,
    left: e.clientX
  };
}
function tm(e) {
  if (e.path)
    return e.path;
  if (e.composedPath)
    return e.composedPath();
  const t = [];
  let i = e.target;
  for (; i; ) {
    if (t.push(i), i.tagName === "HTML")
      return t.push(document), t.push(window), t;
    i = i.parentElement;
  }
}
function dr(e) {
  e.stopPropagation();
}
function ki(e) {
  e.cancelable !== !1 && e.preventDefault();
}
function dt(e) {
  e.cancelable !== !1 && e.preventDefault(), e.stopPropagation();
}
function im(e, t, i) {
  const n = `__q_${t}_evt`;
  e[n] = e[n] !== void 0 ? e[n].concat(i) : i, i.forEach((r) => {
    r[0].addEventListener(r[1], e[r[2]], ct[r[3]]);
  });
}
function nm(e, t) {
  const i = `__q_${t}_evt`;
  e[i] !== void 0 && (e[i].forEach((n) => {
    n[0].removeEventListener(n[1], e[n[2]], ct[n[3]]);
  }), e[i] = void 0);
}
function ic(e, t = 250, i) {
  let n = null;
  function r() {
    const s = arguments, o = () => {
      n = null, e.apply(this, s);
    };
    n !== null && clearTimeout(n), n = setTimeout(o, t);
  }
  return r.cancel = () => {
    n !== null && clearTimeout(n);
  }, r;
}
const os = ["sm", "md", "lg", "xl"], { passive: Zo } = ct, ht = Vi({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0
  },
  gt: {
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1
  },
  xs: !0,
  sm: !1,
  md: !1,
  lg: !1,
  xl: !1
}, {
  setSizes: Ri,
  setDebounce: Ri,
  install({ $q: e, onSSRHydrated: t }) {
    if (e.screen = this, this.__installed === !0) {
      e.config.screen !== void 0 && (e.config.screen.bodyClasses === !1 ? document.body.classList.remove(`screen--${this.name}`) : this.__update(!0));
      return;
    }
    const { visualViewport: i } = window, n = i || window, r = document.scrollingElement || document.documentElement, s = i === void 0 || ke.is.mobile === !0 ? () => [
      Math.max(window.innerWidth, r.clientWidth),
      Math.max(window.innerHeight, r.clientHeight)
    ] : () => [
      i.width * i.scale + window.innerWidth - r.clientWidth,
      i.height * i.scale + window.innerHeight - r.clientHeight
    ], o = e.config.screen !== void 0 && e.config.screen.bodyClasses === !0;
    this.__update = (f) => {
      const [m, g] = s();
      if (g !== this.height && (this.height = g), m !== this.width)
        this.width = m;
      else if (f !== !0)
        return;
      let v = this.sizes;
      this.gt.xs = m >= v.sm, this.gt.sm = m >= v.md, this.gt.md = m >= v.lg, this.gt.lg = m >= v.xl, this.lt.sm = m < v.sm, this.lt.md = m < v.md, this.lt.lg = m < v.lg, this.lt.xl = m < v.xl, this.xs = this.lt.sm, this.sm = this.gt.xs === !0 && this.lt.md === !0, this.md = this.gt.sm === !0 && this.lt.lg === !0, this.lg = this.gt.md === !0 && this.lt.xl === !0, this.xl = this.gt.lg, v = this.xs === !0 && "xs" || this.sm === !0 && "sm" || this.md === !0 && "md" || this.lg === !0 && "lg" || "xl", v !== this.name && (o === !0 && (document.body.classList.remove(`screen--${this.name}`), document.body.classList.add(`screen--${v}`)), this.name = v);
    };
    let l, c = {}, u = 16;
    this.setSizes = (f) => {
      os.forEach((m) => {
        f[m] !== void 0 && (c[m] = f[m]);
      });
    }, this.setDebounce = (f) => {
      u = f;
    };
    const d = () => {
      const f = getComputedStyle(document.body);
      f.getPropertyValue("--q-size-sm") && os.forEach((m) => {
        this.sizes[m] = parseInt(f.getPropertyValue(`--q-size-${m}`), 10);
      }), this.setSizes = (m) => {
        os.forEach((g) => {
          m[g] && (this.sizes[g] = m[g]);
        }), this.__update(!0);
      }, this.setDebounce = (m) => {
        l !== void 0 && n.removeEventListener("resize", l, Zo), l = m > 0 ? ic(this.__update, m) : this.__update, n.addEventListener("resize", l, Zo);
      }, this.setDebounce(u), Object.keys(c).length !== 0 ? (this.setSizes(c), c = void 0) : this.__update(), o === !0 && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    ii.value === !0 ? t.push(d) : d();
  }
}), Ge = Vi({
  isActive: !1,
  mode: !1
}, {
  __media: void 0,
  set(e) {
    Ge.mode = e, e === "auto" ? (Ge.__media === void 0 && (Ge.__media = window.matchMedia("(prefers-color-scheme: dark)"), Ge.__updateMedia = () => {
      Ge.set("auto");
    }, Ge.__media.addListener(Ge.__updateMedia)), e = Ge.__media.matches) : Ge.__media !== void 0 && (Ge.__media.removeListener(Ge.__updateMedia), Ge.__media = void 0), Ge.isActive = e === !0, document.body.classList.remove(`body--${e === !0 ? "light" : "dark"}`), document.body.classList.add(`body--${e === !0 ? "dark" : "light"}`);
  },
  toggle() {
    Ge.set(Ge.isActive === !1);
  },
  install({ $q: e, onSSRHydrated: t, ssrContext: i }) {
    const { dark: n } = e.config;
    if (e.dark = this, this.__installed === !0 && n === void 0)
      return;
    this.isActive = n === !0;
    const r = n !== void 0 ? n : !1;
    if (ii.value === !0) {
      const s = (l) => {
        this.__fromSSR = l;
      }, o = this.set;
      this.set = s, s(r), t.push(() => {
        this.set = o, this.set(this.__fromSSR);
      });
    } else
      this.set(r);
  }
}), nc = () => !0;
function rm(e) {
  return typeof e == "string" && e !== "" && e !== "/" && e !== "#/";
}
function sm(e) {
  return e.startsWith("#") === !0 && (e = e.substring(1)), e.startsWith("/") === !1 && (e = "/" + e), e.endsWith("/") === !0 && (e = e.substring(0, e.length - 1)), "#" + e;
}
function om(e) {
  if (e.backButtonExit === !1)
    return () => !1;
  if (e.backButtonExit === "*")
    return nc;
  const t = ["#/"];
  return Array.isArray(e.backButtonExit) === !0 && t.push(
    ...e.backButtonExit.filter(rm).map(sm)
  ), () => t.includes(window.location.hash);
}
const Ts = {
  __history: [],
  add: Ri,
  remove: Ri,
  install({ $q: e }) {
    if (this.__installed === !0)
      return;
    const { cordova: t, capacitor: i } = ke.is;
    if (t !== !0 && i !== !0)
      return;
    const n = e.config[t === !0 ? "cordova" : "capacitor"];
    if (n !== void 0 && n.backButton === !1 || // if we're on Capacitor mode
    i === !0 && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0))
      return;
    this.add = (o) => {
      o.condition === void 0 && (o.condition = nc), this.__history.push(o);
    }, this.remove = (o) => {
      const l = this.__history.indexOf(o);
      l >= 0 && this.__history.splice(l, 1);
    };
    const r = om(
      Object.assign(
        { backButtonExit: !0 },
        n
      )
    ), s = () => {
      if (this.__history.length) {
        const o = this.__history[this.__history.length - 1];
        o.condition() === !0 && (this.__history.pop(), o.handler());
      } else r() === !0 ? navigator.app.exitApp() : window.history.back();
    };
    t === !0 ? document.addEventListener("deviceready", () => {
      document.addEventListener("backbutton", s, !1);
    }) : window.Capacitor.Plugins.App.addListener("backButton", s);
  }
}, Qo = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (e) => e ? `Expand "${e}"` : "Expand",
    collapse: (e) => e ? `Collapse "${e}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: !1,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (e) => e === 1 ? "1 record selected." : (e === 0 ? "No" : e) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (e, t, i) => e + "-" + t + " of " + i,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function Jo() {
  const e = Array.isArray(navigator.languages) === !0 && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof e == "string")
    return e.split(/[-_]/).map((t, i) => i === 0 ? t.toLowerCase() : i > 1 || t.length < 4 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1).toLowerCase()).join("-");
}
const _t = Vi({
  __langPack: {}
}, {
  getLocale: Jo,
  set(e = Qo, t) {
    const i = {
      ...e,
      rtl: e.rtl === !0,
      getLocale: Jo
    };
    {
      if (i.set = _t.set, _t.__langConfig === void 0 || _t.__langConfig.noHtmlAttrs !== !0) {
        const n = document.documentElement;
        n.setAttribute("dir", i.rtl === !0 ? "rtl" : "ltr"), n.setAttribute("lang", i.isoName);
      }
      Object.assign(_t.__langPack, i), _t.props = i, _t.isoName = i.isoName, _t.nativeName = i.nativeName;
    }
  },
  install({ $q: e, lang: t, ssrContext: i }) {
    e.lang = _t.__langPack, _t.__langConfig = e.config.lang, this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || Qo);
  }
});
let rc = !1;
function am(e) {
  rc = e.isComposing === !0;
}
function sc(e) {
  return rc === !0 || e !== Object(e) || e.isComposing === !0 || e.qKeyEvent === !0;
}
function gn(e, t) {
  return sc(e) === !0 ? !1 : [].concat(t).includes(e.keyCode);
}
function oc(e) {
  if (e.ios === !0) return "ios";
  if (e.android === !0) return "android";
}
function lm({ is: e, has: t, within: i }, n) {
  const r = [
    e.desktop === !0 ? "desktop" : "mobile",
    `${t.touch === !1 ? "no-" : ""}touch`
  ];
  if (e.mobile === !0) {
    const s = oc(e);
    s !== void 0 && r.push("platform-" + s);
  }
  if (e.nativeMobile === !0) {
    const s = e.nativeMobileWrapper;
    r.push(s), r.push("native-mobile"), e.ios === !0 && (n[s] === void 0 || n[s].iosStatusBarPadding !== !1) && r.push("q-ios-padding");
  } else e.electron === !0 ? r.push("electron") : e.bex === !0 && r.push("bex");
  return i.iframe === !0 && r.push("within-iframe"), r;
}
function cm() {
  const { is: e } = ke, t = document.body.className, i = new Set(t.replace(/ {2}/g, " ").split(" "));
  if (Ir !== void 0)
    i.delete("desktop"), i.add("platform-ios"), i.add("mobile");
  else if (e.nativeMobile !== !0 && e.electron !== !0 && e.bex !== !0) {
    if (e.desktop === !0)
      i.delete("mobile"), i.delete("platform-ios"), i.delete("platform-android"), i.add("desktop");
    else if (e.mobile === !0) {
      i.delete("desktop"), i.add("mobile");
      const r = oc(e);
      r !== void 0 ? (i.add(`platform-${r}`), i.delete(`platform-${r === "ios" ? "android" : "ios"}`)) : (i.delete("platform-ios"), i.delete("platform-android"));
    }
  }
  ke.has.touch === !0 && (i.delete("no-touch"), i.add("touch")), ke.within.iframe === !0 && i.add("within-iframe");
  const n = Array.from(i).join(" ");
  t !== n && (document.body.className = n);
}
function um(e) {
  for (const t in e)
    wt(t, e[t]);
}
const dm = {
  install(e) {
    if (this.__installed !== !0) {
      if (ii.value === !0)
        cm();
      else {
        const { $q: t } = e;
        t.config.brand !== void 0 && um(t.config.brand);
        const i = lm(ke, t.config);
        document.body.classList.add.apply(document.body.classList, i);
      }
      ke.is.ios === !0 && document.body.addEventListener("touchstart", Ri), window.addEventListener("keydown", am, !0);
    }
  }
}, fm = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
}, fr = Vi({
  iconMapFn: null,
  __icons: {}
}, {
  set(e, t) {
    const i = { ...e, rtl: e.rtl === !0 };
    i.set = fr.set, Object.assign(fr.__icons, i);
  },
  install({ $q: e, iconSet: t, ssrContext: i }) {
    e.config.iconMapFn !== void 0 && (this.iconMapFn = e.config.iconMapFn), e.iconSet = this.__icons, Ui(e, "iconMapFn", () => this.iconMapFn, (n) => {
      this.iconMapFn = n;
    }), this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || fm);
  }
}), ac = "_q_", hm = "_q_fo_", hr = {};
let lc = !1;
function mm() {
  lc = !0;
}
function ft(e) {
  return e !== null && typeof e == "object" && Array.isArray(e) !== !0;
}
function gm(e) {
  return typeof e == "number" && isFinite(e);
}
const Yo = [
  pi,
  dm,
  Ge,
  ht,
  Ts,
  _t,
  fr
];
function to(e, t) {
  const i = If(e);
  i.config.globalProperties = t.config.globalProperties;
  const { reload: n, ...r } = t._context;
  return Object.assign(i._context, r), i;
}
function Xo(e, t) {
  t.forEach((i) => {
    i.install(e), i.__installed = !0;
  });
}
function pm(e, t, i) {
  e.config.globalProperties.$q = i.$q, e.provide(ac, i.$q), Xo(i, Yo), t.components !== void 0 && Object.values(t.components).forEach((n) => {
    ft(n) === !0 && n.name !== void 0 && e.component(n.name, n);
  }), t.directives !== void 0 && Object.values(t.directives).forEach((n) => {
    ft(n) === !0 && n.name !== void 0 && e.directive(n.name, n);
  }), t.plugins !== void 0 && Xo(
    i,
    Object.values(t.plugins).filter(
      (n) => typeof n.install == "function" && Yo.includes(n) === !1
    )
  ), ii.value === !0 && (i.$q.onSSRHydrated = () => {
    i.onSSRHydrated.forEach((n) => {
      n();
    }), i.$q.onSSRHydrated = () => {
    };
  });
}
const ym = function(e, t = {}) {
  const i = { version: "2.12.0" };
  lc === !1 ? (t.config !== void 0 && Object.assign(hr, t.config), i.config = { ...hr }, mm()) : i.config = t.config || {}, pm(e, t, {
    parentApp: e,
    $q: i,
    lang: t.lang,
    iconSet: t.iconSet,
    onSSRHydrated: []
  });
}, vm = {
  version: "2.12.0",
  install: ym,
  lang: _t,
  iconSet: fr
};
function cc() {
  return navigator.language || a.get(navigator, "languages.0") || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;
}
function Dt(e = !0) {
  const t = a.get(me, "locale.default", cc());
  if (!e) return t;
  const i = a.split(t, "-");
  return a.head(i);
}
function uc(e = !0) {
  const t = a.get(me, "locale.fallbackLocale", "en-GB");
  if (!e) return t;
  const i = a.split(t, "-");
  return a.head(i);
}
async function bm(e, t, i) {
  const n = {};
  n[t] = {}, n[i] = {};
  for (let r = 0; r < e.length; r++) {
    try {
      const s = await import(`@i18n/${e[r]}_${t}.json`);
      a.merge(n[t], s.default);
    } catch {
      I.warn(`[KDK] unable to load translation file ${e[r]}_${t}.json`);
    }
    try {
      const s = await import(`@i18n/${e[r]}_${i}.json`);
      a.merge(n[i], s.default);
    } catch {
      I.error(`[KDK] unable to load translation file ${e[r]}_${i}.json`);
    }
  }
  return n;
}
const Y = {
  async initialize(e, t) {
    const i = uc(), n = Dt();
    this.i18n = Wf({
      locale: n,
      fallbackLocale: i,
      messages: await bm(t, n, i),
      silentFallbackWarn: !0
    }), e.use(this.i18n);
    try {
      const r = await import(`quasar/lang/${Dt(!1)}.js`);
      r && vm.lang.set(r.default);
    } catch (r) {
      I.error(r);
    }
  },
  registerTranslation(e) {
    if (!this.i18n) {
      I.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return;
    }
    const t = this.i18n.global.locale;
    let i = e[t];
    i && this.i18n.global.mergeLocaleMessage(t, i);
    const n = this.i18n.global.fallbackLocale;
    i = e[n], i && this.i18n.global.mergeLocaleMessage(n, i);
  },
  t(e, t) {
    return this.i18n ? this.i18n.global.t(e, t) : (I.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e);
  },
  tc(e, t) {
    if (!this.i18n)
      return I.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e;
    if (this.i18n.global.te(e)) return this.i18n.global.tc(e, t);
    if (this.i18n.global.te(e, this.i18n.global.fallbackLocale)) return this.i18n.global.tc(e, t, this.i18n.global.fallbackLocale);
  },
  tie(e, t) {
    return this.i18n ? a.isEmpty(e) ? e : this.i18n.global.te(e) ? this.i18n.global.t(e, t) : this.i18n.global.te(e, this.i18n.global.fallbackLocale) ? this.i18n.global.t(e, this.i18n.global.fallbackLocale, t) : e : (I.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e);
  },
  localize(e) {
    if (!this.i18n)
      return I.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e;
    const t = e.lastIndexOf("."), i = t > 0 ? e.substring(0, t) : e, n = t > 0 ? e.substring(t, e.length) : "";
    return [
      `${i}_${this.i18n.global.locale}${n}`,
      `${i}_${this.i18n.global.fallbackLocale}${n}`,
      e
    ];
  }
}, Ps = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
}, Pn = {
  size: String
};
function Mn(e, t = Ps) {
  return W(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null);
}
const We = (e) => Ar(zf(e)), wm = (e) => Ar(e);
function St(e, t) {
  return e !== void 0 && e() || t;
}
function li(e, t) {
  return e !== void 0 ? t.concat(e()) : t;
}
function _m(e, t) {
  return e === void 0 ? t : t !== void 0 ? t.concat(e()) : e();
}
const ea = "0 0 24 24", ta = (e) => e, as = (e) => `ionicons ${e}`, dc = {
  "mdi-": (e) => `mdi ${e}`,
  "icon-": ta,
  // fontawesome equiv
  "bt-": (e) => `bt ${e}`,
  "eva-": (e) => `eva ${e}`,
  "ion-md": as,
  "ion-ios": as,
  "ion-logo": as,
  "iconfont ": ta,
  "ti-": (e) => `themify-icon ${e}`,
  "bi-": (e) => `bootstrap-icons ${e}`
}, fc = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
}, hc = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
}, Lm = new RegExp("^(" + Object.keys(dc).join("|") + ")"), xm = new RegExp("^(" + Object.keys(fc).join("|") + ")"), ia = new RegExp("^(" + Object.keys(hc).join("|") + ")"), Sm = /^[Mm]\s?[-+]?\.?\d/, Em = /^img:/, Cm = /^svguse:/, Tm = /^ion-/, Pm = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /, Nt = We({
  name: "QIcon",
  props: {
    ...Pn,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: i } } = qe(), n = Mn(e), r = W(
      () => "q-icon" + (e.left === !0 ? " on-left" : "") + (e.right === !0 ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")
    ), s = W(() => {
      let o, l = e.name;
      if (l === "none" || !l)
        return { none: !0 };
      if (i.iconMapFn !== null) {
        const d = i.iconMapFn(l);
        if (d !== void 0)
          if (d.icon !== void 0) {
            if (l = d.icon, l === "none" || !l)
              return { none: !0 };
          } else
            return {
              cls: d.cls,
              content: d.content !== void 0 ? d.content : " "
            };
      }
      if (Sm.test(l) === !0) {
        const [d, f = ea] = l.split("|");
        return {
          svg: !0,
          viewBox: f,
          nodes: d.split("&&").map((m) => {
            const [g, v, x] = m.split("@@");
            return K("path", { style: v, d: g, transform: x });
          })
        };
      }
      if (Em.test(l) === !0)
        return {
          img: !0,
          src: l.substring(4)
        };
      if (Cm.test(l) === !0) {
        const [d, f = ea] = l.split("|");
        return {
          svguse: !0,
          src: d.substring(7),
          viewBox: f
        };
      }
      let c = " ";
      const u = l.match(Lm);
      if (u !== null)
        o = dc[u[1]](l);
      else if (Pm.test(l) === !0)
        o = l;
      else if (Tm.test(l) === !0)
        o = `ionicons ion-${i.platform.is.ios === !0 ? "ios" : "md"}${l.substring(3)}`;
      else if (ia.test(l) === !0) {
        o = "notranslate material-symbols";
        const d = l.match(ia);
        d !== null && (l = l.substring(6), o += hc[d[1]]), c = l;
      } else {
        o = "notranslate material-icons";
        const d = l.match(xm);
        d !== null && (l = l.substring(2), o += fc[d[1]]), c = l;
      }
      return {
        cls: o,
        content: c
      };
    });
    return () => {
      const o = {
        class: r.value,
        style: n.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      return s.value.none === !0 ? K(e.tag, o, St(t.default)) : s.value.img === !0 ? K("span", o, li(t.default, [
        K("img", { src: s.value.src })
      ])) : s.value.svg === !0 ? K("span", o, li(t.default, [
        K("svg", {
          viewBox: s.value.viewBox || "0 0 24 24"
        }, s.value.nodes)
      ])) : s.value.svguse === !0 ? K("span", o, li(t.default, [
        K("svg", {
          viewBox: s.value.viewBox
        }, [
          K("use", { "xlink:href": s.value.src })
        ])
      ])) : (s.value.cls !== void 0 && (o.class += " " + s.value.cls), K(e.tag, o, li(t.default, [
        s.value.content
      ])));
    };
  }
}), Mm = We({
  name: "QAvatar",
  props: {
    ...Pn,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(e, { slots: t }) {
    const i = Mn(e), n = W(
      () => "q-avatar" + (e.color ? ` bg-${e.color}` : "") + (e.textColor ? ` text-${e.textColor} q-chip--colored` : "") + (e.square === !0 ? " q-avatar--square" : e.rounded === !0 ? " rounded-borders" : "")
    ), r = W(() => e.fontSize ? { fontSize: e.fontSize } : null);
    return () => {
      const s = e.icon !== void 0 ? [K(Nt, { name: e.icon })] : void 0;
      return K("div", {
        class: n.value,
        style: i.value
      }, [
        K("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: r.value
        }, _m(t.default, s))
      ]);
    };
  }
}), km = {
  size: {
    type: [Number, String],
    default: "1em"
  },
  color: String
};
function Fm(e) {
  return {
    cSize: W(() => e.size in Ps ? `${Ps[e.size]}px` : e.size),
    classes: W(
      () => "q-spinner" + (e.color ? ` text-${e.color}` : "")
    )
  };
}
const $i = We({
  name: "QSpinner",
  props: {
    ...km,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(e) {
    const { cSize: t, classes: i } = Fm(e);
    return () => K("svg", {
      class: i.value + " q-spinner-mat",
      width: t.value,
      height: t.value,
      viewBox: "25 25 50 50"
    }, [
      K("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": e.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function Dm(e, t) {
  const i = e.style;
  for (const n in t)
    i[n] = t[n];
}
function Am(e, t) {
  if (e == null || e.contains(t) === !0)
    return !0;
  for (let i = e.nextElementSibling; i !== null; i = i.nextElementSibling)
    if (i.contains(t))
      return !0;
  return !1;
}
function Om(e, t = 250) {
  let i = !1, n;
  return function() {
    return i === !1 && (i = !0, setTimeout(() => {
      i = !1;
    }, t), n = e.apply(this, arguments)), n;
  };
}
function na(e, t, i, n) {
  i.modifiers.stop === !0 && dr(e);
  const r = i.modifiers.color;
  let s = i.modifiers.center;
  s = s === !0 || n === !0;
  const o = document.createElement("span"), l = document.createElement("span"), c = em(e), { left: u, top: d, width: f, height: m } = t.getBoundingClientRect(), g = Math.sqrt(f * f + m * m), v = g / 2, x = `${(f - g) / 2}px`, S = s ? x : `${c.left - u - v}px`, A = `${(m - g) / 2}px`, p = s ? A : `${c.top - d - v}px`;
  l.className = "q-ripple__inner", Dm(l, {
    height: `${g}px`,
    width: `${g}px`,
    transform: `translate3d(${S},${p},0) scale3d(.2,.2,1)`,
    opacity: 0
  }), o.className = `q-ripple${r ? " text-" + r : ""}`, o.setAttribute("dir", "ltr"), o.appendChild(l), t.appendChild(o);
  const y = () => {
    o.remove(), clearTimeout(w);
  };
  i.abort.push(y);
  let w = setTimeout(() => {
    l.classList.add("q-ripple__inner--enter"), l.style.transform = `translate3d(${x},${A},0) scale3d(1,1,1)`, l.style.opacity = 0.2, w = setTimeout(() => {
      l.classList.remove("q-ripple__inner--enter"), l.classList.add("q-ripple__inner--leave"), l.style.opacity = 0, w = setTimeout(() => {
        o.remove(), i.abort.splice(i.abort.indexOf(y), 1);
      }, 275);
    }, 250);
  }, 50);
}
function ra(e, { modifiers: t, value: i, arg: n }) {
  const r = Object.assign({}, e.cfg.ripple, t, i);
  e.modifiers = {
    early: r.early === !0,
    stop: r.stop === !0,
    center: r.center === !0,
    color: r.color || n,
    keyCodes: [].concat(r.keyCodes || 13)
  };
}
const Bm = wm(
  {
    name: "ripple",
    beforeMount(e, t) {
      const i = t.instance.$.appContext.config.globalProperties.$q.config || {};
      if (i.ripple === !1)
        return;
      const n = {
        cfg: i,
        enabled: t.value !== !1,
        modifiers: {},
        abort: [],
        start(r) {
          n.enabled === !0 && r.qSkipRipple !== !0 && r.type === (n.modifiers.early === !0 ? "pointerdown" : "click") && na(r, e, n, r.qKeyEvent === !0);
        },
        keystart: Om((r) => {
          n.enabled === !0 && r.qSkipRipple !== !0 && gn(r, n.modifiers.keyCodes) === !0 && r.type === `key${n.modifiers.early === !0 ? "down" : "up"}` && na(r, e, n, !0);
        }, 300)
      };
      ra(n, t), e.__qripple = n, im(n, "main", [
        [e, "pointerdown", "start", "passive"],
        [e, "click", "start", "passive"],
        [e, "keydown", "keystart", "passive"],
        [e, "keyup", "keystart", "passive"]
      ]);
    },
    updated(e, t) {
      if (t.oldValue !== t.value) {
        const i = e.__qripple;
        i !== void 0 && (i.enabled = t.value !== !1, i.enabled === !0 && Object(t.value) === t.value && ra(i, t));
      }
    },
    beforeUnmount(e) {
      const t = e.__qripple;
      t !== void 0 && (t.abort.forEach((i) => {
        i();
      }), nm(t, "main"), delete e._qripple);
    }
  }
), mc = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
}, Rm = Object.keys(mc), gc = {
  align: {
    type: String,
    validator: (e) => Rm.includes(e)
  }
};
function pc(e) {
  return W(() => {
    const t = e.align === void 0 ? e.vertical === !0 ? "stretch" : "left" : e.align;
    return `${e.vertical === !0 ? "items" : "justify"}-${mc[t]}`;
  });
}
function yc(e) {
  return e.appContext.config.globalProperties.$router !== void 0;
}
function vc(e) {
  return e.isUnmounted === !0 || e.isDeactivated === !0;
}
function sa(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
function oa(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function $m(e, t) {
  for (const i in t) {
    const n = t[i], r = e[i];
    if (typeof n == "string") {
      if (n !== r)
        return !1;
    } else if (Array.isArray(r) === !1 || r.length !== n.length || n.some((s, o) => s !== r[o]))
      return !1;
  }
  return !0;
}
function aa(e, t) {
  return Array.isArray(t) === !0 ? e.length === t.length && e.every((i, n) => i === t[n]) : e.length === 1 && e[0] === t;
}
function Im(e, t) {
  return Array.isArray(e) === !0 ? aa(e, t) : Array.isArray(t) === !0 ? aa(t, e) : e === t;
}
function zm(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const i in e)
    if (Im(e[i], t[i]) === !1)
      return !1;
  return !0;
}
const Nm = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  },
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
function qm({ fallbackTag: e, useDisableForRouterLinkProps: t = !0 } = {}) {
  const i = qe(), { props: n, proxy: r, emit: s } = i, o = yc(i), l = W(() => n.disable !== !0 && n.href !== void 0), c = t === !0 ? W(
    () => o === !0 && n.disable !== !0 && l.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ) : W(
    () => o === !0 && l.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ), u = W(() => c.value === !0 ? p(n.to) : null), d = W(() => u.value !== null), f = W(() => l.value === !0 || d.value === !0), m = W(() => n.type === "a" || f.value === !0 ? "a" : n.tag || e || "div"), g = W(() => l.value === !0 ? {
    href: n.href,
    target: n.target
  } : d.value === !0 ? {
    href: u.value.href,
    target: n.target
  } : {}), v = W(() => {
    if (d.value === !1)
      return -1;
    const { matched: C } = u.value, { length: P } = C, M = C[P - 1];
    if (M === void 0)
      return -1;
    const z = r.$route.matched;
    if (z.length === 0)
      return -1;
    const D = z.findIndex(
      oa.bind(null, M)
    );
    if (D > -1)
      return D;
    const T = sa(C[P - 2]);
    return (
      // we are dealing with nested routes
      P > 1 && sa(M) === T && z[z.length - 1].path !== T ? z.findIndex(
        oa.bind(null, C[P - 2])
      ) : D
    );
  }), x = W(
    () => d.value === !0 && v.value !== -1 && $m(r.$route.params, u.value.params)
  ), S = W(
    () => x.value === !0 && v.value === r.$route.matched.length - 1 && zm(r.$route.params, u.value.params)
  ), A = W(() => d.value === !0 ? S.value === !0 ? ` ${n.exactActiveClass} ${n.activeClass}` : n.exact === !0 ? "" : x.value === !0 ? ` ${n.activeClass}` : "" : "");
  function p(C) {
    try {
      return r.$router.resolve(C);
    } catch {
    }
    return null;
  }
  function y(C, { returnRouterError: P, to: M = n.to, replace: z = n.replace } = {}) {
    if (n.disable === !0)
      return C.preventDefault(), Promise.resolve(!1);
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      C.metaKey || C.altKey || C.ctrlKey || C.shiftKey || C.button !== void 0 && C.button !== 0 || n.target === "_blank"
    )
      return Promise.resolve(!1);
    C.preventDefault();
    const D = r.$router[z === !0 ? "replace" : "push"](M);
    return P === !0 ? D : D.then(() => {
    }).catch(() => {
    });
  }
  function w(C) {
    if (d.value === !0) {
      const P = (M) => y(C, M);
      s("click", C, P), C.defaultPrevented !== !0 && P();
    } else
      s("click", C);
  }
  return {
    hasRouterLink: d,
    hasHrefLink: l,
    hasLink: f,
    linkTag: m,
    resolvedLink: u,
    linkIsActive: x,
    linkIsExactActive: S,
    linkClass: A,
    linkAttrs: g,
    getLink: p,
    navigateToRouterLink: y,
    navigateOnClick: w
  };
}
const la = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
}, jm = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
}, Um = ["button", "submit", "reset"], Vm = /[^\s]\/[^\s]/, Km = ["flat", "outline", "push", "unelevated"], Gm = (e, t) => e.flat === !0 ? "flat" : e.outline === !0 ? "outline" : e.push === !0 ? "push" : e.unelevated === !0 ? "unelevated" : t, Hm = {
  ...Pn,
  ...Nm,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...Km.reduce(
    (e, t) => (e[t] = Boolean) && e,
    {}
  ),
  square: Boolean,
  round: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  align: {
    ...gc.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
function Wm(e) {
  const t = Mn(e, jm), i = pc(e), { hasRouterLink: n, hasLink: r, linkTag: s, linkAttrs: o, navigateOnClick: l } = qm({
    fallbackTag: "button"
  }), c = W(() => {
    const S = e.fab === !1 && e.fabMini === !1 ? t.value : {};
    return e.padding !== void 0 ? Object.assign({}, S, {
      padding: e.padding.split(/\s+/).map((A) => A in la ? la[A] + "px" : A).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : S;
  }), u = W(
    () => e.rounded === !0 || e.fab === !0 || e.fabMini === !0
  ), d = W(
    () => e.disable !== !0 && e.loading !== !0
  ), f = W(() => d.value === !0 ? e.tabindex || 0 : -1), m = W(() => Gm(e, "standard")), g = W(() => {
    const S = { tabindex: f.value };
    return r.value === !0 ? Object.assign(S, o.value) : Um.includes(e.type) === !0 && (S.type = e.type), s.value === "a" ? (e.disable === !0 ? S["aria-disabled"] = "true" : S.href === void 0 && (S.role = "button"), n.value !== !0 && Vm.test(e.type) === !0 && (S.type = e.type)) : e.disable === !0 && (S.disabled = "", S["aria-disabled"] = "true"), e.loading === !0 && e.percentage !== void 0 && Object.assign(S, {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": e.percentage
    }), S;
  }), v = W(() => {
    let S;
    e.color !== void 0 ? e.flat === !0 || e.outline === !0 ? S = `text-${e.textColor || e.color}` : S = `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (S = `text-${e.textColor}`);
    const A = e.round === !0 ? "round" : `rectangle${u.value === !0 ? " q-btn--rounded" : e.square === !0 ? " q-btn--square" : ""}`;
    return `q-btn--${m.value} q-btn--${A}` + (S !== void 0 ? " " + S : "") + (d.value === !0 ? " q-btn--actionable q-focusable q-hoverable" : e.disable === !0 ? " disabled" : "") + (e.fab === !0 ? " q-btn--fab" : e.fabMini === !0 ? " q-btn--fab-mini" : "") + (e.noCaps === !0 ? " q-btn--no-uppercase" : "") + (e.dense === !0 ? " q-btn--dense" : "") + (e.stretch === !0 ? " no-border-radius self-stretch" : "") + (e.glossy === !0 ? " glossy" : "") + (e.square ? " q-btn--square" : "");
  }), x = W(
    () => i.value + (e.stack === !0 ? " column" : " row") + (e.noWrap === !0 ? " no-wrap text-no-wrap" : "") + (e.loading === !0 ? " q-btn__content--hidden" : "")
  );
  return {
    classes: v,
    style: c,
    innerClasses: x,
    attributes: g,
    hasLink: r,
    linkTag: s,
    navigateOnClick: l,
    isActionable: d
  };
}
const { passiveCapture: at } = ct;
let Ci = null, Ti = null, Pi = null;
const Ms = We({
  name: "QBtn",
  props: {
    ...Hm,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(e, { slots: t, emit: i }) {
    const { proxy: n } = qe(), {
      classes: r,
      style: s,
      innerClasses: o,
      attributes: l,
      hasLink: c,
      linkTag: u,
      navigateOnClick: d,
      isActionable: f
    } = Wm(e), m = ue(null), g = ue(null);
    let v = null, x, S = null;
    const A = W(
      () => e.label !== void 0 && e.label !== null && e.label !== ""
    ), p = W(() => e.disable === !0 || e.ripple === !1 ? !1 : {
      keyCodes: c.value === !0 ? [13, 32] : [13],
      ...e.ripple === !0 ? {} : e.ripple
    }), y = W(() => ({ center: e.round })), w = W(() => {
      const $ = Math.max(0, Math.min(100, e.percentage));
      return $ > 0 ? { transition: "transform 0.6s", transform: `translateX(${$ - 100}%)` } : {};
    }), C = W(() => {
      if (e.loading === !0)
        return {
          onMousedown: O,
          onTouchstart: O,
          onClick: O,
          onKeydown: O,
          onKeyup: O
        };
      if (f.value === !0) {
        const $ = {
          onClick: M,
          onKeydown: z,
          onMousedown: T
        };
        if (n.$q.platform.has.touch === !0) {
          const X = e.onTouchstart !== void 0 ? "" : "Passive";
          $[`onTouchstart${X}`] = D;
        }
        return $;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: dt
      };
    }), P = W(() => ({
      ref: m,
      class: "q-btn q-btn-item non-selectable no-outline " + r.value,
      style: s.value,
      ...l.value,
      ...C.value
    }));
    function M($) {
      if (m.value !== null) {
        if ($ !== void 0) {
          if ($.defaultPrevented === !0)
            return;
          const X = document.activeElement;
          if (e.type === "submit" && X !== document.body && m.value.contains(X) === !1 && X.contains(m.value) === !1) {
            m.value.focus();
            const te = () => {
              document.removeEventListener("keydown", dt, !0), document.removeEventListener("keyup", te, at), m.value !== null && m.value.removeEventListener("blur", te, at);
            };
            document.addEventListener("keydown", dt, !0), document.addEventListener("keyup", te, at), m.value.addEventListener("blur", te, at);
          }
        }
        d($);
      }
    }
    function z($) {
      m.value !== null && (i("keydown", $), gn($, [13, 32]) === !0 && Ti !== m.value && (Ti !== null && k(), $.defaultPrevented !== !0 && (m.value.focus(), Ti = m.value, m.value.classList.add("q-btn--active"), document.addEventListener("keyup", F, !0), m.value.addEventListener("blur", F, at)), dt($)));
    }
    function D($) {
      m.value !== null && (i("touchstart", $), $.defaultPrevented !== !0 && (Ci !== m.value && (Ci !== null && k(), Ci = m.value, v = $.target, v.addEventListener("touchcancel", F, at), v.addEventListener("touchend", F, at)), x = !0, S !== null && clearTimeout(S), S = setTimeout(() => {
        S = null, x = !1;
      }, 200)));
    }
    function T($) {
      m.value !== null && ($.qSkipRipple = x === !0, i("mousedown", $), $.defaultPrevented !== !0 && Pi !== m.value && (Pi !== null && k(), Pi = m.value, m.value.classList.add("q-btn--active"), document.addEventListener("mouseup", F, at)));
    }
    function F($) {
      if (m.value !== null && !($ !== void 0 && $.type === "blur" && document.activeElement === m.value)) {
        if ($ !== void 0 && $.type === "keyup") {
          if (Ti === m.value && gn($, [13, 32]) === !0) {
            const X = new MouseEvent("click", $);
            X.qKeyEvent = !0, $.defaultPrevented === !0 && ki(X), $.cancelBubble === !0 && dr(X), m.value.dispatchEvent(X), dt($), $.qKeyEvent = !0;
          }
          i("keyup", $);
        }
        k();
      }
    }
    function k($) {
      const X = g.value;
      $ !== !0 && (Ci === m.value || Pi === m.value) && X !== null && X !== document.activeElement && (X.setAttribute("tabindex", -1), X.focus()), Ci === m.value && (v !== null && (v.removeEventListener("touchcancel", F, at), v.removeEventListener("touchend", F, at)), Ci = v = null), Pi === m.value && (document.removeEventListener("mouseup", F, at), Pi = null), Ti === m.value && (document.removeEventListener("keyup", F, !0), m.value !== null && m.value.removeEventListener("blur", F, at), Ti = null), m.value !== null && m.value.classList.remove("q-btn--active");
    }
    function O($) {
      dt($), $.qSkipRipple = !0;
    }
    return je(() => {
      k(!0);
    }), Object.assign(n, { click: M }), () => {
      let $ = [];
      e.icon !== void 0 && $.push(
        K(Nt, {
          name: e.icon,
          left: e.stack === !1 && A.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      ), A.value === !0 && $.push(
        K("span", { class: "block" }, [e.label])
      ), $ = li(t.default, $), e.iconRight !== void 0 && e.round === !1 && $.push(
        K(Nt, {
          name: e.iconRight,
          right: e.stack === !1 && A.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      );
      const X = [
        K("span", {
          class: "q-focus-helper",
          ref: g
        })
      ];
      return e.loading === !0 && e.percentage !== void 0 && X.push(
        K("span", {
          class: "q-btn__progress absolute-full overflow-hidden" + (e.darkPercentage === !0 ? " q-btn__progress--dark" : "")
        }, [
          K("span", {
            class: "q-btn__progress-indicator fit block",
            style: w.value
          })
        ])
      ), X.push(
        K("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + o.value
        }, $)
      ), e.loading !== null && X.push(
        K(hn, {
          name: "q-transition--fade"
        }, () => e.loading === !0 ? [
          K("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, t.loading !== void 0 ? t.loading() : [K($i)])
        ] : null)
      ), Nf(
        K(
          u.value,
          P.value,
          X
        ),
        [[
          Bm,
          p.value,
          void 0,
          y.value
        ]]
      );
    };
  }
}), Di = [], ln = [];
let Zm = 1, Wt = document.body;
function zr(e, t) {
  const i = document.createElement("div");
  if (i.id = t !== void 0 ? `q-portal--${t}--${Zm++}` : e, hr.globalNodes !== void 0) {
    const n = hr.globalNodes.class;
    n !== void 0 && (i.className = n);
  }
  return Wt.appendChild(i), Di.push(i), ln.push(t), i;
}
function io(e) {
  const t = Di.indexOf(e);
  Di.splice(t, 1), ln.splice(t, 1), e.remove();
}
function Qm(e) {
  if (e === Wt)
    return;
  if (Wt = e, Wt === document.body || ln.reduce((i, n) => n === "dialog" ? i + 1 : i, 0) < 2) {
    Di.forEach((i) => {
      i.contains(Wt) === !1 && Wt.appendChild(i);
    });
    return;
  }
  const t = ln.lastIndexOf("dialog");
  for (let i = 0; i < Di.length; i++) {
    const n = Di[i];
    (i === t || ln[i] !== "dialog") && n.contains(Wt) === !1 && Wt.appendChild(n);
  }
}
let Jm = 0;
const Jn = {}, Yn = {}, Lt = {}, bc = {}, Ym = /^\s*$/, wc = [], no = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "top",
  "bottom",
  "left",
  "right",
  "center"
], Xm = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
], Fi = {
  positive: {
    icon: (e) => e.iconSet.type.positive,
    color: "positive"
  },
  negative: {
    icon: (e) => e.iconSet.type.negative,
    color: "negative"
  },
  warning: {
    icon: (e) => e.iconSet.type.warning,
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: (e) => e.iconSet.type.info,
    color: "info"
  },
  ongoing: {
    group: !1,
    timeout: 0,
    spinner: !0,
    color: "grey-8"
  }
};
function _c(e, t, i) {
  if (!e)
    return Yi("parameter required");
  let n;
  const r = { textColor: "white" };
  if (e.ignoreDefaults !== !0 && Object.assign(r, Jn), ft(e) === !1 && (r.type && Object.assign(r, Fi[r.type]), e = { message: e }), Object.assign(r, Fi[e.type || r.type], e), typeof r.icon == "function" && (r.icon = r.icon(t)), r.spinner ? (r.spinner === !0 && (r.spinner = $i), r.spinner = Ar(r.spinner)) : r.spinner = !1, r.meta = {
    hasMedia: !!(r.spinner !== !1 || r.icon || r.avatar),
    hasText: ca(r.message) || ca(r.caption)
  }, r.position) {
    if (no.includes(r.position) === !1)
      return Yi("wrong position", e);
  } else
    r.position = "bottom";
  if (r.timeout === void 0)
    r.timeout = 5e3;
  else {
    const c = parseInt(r.timeout, 10);
    if (isNaN(c) || c < 0)
      return Yi("wrong timeout", e);
    r.timeout = c;
  }
  r.timeout === 0 ? r.progress = !1 : r.progress === !0 && (r.meta.progressClass = "q-notification__progress" + (r.progressClass ? ` ${r.progressClass}` : ""), r.meta.progressStyle = {
    animationDuration: `${r.timeout + 1e3}ms`
  });
  const s = (Array.isArray(e.actions) === !0 ? e.actions : []).concat(
    e.ignoreDefaults !== !0 && Array.isArray(Jn.actions) === !0 ? Jn.actions : []
  ).concat(
    Fi[e.type] !== void 0 && Array.isArray(Fi[e.type].actions) === !0 ? Fi[e.type].actions : []
  ), { closeBtn: o } = r;
  if (o && s.push({
    label: typeof o == "string" ? o : t.lang.label.close
  }), r.actions = s.map(({ handler: c, noDismiss: u, ...d }) => ({
    flat: !0,
    ...d,
    onClick: typeof c == "function" ? () => {
      c(), u !== !0 && l();
    } : () => {
      l();
    }
  })), r.multiLine === void 0 && (r.multiLine = r.actions.length > 1), Object.assign(r.meta, {
    class: `q-notification row items-stretch q-notification--${r.multiLine === !0 ? "multi-line" : "standard"}` + (r.color !== void 0 ? ` bg-${r.color}` : "") + (r.textColor !== void 0 ? ` text-${r.textColor}` : "") + (r.classes !== void 0 ? ` ${r.classes}` : ""),
    wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (r.multiLine === !0 ? "column no-wrap justify-center" : "row items-center"),
    contentClass: "q-notification__content row items-center" + (r.multiLine === !0 ? "" : " col"),
    leftClass: r.meta.hasText === !0 ? "additional" : "single",
    attrs: {
      role: "alert",
      ...r.attrs
    }
  }), r.group === !1 ? (r.group = void 0, r.meta.group = void 0) : ((r.group === void 0 || r.group === !0) && (r.group = [
    r.message,
    r.caption,
    r.multiline
  ].concat(
    r.actions.map((c) => `${c.label}*${c.icon}`)
  ).join("|")), r.meta.group = r.group + "|" + r.position), r.actions.length === 0 ? r.actions = void 0 : r.meta.actionsClass = "q-notification__actions row items-center " + (r.multiLine === !0 ? "justify-end" : "col-auto") + (r.meta.hasMedia === !0 ? " q-notification__actions--with-media" : ""), i !== void 0) {
    i.notif.meta.timer && (clearTimeout(i.notif.meta.timer), i.notif.meta.timer = void 0), r.meta.uid = i.notif.meta.uid;
    const c = Lt[r.position].value.indexOf(i.notif);
    Lt[r.position].value[c] = r;
  } else {
    const c = Yn[r.meta.group];
    if (c === void 0) {
      if (r.meta.uid = Jm++, r.meta.badge = 1, ["left", "right", "center"].indexOf(r.position) !== -1)
        Lt[r.position].value.splice(
          Math.floor(Lt[r.position].value.length / 2),
          0,
          r
        );
      else {
        const u = r.position.indexOf("top") > -1 ? "unshift" : "push";
        Lt[r.position].value[u](r);
      }
      r.group !== void 0 && (Yn[r.meta.group] = r);
    } else {
      if (c.meta.timer && (clearTimeout(c.meta.timer), c.meta.timer = void 0), r.badgePosition !== void 0) {
        if (Xm.includes(r.badgePosition) === !1)
          return Yi("wrong badgePosition", e);
      } else
        r.badgePosition = `top-${r.position.indexOf("left") > -1 ? "right" : "left"}`;
      r.meta.uid = c.meta.uid, r.meta.badge = c.meta.badge + 1, r.meta.badgeClass = `q-notification__badge q-notification__badge--${r.badgePosition}` + (r.badgeColor !== void 0 ? ` bg-${r.badgeColor}` : "") + (r.badgeTextColor !== void 0 ? ` text-${r.badgeTextColor}` : "") + (r.badgeClass ? ` ${r.badgeClass}` : "");
      const u = Lt[r.position].value.indexOf(c);
      Lt[r.position].value[u] = Yn[r.meta.group] = r;
    }
  }
  const l = () => {
    eg(r), n = void 0;
  };
  if (r.timeout > 0 && (r.meta.timer = setTimeout(() => {
    r.meta.timer = void 0, l();
  }, r.timeout + /* show duration */
  1e3)), r.group !== void 0)
    return (c) => {
      c !== void 0 ? Yi("trying to update a grouped one which is forbidden", e) : l();
    };
  if (n = {
    dismiss: l,
    config: e,
    notif: r
  }, i !== void 0) {
    Object.assign(i, n);
    return;
  }
  return (c) => {
    if (n !== void 0)
      if (c === void 0)
        n.dismiss();
      else {
        const u = Object.assign({}, n.config, c, {
          group: !1,
          position: r.position
        });
        _c(u, t, n);
      }
  };
}
function eg(e) {
  e.meta.timer && (clearTimeout(e.meta.timer), e.meta.timer = void 0);
  const t = Lt[e.position].value.indexOf(e);
  if (t !== -1) {
    e.group !== void 0 && delete Yn[e.meta.group];
    const i = wc["" + e.meta.uid];
    if (i) {
      const { width: n, height: r } = getComputedStyle(i);
      i.style.left = `${i.offsetLeft}px`, i.style.width = n, i.style.height = r;
    }
    Lt[e.position].value.splice(t, 1), typeof e.onDismiss == "function" && e.onDismiss();
  }
}
function ca(e) {
  return e != null && Ym.test(e) !== !0;
}
function Yi(e, t) {
  return console.error(`Notify: ${e}`, t), !1;
}
function tg() {
  return We({
    name: "QNotifications",
    // hide App from Vue devtools
    devtools: { hide: !0 },
    setup() {
      return () => K("div", { class: "q-notifications" }, no.map((e) => K(qf, {
        key: e,
        class: bc[e],
        tag: "div",
        name: `q-notification--${e}`
      }, () => Lt[e].value.map((t) => {
        const i = t.meta, n = [];
        if (i.hasMedia === !0 && (t.spinner !== !1 ? n.push(
          K(t.spinner, {
            class: "q-notification__spinner q-notification__spinner--" + i.leftClass,
            color: t.spinnerColor,
            size: t.spinnerSize
          })
        ) : t.icon ? n.push(
          K(Nt, {
            class: "q-notification__icon q-notification__icon--" + i.leftClass,
            name: t.icon,
            color: t.iconColor,
            size: t.iconSize,
            role: "img"
          })
        ) : t.avatar && n.push(
          K(Mm, {
            class: "q-notification__avatar q-notification__avatar--" + i.leftClass
          }, () => K("img", { src: t.avatar, "aria-hidden": "true" }))
        )), i.hasText === !0) {
          let s;
          const o = { class: "q-notification__message col" };
          if (t.html === !0)
            o.innerHTML = t.caption ? `<div>${t.message}</div><div class="q-notification__caption">${t.caption}</div>` : t.message;
          else {
            const l = [t.message];
            s = t.caption ? [
              K("div", l),
              K("div", { class: "q-notification__caption" }, [t.caption])
            ] : l;
          }
          n.push(
            K("div", o, s)
          );
        }
        const r = [
          K("div", { class: i.contentClass }, n)
        ];
        return t.progress === !0 && r.push(
          K("div", {
            key: `${i.uid}|p|${i.badge}`,
            class: i.progressClass,
            style: i.progressStyle
          })
        ), t.actions !== void 0 && r.push(
          K("div", {
            class: i.actionsClass
          }, t.actions.map((s) => K(Ms, s)))
        ), i.badge > 1 && r.push(
          K("div", {
            key: `${i.uid}|${i.badge}`,
            class: t.meta.badgeClass,
            style: t.badgeStyle
          }, [i.badge])
        ), K("div", {
          ref: (s) => {
            wc["" + i.uid] = s;
          },
          key: i.uid,
          class: i.class,
          ...i.attrs
        }, [
          K("div", { class: i.wrapperClass }, r)
        ]);
      }))));
    }
  });
}
const et = {
  setDefaults(e) {
    ft(e) === !0 && Object.assign(Jn, e);
  },
  registerType(e, t) {
    ft(t) === !0 && (Fi[e] = t);
  },
  install({ $q: e, parentApp: t }) {
    if (e.notify = this.create = (i) => _c(i, e), e.notify.setDefaults = this.setDefaults, e.notify.registerType = this.registerType, e.config.notify !== void 0 && this.setDefaults(e.config.notify), this.__installed !== !0) {
      no.forEach((n) => {
        Lt[n] = ue([]);
        const r = ["left", "center", "right"].includes(n) === !0 ? "center" : n.indexOf("top") > -1 ? "top" : "bottom", s = n.indexOf("left") > -1 ? "start" : n.indexOf("right") > -1 ? "end" : "center", o = ["left", "right"].includes(n) ? `items-${n === "left" ? "start" : "end"} justify-center` : n === "center" ? "flex-center" : `items-${s}`;
        bc[n] = `q-notifications__list q-notifications__list--${r} fixed column no-wrap ${o}`;
      });
      const i = zr("q-notify");
      to(tg(), t).mount(i);
    }
  }
}, Lc = {
  initialize() {
    this.useProxy = a.get(me, "storage.useProxy", !1);
  },
  createService(e) {
    let t = G.getServiceInstance("storage", e, { create: !1 });
    return t || (t = $f(G, {
      servicePath: G.getServicePath("storage", e),
      transport: G.transporter,
      fetch: window.fetch.bind(window),
      useProxy: this.useProxy
    }), t = G.createService("storage", {
      service: t,
      context: e,
      methods: ["create", "get", "find", "remove", "createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"]
    })), t;
  },
  getService(e) {
    return G.getServiceInstance("storage", e);
  },
  async upload(e, t) {
    const { file: i, key: n, blob: r, context: s } = e, o = this.getService(s), l = et.create({
      type: "ongoing",
      message: Y.t("storage.UPLOADING_FILE", { file: i }),
      timeout: 0
    });
    try {
      const c = await o.upload(n, r, { expiresIn: 60 }, t);
      return l(), ne.emit("file-uploaded", { name: i, key: n, type: r.type, context: s }), c;
    } catch (c) {
      throw l(), I.error(`[KDK] Cannot upload ${i} with key '${n}'`, c), c;
    }
  },
  async download(e, t) {
    const { file: i, key: n, context: r, asDataUrl: s } = e, o = this.getService(r), l = et.create({
      type: "ongoing",
      message: Y.t("storage.DOWNLOADING_FILE", { file: i }),
      color: "info",
      timeout: 0
    });
    try {
      const c = await o.download(n, { expiresIn: 60 }, t);
      return ne.emit("file-downloaded", { name: i, key: n, type: c.type, context: r }), l(), new Promise((u, d) => {
        if (s) {
          const f = new FileReader();
          f.onload = (m) => {
            delete c.buffer, c.uri = m.target.result, u(c);
          }, f.readAsDataURL(new Blob([c.buffer], { type: c.type }));
        } else
          u(c);
      });
    } catch (c) {
      throw l(), I.error(`[KDK] Cannot download '${i}' with key '${n}'`, c), c;
    }
  },
  async export(e) {
    const { file: t, key: i, context: n } = e, s = await this.getService(n).create({
      id: i,
      command: "GetObject",
      expiresIn: 60,
      ResponseContentDisposition: `attachment; filename="${t}"`
    });
    if (s.SignedUrl) {
      let o = document.getElementById("export-hidden-frame");
      o || (o = document.createElement("iframe"), o.id = "export-hidden-frame", o.style.display = "none", document.body.appendChild(o)), o.src = s.SignedUrl;
    } else
      I.error(`[KDK] Cannot export ${t} with key '${i}'`);
  },
  async remove(e) {
    const { file: t, key: i, context: n } = e, r = this.getService(n);
    try {
      await r.remove(i), ne.emit("file-removed", { name: t, key: i, context: n });
    } catch (s) {
      throw I.error(`[KDK] Cannot remove ${t} with key '${i}'`, s), s;
    }
  },
  async getObjectUrl(e) {
    const { key: t, context: i } = e, n = this.getService(i);
    let r = G.getConfig("domain") + me.apiPath;
    n.context && (r += `/${i}`), r += `/storage-objects/${t}`;
    const s = a.get(e, "query", {}), o = await G.get("storage").getItem(me.apiJwt);
    return s.jwt = o, r += `?${new URLSearchParams(s)}`, r;
  },
  async getPresignedUrl(e) {
    const { key: t, context: i } = e, n = this.getService(i), { SignedUrl: r } = await n.create({ id: t, command: "GetObject", ...a.omit(e, ["key", "context"]) });
    return r;
  }
}, { store: ig, set: ng, get: ua, unset: rg, has: sg } = Ft("template-context"), ro = Object.assign(ig, {
  get: ua,
  has: sg,
  unset: rg,
  // Override write methods to send events
  set(e, t) {
    const i = ua(e);
    ng(e, t), ne.emit("template-context-changed", e, t, i);
  }
}), be = {
  initialize() {
    this.timer = null, vt.locale(Dt());
    const e = vt.utc(), t = e.clone().subtract(1, "months").startOf("day"), i = e.clone().endOf("day"), n = vt.tz.guess() || "";
    j.set("time", a.defaultsDeep(me.time || {}, {
      range: {
        start: t,
        end: i,
        field: "createdAt",
        query: { createdAt: { $gte: t.toISOString(), $lte: i.toISOString() } }
      },
      format: {
        time: {
          short: "H[h]",
          long: "HH:mm"
        },
        date: {
          short: "DD/MM",
          long: "dddd D"
        },
        year: {
          short: "YY",
          long: "YYYY"
        },
        timezone: n
      },
      currentTime: e,
      realtime: !1,
      step: 60,
      // 1H
      interval: 60
      // 1m
    }));
  },
  convertToMoment(e) {
    return vt.isMoment(e) ? vt.utc(e.valueOf()) : typeof e == "string" && !e.endsWith("Z") ? vt(e).utc() : vt.utc(e);
  },
  get() {
    return j.get("time");
  },
  getRange() {
    return this.get().range;
  },
  patchRange(e) {
    if (this.getRange().start.isSame(e.start) && this.getRange().end.isSame(e.end)) return;
    const t = { [this.getRange().field]: { $gte: e.start.toISOString(), $lte: e.end.toISOString() } };
    j.patch("time.range", Object.assign({ query: t }, e));
  },
  patchField(e) {
    if (this.getRange().field === e) return;
    const t = { [e]: { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() } };
    j.patch("time.range", { field: e, query: t });
  },
  getRangeQuery() {
    return j.get("time.range.query");
  },
  // Build sort query
  updateTimeRangeQuery() {
    const e = {};
    e[this.getRange().field] = { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() }, this.getRange().query = e;
  },
  getFormat() {
    return this.get().format;
  },
  getFormatTimezone() {
    return this.getFormat().timezone;
  },
  convertToLocal(e) {
    let t = this.convertToMoment(e);
    return this.getFormatTimezone() && (t = vt.tz(t.toISOString(), this.getFormatTimezone())), t;
  },
  format(e, t, i = { year: "numeric", month: "numeric", day: "numeric", hour: "2-digit", minute: "2-digit" }) {
    const n = this.convertToLocal(e);
    return t === "iso" ? n.toISOString() : t === "locale" ? n.toDate().toLocaleString(Dt(), i) : n.format(a.get(this.getFormat(), t));
  },
  getCurrentTime() {
    return this.get().currentTime;
  },
  setCurrentTime(e) {
    this.isRealtime() && this.stopRealtime();
    const t = this.convertToMoment(e);
    this.getCurrentTime().isSame(t) || j.patch("time.currentTime", t);
  },
  setNow() {
    this.setCurrentTime(vt.utc());
  },
  isRealtime() {
    return this.get().realtime;
  },
  startRealtime() {
    if (this.isRealtime()) {
      I.warn("[KDK] Realtime mode is already active");
      return;
    }
    j.patch("time", { realtime: !0 }), j.patch("time.currentTime", vt.utc()), this.timer = setInterval(() => {
      j.patch("time.currentTime", vt.utc());
    }, 1e3 * this.get().interval);
  },
  stopRealtime() {
    if (!this.isRealtime()) {
      I.warn("[KDK] Realtime mode is alrady inactive");
      return;
    }
    j.patch("time", { realtime: !1 }), clearInterval(this.timer), this.timer = null;
  },
  getCurrentFormattedTime() {
    const e = this.getCurrentTime();
    return {
      time: {
        short: this.format(e, "time.short"),
        long: this.format(e, "time.long")
      },
      date: {
        short: this.format(e, "date.short"),
        long: this.format(e, "date.long")
      },
      year: {
        short: this.format(e, "year.short"),
        long: this.format(e, "year.long")
      },
      iso: this.format(e, "iso")
    };
  },
  getStep() {
    return this.get().step;
  },
  setStep(e) {
    this.getStep() !== e && j.patch("time", { step: e });
  },
  // Round hours to expected interval, e.g. using 6 hourly interval 00 || 06 || 12 || 18
  roundHours(e, t) {
    return Math.floor(e / t) * t;
  }
}, og = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  mi: {
    symbol: "units.MILE_SYMBOL",
    label: "units.MILE_LABEL"
  },
  NM: {
    symbol: "units.NAUTICAL_MILE_SYMBOL",
    label: "units.NAUTICAL_MILE_LABEL",
    definition: "1852 m"
  }
}, ag = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  ft: {
    symbol: "units.FEET_SYMBOL",
    label: "units.FEET_LABEL"
  }
}, lg = {
  "m^2": {
    symbol: "units.SQUARED_METER_SYMBOL",
    label: "units.SQUARED_METER_LABEL"
  },
  "km^2": {
    symbol: "units.SQUARED_KILOMETER_SYMBOL",
    label: "units.SQUARED_KILOMETER_LABEL"
  },
  acre: {
    symbol: "units.ACRE_SYMBOL",
    label: "units.ACRE_LABEL"
  },
  hectare: {
    symbol: "units.HECTARE_SYMBOL",
    label: "units.HECTARE_LABEL"
  }
}, cg = {
  "m/s": {
    symbol: "units.METER_PER_SECOND_SYMBOL",
    label: "units.METER_PER_SECOND_LABEL"
  },
  "km/h": {
    symbol: "units.KILOMETER_PER_HOUR_SYMBOL",
    label: "units.KILOMETER_PER_HOUR_LABEL"
  },
  "mi/h": {
    symbol: "units.MILES_PER_HOUR_SYMBOL",
    label: "units.MILES_PER_HOUR_LABEL"
  },
  kt: {
    symbol: "units.KNOT_SYMBOL",
    label: "units.KNOT_LABEL",
    definition: "0.514444 m/s",
    override: !0
    // because kt can be kilo ton :(
  }
}, ug = {
  degC: {
    symbol: "units.CELSIUS_SYMBOL",
    label: "units.CELSIUS_LABEL"
  },
  degF: {
    symbol: "units.FAHRENHEIT_SYMBOL",
    label: "units.FAHRENHEIT_LABEL"
  },
  K: {
    symbol: "units.KELVIN_SYMBOL",
    label: "units.KELVIN_LABEL"
  }
}, dg = {
  deg: {
    symbol: "units.DEGREE_SYMBOL",
    label: "units.DEGREE_LABEL"
  },
  rad: {
    symbol: "units.RADIAN_SYMBOL",
    label: "units.RADIAN_LABEL"
  }
}, fg = {
  ppm: {
    symbol: "units.PPM_SYMBOL",
    label: "units.PPM_LABEL"
  }
}, hg = {
  "ug/m^3": {
    symbol: "units.MICROGRAM_PER_M3_SYMBOL",
    label: "units.MICROGRAM_PER_M3_LABEL"
  }
}, mg = {
  "m^3/s": {
    symbol: "units.CUBIC_METER_PER_SECOND_SYMBOL",
    label: "units.CUBIC_METER_PER_SECOND_LABEL"
  }
}, gg = {
  bq: {
    symbol: "units.BEQUEREL_SYMBOL",
    label: "units.BEQUEREL_LABEL",
    baseName: "radioactivity"
  }
}, pg = {
  "bq/m^2": {
    symbol: "units.BEQUEREL_PER_M2_SYMBOL",
    label: "units.BEQUEREL_PER_M2_LABEL"
  },
  "bq/m^3": {
    symbol: "units.BEQUEREL_PER_M3_SYMBOL",
    label: "units.BEQUEREL_PER_M3_LABEL"
  }
}, yg = {
  sv: {
    symbol: "units.SIEVERT_SYMBOL",
    label: "units.SIEVERT_LABEL",
    baseName: "equivalentDose",
    aliases: ["sievert"]
  },
  msv: {
    symbol: "units.MILLISIEVERT_SYMBOL",
    label: "units.MILLISIEVERT_LABEL",
    definition: "0.001 sv"
  },
  usv: {
    symbol: "units.MICROSIEVERT_SYMBOL",
    label: "units.MICROSIEVERT_LABEL",
    definition: "0.000001 sv"
  },
  nsv: {
    symbol: "units.NANOSIEVERT_SYMBOL",
    label: "units.NANOSIEVERT_LABEL",
    definition: "0.000000001 sv"
  }
}, vg = {
  svs: {
    symbol: "units.SIEVERT_PER_SECOND_SYMBOL",
    label: "units.SIEVERT_PER_SECOND_LABEL",
    baseName: "equivalentDoseRate"
  },
  msvs: {
    symbol: "units.MILLISIEVERT_PER_SECOND_SYMBOL",
    label: "units.MILLISIEVERT_PER_SECOND_LABEL",
    definition: "0.001 svs"
  },
  usvs: {
    symbol: "units.MICROSIEVERT_PER_SECOND_SYMBOL",
    label: "units.MICROSIEVERT_PER_SECOND_LABEL",
    definition: "0.000001 svs"
  },
  nsvs: {
    symbol: "units.NANOSIEVERT_PER_SECOND_SYMBOL",
    label: "units.NANOSIEVERT_PER_SECOND_LABEL",
    definition: "0.000000001 svs"
  },
  svh: {
    symbol: "units.SIEVERT_PER_HOUR_SYMBOL",
    label: "units.SIEVERT_PER_HOUR_LABEL",
    definition: "0.000277778 svs"
  },
  msvh: {
    symbol: "units.MILLISIEVERT_PER_HOUR_SYMBOL",
    label: "units.MILLISIEVERT_PER_HOUR_LABEL",
    definition: "0.000000277778 svs"
  },
  usvh: {
    symbol: "units.MICROSIEVERT_PER_HOUR_SYMBOL",
    label: "units.MICROSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000277778 svs"
  },
  nsvh: {
    symbol: "units.NANOSIEVERT_PER_HOUR_SYMBOL",
    label: "units.NANOSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000000277778 svs"
  }
}, bg = {
  length: og,
  altitude: ag,
  area: lg,
  velocity: cg,
  temperature: ug,
  angle: dg,
  fraction: fg,
  density: hg,
  volumeVelocity: mg,
  radioactivity: gg,
  radioactivityDensity: pg,
  equivalentDose: yg,
  equivalentDoseRate: vg
}, Me = {
  initialize() {
    j.set("units", a.defaultsDeep(
      me.units || {},
      bg,
      {
        default: {
          length: "m",
          altitude: "m",
          area: "m^2",
          velocity: "m/s",
          temperature: "degC",
          angle: "deg",
          radioactivity: "bq",
          equivalentDose: "usv",
          equivalentDoseRate: "usvh",
          notation: "auto",
          precision: 3
        }
      }
    )), this.getQuantities().forEach((e) => {
      this.createUnits(e);
    });
  },
  createUnits(e) {
    a.sortBy(this.getUnits(e), [(i) => i.baseName ? 0 : 1]).forEach((i) => {
      Ei.Unit.isValuelessUnit(i.name) && !i.override || (i.definition || i.baseName) && Ei.createUnit(i.name, a.omit(i, ["label", "override"]), { override: a.get(i, "override", !1) });
    });
  },
  get() {
    return j.get("units");
  },
  getDefaultNotation() {
    return j.get("units.default.notation", "auto");
  },
  getDefaultPrecision() {
    return j.get("units.default.precision", 3);
  },
  getQuantities() {
    return a.keys(a.omit(this.get(), ["default"]));
  },
  setUnits(e, t) {
    j.set(`units.${e}`, t), this.createUnits(e);
  },
  getUnits(e) {
    if (e) {
      const t = j.get(`units.${e}`, {});
      return a.values(a.mapValues(t, (i, n) => Object.assign({ name: n, quantity: e }, i)));
    } else {
      let t = [];
      return this.getQuantities().forEach((i) => {
        t = t.concat(this.getUnits(i));
      }), t;
    }
  },
  // Get unit definition by name
  getUnit(e) {
    let t;
    return a.forOwn(this.get(), (i, n) => {
      !t && a.has(i, e) && (t = Object.assign({ name: e, quantity: n }, a.get(i, e)));
    }), t || (t = { name: e, symbol: e, label: e }), t;
  },
  // Get unit symbol by unit name/definition
  getUnitSymbol(e) {
    const t = typeof e == "object" ? e : this.getUnit(e);
    return t && t.symbol ? Y.tie(t.symbol) : e;
  },
  // Get default unit definition (if any) for a given quantity/unit name/definition
  getDefaultUnit(e) {
    if (!e) return null;
    typeof e == "object" && (e = e.name);
    let t = j.get(`units.default.${e}`);
    if (t)
      t = this.getUnit(t);
    else {
      const i = this.getUnit(e);
      i && (t = this.getDefaultUnit(i.quantity));
    }
    return t;
  },
  // Set default unit name for a quantity
  setDefaultUnit(e, t) {
    j.set(`units.default.${e}`, t);
  },
  // Get symbol of default unit (if any) for a given quantity/unit name/definition
  getDefaultUnitSymbol(e) {
    return this.getUnitSymbol(this.getDefaultUnit(e));
  },
  // Get target unit definition for a source unit name/definition, will be default unit (if any) or source unit
  getTargetUnit(e) {
    return this.getDefaultUnit(e) || (typeof e == "object" ? e : this.getUnit(e));
  },
  // Get target unit symbol for a source unit name/definition, will be default unit symbol (if any) or source unit symbol
  getTargetUnitSymbol(e) {
    return this.getUnitSymbol(this.getTargetUnit(e));
  },
  // Convert between units by names/definitions
  // If target unit is not specified will use default unit (if any) for source unit
  convert(e, t, i) {
    if (a.isNil(e) || !a.isFinite(e) || e === Number.MIN_VALUE || e === Number.MAX_VALUE) return e;
    const n = typeof t == "string" ? this.getUnit(t) : t;
    let r = typeof i == "string" ? this.getUnit(i) : i;
    if (!r && n && (r = this.getDefaultUnit(n)), !n || !r || r.name === n.name) return e;
    const s = n.name.replace("^", ""), o = r.name.replace("^", "");
    if (!Ei.Unit.isValuelessUnit(s) || !Ei.Unit.isValuelessUnit(o)) return e;
    let l = Ei.unit(e, s);
    return l = l.toNumber(o), l = o === "deg" && l < 0 ? l + 360 : l, l;
  },
  // Format display of source value in target unit, converting from source unit
  // If target unit is not specified will use default unit (if any) for source unit
  // options are mathjs format options
  format(e, t, i, n) {
    if (a.isNil(e)) {
      I.warn("[KDK] cannot format a nil value");
      return;
    }
    i || (i = this.getDefaultUnit(t));
    const r = i ? this.convert(e, t, i) : e;
    n = Object.assign({
      symbol: !0,
      notation: this.getDefaultNotation(),
      precision: this.getDefaultPrecision(),
      lowerExp: -this.getDefaultPrecision(),
      upperExp: this.getDefaultPrecision()
    }, n);
    let s = Ei.format(r, n);
    return n.symbol && (s += ` ${i ? this.getUnitSymbol(i) : this.getUnitSymbol(t)}`), s;
  }
}, wg = ["handler", "visible", "hidden", "disabled", "on.listener"], _g = ["content", "visible", "hidden", "route"];
function da(e, t) {
  const i = t.split(".");
  let n = e;
  for (const r of i) {
    if (!n || !(r in n))
      return !1;
    n = n[r];
  }
  return !0;
}
function Ai(e, t) {
  if (typeof e != "object") return e;
  const i = Array.isArray(e), n = a.keys(e);
  let r = e;
  return i ? r.forEach((s) => {
    s.content && (s.content = Ai(s.content, t));
  }) : (r.content ? r.content = Ai(r.content, t) : n.forEach((s) => {
    const o = r[s];
    r[s] = Ai(o, t);
  }), r = [r]), r = r.filter(Te(t)), i ? r : r[0];
}
function kn(e, t, i = []) {
  const n = a.flatMapDeep(e);
  return a.forEach(n, (r) => {
    wg.forEach((s) => xc(r, s, t)), mr(r, t, i), r.content && kn(r.content, t, i);
  }), e;
}
function mr(e, t, i = []) {
  if (Array.isArray(e))
    for (let n = 0; n < e.length; n++)
      e[n] = mr(e[n], t);
  else typeof e == "object" && a.forOwn(e, (n, r) => {
    !_g.includes(r) && !i.includes(r) && (typeof n == "string" ? e[r] = so(n, t) : e[r] = mr(n, t));
  });
  return e;
}
function xc(e, t, i) {
  const n = a.get(e, t);
  if (Array.isArray(n)) {
    const r = n.map((s) => Xn(i, s.name || s, s.params));
    a.set(e, t, (...s) => r.reduce((o, l) => o && l(...s), !0));
  } else n && typeof n == "object" ? n.name ? n.name.startsWith(":") || a.set(e, t, Xn(i, n.name, n.params)) : I.debug(`[KDK] invalid handler binding for ${n}: you must provide the name to the function to be called`) : typeof n == "string" && !n.startsWith(":") && a.set(e, t, Xn(i, n));
  return a.get(e, t);
}
function Xn(e, t, i) {
  const n = t.startsWith("!");
  return n && (t = t.substring(1)), (...r) => {
    let s;
    const o = a.get(e, t);
    return typeof o == "function" ? s = o(...i ? gr(i, e, r) : r) : s = o, n ? !s : s;
  };
}
function gr(e, t, i) {
  return a.isNil(e) ? e : Array.isArray(e) ? e.map((n) => gr(n, t, i)) : typeof e == "object" ? a.mapValues(e, (n, r) => gr(n, t, i)) : so(e, t, i);
}
function so(e, t, i) {
  if (typeof e == "string" && e.startsWith(":")) {
    if (e.startsWith(":store.")) {
      const n = e.replace(":store.", "");
      if (j.has(n)) return j.get(n);
    } else if (e.startsWith(":storeRef.")) {
      const n = e.replace(":storeRef.", "");
      if (da(j, n)) return j.getRef(n);
    } else {
      const n = e.substring(1), r = a.toNumber(n);
      if (a.isFinite(r)) return i[r];
      if (da(t, n)) return a.get(t, n);
    }
    return;
  }
  return e;
}
const on = {
  drawer: 3e3,
  // see Quasar css variables
  panes: 1e3,
  fab: 1e3,
  stickies: 980,
  focus: 1010
}, $e = "layout", it = { content: void 0, filter: {}, mode: void 0, visible: !1 }, Un = { opener: !1, size: [0, 0], zIndex: on.panes }, Sc = { menu: !0, pin: !0, unpin: !0, maximize: !0, restore: !0, close: !0, resize: !0 }, Vn = { state: void 0, position: void 0, size: void 0, current: void 0, controls: Sc, controlsMenuBreakpoint: "xs", zIndex: 980 }, fa = {
  minSize: [300, 200],
  floating: { position: [0, 0], size: [300, 200] },
  pinned: { xs: [100, 30], sm: [90, 30], md: [80, 30], lg: [70, 30], xl: [60, 30] }
}, ha = {
  minSize: [200, 300],
  floating: { position: [0, 0], size: [200, 300] },
  pinned: { xs: [50, 90], sm: [40, 80], md: [30, 75], lg: [25, 75], xl: [20, 75] }
}, ma = {
  view: "lHh LpR lFf",
  padding: !0,
  mode: void 0,
  header: { ...it, size: [void 0, 0] },
  footer: { ...it, size: [void 0, 0] },
  page: { ...it, size: [0, 0] },
  stickies: { ...it, zIndex: on.stickies },
  fab: { ...it, icon: "las la-ellipsis-v", position: "bottom-right", offset: [16, 16], zIndex: on.fab },
  panes: {
    left: { ...it, ...Un, sizes: 300, zIndex: on.drawer },
    top: { ...it, ...Un, sizes: void 0 },
    right: { ...it, ...Un, sizes: { xs: [85, 75], sm: [360, 75], md: [440, 80], lg: [500, 80], xl: [500, 85] } },
    bottom: { ...it, ...Un, sizes: void 0 }
  },
  windows: {
    left: { ...it, ...Vn, sizePolicy: ha },
    top: { ...it, ...Vn, sizePolicy: fa },
    right: { ...it, ...Vn, sizePolicy: ha },
    bottom: { ...it, ...Vn, sizePolicy: fa }
  },
  focus: {
    element: null,
    zIndex: on.focus
  }
}, ee = {
  placements: ["top", "right", "bottom", "left"],
  paths: {
    layout: $e,
    view: $e + ".view",
    padding: $e + ".padding",
    mode: $e + ".mode",
    header: $e + ".header",
    footer: $e + ".footer",
    page: $e + ".page",
    stickies: $e + ".stickies",
    fab: $e + ".fab",
    panes: {
      left: $e + ".panes.left",
      top: $e + ".panes.top",
      right: $e + ".panes.right",
      bottom: $e + ".panes.bottom"
    },
    windows: {
      left: $e + ".windows.left",
      top: $e + ".windows.top",
      right: $e + ".windows.right",
      bottom: $e + ".windows.bottom"
    },
    focus: $e + ".focus"
  },
  defaults: ma,
  initialize() {
    j.set(this.paths.view, this.getElementDefaults("view")), j.set(this.paths.padding, this.getElementDefaults("padding")), j.set(this.paths.header, this.getElementDefaults("header")), j.set(this.paths.footer, this.getElementDefaults("footer")), j.set(this.paths.page, this.getElementDefaults("page")), j.set(this.paths.stickies, this.getElementDefaults("stickies")), j.set(this.paths.fab, this.getElementDefaults("fab")), this.placements.forEach((e) => {
      j.set(a.get(this.paths.panes, e), this.getElementDefaults(`panes.${e}`)), j.set(a.get(this.paths.windows, e), this.getElementDefaults(`windows.${e}`));
    }), j.set(this.paths.focus, this.getElementDefaults("focus")), I.debug("[KDK] Layout initialized with configuration:", this.get());
  },
  get() {
    return j.get(this.paths.layout);
  },
  set(e) {
    a.has(e, "view") && this.setView(e.view), a.has(e, "padding") && this.setPadding(e.padding), a.has(e, "header") && this.setHeader(e.header), a.has(e, "footer") && this.setFooter(e.footer), a.has(e, "page") && this.setPage(e.page), a.has(e, "stickies") && this.setStickies(e.stickies), a.has(e, "fab") && this.setFab(e.fab), this.placements.forEach((t) => {
      a.has(e, `panes.${t}`) && this.setPane(t, a.get(e, `panes.${t}`)), a.has(e, `windows.${t}`) && this.setWindow(t, a.get(e, `windows.${t}`));
    }), a.has(e, "mode") && this.setMode(e.mode), a.has(e, "focus") && this.setFocus(e.focus);
  },
  setView(e) {
    if (a.isNil(e)) {
      I.warn("[KDK] Undefined 'view' argument");
      return;
    }
    j.patch(this.paths.layout, { view: e });
  },
  clearView() {
    j.patch(this.paths.layout, { view: this.getElementDefaults("view") });
  },
  getPadding() {
    return this.get().padding;
  },
  setPadding(e) {
    if (a.isNil(e)) {
      I.warn("[KDK] Undefined 'padding' argument");
      return;
    }
    j.patch(this.paths.layout, { padding: e });
  },
  clearPadding() {
    j.patch(this.paths.layout, { padding: this.getElementDefaults("padding") });
  },
  getMode() {
    return this.get().mode;
  },
  setMode(e) {
    this.getMode() !== e && (this.setHeaderMode(e), this.setFooterMode(e), this.setPageMode(e), this.setFabMode(e), this.setStickiesMode(e), this.placements.forEach((t) => {
      this.setPaneMode(t, e), this.setWindowMode(t, e);
    }), j.patch(this.paths.layout, { mode: e }));
  },
  clearMode() {
    j.patch(this.paths.layout, { mode: void 0 });
  },
  getElement(e) {
    return j.get(this.getElementPath(e));
  },
  getElementPath(e) {
    return a.get(this.paths, e);
  },
  getElementDefaults(e) {
    const t = this.getElementPath(e), i = a.get(ma, e), n = a.get(me, t);
    return n ? a.defaultsDeep(a.cloneDeep(n), i) : a.cloneDeep(i);
  },
  setElement(e, t, i, n = []) {
    const r = a.defaultsDeep(a.cloneDeep(t), this.getElementDefaults(e)), { content: s, mode: o } = r;
    !a.isEmpty(s) && i && (r.content = kn(s, i, n)), Array.isArray(s) ? r.components = s.filter(Te(r.filter)) : r.components = a.get(s, o, []).filter(Te(r.filter)), j.patch(this.getElementPath(e), r);
  },
  setElementMode(e, t) {
    const i = this.getElement(e);
    if (i.mode === t) return;
    let n;
    Array.isArray(i.content) ? n = i.content.filter(Te(i.filter)) : n = a.get(i.content, t, []).filter(Te(i.filter)), j.patch(this.getElementPath(e), { mode: t, components: n });
  },
  setElementFilter(e, t) {
    const i = this.getElement(e);
    if (a.isEqual(i.filter, t)) return;
    let n;
    Array.isArray(i.content) ? n = i.content.filter(Te(i.filter)) : n = a.get(i.content, i.mode, []).filter(Te(i.filter)), j.patch(this.getElementPath(e), { filter: t, components: n });
  },
  setElementVisible(e, t) {
    this.getElement(e).visible !== t && j.patch(this.getElementPath(e), { visible: t });
  },
  setElementSize(e, t) {
    if (!Array.isArray(t) && t.length !== 2) {
      I.warn(`[KDK] Invalid size ${t}`);
      return;
    }
    const i = this.getElement(e);
    a.isEqual(i.size, t) || j.patch(this.getElementPath(e), { size: t });
  },
  clearElement(e) {
    this.setElement(e, this.getElementDefaults(e));
  },
  getHeader() {
    return this.getElement("header");
  },
  setHeader(e, t) {
    this.setElement("header", e, t);
  },
  setHeaderMode(e) {
    this.setElementMode("header", e);
  },
  setHeaderFilter(e) {
    this.setElementFilter("header", e);
  },
  setHeaderVisible(e) {
    this.setElementVisible("header", e);
  },
  setHeaderSize(e) {
    this.setElementSize("header", e);
  },
  clearHeader() {
    this.clearElement("header");
  },
  getFooter() {
    return this.getElement("footer");
  },
  setFooter(e, t) {
    this.setElement("footer", e, t);
  },
  setFooterMode(e) {
    this.setElementMode("footer", e);
  },
  setFooterFilter(e) {
    this.setElementFilter("footer", e);
  },
  setFooterVisible(e) {
    this.setElementVisible("footer", e);
  },
  setFooterSize(e) {
    this.setElementSize("footer", e);
  },
  clearFooter() {
    this.clearElement("footer");
  },
  getPage() {
    return this.getElement("page");
  },
  setPage(e, t) {
    this.setElement("page", e, t);
  },
  setPageMode(e) {
    this.setElementMode("page", e);
  },
  setPageFilter(e) {
    this.setElementFilter("page", e);
  },
  setPageVisible(e) {
    this.setElementVisible("page", e);
  },
  clearPage() {
    this.clearElement("page");
  },
  getStickies() {
    return this.getElement("stickies");
  },
  setStickies(e, t) {
    this.setElement("stickies", e, t);
  },
  setStickiesMode(e) {
    this.setElementMode("stickies", e);
  },
  setStickiesFilter(e) {
    this.setElementFilter("stickies", e);
  },
  setStickiesVisible(e) {
    this.setElementVisible("stickies", e);
  },
  clearStickies() {
    this.clearElement("stickies");
  },
  findSticky(e) {
    return a.find(this.getStickies().components, { id: e });
  },
  showSticky(e) {
    const t = this.findSticky(e);
    if (!t) {
      I.error(`[KDK] Cannot find sticky with id '${e}'`);
      return;
    }
    a.set(t, "visible", !0);
  },
  hideSticky(e) {
    const t = this.findSticky(e);
    if (!t) {
      I.error(`[KDK] Cannot find sticky with id '${e}'`);
      return;
    }
    a.set(t, "visible", !1);
  },
  getFab() {
    return this.getElement("fab");
  },
  setFab(e, t) {
    this.setElement("fab", e, t);
  },
  setFabMode(e) {
    this.setElementMode("fab", e);
  },
  setFabFilter(e) {
    this.setElementFilter("fab", e);
  },
  setFabVisible(e) {
    this.setElementVisible("fab", e);
  },
  setFabIcon(e) {
    this.getElement("fab").icon !== e && j.patch(this.getElementPath("fab"), { icon: e });
  },
  setFabPosition(e) {
    if (!["top-left", "top-right", "bottom-left", "bottom-right"].includes(e)) {
      I.warn(`[KDK] Invalid position ${e}`);
      return;
    }
    this.getElement("fab").position !== e && j.patch(this.getElementPath("fab"), { position: e });
  },
  setFabOffset(e) {
    if (!Array.isArray(e) && e.length !== 2) {
      I.warn(`[KDK] Invalid offset ${e}`);
      return;
    }
    this.getElement("fab").offset !== e && j.patch(this.getElementPath("fab"), { offset: e });
  },
  clearFab() {
    this.clearElement("fab");
  },
  getPane(e) {
    return this.getElement(`panes.${e}`);
  },
  setPane(e, t, i) {
    this.setElement(`panes.${e}`, t, i);
  },
  setPaneMode(e, t) {
    this.setElementMode(`panes.${e}`, t);
  },
  setPaneFilter(e, t) {
    this.setElementFilter(`panes.${e}`, t);
  },
  setPaneVisible(e, t) {
    this.setElementVisible(`panes.${e}`, t);
  },
  setPaneOpener(e, t) {
    this.getElement(`panes.${e}`).opener !== t && j.patch(this.getElementPath(`panes.${e}`), { opener: t });
  },
  setPaneSizes(e, t) {
    const i = this.getElement(`panes.${e}`);
    a.isEqual(i.sizes, t) || j.patch(this.getElementPath(`panes.${e}`), { sizes: t });
  },
  clearPane(e) {
    this.clearElement(`panes.${e}`);
  },
  getWindow(e) {
    return this.getElement(`windows.${e}`);
  },
  setWindow(e, t, i) {
    this.setElement(`windows.${e}`, t, i, ["header", "fab"]);
  },
  setWindowMode(e, t) {
    this.setElementMode(`windows.${e}`, t);
  },
  setWindowFilter(e, t) {
    this.setElementFilter(`windows.${e}`, t);
  },
  setWindowVisible(e, t) {
    this.setElementVisible(`windows.${e}`, t);
  },
  setWindowControls(e, t) {
    for (const n of a.keys(Sc))
      if (!a.has(t, n)) {
        I.warn(`[KDK] Invalid window control key ${n}`);
        return;
      }
    const i = this.getElement(`windows.${e}`);
    a.isEqual(i.controls, t) || j.patch(this.getElementPath(`windows.${e}`), { controls: t });
  },
  setWindowState(e, t) {
    if (!["pinned", "floating", "maximized"].includes(t)) {
      I.warn(`[KDK] Invalid window state ${t}`);
      return;
    }
    this.getElement(`windows.${e}`).state !== t && j.patch(this.getElementPath(`windows.${e}`), { state: t });
  },
  setWindowPosition(e, t) {
    if (!Array.isArray(t) && t.length !== 2) {
      I.warn(`[KDK] Invalid position ${t}`);
      return;
    }
    const i = this.getElement(`windows.${e}`);
    a.isEqual(i.position, t) || j.patch(this.getElementPath(`windows.${e}`), { position: t });
  },
  setWindowSize(e, t) {
    this.setElementSize(`windows.${e}`, t);
  },
  setWindowSizePolicy(e, t) {
    if (!t.minSize || !t.floating || !t.pinned) {
      I.warn(`[KDK] Invalid window sizePolicy ${t}`);
      return;
    }
    const i = this.getElement(`windows.${e}`);
    a.isEqual(i.sizePolicy, t) || j.patch(this.getElementPath(`windows.${e}`), { sizePolicy: t });
  },
  setWindowCurrent(e, t) {
    const i = this.getElement(`windows.${e}`);
    if (i.current === t) return;
    a.find(i.components, { id: t }) || (t = a.get(i.components, "[0].id")), j.patch(this.getElementPath(`windows.${e}`), { current: t });
  },
  clearWindow(e) {
    this.clearElement(`windows.${e}`);
  },
  findWindow(e) {
    for (const t of this.placements) {
      const i = this.getWindow(t);
      if (a.find(i.components, { id: e }))
        return { placement: t, window: i };
    }
    return I.debug(`[KDK] Unable to find the widget ${e}`), { placement: void 0, window: void 0 };
  },
  openWidget(e, t = !0) {
    const { placement: i, window: n } = this.findWindow(e);
    i && (n.current !== "current" && this.setWindowCurrent(i, e), n.visible || this.setWindowVisible(i, !0), t && ee.setFocus(`windows.${i}`));
  },
  closeWidget(e) {
    const { placement: t, window: i } = this.findWindow(e);
    t && i.visible && this.setWindowVisible(t, !1);
  },
  setFocus(e) {
    const t = this.getElement("focus");
    if (t.element) {
      if (t.element === e) return;
      j.patch(this.getElementPath(t.element.path), { zIndex: t.element.zIndex });
    }
    const i = this.getElement(e);
    j.patch(this.getElementPath("focus"), { element: { path: e, zIndex: i.zIndex } }), j.patch(this.getElementPath(e), { zIndex: t.zIndex });
  },
  clearFocus() {
    this.clearElement("focus");
  }
}, Ec = {
  initialize() {
    j.set("filter", { fields: "name", pattern: "", items: [], query: {} }), ne.on("filter-changed", () => this.updateFilterQuery());
  },
  get() {
    return j.get("filter");
  },
  getItems() {
    return j.get("filter.items");
  },
  getFields() {
    const e = j.get("filter.fields");
    return typeof e == "string" ? [e] : e;
  },
  getPattern() {
    return j.get("filter.pattern");
  },
  getQuery() {
    return j.get("filter.query");
  },
  clear() {
    j.patch("filter", { fields: "name", pattern: "", items: [], query: {} });
  },
  // Build query from filter pattern and/or items
  updateFilterQuery() {
    const e = {}, t = this.getPattern(), i = this.getFields(), n = this.getItems();
    t !== "" && (e.$or = a.map(i, (r) => ({ [r]: { $search: t } }))), n.forEach((r) => {
      const s = { [r.field]: r[r.field] };
      r.baseQuery && Object.assign(s, r.baseQuery), Object.assign(e, { [r.service]: { $elemMatch: s } });
    }), a.isEqual(e, this.getQuery()) || j.patch("filter", { query: e });
  }
}, Cc = {
  initialize() {
    j.set("sorter", { field: "name", order: "1", query: {} }), ne.on("sorter-changed", () => this.updateSorterQuery());
  },
  get() {
    return j.get("sorter");
  },
  getField() {
    return this.get().field;
  },
  getOrder() {
    return this.get().order;
  },
  getQuery() {
    return j.get("sorter.query");
  },
  // Build sort query
  updateSorterQuery() {
    const e = { $sort: { [this.getField()]: this.getOrder() } };
    a.isEqual(e, this.getQuery()) || j.patch("sorter", { query: e });
  }
}, Tc = {
  initialize() {
    this.options = a.defaultsDeep(a.get(me, "document"), {
      viewers: {
        htm: "document/KHtml",
        html: "document/KHtml",
        "text/html": "document/KHtml",
        txt: "document/KHtml",
        "text/plain": "document/KHtml",
        csv: "document/KCsv",
        "text/csv": "document/KCsv",
        md: "document/KMarkdown",
        "text/markdown": "document/KMarkdown",
        pdf: "document/KPdf",
        "application/pdf": "document/KPdf",
        jpg: "document/KImage",
        jpeg: "document/KImage",
        "image/jpeg": "document/KImage",
        png: "document/KImage",
        "image/png": "document/KImage",
        apng: "document/KImage",
        "image/apng": "document/KImage",
        gif: "document/KImage",
        "image/gif": "document/KImage",
        svg: "document/KImage",
        "image/svg+xml": "document/KImage",
        webp: "document/KImage",
        "image/webp": "document/KImage",
        mp4: "document/KVideo",
        "video/mp4": "document/KVideo",
        mkv: "document/KVideo",
        "video/x-matroska": "document/KVideo",
        mov: "document/KVideo",
        "video/quicktime": "document/KVideo",
        webm: "document/KVideo",
        "video/webm": "document/KVideo"
      },
      browser: {
        scrollableViewers: ["document/KHtml", "document/KMarkdown", "document/KCsv"]
      },
      htmlSanitizer: {
        allowedTags: ns.defaults.allowedTags.concat(["img", "strike"]),
        allowedAttributes: a.assign(ns.defaults.allowedAttributes, { div: ["style"] })
      },
      mdConverter: {}
    }), I.debug("[KDK] Document initialized with options:", this.options);
  },
  register(e, t) {
    a.isArray(e) || (e = [e]), a.forEach(e, (i) => {
      a.set(this.options, `viewers.${i}`, t);
    });
  },
  getViewer(e) {
    return a.get(this.options, `viewers.${e}`);
  },
  hasViewer(e) {
    return !a.isNil(this.getViewer(e));
  },
  sanitizeHtml(e) {
    return a.isNil(e) ? null : ns(e, this.options.htmlSanitizer);
  },
  async fetchUrl(e, t) {
    if (a.isEmpty(e)) return null;
    let i;
    t ? i = Y.localize(e) : i = [e];
    let n;
    for (const r of i)
      try {
        if (n = await fetch(r), n.ok) return n;
      } catch {
      }
    return null;
  }
};
function Lg(e, t, i) {
  let n;
  function r() {
    n !== void 0 && (Ts.remove(n), n = void 0);
  }
  return je(() => {
    e.value === !0 && r();
  }), {
    removeFromHistory: r,
    addToHistory() {
      n = {
        condition: () => i.value === !0,
        handler: t
      }, Ts.add(n);
    }
  };
}
function xg() {
  let e = null;
  const t = qe();
  function i() {
    e !== null && (clearTimeout(e), e = null);
  }
  return Gs(i), je(i), {
    removeTimeout: i,
    registerTimeout(n, r) {
      i(), vc(t) === !1 && (e = setTimeout(n, r));
    }
  };
}
function Sg() {
  let e;
  const t = qe();
  function i() {
    e = void 0;
  }
  return Gs(i), je(i), {
    removeTick: i,
    registerTick(n) {
      e = n, xt(() => {
        e === n && (vc(t) === !1 && e(), e = void 0);
      });
    }
  };
}
const Eg = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
}, Cg = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function Tg({
  showing: e,
  canShow: t,
  // optional
  hideOnRouteChange: i,
  // optional
  handleShow: n,
  // optional
  handleHide: r,
  // optional
  processOnMount: s
  // optional
}) {
  const o = qe(), { props: l, emit: c, proxy: u } = o;
  let d;
  function f(p) {
    e.value === !0 ? v(p) : m(p);
  }
  function m(p) {
    if (l.disable === !0 || p !== void 0 && p.qAnchorHandled === !0 || t !== void 0 && t(p) !== !0)
      return;
    const y = l["onUpdate:modelValue"] !== void 0;
    y === !0 && (c("update:modelValue", !0), d = p, xt(() => {
      d === p && (d = void 0);
    })), (l.modelValue === null || y === !1) && g(p);
  }
  function g(p) {
    e.value !== !0 && (e.value = !0, c("beforeShow", p), n !== void 0 ? n(p) : c("show", p));
  }
  function v(p) {
    if (l.disable === !0)
      return;
    const y = l["onUpdate:modelValue"] !== void 0;
    y === !0 && (c("update:modelValue", !1), d = p, xt(() => {
      d === p && (d = void 0);
    })), (l.modelValue === null || y === !1) && x(p);
  }
  function x(p) {
    e.value !== !1 && (e.value = !1, c("beforeHide", p), r !== void 0 ? r(p) : c("hide", p));
  }
  function S(p) {
    l.disable === !0 && p === !0 ? l["onUpdate:modelValue"] !== void 0 && c("update:modelValue", !1) : p === !0 !== e.value && (p === !0 ? g : x)(d);
  }
  _e(() => l.modelValue, S), i !== void 0 && yc(o) === !0 && _e(() => u.$route.fullPath, () => {
    i.value === !0 && e.value === !0 && v();
  }), Vt(() => {
    S(l.modelValue);
  });
  const A = { show: m, hide: v, toggle: f };
  return Object.assign(u, A), A;
}
const Pg = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function Mg(e, t = () => {
}, i = () => {
}) {
  return {
    transitionProps: W(() => {
      const n = `q-transition--${e.transitionShow || t()}`, r = `q-transition--${e.transitionHide || i()}`;
      return {
        appear: !0,
        enterFromClass: `${n}-enter-from`,
        enterActiveClass: `${n}-enter-active`,
        enterToClass: `${n}-enter-to`,
        leaveFromClass: `${r}-leave-from`,
        leaveActiveClass: `${r}-leave-active`,
        leaveToClass: `${r}-leave-to`
      };
    }),
    transitionStyle: W(() => `--q-transition-duration: ${e.transitionDuration}ms`)
  };
}
let ci = [], pn = [];
function Pc(e) {
  pn = pn.filter((t) => t !== e);
}
function kg(e) {
  Pc(e), pn.push(e);
}
function ga(e) {
  Pc(e), pn.length === 0 && ci.length !== 0 && (ci[ci.length - 1](), ci = []);
}
function oo(e) {
  pn.length === 0 ? e() : ci.push(e);
}
function Fg(e) {
  ci = ci.filter((t) => t !== e);
}
const ls = [];
function Dg(e) {
  for (e = e.parent; e != null; ) {
    if (e.type.name === "QGlobalDialog")
      return !0;
    if (e.type.name === "QDialog" || e.type.name === "QMenu")
      return !1;
    e = e.parent;
  }
  return !1;
}
function Ag(e, t, i, n) {
  const r = ue(!1), s = ue(!1);
  let o = null;
  const l = {}, c = Dg(e);
  function u(f) {
    if (f === !0) {
      ga(l), s.value = !0;
      return;
    }
    s.value = !1, r.value === !1 && (c === !1 && o === null && (o = zr(!1, n)), r.value = !0, ls.push(e.proxy), kg(l));
  }
  function d(f) {
    if (s.value = !1, f !== !0)
      return;
    ga(l), r.value = !1;
    const m = ls.indexOf(e.proxy);
    m !== -1 && ls.splice(m, 1), o !== null && (io(o), o = null);
  }
  return jf(() => {
    d(!0);
  }), e.proxy.__qPortal = !0, Ui(e.proxy, "contentEl", () => t.value), {
    showPortal: u,
    hidePortal: d,
    portalIsActive: r,
    portalIsAccessible: s,
    renderPortal: () => c === !0 ? i() : r.value === !0 ? [K(Uf, { to: o }, i())] : void 0
  };
}
function Og(e) {
  return e === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : e.scrollTop;
}
function Bg(e) {
  return e === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : e.scrollLeft;
}
function Rg(e, t = !0) {
  return !e || e.nodeType !== Node.ELEMENT_NODE ? !1 : t ? e.scrollHeight > e.clientHeight && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-y"])) : e.scrollWidth > e.clientWidth && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-x"]));
}
let Xi = 0, cs, us, an, ds = !1, pa, ya, va, si = null;
function $g(e) {
  Ig(e) && dt(e);
}
function Ig(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop"))
    return !0;
  const t = tm(e), i = e.shiftKey && !e.deltaX, n = !i && Math.abs(e.deltaX) <= Math.abs(e.deltaY), r = i || n ? e.deltaY : e.deltaX;
  for (let s = 0; s < t.length; s++) {
    const o = t[s];
    if (Rg(o, n))
      return n ? r < 0 && o.scrollTop === 0 ? !0 : r > 0 && o.scrollTop + o.clientHeight === o.scrollHeight : r < 0 && o.scrollLeft === 0 ? !0 : r > 0 && o.scrollLeft + o.clientWidth === o.scrollWidth;
  }
  return !0;
}
function ba(e) {
  e.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop);
}
function Kn(e) {
  ds !== !0 && (ds = !0, requestAnimationFrame(() => {
    ds = !1;
    const { height: t } = e.target, { clientHeight: i, scrollTop: n } = document.scrollingElement;
    (an === void 0 || t !== window.innerHeight) && (an = i - t, document.scrollingElement.scrollTop = n), n > an && (document.scrollingElement.scrollTop -= Math.ceil((n - an) / 8));
  }));
}
function wa(e) {
  const t = document.body, i = window.visualViewport !== void 0;
  if (e === "add") {
    const { overflowY: n, overflowX: r } = window.getComputedStyle(t);
    cs = Bg(window), us = Og(window), pa = t.style.left, ya = t.style.top, va = window.location.href, t.style.left = `-${cs}px`, t.style.top = `-${us}px`, r !== "hidden" && (r === "scroll" || t.scrollWidth > window.innerWidth) && t.classList.add("q-body--force-scrollbar-x"), n !== "hidden" && (n === "scroll" || t.scrollHeight > window.innerHeight) && t.classList.add("q-body--force-scrollbar-y"), t.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = !0, ke.is.ios === !0 && (i === !0 ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", Kn, ct.passiveCapture), window.visualViewport.addEventListener("scroll", Kn, ct.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", ba, ct.passiveCapture));
  }
  ke.is.desktop === !0 && ke.is.mac === !0 && window[`${e}EventListener`]("wheel", $g, ct.notPassive), e === "remove" && (ke.is.ios === !0 && (i === !0 ? (window.visualViewport.removeEventListener("resize", Kn, ct.passiveCapture), window.visualViewport.removeEventListener("scroll", Kn, ct.passiveCapture)) : window.removeEventListener("scroll", ba, ct.passiveCapture)), t.classList.remove("q-body--prevent-scroll"), t.classList.remove("q-body--force-scrollbar-x"), t.classList.remove("q-body--force-scrollbar-y"), document.qScrollPrevented = !1, t.style.left = pa, t.style.top = ya, window.location.href === va && window.scrollTo(cs, us), an = void 0);
}
function ks(e) {
  let t = "add";
  if (e === !0) {
    if (Xi++, si !== null) {
      clearTimeout(si), si = null;
      return;
    }
    if (Xi > 1)
      return;
  } else {
    if (Xi === 0 || (Xi--, Xi > 0))
      return;
    if (t = "remove", ke.is.ios === !0 && ke.is.nativeMobile === !0) {
      si !== null && clearTimeout(si), si = setTimeout(() => {
        wa(t), si = null;
      }, 100);
      return;
    }
  }
  wa(t);
}
function zg() {
  let e;
  return {
    preventBodyScroll(t) {
      t !== e && (e !== void 0 || t === !0) && (e = t, ks(t));
    }
  };
}
const di = [];
let Ii;
function Ng(e) {
  Ii = e.keyCode === 27;
}
function qg() {
  Ii === !0 && (Ii = !1);
}
function jg(e) {
  Ii === !0 && (Ii = !1, gn(e, 27) === !0 && di[di.length - 1](e));
}
function Mc(e) {
  window[e]("keydown", Ng), window[e]("blur", qg), window[e]("keyup", jg), Ii = !1;
}
function Ug(e) {
  ke.is.desktop === !0 && (di.push(e), di.length === 1 && Mc("addEventListener"));
}
function _a(e) {
  const t = di.indexOf(e);
  t > -1 && (di.splice(t, 1), di.length === 0 && Mc("removeEventListener"));
}
const fi = [];
function kc(e) {
  fi[fi.length - 1](e);
}
function Vg(e) {
  ke.is.desktop === !0 && (fi.push(e), fi.length === 1 && document.body.addEventListener("focusin", kc));
}
function La(e) {
  const t = fi.indexOf(e);
  t > -1 && (fi.splice(t, 1), fi.length === 0 && document.body.removeEventListener("focusin", kc));
}
let Gn = 0;
const Kg = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
}, xa = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
}, Gg = We({
  name: "QDialog",
  inheritAttrs: !1,
  props: {
    ...Eg,
    ...Pg,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: "standard",
      validator: (e) => e === "standard" || ["top", "bottom", "left", "right"].includes(e)
    }
  },
  emits: [
    ...Cg,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(e, { slots: t, emit: i, attrs: n }) {
    const r = qe(), s = ue(null), o = ue(!1), l = ue(!1);
    let c = null, u = null, d, f;
    const m = W(
      () => e.persistent !== !0 && e.noRouteDismiss !== !0 && e.seamless !== !0
    ), { preventBodyScroll: g } = zg(), { registerTimeout: v } = xg(), { registerTick: x, removeTick: S } = Sg(), { transitionProps: A, transitionStyle: p } = Mg(
      e,
      () => xa[e.position][0],
      () => xa[e.position][1]
    ), { showPortal: y, hidePortal: w, portalIsAccessible: C, renderPortal: P } = Ag(
      r,
      s,
      we,
      "dialog"
    ), { hide: M } = Tg({
      showing: o,
      hideOnRouteChange: m,
      handleShow: $,
      handleHide: X,
      processOnMount: !0
    }), { addToHistory: z, removeFromHistory: D } = Lg(o, M, m), T = W(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${e.maximized === !0 ? "maximized" : "minimized"} q-dialog__inner--${e.position} ${Kg[e.position]}` + (l.value === !0 ? " q-dialog__inner--animating" : "") + (e.fullWidth === !0 ? " q-dialog__inner--fullwidth" : "") + (e.fullHeight === !0 ? " q-dialog__inner--fullheight" : "") + (e.square === !0 ? " q-dialog__inner--square" : "")
    ), F = W(() => o.value === !0 && e.seamless !== !0), k = W(() => e.autoClose === !0 ? { onClick: de } : {}), O = W(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${F.value === !0 ? "modal" : "seamless"}`,
      n.class
    ]);
    _e(() => e.maximized, (q) => {
      o.value === !0 && ce(q);
    }), _e(F, (q) => {
      g(q), q === !0 ? (Vg(J), Ug(oe)) : (La(J), _a(oe));
    });
    function $(q) {
      z(), u = e.noRefocus === !1 && document.activeElement !== null ? document.activeElement : null, ce(e.maximized), y(), l.value = !0, e.noFocus !== !0 ? (document.activeElement !== null && document.activeElement.blur(), x(te)) : S(), v(() => {
        if (r.proxy.$q.platform.is.ios === !0) {
          if (e.seamless !== !0 && document.activeElement) {
            const { top: ie, bottom: le } = document.activeElement.getBoundingClientRect(), { innerHeight: pe } = window, ge = window.visualViewport !== void 0 ? window.visualViewport.height : pe;
            ie > 0 && le > ge / 2 && (document.scrollingElement.scrollTop = Math.min(
              document.scrollingElement.scrollHeight - ge,
              le >= pe ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + le - ge / 2)
            )), document.activeElement.scrollIntoView();
          }
          f = !0, s.value.click(), f = !1;
        }
        y(!0), l.value = !1, i("show", q);
      }, e.transitionDuration);
    }
    function X(q) {
      S(), D(), fe(!0), l.value = !0, w(), u !== null && (((q && q.type.indexOf("key") === 0 ? u.closest('[tabindex]:not([tabindex^="-"])') : void 0) || u).focus(), u = null), v(() => {
        w(!0), l.value = !1, i("hide", q);
      }, e.transitionDuration);
    }
    function te(q) {
      oo(() => {
        let ie = s.value;
        ie === null || ie.contains(document.activeElement) === !0 || (ie = (q !== "" ? ie.querySelector(q) : null) || ie.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || ie.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || ie.querySelector("[autofocus], [data-autofocus]") || ie, ie.focus({ preventScroll: !0 }));
      });
    }
    function H(q) {
      q && typeof q.focus == "function" ? q.focus({ preventScroll: !0 }) : te(), i("shake");
      const ie = s.value;
      ie !== null && (ie.classList.remove("q-animate--scale"), ie.classList.add("q-animate--scale"), c !== null && clearTimeout(c), c = setTimeout(() => {
        c = null, s.value !== null && (ie.classList.remove("q-animate--scale"), te());
      }, 170));
    }
    function oe() {
      e.seamless !== !0 && (e.persistent === !0 || e.noEscDismiss === !0 ? e.maximized !== !0 && e.noShake !== !0 && H() : (i("escapeKey"), M()));
    }
    function fe(q) {
      c !== null && (clearTimeout(c), c = null), (q === !0 || o.value === !0) && (ce(!1), e.seamless !== !0 && (g(!1), La(J), _a(oe))), q !== !0 && (u = null);
    }
    function ce(q) {
      q === !0 ? d !== !0 && (Gn < 1 && document.body.classList.add("q-body--dialog"), Gn++, d = !0) : d === !0 && (Gn < 2 && document.body.classList.remove("q-body--dialog"), Gn--, d = !1);
    }
    function de(q) {
      f !== !0 && (M(q), i("click", q));
    }
    function R(q) {
      e.persistent !== !0 && e.noBackdropDismiss !== !0 ? M(q) : e.noShake !== !0 && H();
    }
    function J(q) {
      e.allowFocusOutside !== !0 && C.value === !0 && Am(s.value, q.target) !== !0 && te('[tabindex]:not([tabindex="-1"])');
    }
    Object.assign(r.proxy, {
      // expose public methods
      focus: te,
      shake: H,
      // private but needed by QSelect
      __updateRefocusTarget(q) {
        u = q || null;
      }
    }), je(fe);
    function we() {
      return K("div", {
        role: "dialog",
        "aria-modal": F.value === !0 ? "true" : "false",
        ...n,
        class: O.value
      }, [
        K(hn, {
          name: "q-transition--fade",
          appear: !0
        }, () => F.value === !0 ? K("div", {
          class: "q-dialog__backdrop fixed-full",
          style: p.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: R
        }) : null),
        K(
          hn,
          A.value,
          () => o.value === !0 ? K("div", {
            ref: s,
            class: T.value,
            style: p.value,
            tabindex: -1,
            ...k.value
          }, St(t.default)) : null
        )
      ]);
    }
    return P;
  }
}), _i = {
  dark: {
    type: Boolean,
    default: null
  }
};
function Li(e, t) {
  return W(() => e.dark === null ? t.dark.isActive : e.dark);
}
const Hg = We({
  name: "QCard",
  props: {
    ..._i,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: i } } = qe(), n = Li(e, i), r = W(
      () => "q-card" + (n.value === !0 ? " q-card--dark q-dark" : "") + (e.bordered === !0 ? " q-card--bordered" : "") + (e.square === !0 ? " q-card--square no-border-radius" : "") + (e.flat === !0 ? " q-card--flat no-shadow" : "")
    );
    return () => K(e.tag, { class: r.value }, St(t.default));
  }
}), en = We({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(e, { slots: t }) {
    const i = W(
      () => `q-card__section q-card__section--${e.horizontal === !0 ? "horiz row no-wrap" : "vert"}`
    );
    return () => K(e.tag, { class: i.value }, St(t.default));
  }
}), Wg = We({
  name: "QCardActions",
  props: {
    ...gc,
    vertical: Boolean
  },
  setup(e, { slots: t }) {
    const i = pc(e), n = W(
      () => `q-card__actions ${i.value} q-card__actions--${e.vertical === !0 ? "vert column" : "horiz row"}`
    );
    return () => K("div", { class: n.value }, St(t.default));
  }
}), Zg = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
}, fs = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
}, Sa = We({
  name: "QSeparator",
  props: {
    ..._i,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(e) {
    const t = qe(), i = Li(e, t.proxy.$q), n = W(() => e.vertical === !0 ? "vertical" : "horizontal"), r = W(() => ` q-separator--${n.value}`), s = W(() => e.inset !== !1 ? `${r.value}-${Zg[e.inset]}` : ""), o = W(
      () => `q-separator${r.value}${s.value}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (i.value === !0 ? " q-separator--dark" : "")
    ), l = W(() => {
      const c = {};
      if (e.size !== void 0 && (c[e.vertical === !0 ? "width" : "height"] = e.size), e.spaced !== !1) {
        const u = e.spaced === !0 ? `${fs.md}px` : e.spaced in fs ? `${fs[e.spaced]}px` : e.spaced, d = e.vertical === !0 ? ["Left", "Right"] : ["Top", "Bottom"];
        c[`margin${d[0]}`] = c[`margin${d[1]}`] = u;
      }
      return c;
    });
    return () => K("hr", {
      class: o.value,
      style: l.value,
      "aria-orientation": n.value
    });
  }
});
function Qg({ validate: e, resetValidation: t, requiresQForm: i }) {
  const n = kl(hm, !1);
  if (n !== !1) {
    const { props: r, proxy: s } = qe();
    Object.assign(s, { validate: e, resetValidation: t }), _e(() => r.disable, (o) => {
      o === !0 ? (typeof t == "function" && t(), n.unbindComponent(s)) : n.bindComponent(s);
    }), Vt(() => {
      r.disable !== !0 && n.bindComponent(s);
    }), je(() => {
      r.disable !== !0 && n.unbindComponent(s);
    });
  } else i === !0 && console.error("Parent QForm not found on useFormChild()!");
}
const Ea = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, Ca = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, Ta = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, Hn = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, Wn = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/, hs = {
  date: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e),
  time: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(e),
  fulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(e),
  timeOrFulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(e),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (e) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e),
  hexColor: (e) => Ea.test(e),
  hexaColor: (e) => Ca.test(e),
  hexOrHexaColor: (e) => Ta.test(e),
  rgbColor: (e) => Hn.test(e),
  rgbaColor: (e) => Wn.test(e),
  rgbOrRgbaColor: (e) => Hn.test(e) || Wn.test(e),
  hexOrRgbColor: (e) => Ea.test(e) || Hn.test(e),
  hexaOrRgbaColor: (e) => Ca.test(e) || Wn.test(e),
  anyColor: (e) => Ta.test(e) || Hn.test(e) || Wn.test(e)
}, Jg = [!0, !1, "ondemand"], Yg = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    validator: (e) => Jg.includes(e)
  }
};
function Xg(e, t) {
  const { props: i, proxy: n } = qe(), r = ue(!1), s = ue(null), o = ue(null);
  Qg({ validate: v, resetValidation: g });
  let l = 0, c;
  const u = W(
    () => i.rules !== void 0 && i.rules !== null && i.rules.length !== 0
  ), d = W(
    () => i.disable !== !0 && u.value === !0
  ), f = W(
    () => i.error === !0 || r.value === !0
  ), m = W(() => typeof i.errorMessage == "string" && i.errorMessage.length !== 0 ? i.errorMessage : s.value);
  _e(() => i.modelValue, () => {
    x();
  }), _e(() => i.reactiveRules, (A) => {
    A === !0 ? c === void 0 && (c = _e(() => i.rules, () => {
      x(!0);
    })) : c !== void 0 && (c(), c = void 0);
  }, { immediate: !0 }), _e(e, (A) => {
    A === !0 ? o.value === null && (o.value = !1) : o.value === !1 && (o.value = !0, d.value === !0 && i.lazyRules !== "ondemand" && t.value === !1 && S());
  });
  function g() {
    l++, t.value = !1, o.value = null, r.value = !1, s.value = null, S.cancel();
  }
  function v(A = i.modelValue) {
    if (d.value !== !0)
      return !0;
    const p = ++l, y = t.value !== !0 ? () => {
      o.value = !0;
    } : () => {
    }, w = (P, M) => {
      P === !0 && y(), r.value = P, s.value = M || null, t.value = !1;
    }, C = [];
    for (let P = 0; P < i.rules.length; P++) {
      const M = i.rules[P];
      let z;
      if (typeof M == "function" ? z = M(A, hs) : typeof M == "string" && hs[M] !== void 0 && (z = hs[M](A)), z === !1 || typeof z == "string")
        return w(!0, z), !1;
      z !== !0 && z !== void 0 && C.push(z);
    }
    return C.length === 0 ? (w(!1), !0) : (t.value = !0, Promise.all(C).then(
      (P) => {
        if (P === void 0 || Array.isArray(P) === !1 || P.length === 0)
          return p === l && w(!1), !0;
        const M = P.find((z) => z === !1 || typeof z == "string");
        return p === l && w(M !== void 0, M), M === void 0;
      },
      (P) => (p === l && (console.error(P), w(!0)), !1)
    ));
  }
  function x(A) {
    d.value === !0 && i.lazyRules !== "ondemand" && (o.value === !0 || i.lazyRules !== !0 && A !== !0) && S();
  }
  const S = ic(v, 0);
  return je(() => {
    c !== void 0 && c(), S.cancel();
  }), Object.assign(n, { resetValidation: g, validate: v }), Ui(n, "hasError", () => f.value), {
    isDirtyModel: o,
    hasRules: u,
    hasError: f,
    errorMessage: m,
    validate: v,
    resetValidation: g
  };
}
const Pa = /^on[A-Z]/;
function ep(e, t) {
  const i = {
    listeners: ue({}),
    attributes: ue({})
  };
  function n() {
    const r = {}, s = {};
    for (const o in e)
      o !== "class" && o !== "style" && Pa.test(o) === !1 && (r[o] = e[o]);
    for (const o in t.props)
      Pa.test(o) === !0 && (s[o] = t.props[o]);
    i.attributes.value = r, i.listeners.value = s;
  }
  return Vf(n), n(), i;
}
function Fs(e) {
  return e === void 0 ? `f_${ti()}` : e;
}
function Ds(e) {
  return e != null && ("" + e).length !== 0;
}
const tp = {
  ..._i,
  ...Yg,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String,
  maxlength: [Number, String]
}, ip = ["update:modelValue", "clear", "focus", "blur", "popupShow", "popupHide"];
function np() {
  const { props: e, attrs: t, proxy: i, vnode: n } = qe();
  return {
    isDark: Li(e, i.$q),
    editable: W(
      () => e.disable !== !0 && e.readonly !== !0
    ),
    innerLoading: ue(!1),
    focused: ue(!1),
    hasPopupOpen: !1,
    splitAttrs: ep(t, n),
    targetUid: ue(Fs(e.for)),
    rootRef: ue(null),
    targetRef: ue(null),
    controlRef: ue(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function rp(e) {
  const { props: t, emit: i, slots: n, attrs: r, proxy: s } = qe(), { $q: o } = s;
  let l = null;
  e.hasValue === void 0 && (e.hasValue = W(() => Ds(t.modelValue))), e.emitValue === void 0 && (e.emitValue = (H) => {
    i("update:modelValue", H);
  }), e.controlEvents === void 0 && (e.controlEvents = {
    onFocusin: D,
    onFocusout: T
  }), Object.assign(e, {
    clearValue: F,
    onControlFocusin: D,
    onControlFocusout: T,
    focus: M
  }), e.computedCounter === void 0 && (e.computedCounter = W(() => {
    if (t.counter !== !1) {
      const H = typeof t.modelValue == "string" || typeof t.modelValue == "number" ? ("" + t.modelValue).length : Array.isArray(t.modelValue) === !0 ? t.modelValue.length : 0, oe = t.maxlength !== void 0 ? t.maxlength : t.maxValues;
      return H + (oe !== void 0 ? " / " + oe : "");
    }
  }));
  const {
    isDirtyModel: c,
    hasRules: u,
    hasError: d,
    errorMessage: f,
    resetValidation: m
  } = Xg(e.focused, e.innerLoading), g = e.floatingLabel !== void 0 ? W(() => t.stackLabel === !0 || e.focused.value === !0 || e.floatingLabel.value === !0) : W(() => t.stackLabel === !0 || e.focused.value === !0 || e.hasValue.value === !0), v = W(
    () => t.bottomSlots === !0 || t.hint !== void 0 || u.value === !0 || t.counter === !0 || t.error !== null
  ), x = W(() => t.filled === !0 ? "filled" : t.outlined === !0 ? "outlined" : t.borderless === !0 ? "borderless" : t.standout ? "standout" : "standard"), S = W(
    () => `q-field row no-wrap items-start q-field--${x.value}` + (e.fieldClass !== void 0 ? ` ${e.fieldClass.value}` : "") + (t.rounded === !0 ? " q-field--rounded" : "") + (t.square === !0 ? " q-field--square" : "") + (g.value === !0 ? " q-field--float" : "") + (p.value === !0 ? " q-field--labeled" : "") + (t.dense === !0 ? " q-field--dense" : "") + (t.itemAligned === !0 ? " q-field--item-aligned q-item-type" : "") + (e.isDark.value === !0 ? " q-field--dark" : "") + (e.getControl === void 0 ? " q-field--auto-height" : "") + (e.focused.value === !0 ? " q-field--focused" : "") + (d.value === !0 ? " q-field--error" : "") + (d.value === !0 || e.focused.value === !0 ? " q-field--highlighted" : "") + (t.hideBottomSpace !== !0 && v.value === !0 ? " q-field--with-bottom" : "") + (t.disable === !0 ? " q-field--disabled" : t.readonly === !0 ? " q-field--readonly" : "")
  ), A = W(
    () => "q-field__control relative-position row no-wrap" + (t.bgColor !== void 0 ? ` bg-${t.bgColor}` : "") + (d.value === !0 ? " text-negative" : typeof t.standout == "string" && t.standout.length !== 0 && e.focused.value === !0 ? ` ${t.standout}` : t.color !== void 0 ? ` text-${t.color}` : "")
  ), p = W(
    () => t.labelSlot === !0 || t.label !== void 0
  ), y = W(
    () => "q-field__label no-pointer-events absolute ellipsis" + (t.labelColor !== void 0 && d.value !== !0 ? ` text-${t.labelColor}` : "")
  ), w = W(() => ({
    id: e.targetUid.value,
    editable: e.editable.value,
    focused: e.focused.value,
    floatingLabel: g.value,
    modelValue: t.modelValue,
    emitValue: e.emitValue
  })), C = W(() => {
    const H = {
      for: e.targetUid.value
    };
    return t.disable === !0 ? H["aria-disabled"] = "true" : t.readonly === !0 && (H["aria-readonly"] = "true"), H;
  });
  _e(() => t.for, (H) => {
    e.targetUid.value = Fs(H);
  });
  function P() {
    const H = document.activeElement;
    let oe = e.targetRef !== void 0 && e.targetRef.value;
    oe && (H === null || H.id !== e.targetUid.value) && (oe.hasAttribute("tabindex") === !0 || (oe = oe.querySelector("[tabindex]")), oe && oe !== H && oe.focus({ preventScroll: !0 }));
  }
  function M() {
    oo(P);
  }
  function z() {
    Fg(P);
    const H = document.activeElement;
    H !== null && e.rootRef.value.contains(H) && H.blur();
  }
  function D(H) {
    l !== null && (clearTimeout(l), l = null), e.editable.value === !0 && e.focused.value === !1 && (e.focused.value = !0, i("focus", H));
  }
  function T(H, oe) {
    l !== null && clearTimeout(l), l = setTimeout(() => {
      l = null, !(document.hasFocus() === !0 && (e.hasPopupOpen === !0 || e.controlRef === void 0 || e.controlRef.value === null || e.controlRef.value.contains(document.activeElement) !== !1)) && (e.focused.value === !0 && (e.focused.value = !1, i("blur", H)), oe !== void 0 && oe());
    });
  }
  function F(H) {
    dt(H), o.platform.is.mobile !== !0 ? (e.targetRef !== void 0 && e.targetRef.value || e.rootRef.value).focus() : e.rootRef.value.contains(document.activeElement) === !0 && document.activeElement.blur(), t.type === "file" && (e.inputRef.value.value = null), i("update:modelValue", null), i("clear", t.modelValue), xt(() => {
      m(), o.platform.is.mobile !== !0 && (c.value = !1);
    });
  }
  function k() {
    const H = [];
    return n.prepend !== void 0 && H.push(
      K("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: ki
      }, n.prepend())
    ), H.push(
      K("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, O())
    ), d.value === !0 && t.noErrorIcon === !1 && H.push(
      X("error", [
        K(Nt, { name: o.iconSet.field.error, color: "negative" })
      ])
    ), t.loading === !0 || e.innerLoading.value === !0 ? H.push(
      X(
        "inner-loading-append",
        n.loading !== void 0 ? n.loading() : [K($i, { color: t.color })]
      )
    ) : t.clearable === !0 && e.hasValue.value === !0 && e.editable.value === !0 && H.push(
      X("inner-clearable-append", [
        K(Nt, {
          class: "q-field__focusable-action",
          tag: "button",
          name: t.clearIcon || o.iconSet.field.clear,
          tabindex: 0,
          type: "button",
          "aria-hidden": null,
          role: null,
          onClick: F
        })
      ])
    ), n.append !== void 0 && H.push(
      K("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: ki
      }, n.append())
    ), e.getInnerAppend !== void 0 && H.push(
      X("inner-append", e.getInnerAppend())
    ), e.getControlChild !== void 0 && H.push(
      e.getControlChild()
    ), H;
  }
  function O() {
    const H = [];
    return t.prefix !== void 0 && t.prefix !== null && H.push(
      K("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, t.prefix)
    ), e.getShadowControl !== void 0 && e.hasShadow.value === !0 && H.push(
      e.getShadowControl()
    ), e.getControl !== void 0 ? H.push(e.getControl()) : n.rawControl !== void 0 ? H.push(n.rawControl()) : n.control !== void 0 && H.push(
      K("div", {
        ref: e.targetRef,
        class: "q-field__native row",
        tabindex: -1,
        ...e.splitAttrs.attributes.value,
        "data-autofocus": t.autofocus === !0 || void 0
      }, n.control(w.value))
    ), p.value === !0 && H.push(
      K("div", {
        class: y.value
      }, St(n.label, t.label))
    ), t.suffix !== void 0 && t.suffix !== null && H.push(
      K("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, t.suffix)
    ), H.concat(St(n.default));
  }
  function $() {
    let H, oe;
    d.value === !0 ? f.value !== null ? (H = [K("div", { role: "alert" }, f.value)], oe = `q--slot-error-${f.value}`) : (H = St(n.error), oe = "q--slot-error") : (t.hideHint !== !0 || e.focused.value === !0) && (t.hint !== void 0 ? (H = [K("div", t.hint)], oe = `q--slot-hint-${t.hint}`) : (H = St(n.hint), oe = "q--slot-hint"));
    const fe = t.counter === !0 || n.counter !== void 0;
    if (t.hideBottomSpace === !0 && fe === !1 && H === void 0)
      return;
    const ce = K("div", {
      key: oe,
      class: "q-field__messages col"
    }, H);
    return K("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (t.hideBottomSpace !== !0 ? "animated" : "stale"),
      onClick: ki
    }, [
      t.hideBottomSpace === !0 ? ce : K(hn, { name: "q-transition--field-message" }, () => ce),
      fe === !0 ? K("div", {
        class: "q-field__counter"
      }, n.counter !== void 0 ? n.counter() : e.computedCounter.value) : null
    ]);
  }
  function X(H, oe) {
    return oe === null ? null : K("div", {
      key: H,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, oe);
  }
  let te = !1;
  return Gs(() => {
    te = !0;
  }), Kf(() => {
    te === !0 && t.autofocus === !0 && s.focus();
  }), Vt(() => {
    ii.value === !0 && t.for === void 0 && (e.targetUid.value = Fs()), t.autofocus === !0 && s.focus();
  }), je(() => {
    l !== null && clearTimeout(l);
  }), Object.assign(s, { focus: M, blur: z }), function() {
    const oe = e.getControl === void 0 && n.control === void 0 ? {
      ...e.splitAttrs.attributes.value,
      "data-autofocus": t.autofocus === !0 || void 0,
      ...C.value
    } : C.value;
    return K("label", {
      ref: e.rootRef,
      class: [
        S.value,
        r.class
      ],
      style: r.style,
      ...oe
    }, [
      n.before !== void 0 ? K("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: ki
      }, n.before()) : null,
      K("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        K("div", {
          ref: e.controlRef,
          class: A.value,
          tabindex: -1,
          ...e.controlEvents
        }, k()),
        v.value === !0 ? $() : null
      ]),
      n.after !== void 0 ? K("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: ki
      }, n.after()) : null
    ]);
  };
}
const Ma = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
}, pr = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleLowerCase() }
}, Fc = Object.keys(pr);
Fc.forEach((e) => {
  pr[e].regex = new RegExp(pr[e].pattern);
});
const sp = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + Fc.join("") + "])|(.)", "g"), ka = /[.*+?^${}()|[\]\\]/g, Ae = "", op = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function ap(e, t, i, n) {
  let r, s, o, l, c, u;
  const d = ue(null), f = ue(g());
  function m() {
    return e.autogrow === !0 || ["textarea", "text", "search", "url", "tel", "password"].includes(e.type);
  }
  _e(() => e.type + e.autogrow, x), _e(() => e.mask, (D) => {
    if (D !== void 0)
      S(f.value, !0);
    else {
      const T = M(f.value);
      x(), e.modelValue !== T && t("update:modelValue", T);
    }
  }), _e(() => e.fillMask + e.reverseFillMask, () => {
    d.value === !0 && S(f.value, !0);
  }), _e(() => e.unmaskedValue, () => {
    d.value === !0 && S(f.value);
  });
  function g() {
    if (x(), d.value === !0) {
      const D = C(M(e.modelValue));
      return e.fillMask !== !1 ? z(D) : D;
    }
    return e.modelValue;
  }
  function v(D) {
    if (D < r.length)
      return r.slice(-D);
    let T = "", F = r;
    const k = F.indexOf(Ae);
    if (k > -1) {
      for (let O = D - F.length; O > 0; O--)
        T += Ae;
      F = F.slice(0, k) + T + F.slice(k);
    }
    return F;
  }
  function x() {
    if (d.value = e.mask !== void 0 && e.mask.length !== 0 && m(), d.value === !1) {
      l = void 0, r = "", s = "";
      return;
    }
    const D = Ma[e.mask] === void 0 ? e.mask : Ma[e.mask], T = typeof e.fillMask == "string" && e.fillMask.length !== 0 ? e.fillMask.slice(0, 1) : "_", F = T.replace(ka, "\\$&"), k = [], O = [], $ = [];
    let X = e.reverseFillMask === !0, te = "", H = "";
    D.replace(sp, (de, R, J, we, q) => {
      if (we !== void 0) {
        const ie = pr[we];
        $.push(ie), H = ie.negate, X === !0 && (O.push("(?:" + H + "+)?(" + ie.pattern + "+)?(?:" + H + "+)?(" + ie.pattern + "+)?"), X = !1), O.push("(?:" + H + "+)?(" + ie.pattern + ")?");
      } else if (J !== void 0)
        te = "\\" + (J === "\\" ? "" : J), $.push(J), k.push("([^" + te + "]+)?" + te + "?");
      else {
        const ie = R !== void 0 ? R : q;
        te = ie === "\\" ? "\\\\\\\\" : ie.replace(ka, "\\\\$&"), $.push(ie), k.push("([^" + te + "]+)?" + te + "?");
      }
    });
    const oe = new RegExp(
      "^" + k.join("") + "(" + (te === "" ? "." : "[^" + te + "]") + "+)?" + (te === "" ? "" : "[" + te + "]*") + "$"
    ), fe = O.length - 1, ce = O.map((de, R) => R === 0 && e.reverseFillMask === !0 ? new RegExp("^" + F + "*" + de) : R === fe ? new RegExp(
      "^" + de + "(" + (H === "" ? "." : H) + "+)?" + (e.reverseFillMask === !0 ? "$" : F + "*")
    ) : new RegExp("^" + de));
    o = $, l = (de) => {
      const R = oe.exec(e.reverseFillMask === !0 ? de : de.slice(0, $.length + 1));
      R !== null && (de = R.slice(1).join(""));
      const J = [], we = ce.length;
      for (let q = 0, ie = de; q < we; q++) {
        const le = ce[q].exec(ie);
        if (le === null)
          break;
        ie = ie.slice(le.shift().length), J.push(...le);
      }
      return J.length !== 0 ? J.join("") : de;
    }, r = $.map((de) => typeof de == "string" ? de : Ae).join(""), s = r.split(Ae).join(T);
  }
  function S(D, T, F) {
    const k = n.value, O = k.selectionEnd, $ = k.value.length - O, X = M(D);
    T === !0 && x();
    const te = C(X), H = e.fillMask !== !1 ? z(te) : te, oe = f.value !== H;
    k.value !== H && (k.value = H), oe === !0 && (f.value = H), document.activeElement === k && xt(() => {
      if (H === s) {
        const ce = e.reverseFillMask === !0 ? s.length : 0;
        k.setSelectionRange(ce, ce, "forward");
        return;
      }
      if (F === "insertFromPaste" && e.reverseFillMask !== !0) {
        const ce = k.selectionEnd;
        let de = O - 1;
        for (let R = c; R <= de && R < ce; R++)
          r[R] !== Ae && de++;
        p.right(k, de);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(F) > -1) {
        const ce = e.reverseFillMask === !0 ? O === 0 ? H.length > te.length ? 1 : 0 : Math.max(0, H.length - (H === s ? 0 : Math.min(te.length, $) + 1)) + 1 : O;
        k.setSelectionRange(ce, ce, "forward");
        return;
      }
      if (e.reverseFillMask === !0)
        if (oe === !0) {
          const ce = Math.max(0, H.length - (H === s ? 0 : Math.min(te.length, $ + 1)));
          ce === 1 && O === 1 ? k.setSelectionRange(ce, ce, "forward") : p.rightReverse(k, ce);
        } else {
          const ce = H.length - $;
          k.setSelectionRange(ce, ce, "backward");
        }
      else if (oe === !0) {
        const ce = Math.max(0, r.indexOf(Ae), Math.min(te.length, O) - 1);
        p.right(k, ce);
      } else {
        const ce = O - 1;
        p.right(k, ce);
      }
    });
    const fe = e.unmaskedValue === !0 ? M(H) : H;
    String(e.modelValue) !== fe && i(fe, !0);
  }
  function A(D, T, F) {
    const k = C(M(D.value));
    T = Math.max(0, r.indexOf(Ae), Math.min(k.length, T)), c = T, D.setSelectionRange(T, F, "forward");
  }
  const p = {
    left(D, T) {
      const F = r.slice(T - 1).indexOf(Ae) === -1;
      let k = Math.max(0, T - 1);
      for (; k >= 0; k--)
        if (r[k] === Ae) {
          T = k, F === !0 && T++;
          break;
        }
      if (k < 0 && r[T] !== void 0 && r[T] !== Ae)
        return p.right(D, 0);
      T >= 0 && D.setSelectionRange(T, T, "backward");
    },
    right(D, T) {
      const F = D.value.length;
      let k = Math.min(F, T + 1);
      for (; k <= F; k++)
        if (r[k] === Ae) {
          T = k;
          break;
        } else r[k - 1] === Ae && (T = k);
      if (k > F && r[T - 1] !== void 0 && r[T - 1] !== Ae)
        return p.left(D, F);
      D.setSelectionRange(T, T, "forward");
    },
    leftReverse(D, T) {
      const F = v(D.value.length);
      let k = Math.max(0, T - 1);
      for (; k >= 0; k--)
        if (F[k - 1] === Ae) {
          T = k;
          break;
        } else if (F[k] === Ae && (T = k, k === 0))
          break;
      if (k < 0 && F[T] !== void 0 && F[T] !== Ae)
        return p.rightReverse(D, 0);
      T >= 0 && D.setSelectionRange(T, T, "backward");
    },
    rightReverse(D, T) {
      const F = D.value.length, k = v(F), O = k.slice(0, T + 1).indexOf(Ae) === -1;
      let $ = Math.min(F, T + 1);
      for (; $ <= F; $++)
        if (k[$ - 1] === Ae) {
          T = $, T > 0 && O === !0 && T--;
          break;
        }
      if ($ > F && k[T - 1] !== void 0 && k[T - 1] !== Ae)
        return p.leftReverse(D, F);
      D.setSelectionRange(T, T, "forward");
    }
  };
  function y(D) {
    t("click", D), u = void 0;
  }
  function w(D) {
    if (t("keydown", D), sc(D) === !0)
      return;
    const T = n.value, F = T.selectionStart, k = T.selectionEnd;
    if (D.shiftKey || (u = void 0), D.keyCode === 37 || D.keyCode === 39) {
      D.shiftKey && u === void 0 && (u = T.selectionDirection === "forward" ? F : k);
      const O = p[(D.keyCode === 39 ? "right" : "left") + (e.reverseFillMask === !0 ? "Reverse" : "")];
      if (D.preventDefault(), O(T, u === F ? k : F), D.shiftKey) {
        const $ = T.selectionStart;
        T.setSelectionRange(Math.min(u, $), Math.max(u, $), "forward");
      }
    } else D.keyCode === 8 && e.reverseFillMask !== !0 && F === k ? (p.left(T, F), T.setSelectionRange(T.selectionStart, k, "backward")) : D.keyCode === 46 && e.reverseFillMask === !0 && F === k && (p.rightReverse(T, k), T.setSelectionRange(F, T.selectionEnd, "forward"));
  }
  function C(D) {
    if (D == null || D === "")
      return "";
    if (e.reverseFillMask === !0)
      return P(D);
    const T = o;
    let F = 0, k = "";
    for (let O = 0; O < T.length; O++) {
      const $ = D[F], X = T[O];
      if (typeof X == "string")
        k += X, $ === X && F++;
      else if ($ !== void 0 && X.regex.test($))
        k += X.transform !== void 0 ? X.transform($) : $, F++;
      else
        return k;
    }
    return k;
  }
  function P(D) {
    const T = o, F = r.indexOf(Ae);
    let k = D.length - 1, O = "";
    for (let $ = T.length - 1; $ >= 0 && k > -1; $--) {
      const X = T[$];
      let te = D[k];
      if (typeof X == "string")
        O = X + O, te === X && k--;
      else if (te !== void 0 && X.regex.test(te))
        do
          O = (X.transform !== void 0 ? X.transform(te) : te) + O, k--, te = D[k];
        while (F === $ && te !== void 0 && X.regex.test(te));
      else
        return O;
    }
    return O;
  }
  function M(D) {
    return typeof D != "string" || l === void 0 ? typeof D == "number" ? l("" + D) : D : l(D);
  }
  function z(D) {
    return s.length - D.length <= 0 ? D : e.reverseFillMask === !0 && D.length !== 0 ? s.slice(0, -D.length) + D : D + s.slice(D.length);
  }
  return {
    innerValue: f,
    hasMask: d,
    moveCursorForPaste: A,
    updateMaskValue: S,
    onMaskedKeydown: w,
    onMaskedClick: y
  };
}
const ao = {
  name: String
};
function Dc(e = {}) {
  return (t, i, n) => {
    t[i](
      K("input", {
        class: "hidden" + (n || ""),
        ...e.value
      })
    );
  };
}
function lp(e) {
  return W(() => e.name || e.for);
}
function cp(e, t) {
  function i() {
    const n = e.modelValue;
    try {
      const r = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      return Object(n) === n && ("length" in n ? Array.from(n) : [n]).forEach((s) => {
        r.items.add(s);
      }), {
        files: r.files
      };
    } catch {
      return {
        files: void 0
      };
    }
  }
  return W(() => {
    if (e.type === "file")
      return i();
  });
}
const up = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/, dp = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u, fp = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/, hp = /[a-z0-9_ -]$/i;
function mp(e) {
  return function(i) {
    if (i.type === "compositionend" || i.type === "change") {
      if (i.target.qComposing !== !0)
        return;
      i.target.qComposing = !1, e(i);
    } else i.type === "compositionupdate" && i.target.qComposing !== !0 && typeof i.data == "string" && (ke.is.firefox === !0 ? hp.test(i.data) === !1 : up.test(i.data) === !0 || dp.test(i.data) === !0 || fp.test(i.data) === !0) === !0 && (i.target.qComposing = !0);
  };
}
const gp = We({
  name: "QInput",
  inheritAttrs: !1,
  props: {
    ...tp,
    ...op,
    ...ao,
    modelValue: { required: !1 },
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...ip,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(e, { emit: t, attrs: i }) {
    const { proxy: n } = qe(), { $q: r } = n, s = {};
    let o = NaN, l, c, u = null, d;
    const f = ue(null), m = lp(e), {
      innerValue: g,
      hasMask: v,
      moveCursorForPaste: x,
      updateMaskValue: S,
      onMaskedKeydown: A,
      onMaskedClick: p
    } = ap(e, t, te, f), y = cp(e), w = W(() => Ds(g.value)), C = mp($), P = np(), M = W(
      () => e.type === "textarea" || e.autogrow === !0
    ), z = W(
      () => M.value === !0 || ["text", "search", "url", "tel", "password"].includes(e.type)
    ), D = W(() => {
      const R = {
        ...P.splitAttrs.listeners.value,
        onInput: $,
        onPaste: O,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: oe,
        onBlur: fe,
        onFocus: dr
      };
      return R.onCompositionstart = R.onCompositionupdate = R.onCompositionend = C, v.value === !0 && (R.onKeydown = A, R.onClick = p), e.autogrow === !0 && (R.onAnimationend = X), R;
    }), T = W(() => {
      const R = {
        tabindex: 0,
        "data-autofocus": e.autofocus === !0 || void 0,
        rows: e.type === "textarea" ? 6 : void 0,
        "aria-label": e.label,
        name: m.value,
        ...P.splitAttrs.attributes.value,
        id: P.targetUid.value,
        maxlength: e.maxlength,
        disabled: e.disable === !0,
        readonly: e.readonly === !0
      };
      return M.value === !1 && (R.type = e.type), e.autogrow === !0 && (R.rows = 1), R;
    });
    _e(() => e.type, () => {
      f.value && (f.value.value = e.modelValue);
    }), _e(() => e.modelValue, (R) => {
      if (v.value === !0) {
        if (c === !0 && (c = !1, String(R) === o))
          return;
        S(R);
      } else g.value !== R && (g.value = R, e.type === "number" && s.hasOwnProperty("value") === !0 && (l === !0 ? l = !1 : delete s.value));
      e.autogrow === !0 && xt(H);
    }), _e(() => e.autogrow, (R) => {
      R === !0 ? xt(H) : f.value !== null && i.rows > 0 && (f.value.style.height = "auto");
    }), _e(() => e.dense, () => {
      e.autogrow === !0 && xt(H);
    });
    function F() {
      oo(() => {
        const R = document.activeElement;
        f.value !== null && f.value !== R && (R === null || R.id !== P.targetUid.value) && f.value.focus({ preventScroll: !0 });
      });
    }
    function k() {
      f.value !== null && f.value.select();
    }
    function O(R) {
      if (v.value === !0 && e.reverseFillMask !== !0) {
        const J = R.target;
        x(J, J.selectionStart, J.selectionEnd);
      }
      t("paste", R);
    }
    function $(R) {
      if (!R || !R.target)
        return;
      if (e.type === "file") {
        t("update:modelValue", R.target.files);
        return;
      }
      const J = R.target.value;
      if (R.target.qComposing === !0) {
        s.value = J;
        return;
      }
      if (v.value === !0)
        S(J, !1, R.inputType);
      else if (te(J), z.value === !0 && R.target === document.activeElement) {
        const { selectionStart: we, selectionEnd: q } = R.target;
        we !== void 0 && q !== void 0 && xt(() => {
          R.target === document.activeElement && J.indexOf(R.target.value) === 0 && R.target.setSelectionRange(we, q);
        });
      }
      e.autogrow === !0 && H();
    }
    function X(R) {
      t("animationend", R), H();
    }
    function te(R, J) {
      d = () => {
        u = null, e.type !== "number" && s.hasOwnProperty("value") === !0 && delete s.value, e.modelValue !== R && o !== R && (o = R, J === !0 && (c = !0), t("update:modelValue", R), xt(() => {
          o === R && (o = NaN);
        })), d = void 0;
      }, e.type === "number" && (l = !0, s.value = R), e.debounce !== void 0 ? (u !== null && clearTimeout(u), s.value = R, u = setTimeout(d, e.debounce)) : d();
    }
    function H() {
      requestAnimationFrame(() => {
        const R = f.value;
        if (R !== null) {
          const J = R.parentNode.style, { scrollTop: we } = R, { overflowY: q, maxHeight: ie } = r.platform.is.firefox === !0 ? {} : window.getComputedStyle(R), le = q !== void 0 && q !== "scroll";
          le === !0 && (R.style.overflowY = "hidden"), J.marginBottom = R.scrollHeight - 1 + "px", R.style.height = "1px", R.style.height = R.scrollHeight + "px", le === !0 && (R.style.overflowY = parseInt(ie, 10) < R.scrollHeight ? "auto" : "hidden"), J.marginBottom = "", R.scrollTop = we;
        }
      });
    }
    function oe(R) {
      C(R), u !== null && (clearTimeout(u), u = null), d !== void 0 && d(), t("change", R.target.value);
    }
    function fe(R) {
      R !== void 0 && dr(R), u !== null && (clearTimeout(u), u = null), d !== void 0 && d(), l = !1, c = !1, delete s.value, e.type !== "file" && setTimeout(() => {
        f.value !== null && (f.value.value = g.value !== void 0 ? g.value : "");
      });
    }
    function ce() {
      return s.hasOwnProperty("value") === !0 ? s.value : g.value !== void 0 ? g.value : "";
    }
    je(() => {
      fe();
    }), Vt(() => {
      e.autogrow === !0 && H();
    }), Object.assign(P, {
      innerValue: g,
      fieldClass: W(
        () => `q-${M.value === !0 ? "textarea" : "input"}` + (e.autogrow === !0 ? " q-textarea--autogrow" : "")
      ),
      hasShadow: W(
        () => e.type !== "file" && typeof e.shadowText == "string" && e.shadowText.length !== 0
      ),
      inputRef: f,
      emitValue: te,
      hasValue: w,
      floatingLabel: W(
        () => w.value === !0 && (e.type !== "number" || isNaN(g.value) === !1) || Ds(e.displayValue)
      ),
      getControl: () => K(M.value === !0 ? "textarea" : "input", {
        ref: f,
        class: [
          "q-field__native q-placeholder",
          e.inputClass
        ],
        style: e.inputStyle,
        ...T.value,
        ...D.value,
        ...e.type !== "file" ? { value: ce() } : y.value
      }),
      getShadowControl: () => K("div", {
        class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (M.value === !0 ? "" : " text-no-wrap")
      }, [
        K("span", { class: "invisible" }, ce()),
        K("span", e.shadowText)
      ])
    });
    const de = rp(P);
    return Object.assign(n, {
      focus: F,
      select: k,
      getNativeElement: () => f.value
      // deprecated
    }), Ui(n, "nativeEl", () => f.value), de;
  }
});
function Ac(e, t) {
  const i = ue(null), n = W(() => e.disable === !0 ? null : K("span", {
    ref: i,
    class: "no-outline",
    tabindex: -1
  }));
  function r(s) {
    const o = t.value;
    s !== void 0 && s.type.indexOf("key") === 0 ? o !== null && document.activeElement !== o && o.contains(document.activeElement) === !0 && o.focus() : i.value !== null && (s === void 0 || o !== null && o.contains(s.target) === !0) && i.value.focus();
  }
  return {
    refocusTargetEl: n,
    refocusTarget: r
  };
}
const Oc = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}, pp = K("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  K("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  K("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]), yp = We({
  name: "QRadio",
  props: {
    ..._i,
    ...Pn,
    ...ao,
    modelValue: { required: !0 },
    val: { required: !0 },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(e, { slots: t, emit: i }) {
    const { proxy: n } = qe(), r = Li(e, n.$q), s = Mn(e, Oc), o = ue(null), { refocusTargetEl: l, refocusTarget: c } = Ac(e, o), u = W(() => $t(e.modelValue) === $t(e.val)), d = W(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (e.disable === !0 ? " disabled" : "") + (r.value === !0 ? " q-radio--dark" : "") + (e.dense === !0 ? " q-radio--dense" : "") + (e.leftLabel === !0 ? " reverse" : "")
    ), f = W(() => {
      const y = e.color !== void 0 && (e.keepColor === !0 || u.value === !0) ? ` text-${e.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${u.value === !0 ? "truthy" : "falsy"}${y}`;
    }), m = W(
      () => (u.value === !0 ? e.checkedIcon : e.uncheckedIcon) || null
    ), g = W(() => e.disable === !0 ? -1 : e.tabindex || 0), v = W(() => {
      const y = { type: "radio" };
      return e.name !== void 0 && Object.assign(y, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": u.value === !0,
        "^checked": u.value === !0 ? "checked" : void 0,
        name: e.name,
        value: e.val
      }), y;
    }), x = Dc(v);
    function S(y) {
      y !== void 0 && (dt(y), c(y)), e.disable !== !0 && u.value !== !0 && i("update:modelValue", e.val, y);
    }
    function A(y) {
      (y.keyCode === 13 || y.keyCode === 32) && dt(y);
    }
    function p(y) {
      (y.keyCode === 13 || y.keyCode === 32) && S(y);
    }
    return Object.assign(n, { set: S }), () => {
      const y = m.value !== null ? [
        K("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          K(Nt, {
            class: "q-radio__icon",
            name: m.value
          })
        ])
      ] : [pp];
      e.disable !== !0 && x(
        y,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const w = [
        K("div", {
          class: f.value,
          style: s.value,
          "aria-hidden": "true"
        }, y)
      ];
      l.value !== null && w.push(l.value);
      const C = e.label !== void 0 ? li(t.default, [e.label]) : St(t.default);
      return C !== void 0 && w.push(
        K("div", {
          class: "q-radio__label q-anchor--skip"
        }, C)
      ), K("div", {
        ref: o,
        class: d.value,
        tabindex: g.value,
        role: "radio",
        "aria-label": e.label,
        "aria-checked": u.value === !0 ? "true" : "false",
        "aria-disabled": e.disable === !0 ? "true" : void 0,
        onClick: S,
        onKeydown: A,
        onKeyup: p
      }, w);
    };
  }
}), Bc = {
  ..._i,
  ...Pn,
  ...ao,
  modelValue: {
    required: !0,
    default: null
  },
  val: {},
  trueValue: { default: !0 },
  falseValue: { default: !1 },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (e) => e === "tf" || e === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
}, Rc = ["update:modelValue"];
function $c(e, t) {
  const { props: i, slots: n, emit: r, proxy: s } = qe(), { $q: o } = s, l = Li(i, o), c = ue(null), { refocusTargetEl: u, refocusTarget: d } = Ac(i, c), f = Mn(i, Oc), m = W(
    () => i.val !== void 0 && Array.isArray(i.modelValue)
  ), g = W(() => {
    const k = $t(i.val);
    return m.value === !0 ? i.modelValue.findIndex((O) => $t(O) === k) : -1;
  }), v = W(() => m.value === !0 ? g.value > -1 : $t(i.modelValue) === $t(i.trueValue)), x = W(() => m.value === !0 ? g.value === -1 : $t(i.modelValue) === $t(i.falseValue)), S = W(
    () => v.value === !1 && x.value === !1
  ), A = W(() => i.disable === !0 ? -1 : i.tabindex || 0), p = W(
    () => `q-${e} cursor-pointer no-outline row inline no-wrap items-center` + (i.disable === !0 ? " disabled" : "") + (l.value === !0 ? ` q-${e}--dark` : "") + (i.dense === !0 ? ` q-${e}--dense` : "") + (i.leftLabel === !0 ? " reverse" : "")
  ), y = W(() => {
    const k = v.value === !0 ? "truthy" : x.value === !0 ? "falsy" : "indet", O = i.color !== void 0 && (i.keepColor === !0 || (e === "toggle" ? v.value === !0 : x.value !== !0)) ? ` text-${i.color}` : "";
    return `q-${e}__inner relative-position non-selectable q-${e}__inner--${k}${O}`;
  }), w = W(() => {
    const k = { type: "checkbox" };
    return i.name !== void 0 && Object.assign(k, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": v.value,
      "^checked": v.value === !0 ? "checked" : void 0,
      name: i.name,
      value: m.value === !0 ? i.val : i.trueValue
    }), k;
  }), C = Dc(w), P = W(() => {
    const k = {
      tabindex: A.value,
      role: e === "toggle" ? "switch" : "checkbox",
      "aria-label": i.label,
      "aria-checked": S.value === !0 ? "mixed" : v.value === !0 ? "true" : "false"
    };
    return i.disable === !0 && (k["aria-disabled"] = "true"), k;
  });
  function M(k) {
    k !== void 0 && (dt(k), d(k)), i.disable !== !0 && r("update:modelValue", z(), k);
  }
  function z() {
    if (m.value === !0) {
      if (v.value === !0) {
        const k = i.modelValue.slice();
        return k.splice(g.value, 1), k;
      }
      return i.modelValue.concat([i.val]);
    }
    if (v.value === !0) {
      if (i.toggleOrder !== "ft" || i.toggleIndeterminate === !1)
        return i.falseValue;
    } else if (x.value === !0) {
      if (i.toggleOrder === "ft" || i.toggleIndeterminate === !1)
        return i.trueValue;
    } else
      return i.toggleOrder !== "ft" ? i.trueValue : i.falseValue;
    return i.indeterminateValue;
  }
  function D(k) {
    (k.keyCode === 13 || k.keyCode === 32) && dt(k);
  }
  function T(k) {
    (k.keyCode === 13 || k.keyCode === 32) && M(k);
  }
  const F = t(v, S);
  return Object.assign(s, { toggle: M }), () => {
    const k = F();
    i.disable !== !0 && C(
      k,
      "unshift",
      ` q-${e}__native absolute q-ma-none q-pa-none`
    );
    const O = [
      K("div", {
        class: y.value,
        style: f.value,
        "aria-hidden": "true"
      }, k)
    ];
    u.value !== null && O.push(u.value);
    const $ = i.label !== void 0 ? li(n.default, [i.label]) : St(n.default);
    return $ !== void 0 && O.push(
      K("div", {
        class: `q-${e}__label q-anchor--skip`
      }, $)
    ), K("div", {
      ref: c,
      class: p.value,
      ...P.value,
      onClick: M,
      onKeydown: D,
      onKeyup: T
    }, O);
  };
}
const vp = K("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  K("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    K("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    K("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]), bp = We({
  name: "QCheckbox",
  props: Bc,
  emits: Rc,
  setup(e) {
    function t(i, n) {
      const r = W(
        () => (i.value === !0 ? e.checkedIcon : n.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || null
      );
      return () => r.value !== null ? [
        K("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          K(Nt, {
            class: "q-checkbox__icon",
            name: r.value
          })
        ])
      ] : [vp];
    }
    return $c("checkbox", t);
  }
}), wp = We({
  name: "QToggle",
  props: {
    ...Bc,
    icon: String,
    iconColor: String
  },
  emits: Rc,
  setup(e) {
    function t(i, n) {
      const r = W(
        () => (i.value === !0 ? e.checkedIcon : n.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || e.icon
      ), s = W(() => i.value === !0 ? e.iconColor : null);
      return () => [
        K("div", { class: "q-toggle__track" }),
        K(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          r.value !== void 0 ? [
            K(Nt, {
              name: r.value,
              color: s.value
            })
          ] : void 0
        )
      ];
    }
    return $c("toggle", t);
  }
}), Ic = {
  radio: yp,
  checkbox: bp,
  toggle: wp
}, _p = Object.keys(Ic), Lp = We({
  name: "QOptionGroup",
  props: {
    ..._i,
    modelValue: {
      required: !0
    },
    options: {
      type: Array,
      validator: (e) => e.every((t) => "value" in t && "label" in t)
    },
    name: String,
    type: {
      default: "radio",
      validator: (e) => _p.includes(e)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t, slots: i }) {
    const { proxy: { $q: n } } = qe(), r = Array.isArray(e.modelValue);
    e.type === "radio" ? r === !0 && console.error("q-option-group: model should not be array") : r === !1 && console.error("q-option-group: model should be array in your case");
    const s = Li(e, n), o = W(() => Ic[e.type]), l = W(
      () => "q-option-group q-gutter-x-sm" + (e.inline === !0 ? " q-option-group--inline" : "")
    ), c = W(() => {
      const d = { role: "group" };
      return e.type === "radio" && (d.role = "radiogroup", e.disable === !0 && (d["aria-disabled"] = "true")), d;
    });
    function u(d) {
      t("update:modelValue", d);
    }
    return () => K("div", {
      class: l.value,
      ...c.value
    }, e.options.map((d, f) => {
      const m = i["label-" + f] !== void 0 ? () => i["label-" + f](d) : i.label !== void 0 ? () => i.label(d) : void 0;
      return K("div", [
        K(o.value, {
          modelValue: e.modelValue,
          val: d.value,
          name: d.name === void 0 ? e.name : d.name,
          disable: e.disable || d.disable,
          label: m === void 0 ? d.label : null,
          leftLabel: d.leftLabel === void 0 ? e.leftLabel : d.leftLabel,
          color: d.color === void 0 ? e.color : d.color,
          checkedIcon: d.checkedIcon,
          uncheckedIcon: d.uncheckedIcon,
          dark: d.dark || s.value,
          size: d.size === void 0 ? e.size : d.size,
          dense: e.dense,
          keepColor: d.keepColor === void 0 ? e.keepColor : d.keepColor,
          "onUpdate:modelValue": u
        }, m)
      ]);
    }));
  }
}), xp = We({
  name: "DialogPlugin",
  props: {
    ..._i,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: !0
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (e) => ["ok", "cancel", "none"].includes(e)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(e, { emit: t }) {
    const { proxy: i } = qe(), { $q: n } = i, r = Li(e, n), s = ue(null), o = ue(
      e.prompt !== void 0 ? e.prompt.model : e.options !== void 0 ? e.options.model : void 0
    ), l = W(
      () => "q-dialog-plugin" + (r.value === !0 ? " q-dialog-plugin--dark q-dark" : "") + (e.progress !== !1 ? " q-dialog-plugin--progress" : "")
    ), c = W(
      () => e.color || (r.value === !0 ? "amber" : "primary")
    ), u = W(() => e.progress === !1 ? null : ft(e.progress) === !0 ? {
      component: e.progress.spinner || $i,
      props: { color: e.progress.color || c.value }
    } : {
      component: $i,
      props: { color: c.value }
    }), d = W(
      () => e.prompt !== void 0 || e.options !== void 0
    ), f = W(() => {
      if (d.value !== !0)
        return {};
      const { model: $, isValid: X, items: te, ...H } = e.prompt !== void 0 ? e.prompt : e.options;
      return H;
    }), m = W(() => ft(e.ok) === !0 || e.ok === !0 ? n.lang.label.ok : e.ok), g = W(() => ft(e.cancel) === !0 || e.cancel === !0 ? n.lang.label.cancel : e.cancel), v = W(() => e.prompt !== void 0 ? e.prompt.isValid !== void 0 && e.prompt.isValid(o.value) !== !0 : e.options !== void 0 ? e.options.isValid !== void 0 && e.options.isValid(o.value) !== !0 : !1), x = W(() => ({
      color: c.value,
      label: m.value,
      ripple: !1,
      disable: v.value,
      ...ft(e.ok) === !0 ? e.ok : { flat: !0 },
      "data-autofocus": e.focus === "ok" && d.value !== !0 || void 0,
      onClick: y
    })), S = W(() => ({
      color: c.value,
      label: g.value,
      ripple: !1,
      ...ft(e.cancel) === !0 ? e.cancel : { flat: !0 },
      "data-autofocus": e.focus === "cancel" && d.value !== !0 || void 0,
      onClick: w
    }));
    _e(() => e.prompt && e.prompt.model, P), _e(() => e.options && e.options.model, P);
    function A() {
      s.value.show();
    }
    function p() {
      s.value.hide();
    }
    function y() {
      t("ok", $t(o.value)), p();
    }
    function w() {
      p();
    }
    function C() {
      t("hide");
    }
    function P($) {
      o.value = $;
    }
    function M($) {
      v.value !== !0 && e.prompt.type !== "textarea" && gn($, 13) === !0 && y();
    }
    function z($, X) {
      return e.html === !0 ? K(en, {
        class: $,
        innerHTML: X
      }) : K(en, { class: $ }, () => X);
    }
    function D() {
      return [
        K(gp, {
          color: c.value,
          dense: !0,
          autofocus: !0,
          dark: r.value,
          ...f.value,
          modelValue: o.value,
          "onUpdate:modelValue": P,
          onKeyup: M
        })
      ];
    }
    function T() {
      return [
        K(Lp, {
          color: c.value,
          options: e.options.items,
          dark: r.value,
          ...f.value,
          modelValue: o.value,
          "onUpdate:modelValue": P
        })
      ];
    }
    function F() {
      const $ = [];
      return e.cancel && $.push(
        K(Ms, S.value)
      ), e.ok && $.push(
        K(Ms, x.value)
      ), K(Wg, {
        class: e.stackButtons === !0 ? "items-end" : "",
        vertical: e.stackButtons,
        align: "right"
      }, () => $);
    }
    function k() {
      const $ = [];
      return e.title && $.push(
        z("q-dialog__title", e.title)
      ), e.progress !== !1 && $.push(
        K(
          en,
          { class: "q-dialog__progress" },
          () => K(u.value.component, u.value.props)
        )
      ), e.message && $.push(
        z("q-dialog__message", e.message)
      ), e.prompt !== void 0 ? $.push(
        K(
          en,
          { class: "scroll q-dialog-plugin__form" },
          D
        )
      ) : e.options !== void 0 && $.push(
        K(Sa, { dark: r.value }),
        K(
          en,
          { class: "scroll q-dialog-plugin__form" },
          T
        ),
        K(Sa, { dark: r.value })
      ), (e.ok || e.cancel) && $.push(F()), $;
    }
    function O() {
      return [
        K(Hg, {
          class: [
            l.value,
            e.cardClass
          ],
          style: e.cardStyle,
          dark: r.value
        }, k)
      ];
    }
    return Object.assign(i, { show: A, hide: p }), () => K(Gg, {
      ref: s,
      onHide: C
    }, O);
  }
});
function zc(e, t) {
  for (const i in t)
    i !== "spinner" && Object(t[i]) === t[i] ? (e[i] = Object(e[i]) !== e[i] ? {} : { ...e[i] }, zc(e[i], t[i])) : e[i] = t[i];
}
function Sp(e, t, i) {
  return (n) => {
    let r, s;
    const o = n.component !== void 0;
    if (o === !0) {
      const { component: p, componentProps: y } = n;
      r = typeof p == "string" ? i.component(p) : p, s = y || {};
    } else {
      const { class: p, style: y, ...w } = n;
      r = e, s = w, p !== void 0 && (w.cardClass = p), y !== void 0 && (w.cardStyle = y);
    }
    let l, c = !1;
    const u = ue(null), d = zr(!1, "dialog"), f = (p) => {
      if (u.value !== null && u.value[p] !== void 0) {
        u.value[p]();
        return;
      }
      const y = l.$.subTree;
      if (y && y.component) {
        if (y.component.proxy && y.component.proxy[p]) {
          y.component.proxy[p]();
          return;
        }
        if (y.component.subTree && y.component.subTree.component && y.component.subTree.component.proxy && y.component.subTree.component.proxy[p]) {
          y.component.subTree.component.proxy[p]();
          return;
        }
      }
      console.error("[Quasar] Incorrectly defined Dialog component");
    }, m = [], g = [], v = {
      onOk(p) {
        return m.push(p), v;
      },
      onCancel(p) {
        return g.push(p), v;
      },
      onDismiss(p) {
        return m.push(p), g.push(p), v;
      },
      hide() {
        return f("hide"), v;
      },
      update(p) {
        if (l !== null) {
          if (o === !0)
            Object.assign(s, p);
          else {
            const { class: y, style: w, ...C } = p;
            y !== void 0 && (C.cardClass = y), w !== void 0 && (C.cardStyle = w), zc(s, C);
          }
          l.$forceUpdate();
        }
        return v;
      }
    }, x = (p) => {
      c = !0, m.forEach((y) => {
        y(p);
      });
    }, S = () => {
      A.unmount(d), io(d), A = null, l = null, c !== !0 && g.forEach((p) => {
        p();
      });
    };
    let A = to({
      name: "QGlobalDialog",
      setup: () => () => K(r, {
        ...s,
        ref: u,
        onOk: x,
        onHide: S,
        onVnodeMounted(...p) {
          typeof s.onVnodeMounted == "function" && s.onVnodeMounted(...p), xt(() => f("show"));
        }
      })
    }, i);
    return l = A.mount(d), v;
  };
}
const xi = {
  install({ $q: e, parentApp: t }) {
    e.dialog = Sp(xp, !0, t), this.__installed !== !0 && (this.create = e.dialog);
  }
}, ms = {
  initialize(e) {
    this.maxConcurrentRequests = e, this.pendingRequests = [], this.runningRequests = [], this.exportService = G.getService("import-export"), this.exportService.on("export-created", (t) => this.onRequestCreated(t)), this.exportService.on("export-completed", (t) => this.onRequestCompleted(t)), I.debug(`[KDK] Initialized 'Exporter' with '${e}' maxConcurrentRequests`);
  },
  push(e) {
    return this.pendingRequests.push(e), this.triggerRequest();
  },
  triggerRequest() {
    if (this.runningRequests.length >= this.maxConcurrentRequests) return !1;
    if (this.pendingRequests.length === 0) return !0;
    const e = this.pendingRequests.shift();
    try {
      let t = e.filename;
      if (!t) {
        const s = he().toISOString().replace(/:/g, "-");
        t = `${a.get(e, "basename", e.service)}_${s}.${e.format}`;
      }
      let i = G.getServicePath(e.service);
      i.startsWith("/") && (i = i.substring(1));
      const n = a.get(e, "transform." + e.format), r = Object.assign(
        a.omit(e, ["title", "service", "context", "formats"]),
        { method: "export", filename: t, servicePath: i, transform: n }
      );
      I.debug(`[KDK] request export with options ${JSON.stringify(r, null, 2)}`), this.exportService.create(r);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return !0;
  },
  onRequestCreated(e) {
    I.debug(`[KDK] export request ${e.uuid} created`);
    const t = {
      uuid: e.uuid,
      notification: et.create({
        icon: "las la-hourglass-half",
        message: Y.t("exporter.EXPORTING"),
        color: "primary",
        timeout: 0,
        spinner: !0
      })
    };
    this.runningRequests.push(t);
  },
  onRequestCompleted(e) {
    I.debug(`[KDK] export request ${e.uuid} completed`);
    const t = a.head(a.remove(this.runningRequests, { uuid: e.uuid }));
    if (!t) {
      I.warn(`[KDK] export request ${e.uuid} not found`);
      return;
    }
    if (t.notification(), e.SignedUrl) {
      let i = document.getElementById("export-hidden-frame");
      i || (i = document.createElement("iframe"), i.id = "export-hidden-frame", i.style.display = "none", document.body.appendChild(i)), i.src = e.SignedUrl, et.create({
        type: "positive",
        message: Y.t("exporter.SUCCEEDED", { filename: e.filename }),
        html: !0
      });
    } else e.chunks === 0 ? et.create({
      type: "warning",
      message: Y.t("exporter.NO_DATA")
    }) : et.create({
      type: "negative",
      message: Y.t("exporter.ERRORED")
    });
    this.triggerRequest();
  }
}, Nc = {
  initialize(e) {
    ms.initialize(a.get(e, "maxConcurrentRequests", 3));
  },
  export(e) {
    if (!e.service) {
      I.error("[KDK] invalid options: missing 'service' property");
      return;
    }
    const t = a.cloneDeep(e);
    if (e.formats.length > 1) {
      const i = {
        title: Y.t(e.title ? e.title : "exporter.TITLE"),
        message: Y.t("exporter.MESSAGE"),
        options: {
          type: "radio",
          model: e.formats[0].label,
          items: e.formats.map((n) => ({ label: n.label, value: n.label }))
        },
        cancel: {
          id: "cancel-button",
          label: Y.t("CANCEL"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "export-button",
          label: Y.t("exporter.EXPORT"),
          color: "primary"
        },
        persistent: !0
      };
      xi.create(i).onOk((n) => {
        const r = a.find(e.formats, { label: n });
        ms.push(Object.assign(t, r)) || et.create({
          type: "negative",
          message: Y.t("exporter.EXPORTS_LIMIT_REACHED")
        });
      });
    } else
      ms.push(Object.assign(t, e.formats[0])) || et.create({
        type: "negative",
        message: Y.t("exporter.EXPORTS_LIMIT_REACHED")
      });
  }
};
let Mi, gs, Fa = 0, oi = null, Ie = {}, ui = {};
const qc = {
  group: "__default_quasar_group__",
  delay: 0,
  message: !1,
  html: !1,
  spinnerSize: 80,
  spinnerColor: "",
  messageColor: "",
  backgroundColor: "",
  boxClass: "",
  spinner: $i,
  customClass: ""
}, jc = { ...qc };
function Ep(e) {
  if (e && e.group !== void 0 && ui[e.group] !== void 0)
    return Object.assign(ui[e.group], e);
  const t = ft(e) === !0 && e.ignoreDefaults === !0 ? { ...qc, ...e } : { ...jc, ...e };
  return ui[t.group] = t, t;
}
const Be = Vi({
  isActive: !1
}, {
  show(e) {
    Ie = Ep(e);
    const { group: t } = Ie;
    return Be.isActive = !0, Mi !== void 0 ? (Ie.uid = Fa, gs.$forceUpdate()) : (Ie.uid = ++Fa, oi !== null && clearTimeout(oi), oi = setTimeout(() => {
      oi = null;
      const i = zr("q-loading");
      Mi = to({
        name: "QLoading",
        setup() {
          Vt(() => {
            ks(!0);
          });
          function n() {
            Be.isActive !== !0 && Mi !== void 0 && (ks(!1), Mi.unmount(i), io(i), Mi = void 0, gs = void 0);
          }
          function r() {
            if (Be.isActive !== !0)
              return null;
            const s = [
              K(Ie.spinner, {
                class: "q-loading__spinner",
                color: Ie.spinnerColor,
                size: Ie.spinnerSize
              })
            ];
            return Ie.message && s.push(
              K("div", {
                class: "q-loading__message" + (Ie.messageColor ? ` text-${Ie.messageColor}` : ""),
                [Ie.html === !0 ? "innerHTML" : "textContent"]: Ie.message
              })
            ), K("div", {
              class: "q-loading fullscreen flex flex-center z-max " + Ie.customClass.trim(),
              key: Ie.uid
            }, [
              K("div", {
                class: "q-loading__backdrop" + (Ie.backgroundColor ? ` bg-${Ie.backgroundColor}` : "")
              }),
              K("div", {
                class: "q-loading__box column items-center " + Ie.boxClass
              }, s)
            ]);
          }
          return () => K(hn, {
            name: "q-transition--fade",
            appear: !0,
            onAfterLeave: n
          }, r);
        }
      }, Be.__parentApp), gs = Mi.mount(i);
    }, Ie.delay)), (i) => {
      if (i === void 0 || Object(i) !== i) {
        Be.hide(t);
        return;
      }
      Be.show({ ...i, group: t });
    };
  },
  hide(e) {
    if (Be.isActive === !0) {
      if (e === void 0)
        ui = {};
      else {
        if (ui[e] === void 0)
          return;
        {
          delete ui[e];
          const t = Object.keys(ui);
          if (t.length !== 0) {
            const i = t[t.length - 1];
            Be.show({ group: i });
            return;
          }
        }
      }
      oi !== null && (clearTimeout(oi), oi = null), Be.isActive = !1;
    }
  },
  setDefaults(e) {
    ft(e) === !0 && Object.assign(jc, e);
  },
  install({ $q: e, parentApp: t }) {
    e.loading = this, Be.__parentApp = t, e.config.loading !== void 0 && this.setDefaults(e.config.loading);
  }
}), yi = {
  readers: {},
  register(e, t) {
    a.isArray(e) || (e = [e]), a.forEach(e, (i) => {
      this.readers[i] = t, t.mimeType = i;
    });
  },
  filter(e) {
    const t = [], i = [];
    for (let n = 0; n < e.length; ++n) {
      const r = e[n], s = zt.extname(r.name).toLowerCase();
      let o = this.readers[s];
      if (o)
        t.push({ reader: s, name: r.name, files: [r] });
      else if (o = a.find(this.readers, (l) => l.getAdditionalFiles().includes(s)), o)
        i.push({ reader: o.mimeType, file: r });
      else {
        const l = { message: Y.t("errors.UNSUPPORTED_FILE_FORMAT", { file: r.name }) };
        ne.emit("error", l);
      }
    }
    return a.forEach(i, (n) => {
      const r = a.find(t, (s) => s.reader === n.reader);
      if (r) r.files.push(n.file);
      else {
        const s = { message: Y.t("errors.UNSUPPORTED_FILE_FORMAT", { file: n.name }) };
        ne.emit("error", s);
      }
    }), t;
  },
  async read(e, t) {
    const i = this.readers[e.reader];
    Be.show({ message: Y.t("reader.READING_FILE", { file: e.name }), html: !0 });
    try {
      const n = await i.read(e.files, t);
      return Be.hide(), n;
    } catch (n) {
      Be.hide(), ne.emit("error", n);
    }
  },
  getSupportedFormats() {
    return Object.keys(this.readers);
  }
};
function Cp(e, t, i) {
  const n = i.propertyMapping, r = a.uniq(a.values(n).map((o) => o.split(".")[0])), s = i.settingsKey || "settings";
  return {
    async get(o) {
      const l = {};
      return a.forOwn(n, (c, u) => {
        c && a.set(l, u, j.get(c));
      }), l;
    },
    async patch(o, l) {
      const c = r.map((u) => j.get(u));
      a.forOwn(l, (u, d) => {
        a.get(n, d) && j.set(n[d], u);
      }), r.forEach((u, d) => {
        const f = a.kebabCase(`${u}-changed`);
        ne.emit(f, j.get(u), c[d]);
      }), this.saveSettings();
    },
    saveSettings() {
      const o = {};
      a.forOwn(n, (l, c) => {
        l && j.has(l) && a.set(o, c, j.get(l));
      }), Xe.set(s, o);
    },
    restoreSettings() {
      let o = Xe.get(s);
      o && (a.get(o, "utc") && a.has(n, "timezone") && !a.get(o, "timezone") && a.set(o, "timezone", "UTC"), a.forOwn(n, (l, c) => {
        l && a.has(o, c) && j.set(l, a.get(o, c));
      }));
    },
    getSchema() {
      return i.settingsSchema;
    },
    getSettingsMapping() {
      return n;
    }
  };
}
function Uc() {
  const e = this;
  e.createService("users"), e.createService("authorisations"), e.createService("import-export"), e.createService("account", { methods: ["create", "verifyEmail"] });
  const t = a.get(me, "settings.propertyMapping", {
    shortTime: "time.format.time.short",
    longTime: "time.format.time.long",
    shortDate: "time.format.date.short",
    longDate: "time.format.date.long",
    shortYear: "time.format.year.short",
    longYear: "time.format.year.long",
    timezone: "time.format.timezone",
    timelineStep: "time.step",
    timelineInterval: "time.interval",
    timeseriesSpan: "timeseries.span",
    timeseriesGroupBy: "timeseries.groupBy",
    location: "locationFormat",
    navigator: "navigator",
    restoreView: "restore.view",
    restoreLayers: "restore.layers",
    defaultLength: "units.default.length",
    defaultAltitude: "units.default.altitude",
    defaultArea: "units.default.area",
    defaultVelocity: "units.default.velocity",
    defaultTemperature: "units.default.temperature",
    defaultAngle: "units.default.angle",
    defaultEquivalentDoseRate: "units.default.equivalentDoseRate",
    defaultNotation: "units.default.notation",
    defaultPrecision: "units.default.precision"
  }), i = a.get(me, "settings.schema", "settings.update");
  e.createService("settings", {
    service: Cp,
    propertyMapping: t,
    settingsSchema: i
  });
}
function Da(e) {
  setTimeout(() => {
    window.URL.revokeObjectURL(e.href);
  }, 1e4), e.remove();
}
function yr(e, t, i = {}) {
  const { mimeType: n, byteOrderMark: r, encoding: s } = typeof i == "string" ? { mimeType: i } : i, o = s !== void 0 ? new TextEncoder(s).encode([t]) : t, l = r !== void 0 ? [r, o] : [o], c = new Blob(l, { type: n || "application/octet-stream" }), u = document.createElement("a");
  u.href = window.URL.createObjectURL(c), u.setAttribute("download", e), typeof u.download > "u" && u.setAttribute("target", "_blank"), u.classList.add("hidden"), u.style.position = "fixed", document.body.appendChild(u);
  try {
    return u.click(), Da(u), !0;
  } catch (d) {
    return Da(u), d;
  }
}
async function Tp(e) {
  return (await G.getService("account").verifyEmail({ email: e })).status === 200;
}
function Pp(e) {
  return G.getService("account").create({
    action: "resendVerifySignup",
    value: { email: e }
  });
}
function Vc(e, t) {
  return G.getService("account").create({
    action: "verifySignupShort",
    value: { user: { email: t }, token: e }
  });
}
function Mp(e) {
  return G.getService("account").create({
    action: "sendResetPwd",
    value: { email: e }
  });
}
function kp(e, t, i) {
  return G.getService("account").create({
    action: "resetPwdShort",
    value: { user: { email: e }, token: t, password: i }
  });
}
function Fp(e, t, i) {
  return G.getService("account").create({
    action: "passwordChange",
    value: { user: { email: e }, oldPassword: t, password: i }
  });
}
function Dp(e, t, i) {
  return G.getService("account").create({
    action: "identityChange",
    value: { user: { email: e }, changes: { email: t }, password: i }
  });
}
function Ap(e) {
  return Vc(e);
}
const Op = {
  id: {
    type: String,
    required: !0
  },
  label: {
    type: String,
    default: null
  },
  icon: {
    type: String,
    default: void 0
  },
  iconRight: {
    type: Boolean,
    default: !1
  },
  color: {
    type: String,
    default: "grey-9"
  },
  size: {
    type: String,
    default: "md"
  },
  flat: {
    type: Boolean,
    default: !0
  },
  outline: {
    type: Boolean,
    default: !1
  },
  badge: {
    type: Object,
    default: () => null
  },
  tooltip: {
    type: String,
    default: ""
  },
  disabled: {
    type: [Boolean, Function],
    default: !1
  },
  toggled: {
    type: Boolean,
    default: !1
  },
  toggle: {
    type: Object,
    default: () => {
    }
  },
  stack: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  propagate: {
    type: Boolean,
    default: !0
  },
  context: {
    type: Object,
    default: () => null
  },
  handler: {
    type: Function,
    default: null
  },
  closePopup: {
    type: [Boolean, Number, String],
    default: !1
  },
  dialog: {
    type: Object,
    default: null
  },
  route: {
    type: Object,
    default: () => null
  },
  url: {
    type: String,
    default: null
  },
  renderer: {
    type: String,
    default: "button",
    validator: (e) => ["button", "form-button", "item", "fab", "fab-action", "tab"].includes(e)
  }
};
function Kc(e, t) {
  return G.getService(e, t);
}
async function Bp(e, t, i = {}, n = 50) {
  return e.find({ query: a.merge({}, i, { $limit: n, $select: t }) });
}
async function Gc(e, t = "createdAt", i = {}) {
  const n = await e.find({ query: a.merge({}, i, { $sort: { [t]: 1 }, $limit: 1 }) });
  return a.get(n, "data[0]");
}
async function Hc(e, t = "createdAt", i = {}) {
  const n = await Gc(e, t, i);
  return a.get(n, t);
}
async function Wc(e, t = "createdAt", i = {}) {
  const n = await e.find({ query: a.merge({}, i, { $sort: { [t]: -1 }, $limit: 1 }) });
  return a.get(n, "data[0]");
}
async function Zc(e, t = "createdAt", i = {}) {
  const n = await Wc(e, t, i);
  return a.get(n, t);
}
async function Rp(e, t, i = {}) {
  const n = a.merge({}, i, { $distinct: t }), r = await e.find({ query: n });
  return Array.isArray(r) ? r : [r];
}
async function Qc(e, t, i = !1, n = !1) {
  const r = {
    $text: {
      $search: t,
      $caseSensitive: i,
      $diacriticSensitive: n
    }
  };
  return e.find({ query: r });
}
async function $p(e, t, i, n = !1, r = !1) {
  const s = await Qc(e, i, n, r);
  for (const o of s.data) {
    const l = a.get(o, t);
    if (l && a.size(i) === a.size(l)) {
      let c = i, u = l;
      if (r || (c = a.deburr(c), u = a.deburr(u)), n || (c = a.toUpper(c), u = a.toUpper(u)), c === u) return !0;
    }
  }
  return !1;
}
const Aa = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
}, zi = {
  white: "#fff",
  dark: "#333",
  red: "#f44336",
  pink: "#e91e63",
  purple: "#9c27b0",
  "deep-purple": "#673ab7",
  indigo: "#3f51b5",
  blue: "#2196f3",
  "light-blue": "#03a9f4",
  cyan: "#00bcd4",
  teal: "#009688",
  green: "#4caf50",
  "light-green": "#8bc34a",
  lime: "#cddc39",
  yellow: "#ffeb3b",
  amber: "#ffc107",
  orange: "#ff9800",
  "deep-orange": "#ff5722",
  brown: "#795548",
  grey: "#9e9e9e",
  "blue-grey": "#607d8b"
};
function Qt(e, t) {
  return e ? e.startsWith("#") || e.startsWith("hsl") || e.startsWith("rgb") ? e : a.has(Aa, e) ? Aa[e] : Mt.getPaletteColor(e) : t;
}
function As(e) {
  return e.startsWith("#") ? e : zi[e] || "#ffffff";
}
function Ip(e, t = !1) {
  if (zi[e]) return e;
  const i = a.findKey(zi, (n) => n === e);
  return i || t && Jc(e) || "white";
}
function Jc(e) {
  let t = Number.MAX_VALUE, i = null;
  for (const n in zi) {
    const r = Xt.deltaE(e, zi[n]);
    r < t && (t = r, i = n);
  }
  return i;
}
function zp(e, t = "white", i = "black") {
  const n = Qt(e);
  return Mt.luminosity(n) < 0.5 ? t : i;
}
function Fn(e) {
  if (!e) {
    I.warn("[KDK] buildColorScale: 'options' argument must be defined");
    return;
  }
  let t = e.colors;
  t || (e.scale ? (I.warn("[KDK] buildColorScale: please update 'scale' property to 'colors'"), t = e.scale) : (I.warn("[KDK] buildColorScale: no colors defined, using default default colors 'Spectral'"), t = "Spectral"));
  let i = Xt.scale(t);
  return e.classes ? Array.isArray(e.classes) ? i = i.classes(e.classes) : e.domain ? i = i.domain(e.domain).classes(e.classes) : i = i.classes(e.classes) : e.domain && (i = i.domain(e.domain)), i;
}
function Np(e) {
  return zt.basename(e);
}
function Yc(e) {
  return zt.extname(e);
}
function qp(e) {
  return zt.basename(e, Yc(e));
}
function jp(e) {
  return zt.dirname(e);
}
const Up = {
  title: {
    type: String,
    default: ""
  },
  item: {
    type: Object,
    default: () => null
  },
  actions: {
    type: Array,
    default: () => null
  },
  actionsFilter: {
    type: [String, Array],
    default: () => null
  },
  hideSeparator: {
    type: Boolean,
    default: !1
  },
  hideHeader: {
    type: Boolean,
    default: !1
  },
  dense: {
    type: Boolean,
    default: !1
  }
};
function Xc(e, t, i) {
  return Math.min(Math.max(e, t), i);
}
function eu(e, t = 0.5) {
  return 1 - Math.pow(1 - e, 1 / t);
}
function tu(e, t = 0, i = 1) {
  return t + e * i;
}
function iu(e, t = 0.42, i = 0, n = 0.58, r = 1) {
  return (1 - e) * (1 - e) * (1 - e) * i + 3 * (1 - e) * (1 - e) * e * t + 3 * (1 - e) * e * e * n + e * e * e * r;
}
const cn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clamp: Xc,
  cubicBezier: iu,
  easeOut: eu,
  linear: tu
}, Symbol.toStringTag, { value: "Module" }));
class Oa extends Ml {
  constructor(t, i) {
    super(t, "PermissionDeniedNotifications", 499, "permission-denied-notifications", i);
  }
}
class Ba extends Ml {
  constructor(t, i) {
    super(t, "NotificationsNotSupported", 498, "notifications-not-supported", i);
  }
}
async function Vp() {
  if (!("PushManager" in window)) throw new Ba("Push isn't supported on this browser");
  if (!("Notification" in window)) throw new Ba("This browser does not support notifications");
  return !0;
}
async function Kp() {
  if (window.Notification.permission === "default")
    try {
      return await window.Notification.requestPermission();
    } catch {
      throw new Oa("Denied permission to send notifications");
    }
  else if (window.Notification.permission === "denied") throw new Oa("Denied permission to send notifications");
}
async function Gp() {
  return await (await navigator.serviceWorker.ready).pushManager.getSubscription();
}
async function Hp(e) {
  const i = await (await navigator.serviceWorker.getRegistration()).pushManager.subscribe({
    userVisibleOnly: !0,
    applicationServerKey: e
  });
  return JSON.parse(JSON.stringify(i));
}
async function Wp(e, t, i) {
  return a.has(e, i) ? a.find(a.get(e, i), (n) => n.endpoint === t.endpoint) ? a.get(e, i) : a.get(e, i).push(t) : a.set(e, i, [t]);
}
async function Zp() {
  if (a.get(It.getData("application"), "mode") !== "PWA") {
    I.error("[KDK] Cannot subscribe to push notification: the application must run in PWA mode");
    return;
  }
  try {
    await Vp(), await Kp();
  } catch (o) {
    et.create({ type: "negative", message: Y.t(`errors.${o.code}`) });
    return;
  }
  const t = G.service("api/users"), i = he.utc().toISOString(), n = await Gp(), r = j.get("user");
  if (r || I.error("[KDK] User must be authenticated before calling 'subscribeToPushNotifications'"), n && a.find(a.get(r, "subscriptions", []), (o) => o.endpoint === n.endpoint)) {
    const o = a.map(r.subscriptions, (l) => (l.endpoint === n.endpoint && (l.lastActivity = i), l));
    t.patch(r._id, { subscriptions: o }), I.debug(`[KDK] New connection with subscription endpoint: ${n.endpoint}`);
    return;
  }
  const s = await Hp(j.get("capabilities.api.vapidPublicKey"));
  s.fingerprint = It.fingerprint, s.browser = a.pick(It.getData("browser"), ["name", "version"]), s.system = a.pick(It.getData("system"), ["os"]), s.lastActivity = i, await Wp(r, s, "subscriptions"), t.patch(r._id, { subscriptions: r.subscriptions }), I.debug(`[KDK] New webpush subscription registered with endpoint: ${s.endpoint}`);
}
let yn = null;
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault(), yn = e;
});
function nu() {
  xi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.INSTALL_MESSAGE"),
    cancel: {
      id: "ignore-button",
      label: Y.t("utils.pwa.IGNORE"),
      color: "primary",
      outline: !0
    },
    ok: {
      id: "install-button",
      label: Y.t("utils.pwa.INSTALL"),
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  }).onOk(async () => {
    yn.prompt();
    const { outcome: e } = await yn.userChoice;
    e === "accepted" && location.reload();
  });
}
function ru() {
  xi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.IOS_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  });
}
function su() {
  xi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.FIREFOX_DESKTOP_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  });
}
const tn = {};
function Qp(e) {
  Object.assign(ze, {
    request: e,
    exit: e,
    toggle: e
  });
}
function ou() {
  return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null;
}
function au() {
  const e = ze.activeEl = ze.isActive === !1 ? null : ou();
  Qm(
    e === null || e === document.documentElement ? document.body : e
  );
}
function Jp() {
  ze.isActive = ze.isActive === !1, au();
}
function Ra(e, t) {
  try {
    const i = e[t]();
    return i === void 0 ? Promise.resolve() : i;
  } catch (i) {
    return Promise.reject(i);
  }
}
const ze = Vi({
  isActive: !1,
  activeEl: null
}, {
  isCapable: !1,
  install({ $q: e }) {
    e.fullscreen = this;
  }
});
tn.request = [
  "requestFullscreen",
  "msRequestFullscreen",
  "mozRequestFullScreen",
  "webkitRequestFullscreen"
].find((e) => document.documentElement[e] !== void 0), ze.isCapable = tn.request !== void 0, ze.isCapable === !1 ? Qp(() => Promise.reject("Not capable")) : (Object.assign(ze, {
  request(e) {
    const t = e || document.documentElement, { activeEl: i } = ze;
    return t === i ? Promise.resolve() : (i !== null && t.contains(i) === !0 ? ze.exit() : Promise.resolve()).finally(() => Ra(t, tn.request));
  },
  exit() {
    return ze.isActive === !0 ? Ra(document, tn.exit) : Promise.resolve();
  },
  toggle(e) {
    return ze.isActive === !0 ? ze.exit() : ze.request(e);
  }
}), tn.exit = [
  "exitFullscreen",
  "msExitFullscreen",
  "mozCancelFullScreen",
  "webkitExitFullscreen"
].find((e) => document[e]), ze.isActive = !!ou(), ze.isActive === !0 && au(), [
  "onfullscreenchange",
  "onmsfullscreenchange",
  "onwebkitfullscreenchange"
].forEach((e) => {
  document[e] = Jp;
}));
const lu = Ks(ze, "isActive");
function lo(e) {
  if (a.isNumber(e))
    return e > 100 ? e : ht.width * e / 100;
  if (!a.isObject(e)) {
    I.warn(`[KDK] Invalid width parameter ${e}`);
    return;
  }
  let t = a.get(e, ht.name);
  if (!t) {
    I.warn(`[KDK] Cannot find width value for breakpoint ${ht.name}`);
    return;
  }
  if (!a.isNumber(t)) {
    I.warn(`[KDK] Invalid width value ${t} for breakpoint ${ht.name}`);
    return;
  }
  return lo(t);
}
function co(e) {
  if (a.isNumber(e))
    return e > 100 ? e : ht.height * e / 100;
  if (!a.isObject(e)) {
    I.warn(`[KDK] Invalid height parameter ${e}`);
    return;
  }
  let t = a.get(e, ht.name);
  if (!t) {
    I.warn(`[KDK] Cannot find height value for breakpoint ${ht.name}`);
    return;
  }
  if (!a.isNumber(t)) {
    I.warn(`[KDK] Invalid height value ${t} for breakpoint ${ht.name}`);
    return;
  }
  return co(t);
}
function Yp(e) {
  if (a.isArray(e)) {
    if (e.length === 2) {
      I.warn(`[KDK] Invalid size parameter ${e}`);
      return;
    }
    return e;
  }
  if (!a.isObject(e)) {
    I.warn(`[KDK] Invalid size parameter ${e}`);
    return;
  }
  let t = a.get(e, ht.name);
  return [lo(t[0]), co(t[1])];
}
function Xp() {
  return ht.width > ht.height ? "portrait" : "landscape";
}
async function cu() {
  return new Promise((e, t) => {
    ze.toggle().then(() => {
      e(!0);
    }).catch((i) => {
      I.warn(`[KDK] Cannot toggle fullscreen mode: ${i}`), t(!1);
    });
  });
}
async function uu(e) {
  screen.orientation && screen.orientation.lock && typeof screen.orientation.lock == "function" && await screen.orientation.lock(e);
}
function qt(e, {
  context: t = null,
  created: i = null,
  updated: n = null,
  patched: r = null,
  removed: s = null,
  all: o = null
} = {}, l) {
  At(l), typeof e == "string" && (e = G.getService(e, t));
  const c = (u, d) => u ? (f) => u(f, d) : null;
  return e && ((i || o) && (i = c(i || o, "created"), e.on("created", i)), (n || o) && (n = c(n || o, "updated"), e.on("updated", n)), (r || o) && (r = c(r || o, "patched"), e.on("patched", r)), (s || o) && (s = c(s || o, "removed"), e.on("removed", s))), { service: e, created: i, updated: n, patched: r, removed: s };
}
function At(e) {
  if (!e) return;
  const { service: t, created: i, updated: n, patched: r, removed: s } = e;
  i && t.off("created", i), n && t.off("updated", n), r && t.off("patched", r), s && t.off("removed", s);
}
const ey = { width: 24, height: 24 }, ps = "black", ty = 12, iy = 12;
function ny(e) {
  return { width: e * 2, height: e * 2 };
}
const Ni = {
  circle: {
    viewBox: [0, 0, 100, 100],
    content: '<circle cx="50" cy="50" r="50" />'
  },
  rect: {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 0.9), height: Math.round(e * 2 * 0.9) })
  },
  "rounded-rect": {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" rx="20" ry="20" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 0.9), height: Math.round(e * 2 * 0.9) })
  },
  diamond: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 50, 50 100, 0 50" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.2), height: Math.round(e * 2 * 1.2) })
  },
  triangle: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 100, 0 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.125), height: Math.round(e * 2 * 1.025) })
  },
  "triangle-down": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 0, 50 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.125), height: Math.round(e * 2 * 1.025) })
  },
  "triangle-left": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 50, 100 0, 100 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.025), height: Math.round(e * 2 * 1.125) })
  },
  "triangle-right": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 50, 0 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.025), height: Math.round(e * 2 * 1.125) })
  },
  star: {
    viewBox: [0, 0, 48, 48],
    content: '<path d="m24,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.4), height: Math.round(e * 2 * 1.4) })
  },
  "marker-pin": {
    viewBox: [0, 0, 384, 512],
    content: '<path d="M384 192c0 87.4-117 243-168.3 307.2c-12.3 15.3-35.1 15.3-47.4 0C117 435 0 279.4 0 192C0 86 86 0 192 0s192 86 192 192z" />',
    icon: {
      translation: ["-50%", "-70%"]
    },
    text: {
      translation: ["-50%", "-70%"]
    },
    anchor: "bottom-center"
  },
  "square-pin": {
    viewBox: [0, 0, 56, 56],
    content: '<path d="M 27.9532 52.3633 C 29.0079 52.3633 29.9923 51.9180 30.9298 50.3008 L 35.2657 43.0586 L 43.0938 43.0586 C 50.0783 43.0586 53.8280 39.1914 53.8280 32.3242 L 53.8280 14.3711 C 53.8280 7.5039 50.0783 3.6367 43.0938 3.6367 L 12.9064 3.6367 C 5.9454 3.6367 2.1720 7.4805 2.1720 14.3711 L 2.1720 32.3242 C 2.1720 39.2148 5.9454 43.0586 12.9064 43.0586 L 20.6407 43.0586 L 24.9766 50.3008 C 25.9142 51.9180 26.8985 52.3633 27.9532 52.3633 Z"/>',
    icon: {
      translation: ["-50%", "-75%"]
    },
    text: {
      translation: ["-50%", "-60%"]
    },
    anchor: "bottom-center"
  }
};
function ry(e, t, i) {
  return e.slice(0, -1) + ` ${t}="${i}">`;
}
function bt(e, t, i) {
  return e.slice(0, -2) + ` ${t}="${i}" />`;
}
function $a(e) {
  return Array.isArray(e) ? { width: a.toNumber(e[0]), height: a.toNumber(e[1]) } : { width: a.toNumber(e), height: a.toNumber(e) };
}
function du(e) {
  if (!e) {
    I.warn("[KDK] 'options' argument is required");
    return;
  }
  let t = "middle-center", i;
  e.shape && e.shape !== "none" && (typeof e.shape == "object" ? i = e.shape : (i = Ni[e.shape], i || (I.warn(`[KDK] unknown shape '${e.shape}'. Using default shape 'circle'`), i = Ni.circle)), t = i.anchor || t);
  let n = ey;
  e.size ? n = $a(e.size) : e.radius && (n = a.get(i, "radiusToSize", ny)(e.radius));
  const r = a.get(e, "extraStyle", ""), o = `<div ${a.get(e, "id") ? `id=${e.id}` : ""} style="position: relative; width: ${n.width}px; height: ${n.height}px; ${r}">`, l = "</div>";
  let c = "", u = "", d = "", f = "";
  if (i) {
    const x = i.extraStyle || "", S = i.translation || [0, 0], A = i.rotation || 0;
    c = `<svg xmlns="http://www.w3.org/2000/svg" width="${n.width}" height="${n.height}" preserveAspectRatio="none"
                   style="transform: translate(${S[0]},${S[1]}) rotate(${A}deg); ${x}">`, c = ry(c, "viewBox", a.join(i.viewBox, " ")), u = i.content, d = "", f = "</svg>";
    const p = e.color ? Qt(e.color) : "none";
    if (u = bt(u, "fill", p), a.isNil(e.opacity) || (u = bt(u, "fill-opacity", e.opacity)), e.stroke) {
      const y = Qt(e.stroke.color, ps);
      if (y !== "transparent") {
        u = bt(u, "stroke", y);
        const w = e.stroke.width || 1;
        u = bt(u, "stroke-width", w * 2), u = bt(u, "vector-effect", "non-scaling-stroke"), e.stroke.cap && (u = bt(u, "stroke-linecap", e.stroke.cap)), e.stroke.join && (u = bt(u, "stroke-linejoin", e.stroke.join)), e.stroke.dashArray && (u = bt(u, "stroke-dasharray", e.stroke.dashArray)), e.stroke.dashOffset && (u = bt(u, "stroke-dashoffset", e.stroke.dashOffset)), a.has(e, "stroke.opacity") && (u = bt(u, "stroke-opacity", e.stroke.opacity));
        const C = ti();
        a.get(i, "clipPath", !0) && (u = bt(u, "clip-path", `url(#${C})`), d = `<clipPath id="${C}">${a.clone(i.content)}</clipPath>`);
      }
    }
  }
  let m = "";
  if (e.icon)
    if (!a.isNil(e.icon.classes) || !a.isNil(e.icon.url)) {
      if (!a.isEmpty(e.icon.classes) || !a.isEmpty(e.icon.url)) {
        let x = "";
        if (e.icon.url) {
          let y = e.icon.size ? $a(e.icon.size) : n;
          m = `<img src="${e.icon.url}" `, m += `width=${y.width} height=${y.height} `;
        } else {
          m += `<i class="${e.icon.classes}" `;
          const y = Qt(e.icon.color, ps);
          x += `color: ${y};`;
          let w = e.icon.size || ty;
          x += `font-size: ${w}px;`;
        }
        const S = e.icon.opacity || 1, A = e.icon.translation || a.get(i, "icon.translation", ["-50%", "-50%"]), p = e.icon.rotation || a.get(i, "icon.rotation", 0);
        m += `style="position: absolute; top: 50%; left: 50%; transform: translate(${A[0]},${A[1]}) rotate(${p}deg); opacity: ${S}; ${x}"`, m += "/>";
      }
    } else
      I.warn("[KDK] icon must contain either the 'classes' property or the 'url' property");
  let g = "";
  if (e.text) {
    if (a.isNil(e.text.label))
      I.warn("[KDK] text must contain the 'label' property");
    else if (!a.isEmpty(e.text.label)) {
      g = "<span ", e.text.classes && (g += `classes="${e.text.classes}" `);
      const x = Qt(e.text.color, ps), S = e.text.size || iy, A = e.text.translation || a.get(i, "text.translation", ["-50%", "-50%"]), p = e.text.rotation || a.get(i, "icon.rotation", 0), y = e.text.extraStyle || "";
      g += `style="position: absolute; 5px; top: 50%; left: 50%; transform: translate(${A[0]},${A[1]}) rotate(${p}deg); color: ${x}; font-size: ${S}px; ${y}"`, g += ">", g += e.text.label, g += "</span>";
    }
  }
  let v = "";
  return e.html && (v = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">', v += e.html, v += "</div>"), {
    html: o + c + d + u + f + m + g + v + l,
    size: n,
    anchor: t
  };
}
async function fu(e) {
  let t = j.get("user");
  t || (await Se.setItem("authentication", e), t = e.user ? e.user : { name: Y.t("composables.ANONYMOUS"), anonymous: !0 }, j.set("user", t), await uo());
}
async function hu(e, t) {
  const i = {
    strategy: "local",
    email: e,
    password: t
  }, n = await G.authenticate(i);
  await fu(n);
}
async function sy(e) {
  delete e.confirmPassword, await G.getService("users").create(e), await hu(e.email, e.password);
}
async function oy() {
  try {
    await Se.removeItem("authentication"), await G.logout(), j.set("user", null);
  } catch (e) {
    throw j.set("user", null), await G.authentication.removeAccessToken(), e;
  }
}
async function mu() {
  try {
    let e;
    G.isDisconnected && (e = await Se.getItem("authentication"), e && (G.emit("login", e), G.emit("authenticated", e))), e || (e = await G.reAuthenticate()), await fu(e);
  } catch (e) {
    throw await G.authentication.removeAccessToken(), e;
  }
}
async function uo() {
  const e = j.get("user");
  if (!e) return;
  const t = await $r(e, G), i = j.get("user.abilities"), n = a.get(t, "rules"), r = a.get(i, "rules");
  a.isEqual(n, r) || (j.set("user.abilities", t), Al.debug("[KDK] New user abilities: ", t.rules));
}
async function fo(e) {
  e._id === j.get("user._id") && (j.patch("user", e), await uo());
}
async function ho(e) {
  await Se.removeItem("authentication"), await G.authentication.removeAccessToken(), await G.authentication.reset(), j.set("user", null), G.emit("logout", e);
}
function gu() {
  const e = G.getService("users");
  e.on("patched", fo), e.on("logout", ho);
}
function ay() {
  const e = G.getService("users");
  e.off("patched", fo), e.off("logout", ho);
}
async function ly(e) {
  const t = G.getService("tags");
  if (!t)
    return I.warn("[KDK] Tags service not found"), [];
  const i = (await t.find({ service: e })).data;
  for (const n of i)
    n.label = n.name;
  return i;
}
function cy(e) {
  const t = he().tz(e).format("Z");
  return `${e} (${t})`;
}
function uy(e, t) {
  return t ? he.tz(e, t) : he(e).local();
}
function dy(e, t) {
  return be.convertToLocal(e).format(t);
}
function fy(e, t) {
  return be.convertToLocal(e).format(t);
}
function hy(e, t) {
  return be.getFormatTimezone() ? he.tz(e, t, be.getFormatTimezone()) : he(e, t);
}
function my(e, t) {
  return be.getFormatTimezone() ? he.tz(e, t, be.getFormatTimezone()) : he(e, t);
}
et.setDefaults({
  position: "bottom-left",
  timeout: 5e3,
  textColor: "white"
});
Be.setDefaults({
  spinnerColor: "primary",
  spinnerSize: 140,
  messageColor: "white",
  customClass: "full-width"
});
function Nr(e) {
  let t = e;
  if (typeof e == "function" && (t = new Promise(e)), t.isResolved) return t;
  let i = !0, n = !1, r = !1;
  const s = t.then(
    (o) => (r = !0, i = !1, o),
    (o) => {
      throw n = !0, i = !1, o;
    }
  );
  return s.isFulfilled = () => r, s.isPending = () => i, s.isRejected = () => n, s;
}
function gy(e) {
  return (e.toUpperCase().match(/\b\w/g) || []).join("");
}
function py(e) {
  return ah.validate(e);
}
function yy(e, t, i, n, r) {
  const s = document.createElement("img");
  s.onload = function() {
    const o = document.createElement("canvas"), l = o.getContext("2d");
    o.width = t, o.height = i, l.drawImage(this, 0, 0, t, i), r(o.toDataURL("image/jpeg", n));
  }, s.src = e;
}
function vy(e) {
  const t = atob(e.split(",")[1]), i = e.split(",")[0].split(":")[1].split(";")[0], n = new ArrayBuffer(t.length), r = new Uint8Array(n);
  for (let s = 0; s < t.length; s++)
    r[s] = t.charCodeAt(s);
  return new Blob([n], { type: i });
}
const pu = function(e) {
  e = new Uint8Array(e);
  const t = 32768, i = [];
  for (let n = 0; n < e.length; n += t)
    i.push(String.fromCharCode.apply(null, e.subarray(n, n + t)));
  return btoa(i.join(""));
};
function yu(e, t, i) {
  const n = new Blob([e], { type: i });
  yr(t, n);
}
async function mo(e) {
  return new Promise((t, i) => {
    xi.create(e).onOk((n) => t({ ok: !0, data: n })).onCancel(() => t({ cancel: !0 })).onDismiss(() => t({ dismiss: !0 }));
  });
}
function go(e, t = "icon.name") {
  const i = typeof e == "object" ? a.get(e, t, "") : e;
  return typeof i == "object" ? "" : i.startsWith("fa-") ? `fas ${i}` : i;
}
function vu(e, t = "icon.name") {
  a.set(e, t, go(e, t));
}
function by(e) {
  if (e.startsWith("kdk:") === !0)
    return { icon: "img:kdk/" + e.substring(4) };
}
function Dn(e) {
  const t = {};
  function i(n, r) {
    a.forOwn(n, (s, o) => {
      const l = r ? r + "." + o : o;
      s && typeof s == "object" ? i(s, l) : t[l] = s;
    });
  }
  return i(e), t;
}
const wy = /^[0-9a-fA-F]{24}$/;
function bu(e) {
  return e.length === 24 && wy.test(e);
}
async function wu(e) {
  try {
    return (await import(`@schemas/${e}.json`)).default;
  } catch (t) {
    I.error(t);
  }
}
function _y(e) {
  try {
    return Ar(Gf(() => import(`@components/${e}.vue`)));
  } catch (t) {
    I.error(t);
  }
}
const Ly = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CardSectionProps: Up,
  Colors: zi,
  Fullscreen: lu,
  get InstallPwaPrompt() {
    return yn;
  },
  Shapes: Ni,
  actionProps: Op,
  base64Encode: pu,
  bindContent: kn,
  bindHandler: xc,
  bindParams: gr,
  bindProperties: mr,
  buildColorScale: Fn,
  changeIdentity: Ap,
  changePassword: Fp,
  clamp: Xc,
  computeResponsiveHeight: co,
  computeResponsiveSize: Yp,
  computeResponsiveWidth: lo,
  containsText: $p,
  createQuerablePromise: Nr,
  createShape: du,
  createThumbnail: yy,
  cubicBezier: iu,
  dataUriToBlob: vy,
  dialog: mo,
  dotify: Dn,
  downloadAsBlob: yu,
  easeOut: eu,
  filterContent: Ai,
  findClosestColor: Jc,
  fromQuasarDate: hy,
  fromQuasarTime: my,
  generateHandler: Xn,
  getBaseName: qp,
  getBoundValue: so,
  getBrowserLocale: cc,
  getCollectionService: Kc,
  getColorFromPalette: As,
  getContrastColor: zp,
  getDir: jp,
  getDistinctValues: Rp,
  getExtension: Yc,
  getFallbackLocale: uc,
  getFileName: Np,
  getHtmlColor: Qt,
  getIconName: go,
  getInitials: gy,
  getLatestItem: Wc,
  getLatestTime: Zc,
  getLocale: Dt,
  getOldestItem: Gc,
  getOldestTime: Hc,
  getOrientation: Xp,
  getPaletteFromColor: Ip,
  getTagsFilterOptions: ly,
  getTimezoneLabel: cy,
  installDefaultPrompt: nu,
  installFFDesktopPrompt: su,
  installSafariPrompt: ru,
  isEmailValid: py,
  isObjectID: bu,
  linear: tu,
  listItems: Bp,
  listenToServiceEvents: qt,
  loadComponent: _y,
  loadSchema: wu,
  lockOrientation: uu,
  login: hu,
  logout: oy,
  logoutUser: ho,
  mapIconFunction: by,
  processIcon: vu,
  register: sy,
  resendVerifySignup: Pp,
  resetPassword: kp,
  restoreSession: mu,
  searchText: Qc,
  sendChangeIdentity: Dp,
  sendResetPassword: Mp,
  subscribeToPushNotifications: Zp,
  subscribeToUserChanges: gu,
  toLocalTimezone: uy,
  toQuasarDate: dy,
  toQuasarTime: fy,
  toggleFullscreen: cu,
  unlistenToServiceEvents: At,
  unsubscribeToUserChanges: ay,
  updateAbilities: uo,
  updateUser: fo,
  verifyEmail: Tp,
  verifySignup: Vc
}, Symbol.toStringTag, { value: "Module" })), xy = {
  mounted(e, t) {
    e.__state = {
      dropCallback: a.get(t.value, "dropCallback"),
      acceptedTypes: a.get(t.value, "mimeTypes"),
      maxFiles: a.get(t.value, "maxFiles"),
      fontSize: a.get(t.value, "fontSize", "2rem"),
      enabled: a.get(t.value, "enabled", !0)
    }, e.style.position = "relative";
    const i = document.createElement("div");
    i.className = "drag-overlay", i.innerHTML = '<div class="drag-overlay-box" />', e.appendChild(i);
    const n = document.createElement("style");
    n.textContent = `
      .drag-overlay {
        display: none;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        justify-content: center;
        align-items: center;
        font-size: ${e.__state.fontSize};
        z-index: 9999;
        pointer-events: none;
      }
      .drag-overlay-box {
        display: flex;
        border: 3px dashed;
        width: 95%; height: 95%;
        border-radius: 5px;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }
    `, document.head.appendChild(n);
    const r = () => i.style.display = "flex", s = () => i.style.display = "none";
    let o = 0, l = !1;
    const c = (m) => {
      if (!e.__state.enabled) return;
      m.preventDefault();
      const g = m.dataTransfer.items;
      let v = [], x = [], S, A;
      if (e.__state.maxFiles && a.size(g) > e.__state.maxFiles)
        S = Mt.getPaletteColor("negative"), A = Y.tc("directives.MAX_FILES_REACHED", e.__state.maxFiles);
      else {
        for (const y of g)
          y.kind === "file" && a.includes(e.__state.acceptedTypes, y.type) ? x.push(y) : v.push(y);
        a.isEmpty(x) ? (S = Mt.getPaletteColor("negative"), A = Y.tc("directives.ALL_FILES_ARE_UNSUPPORTED", v.length)) : a.isEmpty(v) ? (S = Mt.getPaletteColor("positive"), A = Y.tc("directives.DROP_FILES", x.length)) : (S = Mt.getPaletteColor("warning"), A = Y.t("directives.SOME_FILES_ARE_UNSUPPORTED"));
      }
      l = a.size(x) > 0, i.style.background = "#0007";
      const p = i.querySelector(".drag-overlay-box");
      p.textContent = A, p.style.borderColor = S, p.style.color = "white", p.style.textShadow = "-2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black", p.style.padding = "20px;", o++, r();
    }, u = (m) => {
      m.preventDefault();
    }, d = (m) => {
      m.preventDefault(), o--, o === 0 && s();
    }, f = async (m) => {
      if (m.preventDefault(), o = 0, s(), !l) return;
      const g = Array.from(m.dataTransfer.files);
      if (e.__state.dropCallback && typeof e.__state.dropCallback == "function") {
        const v = yi.filter(g);
        for (const x of v) {
          const S = await yi.read(x);
          await e.__state.dropCallback(S);
        }
      } else I.warn("[KDK] Missing 'dropCallback' argument in 'v-drop-file' directive");
    };
    e.__handlers = { onDragEnter: c, onDragOver: u, onDragLeave: d, onDrop: f }, e.addEventListener("dragenter", c), e.addEventListener("dragover", u), e.addEventListener("dragleave", d), e.addEventListener("drop", f);
  },
  updated(e, t) {
    t.value !== t.oldValue && (e.__state = {
      dropCallback: a.get(t.value, "dropCallback"),
      acceptedTypes: a.get(t.value, "mimeTypes"),
      maxFiles: a.get(t.value, "maxFiles"),
      fontSize: a.get(t.value, "fontSize", "2rem"),
      enabled: a.get(t.value, "enabled", !0)
    });
  },
  beforeUnmount(e, t) {
    const { onDragEnter: i, onDragOver: n, onDragLeave: r, onDrop: s } = e.__handlers;
    e.removeEventListener("dragenter", i), e.removeEventListener("dragover", n), e.removeEventListener("dragleave", r), e.removeEventListener("drop", s), delete e.__handlers, delete e.__state;
  }
}, Sy = {
  mounted(e, t) {
    It.touch || (e.__vHoverEnter__ = t.value.enter || (() => {
    }), e.__vHoverOver__ = t.value.over || (() => {
    }), e.__vHoverLeave__ = t.value.leave || (() => {
    }), e.addEventListener("mouseenter", e.__vHoverEnter__), e.addEventListener("mouseover", e.__vHoverOver__), e.addEventListener("mouseleave", e.__vHoverLeave__));
  },
  beforeUnmount(e, t) {
    e.removeEventListener("mouseenter", e.__vHoverEnter__), e.removeEventListener("mouseover", e.__vHoverOver__), e.removeEventListener("mouseleave", e.__vHoverLeave__), delete e.__vHoverEnter__, delete e.__vHoverOver__, delete e.__vHoverLeave__;
  }
}, Ey = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vDropFile: xy,
  vHover: Sy
}, Symbol.toStringTag, { value: "Module" }));
function po(e, t = {}) {
  const i = t.matches || a.matches, { store: n, set: r, get: s, has: o } = Ft(`selections.${e}`);
  function l() {
    g() && p() && r("items", []);
  }
  function c() {
    return s("mode");
  }
  function u(P) {
    return r("mode", P);
  }
  function d() {
    return s("mode") === "single";
  }
  function f() {
    return s("mode") !== "single";
  }
  function m(P = !0) {
    return r("enabled", P);
  }
  function g() {
    return s("enabled");
  }
  function v() {
    return s("filter");
  }
  function x(P) {
    return r("filter", P);
  }
  function S(P) {
    if (!g()) return;
    const M = v();
    if (M && !M(P)) return;
    const z = s("items");
    a.find(z, i(P)) || r("items", z.concat([P]));
  }
  function A(P) {
    if (!g()) return;
    const M = s("items");
    a.remove(M, i(P)), r("items", a.clone(M));
  }
  function p() {
    return o("items") && s("items").length > 0;
  }
  function y() {
    return p();
  }
  function w() {
    return a.last(s("items"));
  }
  function C() {
    return s("items");
  }
  return o("items") || (r("items", []), r("mode", "single"), r("enabled", !0)), {
    selection: n,
    clearSelection: l,
    getSelectionMode: c,
    setSelectionMode: u,
    isSingleSelectionMode: d,
    isMultipleSelectionMode: f,
    setSelectionEnabled: m,
    isSelectionEnabled: g,
    getSelectionFilter: v,
    setSelectionFilter: x,
    selectItem: S,
    unselectItem: A,
    hasSelectedItem: p,
    hasSelectedItems: y,
    getSelectedItem: w,
    getSelectedItems: C
  };
}
const Ye = Hf({
  activity: null,
  name: null,
  state: null,
  config: null
}), vr = Fl(null), _u = {};
function Lu(e, t = {}) {
  a.defaults(t, { selection: !0 }), Ye.name = e, Ye.state = Ft(`store.${e}.state`, t.state).store, Ye.config = Ft(`store.${e}.options`, me[e]).store;
  function i(r) {
    Ye.activity !== r && (r ? (Ye.activity = r, vr.value = r, I.debug("[KDK] Current activity set to", r)) : (Ye.activity = null, vr.value = null, I.debug("[KDK] Current activity cleared")));
  }
  je(() => {
    Ye.name = null, Ye.state = null, Ye.config = null, i(null);
  });
  const n = {
    CurrentActivityContext: Ye,
    setCurrentActivity: i
  };
  return t.selection && Object.assign(n, {
    ...po(e)
  }), a.set(_u, e, n), n;
}
function ni(e = {}) {
  a.defaults(e, { selection: !0 });
  const t = {
    CurrentActivityContext: Ye,
    CurrentActivity: vr,
    kActivity: gi(vr),
    kActivityName: gi(Ks(Ye, "name"))
  };
  return Ye.name && Object.assign(t, a.get(_u, Ye.name)), t;
}
function Cy(e = {}) {
  const t = ue(0);
  Dl(() => s());
  function i() {
    const o = G.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!o)
      throw new Error("[KDK] Cannot retrieve target service " + e.service.value);
    return o;
  }
  function n() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function r() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  async function s() {
    const o = a.merge(n(), r(), { $limit: 0 });
    I.debug(`[KDK] Count service '${e.service.value}' with query`, o);
    const l = await i().find({ query: o });
    t.value = l.total;
  }
  return Cn(async () => {
    const o = i();
    o.on("created", s), o.on("removed", s);
  }), je(() => {
    const o = i();
    o.off("created", s), o.off("removed", s);
  }), {
    counter: t
  };
}
function Ty(e = {}) {
  const { CurrentActivityContext: t } = ni(), i = t.state.tagsFilter, n = t.state.timeFilter, r = ue({});
  let s;
  const o = W(() => a.get(i, "selection", [])), l = W(() => !a.isEmpty(o.value)), c = W(() => a.cloneDeep(n)), u = W(() => {
    const S = a.get(n, "start"), A = a.get(n, "end");
    return S && A && S !== A;
  });
  _e(o, () => x(), { immediate: !0 }), _e(c, (S, A) => {
    A && A.start !== null && A.end !== null && x();
  }, { deep: !0 });
  function d() {
    return Kc(e.service.value, e.context ? e.context.value : null);
  }
  function f() {
    return a.get(e, "baseQuery.value", {});
  }
  function m() {
    return a.get(e, "timeField.value", "createdAt");
  }
  function g() {
    return a.get(e, "tagFields", []);
  }
  async function v() {
    const S = m(), A = await Hc(d(), S, f());
    A && a.set(n, "min", A);
    const p = await Zc(d(), S, f());
    p && a.set(n, "max", p);
    const y = g();
    let w = [];
    a.forEach(y, (C, P) => {
      const M = a.map(C, (z, D) => a.merge({ scope: P, name: D }, z));
      a.size(M) > 1 && (w = a.concat(w, M));
    }), a.set(i, "options", w);
  }
  function x() {
    const S = {};
    if (l.value) {
      const A = g();
      a.forEach(A, (p, y) => {
        const w = a.map(a.filter(o.value, { scope: y }), (C) => C.name);
        a.isEmpty(w) || a.merge(S, { [y]: { $in: w } });
      });
    }
    u.value && a.merge(S, {
      [m()]: {
        $gte: c.value.start,
        $lte: c.value.end
      }
    }), r.value = S;
  }
  return Vt(async () => {
    await v(), s = qt(d(), {
      created: () => v(),
      updated: () => v(),
      patched: () => v(),
      removed: () => v()
    });
  }), je(() => {
    At(s);
  }), {
    filterQuery: r,
    hasTagsSelection: l,
    hasTimeSelection: u
  };
}
function Py(e = {}) {
  const t = ue(null);
  let i;
  Dl(() => o());
  function n() {
    const l = G.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!l)
      throw new Error("[KDK] Cannot retrieve target service " + e.service.value);
    return l;
  }
  function r() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function s() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  async function o() {
    let l, c;
    const u = e.property ? e.property.value : "createdAt", d = { $sort: { [u]: 1 }, $limit: 1 };
    I.debug(`[KDK] Get min timestamp on service '${e.service.value}' with query`, d);
    const f = await n().find({ query: a.merge({}, r(), s(), d) });
    a.size(f.data) > 0 && (l = f.data[0]);
    const m = { $sort: { [u]: -1 }, $limit: 1 };
    I.debug(`[KDK] Get max timestamp on service '${e.service.value}' with query`, m);
    const g = await n().find({ query: a.merge({}, r(), s(), m) });
    a.size(g.data) > 0 && (c = g.data[0]), t.value = { start: a.get(l, u), end: a.get(c, u) };
  }
  return Cn(() => {
    i = qt(n(), { all: o });
  }), je(() => {
    At(i);
  }), {
    timeRange: t
  };
}
function My(e) {
  a.defaults(e, {
    // This value can be overriden in activities if they want to manage pagination by themselves
    // nbItemsPerPage = 0 means that the client does not handle pagination and server defaults will be used
    nbItemsPerPage: ue(12),
    // This value indicate if items of each page replace or are appended to previous ones
    appendItems: ue(!1),
    // Only invoke refresh at most once per every refreshThrottle milliseconds
    refreshThrottle: ue(500),
    // Refresh strategy to be used
    listStrategy: ue("smart"),
    // Item processor to be used
    processor: ue()
  });
  const t = ue(null), i = ue(0), n = ue(1);
  let r = null, s;
  const o = W(() => e.nbItemsPerPage.value > 0 ? Math.ceil(i.value / e.nbItemsPerPage.value) : 1);
  function l() {
    const A = G.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!A)
      throw new Error("Cannot retrieve target service " + e.service.value);
    return A;
  }
  function c() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function u() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  function d() {
    return e.nbItemsPerPage.value > 0 ? {
      $limit: e.nbItemsPerPage.value,
      $skip: (n.value - 1) * e.nbItemsPerPage.value
    } : {};
  }
  function f(A) {
    typeof e.processor.value == "function" && (A = e.processor.value(A)), t.value = A;
  }
  function m(A) {
    g(), r = l().watch({ listStrategy: e.listStrategy.value }).find({ query: A }).subscribe((p) => {
      if (p.type === "FeatureCollection")
        f(p.features);
      else if (e.appendItems.value) {
        const y = a.unionBy(p.data, t.value, "_id"), w = a.get(c(), "$sort");
        f(w ? a.orderBy(
          y,
          // Sort function for each sort property
          a.map(a.keys(w), (C) => (P) => {
            const M = a.get(P, C);
            return typeof M == "string" ? M.toLowerCase() : M;
          }),
          // Sort order for each sort property
          a.map(a.values(w), (C) => C > 0 ? "asc" : "desc")
        ) : y);
      } else
        f(p.data);
      i.value = p.total;
    }, (p) => {
      I.error(p);
    });
  }
  function g() {
    r && (r.unsubscribe(), r = null);
  }
  const v = a.throttle(() => {
    const A = {
      $locale: Dt(),
      ...c(),
      ...u(),
      ...d()
    };
    m(A);
  }, e.refreshThrottle.value, { leading: !1 });
  function x() {
    a.isNil(t.value) || (e.appendItems.value && f([]), n.value = 1, v());
  }
  function S(A) {
    A = Array.isArray(A) ? A : [A], A = a.intersectionWith(t.value, A, (p, y) => p._id && y._id && p._id.toString() === y._id.toString()), A.length > 0 && x();
  }
  return _e(e.service, x), _e(e.listStrategy, x), _e(e.nbItemsPerPage, x), _e(e.appendItems, x), e.contextId && _e(e.contextId, x), e.baseQuery && _e(e.baseQuery, x), e.filterQuery && _e(e.filterQuery, x), Cn(() => {
    e.appendItems.value && (s = qt(l(), {
      patched: S,
      updated: S,
      removed: S
    }));
  }), je(() => {
    g(), e.appendItems.value && At(s);
  }), {
    items: t,
    nbTotalItems: i,
    currentPage: n,
    nbPages: o,
    setCollectionItems: f,
    subscribe: m,
    unsubscribe: g,
    getCollectionBaseQuery: c,
    getCollectionFilterQuery: u,
    getCollectionPaginationQuery: d,
    resetCollection: x,
    refreshCollection: v
  };
}
function ky(e) {
  const t = Hs(), i = e?.fallbackRoute || "home";
  let n;
  function r() {
    return nt.getService();
  }
  async function s(f) {
    let m = nt.get();
    if (m && c(), _.isString(f)) {
      const g = nt.getService();
      try {
        I.debug(`[KDK] Setting context to '${f}'`), m = await g.get(f);
      } catch (v) {
        I.debug(`[KDK] cannot get event with id ${f}: ${v}`), setTimeout(() => t.push({ name: i }), 2e3);
      }
    } else if (_.isObject(f))
      I.debug(`[KDK] Setting context to '${f._id}'`), m = f;
    else {
      I.error("[KDK] Setting context: invalid parameter", f);
      return;
    }
    nt.set(m), l();
  }
  function o() {
    nt.get() && c(), nt.set(null);
  }
  function l() {
    n = qt(nt.getService(), {
      patched: u,
      removed: d
    });
  }
  function c() {
    At(n);
  }
  function u(f) {
    const m = nt.get();
    m._id === f._id && Object.assign(m, _.omit(f, ["_id"]));
  }
  function d(f) {
    nt.get()._id === f._id && xi.create({
      title: Y.t("ALERT"),
      message: Y.t("composables.context.REMOVED_MESSAGE"),
      persistent: !0,
      position: "bottom",
      html: !0,
      backdropFilter: "blur(4px)",
      ok: {
        label: Y.t("OK"),
        flat: !0
      }
    }).onOk(async () => {
      t.push({ name: i });
    });
  }
  return {
    Context: gi(nt.getRef("store")),
    getService: r,
    setContext: s,
    clearContext: o
  };
}
function qr() {
  return kl(ac);
}
function Fy() {
  const e = qr(), t = Ws();
  function i(r) {
    if (r.ignore) {
      I.error(r);
      return;
    }
    const s = { type: "negative", message: r.message || r.error_message || r.error, html: !0 };
    r.retryHandler && (s.actions = [{
      label: this.$t("RETRY"),
      handler: r.retryHandler
    }], s.timeout = 2e4), e.notify(s);
  }
  function n(r) {
    r.query && (r.query.error_message || r.query.error) ? i(r.query) : r.params && r.params.token && r.params.token.startsWith("error=") && i({ message: r.params.token.split("=")[1] });
  }
  return _e(t, (r, s) => n(r)), Vt(() => {
    n(t), ne.on("error-hook", (r) => {
      a.get(r.error, "data.name") !== "TokenExpiredError" && ne.emit("error", r.error);
    }), ne.on("error", (r) => {
      const s = a.get(r, "data.translation");
      s ? (r.message = Y.tie("errors." + s.key, s.params), s.keys && s.keys.forEach((o) => {
        r.message += "<br/>" + Y.tie("errors." + o, s.params);
      })) : r.code && (r.message = Y.tie("errors." + r.code)), i(r);
    });
  }), {
    showError: i,
    showRouteError: n
  };
}
function Dy() {
  function e(r, s) {
    _.has(r, "view") && ee.setView(r.view), _.has(r, "padding") && ee.setPadding(r.padding), _.has(r, "header") && ee.setHeader(r.header, s), _.has(r, "footer") && ee.setFooter(r.footer, s), _.has(r, "page") && ee.setPage(r.page, s), _.has(r, "stickies") && ee.setStickies(r.stickies, s), _.has(r, "fab") && ee.setFab(r.fab, s), ee.placements.forEach((o) => {
      _.has(r, `panes.${o}`) && ee.setPane(o, _.get(r, `panes.${o}`), s), _.has(r, `windows.${o}`) && ee.setWindow(o, _.get(r, `windows.${o}`), s);
    }), _.has(r, "leftPane") && ee.setPane("left", r.leftPane, s), _.has(r, "rightPane") && ee.setPane("right", r.rightPane, s), _.has(r, "topPane") && ee.setPane("top", r.topPane, s), _.has(r, "bottomPane") && ee.setPane("bottom", r.bottomPane, s), _.has(r, "mode") && ee.setMode(r.mode);
  }
  function t() {
    ee.clearFocus(), ee.clearView(), ee.clearPadding(), ee.clearHeader(), ee.clearFooter(), ee.clearPage(), ee.clearStickies(), ee.clearFab(), ee.placements.forEach((r) => {
      ee.clearPane(r), ee.clearWindow(r);
    }), ee.clearMode();
  }
  function i(r) {
    r && ee.setMode(r);
  }
  const n = {};
  return ee.placements.forEach((r) => {
    n[`set${_.upperFirst(r)}Pane`] = (s, o) => {
      ee.setPane(r, s, o);
    }, n[`set${_.upperFirst(r)}PaneMode`] = (s) => {
      ee.setPaneMode(r, s);
    }, n[`set${_.upperFirst(r)}PaneFilter`] = (s) => {
      ee.setPaneFilter(r, s);
    }, n[`set${_.upperFirst(r)}PaneVisible`] = (s) => {
      ee.setPaneVisible(r, s);
    }, n[`set${_.upperFirst(r)}PaneOpener`] = (s) => {
      ee.setPaneOpener(r, s);
    }, n[`clear${_.upperFirst(r)}Pane`] = () => {
      ee.clearPane(r);
    };
  }), {
    Layout: ee,
    configureLayout: e,
    clearLayout: t,
    setLayoutMode: i,
    ...n
  };
}
function Ay() {
  const e = G.getService("messages");
  async function t(i, n) {
    return e.create(i, { query: n });
  }
  return {
    createMessage: t
  };
}
function Oy(e = { updateTimeout: 5e3 }) {
  const t = qr(), i = "install";
  function n() {
    const s = me.buildMode !== "pwa", o = window.matchMedia("(display-mode: standalone)").matches, l = a.get(It, "within.iframe", !1);
    s || o || l || Xe.get(i, !0) && (yn && nu(), t.platform.is.ios && ru(), t.platform.is.firefox && t.platform.is.desktop && su());
  }
  function r(s) {
    s.waiting.addEventListener("statechange", (o) => {
      o.target.state === "activated" && window.location.reload();
    }), t.notify({
      message: Y.t("composables.pwa.UPDATE_MESSAGE"),
      type: "info",
      html: !0,
      timeout: e.updateTimeout,
      spinner: !0
    }), setTimeout(() => {
      s.waiting.postMessage({ type: "SKIP_WAITING" });
    }, e.updateTimeout);
  }
  return Vt(() => {
    ne.on("pwa-updated", r);
  }), je(() => {
    ne.off("pwa-updated", r);
  }), {
    installPwa: n
  };
}
let vn = [];
function By(e, t, i) {
  if (t.path.startsWith("/oauth/")) return !0;
  if (a.get(t, "meta.authenticated") && a.get(t, "meta.unauthenticated") || a.get(t, "meta.public"))
    return t.path === "/" ? "home" : !0;
  if (a.get(t, "meta.authenticated"))
    return e ? !0 : "login";
  if (a.get(t, "meta.unauthenticated"))
    return e ? "home" : t.path === "/" ? "login" : !0;
}
function Ry(e, t, i) {
  if (a.has(t, "meta.can")) {
    if (!e) return "login";
    let n = a.get(t, "meta.can");
    return n = n.map((r) => {
      if (typeof r == "string" && r.startsWith(":")) {
        const s = r.substring(1);
        return a.get(t, `query.${s}`, a.get(t, `params.${s}`));
      } else
        return r;
    }), G.can(...n, e) || a.get(t, "meta.redirect", "home");
  } else return !0;
}
function $y(e, t, i) {
  const n = a.get(t, "matched", []), r = n[n.length - 1];
  return !(r.name === "not-found" || r.name === "index");
}
function bn(e, t, i) {
  const n = j.get("user");
  for (const r of vn) {
    const s = r(n, e, t);
    if (typeof s == "string")
      return I.debug("[KDK] Navigation guard would redirect to route " + s), typeof i == "function" ? i({ name: s }) : s;
    if (!s)
      return I.debug("[KDK] Navigation aborted by guard"), typeof i == "function" ? i(!1) : !1;
  }
  return I.debug("[KDK] Navigation guards passed"), typeof i == "function" ? i() : !0;
}
bn.registerGuard = function(e) {
  vn.includes(e) || vn.push(e);
};
bn.unregisterGuard = function(e) {
  vn = vn.filter((t) => t !== e);
};
function Iy(e = {}) {
  const t = "disconnect-dialog", i = "reconnect-dialog", n = Hs(), r = Ws(), s = qr(), o = ue(!1);
  let l = null, c = null, u = !1;
  const d = j.getRef("user");
  function f() {
    return "redirect";
  }
  async function m() {
    let S = bn(r);
    if (typeof e.redirect == "function" && (S = await e.redirect(r, S, d.value)), typeof S == "string")
      if (S === "login")
        r.path !== "/" && Xe.set(f(), a.pick(r, ["name", "query", "params"])), await n.push({ name: "login" });
      else {
        const A = Xe.get(f());
        A ? (Xe.clear(f()), await n.push(A)) : await n.push({ name: S });
      }
    else
      Xe.clear(f()), typeof S == "object" ? await n.push(S) : S || await n.push({ name: d.value ? "home" : "login" });
    o.value || (n && n.beforeEach(bn), o.value = !0);
  }
  function g() {
    if (c && (c.hide(), c = null), !l && !u) {
      if (Be.hide(), !Xe.get(t, !0)) {
        l = !0;
        return;
      }
      l = s.dialog({
        title: Y.t("composables.session.ALERT"),
        message: Y.t("composables.session.DISCONNECT"),
        html: !0,
        persistent: !0,
        cancel: {
          id: "ignore-button",
          label: Y.t("composables.session.IGNORE"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "close-button",
          label: Y.t("CLOSE"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        l = null, u = !1;
      }).onCancel(() => {
        l = null, u = !0;
      });
    }
  }
  function v() {
    if (l && (typeof l.hide == "function" && l.hide(), l = null), u = !1, !c) {
      if (!Xe.get(i, !0)) return;
      c = s.dialog({
        title: Y.t("composables.session.INFORMATION"),
        message: Y.t("composables.session.RECONNECT"),
        html: !0,
        cancel: {
          id: "ignore-button",
          label: Y.t("composables.session.IGNORE"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "update-button",
          label: Y.t("composables.session.RELOAD"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        window.location.reload();
      }).onCancel(() => {
        c = null;
      });
    }
  }
  function x() {
    s.dialog({
      title: Y.t("composables.session.ALERT"),
      message: Y.t("composables.session.REFUSED"),
      html: !0,
      ok: {
        label: Y.t("composables.session.RETRY"),
        flat: !0
      },
      position: "bottom"
    }).onOk(() => window.location.reload());
  }
  return Vt(async () => {
    G.socket && (G.socket.io.on("reconnect_error", g), G.socket.io.on("reconnect", v), G.socket.on("rate-limit", x)), ne.on("user-abilities-changed", m), G.on("logout", () => {
      n.push({ name: "logout" });
    });
    try {
      await mu();
    } catch {
      await m();
    }
  }), je(() => {
    G.socket && (G.socket.off("reconnect_error", g), G.socket.off("reconnect", v), G.socket.off("rate-limit", x)), ne.off("user-abilities-changed", m);
  }), {
    User: d,
    redirect: m,
    isInitialized: o,
    onReconnectError: g,
    onReconnect: v,
    onRateLimit: x
  };
}
const Ia = Dt();
function zy() {
  const e = ue(null), t = ue(null);
  async function i(r, s) {
    if (typeof r == "string") {
      I.trace("[KDK] Loading schema ", r);
      const o = await import(`@schemas/${r}.json`);
      t.value = a.cloneDeep(o.default);
    } else
      I.trace("[KDK] setting schema ", r.$id), t.value = a.cloneDeep(r);
    if (s) {
      let o = s;
      typeof s == "string" && (o = a.split(s, ",")), I.trace("[KDK] Filtering schema with ", o), a.forOwn(t.value.properties, (l, c) => {
        o.includes(c) || delete t.value.properties[c];
      }), t.value.$id += o.join(), t.value.required = a.intersection(t.value.required, o);
    }
    I.trace("[KDK] Compiling schema ", t.value.$id), e.value = Qs.register(t.value);
  }
  function n(r) {
    if (!e.value) {
      I.error("[KDK] schema 'validator' not instantiated");
      return;
    }
    const s = e.value(r);
    return s || Vo[Ia] && Vo[Ia](e.value.errors), { isValid: s, errors: e.value.errors };
  }
  return {
    schema: gi(t),
    compile: i,
    validate: n
  };
}
ue(null);
function Ny(e = {}) {
  const t = qr(), i = a.get(e, "dense", "sm"), n = a.get(e, "wide", "sm"), r = W(() => t.screen.lt[i]), s = W(() => t.screen.gt[n]), o = W(() => t.screen.width >= t.screen.height ? "landscape" : "portrait");
  return {
    Screen: gi(t.screen),
    dense: r,
    wide: s,
    orientation: o,
    Fullscreen: gi(lu),
    toggleFullscreen: cu,
    lockOrientation: uu
  };
}
const nn = ue({
  client: {
    number: a.get(me, "version"),
    buildNumber: a.get(me, "buildNumber")
  },
  api: {
    number: void 0,
    buildNumber: void 0
  },
  flavor: a.get(me, "flavor")
});
let za = !1;
function qy() {
  const e = W(() => {
    const i = nn.value.client;
    let n = i.number;
    return i.buildNumber && (n += ` (${i.buildNumber})`), n;
  }), t = W(() => {
    const i = nn.value.api;
    let n = i.number;
    return i.buildNumber && (n += ` (${i.buildNumber})`), n;
  });
  return za || (za = !0, nn.value.api.number = ur.get("version"), nn.value.api.buildNumber = ur.get("buildNumber")), {
    Version: gi(nn),
    clientVersionName: e,
    apiVersionName: t
  };
}
const jy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActivity: Lu,
  useCollection: My,
  useCollectionCounter: Cy,
  useCollectionFilter: Ty,
  useCollectionTimeRange: Py,
  useContext: ky,
  useCurrentActivity: ni,
  useErrors: Fy,
  useLayout: Dy,
  useMessages: Ay,
  usePwa: Oy,
  useSchema: zy,
  useScreen: Ny,
  useSelection: po,
  useSession: Iy,
  useStore: Ft,
  useVersion: qy
}, Symbol.toStringTag, { value: "Module" }));
function Uy(e) {
  return {
    methods: {
      getAppName() {
        return me.appName;
      },
      configurePadding() {
        a.has(this.activityOptions, "padding") && ee.setPadding(a.get(this.activityOptions, "padding"));
      },
      clearPadding() {
        ee.setPadding(!0);
      },
      configureHeader() {
        a.has(this.activityOptions, "header") && ee.setHeader(a.get(this.activityOptions, "header"), this);
      },
      clearHeader() {
        ee.setHeader(null);
      },
      configureFooter() {
        a.has(this.activityOptions, "footer") && ee.setFooter(a.get(this.activityOptions, "footer"), this);
      },
      clearFooter() {
        ee.setFooter(null);
      },
      getTopPane() {
        return ee.getPane("top");
      },
      getTopPaneMode() {
        return ee.getPane("top").mode;
      },
      isTopPaneVisible() {
        return ee.getPane("top").visible;
      },
      setTopPane(t, i, n) {
        ee.setPane("top", { content: t, mode: i, filter: n }, this);
      },
      setTopPaneMode(t) {
        ee.setPaneMode("top", t);
      },
      setTopPaneVisible(t) {
        ee.setPaneVisible("top", t);
      },
      configureTopPane() {
        a.has(this.activityOptions, "topPane") && ee.setPane("top", a.get(this.activityOptions, "topPane"), this);
      },
      clearTopPane() {
        ee.setPane("top", null);
      },
      getLeftPane() {
        return ee.getPane("left");
      },
      getLeftPaneMode() {
        return ee.getPane("left").mode;
      },
      isLeftPaneVisible() {
        return ee.getPane("left").visible;
      },
      setLeftPane(t, i, n) {
        ee.setPane("left", { content: t, mode: i, filter: n }, this);
      },
      setLeftPaneMode(t) {
        ee.setPaneMode("left", t);
      },
      setLeftPaneVisible(t) {
        ee.setPaneVisible("left", t);
      },
      configureLeftPane() {
        a.has(this.activityOptions, "leftPane") && ee.setPane("left", a.get(this.activityOptions, "leftPane"), this);
      },
      clearLeftPane() {
        ee.setPane("left", null);
      },
      getBottomPane() {
        return ee.getPane("bottom");
      },
      getBottomPaneMode() {
        return ee.getPane("bottom").mode;
      },
      isBottomPaneVisible() {
        return ee.getPane("bottom").visible;
      },
      setBottomPane(t, i, n) {
        ee.setPane("bottom", { content: t, mode: i, filter: n }, this);
      },
      setBottomPaneMode(t) {
        ee.setPaneMode("bottom", t);
      },
      setBottomPaneVisible(t) {
        ee.setPaneMode("bottom", t);
      },
      configureBottomPane() {
        a.has(this.activityOptions, "bottomPane") && ee.setPane("bottom", a.get(this.activityOptions, "bottomPane"), this);
      },
      clearBottomPane() {
        ee.setPane("bottom", null);
      },
      getRightPane() {
        return ee.getPane("right");
      },
      getRightPaneMode() {
        return this.getRightPane().mode;
      },
      isRightPaneVisible() {
        return this.getRightPane().visible;
      },
      setRightPane(t, i, n) {
        ee.setPane("right", { content: t, mode: i, filter: n }, this);
      },
      setRightPaneMode(t) {
        ee.setPaneMode("right", t);
      },
      setRightPaneVisible(t) {
        ee.setPaneMode("right", t);
      },
      configureRightPane() {
        a.has(this.activityOptions, "rightPane") && ee.setPane("right", a.get(this.activityOptions, "rightPane"), this);
      },
      clearRightPane() {
        ee.setPane("right", null);
      },
      getPage() {
        return ee.getPage();
      },
      setPage(t, i, n, r) {
        ee.setPage({ content: t, mode: i, filter: n, sticky: r }, this);
      },
      setPageMode(t) {
        ee.setPageMode(t);
      },
      configurePage() {
        a.has(this.activityOptions, "page") && ee.setPage(a.get(this.activityOptions, "page"), this);
      },
      clearPage() {
        ee.setPage(null);
      },
      getStickies() {
        return ee.getPage();
      },
      setStickies(t, i, n, r) {
        ee.setStickies({ content: t, mode: i, filter: n, sticky: r }, this);
      },
      setStickiesMode(t) {
        ee.setStickiesMode(t);
      },
      configureStickies() {
        a.has(this.activityOptions, "stickies") && ee.setStickies(a.get(this.activityOptions, "stickies"), this);
      },
      clearStickies() {
        ee.clearStickies();
      },
      getFab() {
        return ee.getFab();
      },
      setFab(t, i, n) {
        ee.setFab({ content: t, mode: i, filter: n }, this);
      },
      configureFab() {
        a.has(this.activityOptions, "fab") && ee.setFab(a.get(this.activityOptions, "fab"), this);
      },
      clearFab() {
        ee.setFab(null);
      },
      configureWindows() {
        if (!a.has(this.activityOptions, "windows")) return;
        const t = a.get(this.activityOptions, "windows", null);
        a.forOwn(t, (i, n) => {
          ee.setWindow(n, i, this);
        });
      },
      clearWindows() {
        const t = a.get(this.activityOptions, "windows", null);
        a.forOwn(t, (i, n) => {
          ee.setWindow(n, null);
        });
      },
      openWindow(t) {
        ee.setWindowVisible(t, !0);
      },
      closeWindow(t) {
        ee.setWindowVisible(t, !1);
      },
      findWindow(t) {
        return ee.findWindow(t);
      },
      isWidgetWindowVisible(t) {
        const { window: i } = this.findWindow(t);
        return i && i.visible;
      },
      openWidget(t) {
        ee.openWidget(t);
      },
      closeWidget(t) {
        ee.closeWidget(t);
      },
      clearFocus() {
        ee.clearFocus();
      },
      clearMode() {
        ee.clearMode();
      },
      clearActivity() {
        this.clearPadding(), this.clearFocus(), this.clearHeader(), this.clearFooter(), this.clearTopPane(), this.clearBottomPane(), this.clearLeftPane(), this.clearRightPane(), this.clearPage(), this.clearStickies(), this.clearFab(), this.clearWindows(), this.clearMode();
      },
      configureActivity() {
        this.configurePadding(), this.configureHeader(), this.configureFooter(), this.configureTopPane(), this.configureLeftPane(), this.configureBottomPane(), this.configureRightPane(), this.configurePage(), this.configureStickies(), this.configureFab(), this.configureWindows();
      },
      goBack() {
        this.$router.back();
      },
      refresh() {
        window.location.reload();
      },
      launchTour(t) {
        if (!t) {
          let n = this.$route.name;
          a.has(this.$route, "params.page") && (n += "/" + a.get(this.$route, "params.page")), t = n;
        }
        j.patch("tours.current", { name: t });
      }
    },
    beforeCreate() {
      this.activityName = e || a.camelCase(this.$options.name), this.activityOptions = me[this.activityName];
    },
    mounted() {
      this.configureActivity(), ne.on("user-abilities-changed", this.configureActivity);
    },
    beforeUnmount() {
      ne.off("user-abilities-changed", this.configureActivity), this.clearActivity();
    }
  };
}
const Vy = {
  emits: ["applied"],
  props: {
    baseObject: {
      type: Object,
      default: () => {
      }
    },
    baseQuery: {
      type: Object,
      default: () => {
      }
    },
    schemaName: {
      type: String,
      default: void 0
    },
    perspective: {
      type: String,
      default: ""
    },
    // Indicates if the stored object in-memory is only the perspective part (default)
    // or the full structure, ie { perspective: { xxx } }
    // Note: the full structure is always retrieved/sent from/to the service anyway but sometimes
    // it is easier to manipulate a full-object and edit a nested property seen as a perspective on the front side
    perspectiveAsObject: {
      type: Boolean,
      default: !0
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    editorTitle() {
      if (this.getSchema()) {
        const e = this.getSchema().title, t = a.get(this.getObject(), "name");
        return Y.tie(e, { name: t, interpolation: { escapeValue: !1 } });
      }
      return "";
    },
    editorMode() {
      return this.objectId ? "update" : "create";
    },
    applyButton() {
      return this.editorMode === "update" ? this.$t("UPDATE") : this.$t("CREATE");
    }
  },
  data() {
    return {
      isFormReady: !1,
      applyInProgress: !1
    };
  },
  methods: {
    getBaseObject() {
      const e = {}, t = this.getObject() || this.baseObject;
      return this.perspective !== "" ? (this.perspectiveAsObject ? Object.assign(e, a.get(t, this.perspective)) : a.set(e, this.perspective, a.get(t, this.perspective)), t._id && (e._id = t._id)) : Object.assign(e, t), e;
    },
    getBaseQuery() {
      const e = {};
      return Object.assign(e, this.baseQuery), this.editorMode === "update" && this.perspective && this.perspectiveAsObject && Object.assign(e, { $select: ["_id", this.perspective] }), e;
    },
    getSchemaName() {
      if (this.schemaName) return this.schemaName;
      let e = a.get(this.$route, "meta.schemaName");
      return e || (e = this.service + (this.objectId ? ".update" : ".create"), this.perspective && (e += "-" + this.perspective), e);
    },
    onFormReferenceCreated(e) {
      e && (this.form = e);
    },
    onFormReady() {
      this.isFormReady = !0, this.fillEditor();
    },
    fillEditor() {
      if (!this.isFormReady) throw new Error("Cannot fill the editor with a non-ready form");
      this.getObject() && (this.perspective !== "" ? this.form.fill(a.get(this.getObject(), this.perspective)) : this.form.fill(this.getObject()));
    },
    clearEditor() {
      if (!this.isFormReady) throw new Error("Cannot clear the editor with a non-ready form");
      this.form.clear();
    },
    resetEditor() {
      if (!this.isFormReady) throw new Error("Cannot reset the editor with a non-ready form");
      this.fillEditor();
    },
    async apply() {
      if (!this.getService()) throw new Error("Cannot apply the editor with undefined service");
      if (!this.form) throw new Error("Cannot apply the editor with a non-ready form");
      if (!this.form.validate().isValid) return;
      const e = this.getBaseObject();
      await this.form.apply(e);
      const t = async (n) => {
        await this.form.submitted(n), this.$emit("applied", n);
      }, i = this.getBaseQuery(e);
      this.applyInProgress = !0;
      try {
        if (this.editorMode === "update")
          if (this.perspective !== "") {
            const n = {};
            this.perspectiveAsObject ? a.set(n, this.perspective, a.omit(e, ["_id"])) : a.set(n, this.perspective, a.get(e, this.perspective));
            const r = await this.getService().patch(this.objectId, n, { query: i });
            e._id && (r._id = e._id), t(r);
          } else {
            const n = await this.getService().patch(this.objectId, e, { query: i });
            t(n);
          }
        else if (this.editorMode === "create") {
          const n = await this.getService().create(e, { query: i });
          t(n);
        } else
          I.warn("[KDK] Invalid editor mode");
      } catch (n) {
        return I.error(n), !1;
      }
      return this.applyInProgress = !1, !0;
    },
    async refresh() {
      this.form = null, await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]), this.isFormReady && this.fillEditor();
    }
  }
}, Ky = {
  emits: [
    "item-selected",
    "item-toggled",
    "item-expanded"
  ],
  props: {
    service: {
      type: String,
      required: !0
    },
    item: {
      type: Object,
      required: !0
    },
    actions: {
      type: [Object, Array],
      default: () => null
    },
    filter: {
      type: Object,
      default: () => {
      }
    },
    handlerContext: {
      type: Object,
      default: () => null
    },
    options: {
      type: Object,
      default: function() {
        return {};
      }
    },
    bindActions: {
      type: Boolean,
      default: !0
    }
  },
  watch: {
    // Make configured actions reactive as item actions are built from
    item: function() {
      this.configureActions();
    },
    actions: function() {
      this.configureActions();
    }
  },
  data() {
    return {
      itemActions: null
    };
  },
  computed: {
    name() {
      return a.get(this.item, this.options.nameField || "name", "");
    },
    description() {
      return a.get(this.item, this.options.descriptionField || "description", "");
    },
    avatar() {
      return a.get(this.options, "avatar", !0);
    }
  },
  methods: {
    setActions(e) {
      this.itemActions = this.bindActions ? kn(a.cloneDeep(e), this.handlerContext || this) : e;
    },
    clearActions() {
      this.itemActions = null;
    },
    filteredActions() {
      return this.actions ? Ai(this.actions, this.filter || {}) : [];
    },
    // This method should be overridden in items
    configureActions() {
      const e = this.filteredActions();
      e && e.length > 0 ? this.setActions(e) : this.clearActions();
    },
    onItemToggled(e) {
      this.$emit("item-toggled", this.item, e);
    },
    onItemSelected(e) {
      this.$emit("item-selected", this.item, e);
    },
    onItemExpanded(e) {
      this.$emit("item-expanded", this.item, e);
    },
    canViewItem() {
      return G.can("read", this.service, this.item);
    },
    viewItem() {
      const e = this.$route.fullPath + `/view/${this.item._id}`;
      this.$router.push(e);
    },
    canEditItem() {
      return G.can("update", this.service, this.item);
    },
    editItem(e = void 0, t = void 0) {
      const i = this.$route;
      let n = "edit/" + this.item._id;
      i.path.endsWith("/") || (n = `/${n}`), e && (t ? n += `/${t}` : n += `/${e}`), this.$router.push({
        path: i.path + n,
        params: i.params,
        query: i.query
      });
    },
    canRemoveItem() {
      return G.can("remove", this.service, this.item);
    },
    removeItem(e, t = "name") {
      if (e === "confirm" || e === "input") {
        const i = a.get(this.item, t), n = {
          type: "text",
          model: "",
          isValid: (r) => r === i
        };
        xi.create({
          title: this.$t("mixins.baseItem.REMOVE_ITEM_TITLE", { name: i }),
          message: e === "input" ? this.$t("mixins.baseItem.REMOVE_ITEM_MESSAGE") : "",
          html: !0,
          prompt: e === "input" ? n : void 0,
          persistent: !0,
          ok: {
            label: this.$t("YES"),
            flat: !0
          },
          cancel: {
            label: this.$t("NO"),
            flat: !0
          }
        }).onOk(() => {
          G.getService(this.service).remove(this.item._id);
        });
      } else
        G.getService(this.service).remove(this.item._id);
    },
    exportItem() {
      const e = this.name, t = e + ".json";
      yr(t, JSON.stringify(this.item)) ? et.create({ type: "positive", message: this.$t("mixins.baseItem.ITEM_EXPORTED", { name: e, file: t }) }) : et.create({ type: "negative", message: this.$t("mixins.baseItme.CANNOT_EXPORT_ITEM") });
    }
  },
  created() {
    this.configureActions(), ne.on("user-abilities-changed", this.configureActions);
  },
  beforeUnmount() {
    ne.off("user-abilities-changed", this.configureActions);
  }
};
function Gy(e) {
  const t = Object.assign({ noopener: !0 }, e), i = [];
  for (const n in t) {
    const r = t[n];
    r === !0 ? i.push(n) : (gm(r) || typeof r == "string" && r !== "") && i.push(n + "=" + r);
  }
  return i.join(",");
}
function Na(e, t, i) {
  let n = window.open;
  if (pi.is.cordova === !0) {
    if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0)
      n = cordova.InAppBrowser.open;
    else if (navigator !== void 0 && navigator.app !== void 0)
      return navigator.app.loadUrl(e, {
        openExternal: !0
      });
  }
  const r = n(e, "_blank", Gy(i));
  if (r)
    return pi.is.desktop && r.focus(), r;
}
const Hy = (e, t, i) => {
  if (pi.is.ios === !0 && window.SafariViewController !== void 0) {
    window.SafariViewController.isAvailable((n) => {
      n ? window.SafariViewController.show(
        { url: e },
        Ri,
        t
      ) : Na(e, t, i);
    });
    return;
  }
  return Na(e, t, i);
}, Wy = {
  props: {
    values: {
      type: Object,
      default: () => null
    },
    properties: {
      type: Object,
      required: !0
    },
    required: {
      type: Boolean,
      default: !1
    },
    readOnly: {
      type: Boolean,
      default: !1
    },
    dense: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    label() {
      const e = a.get(this.properties, "description", "");
      return Y.tie(a.get(this.properties.field, "label", e));
    },
    hasHelper() {
      return !a.isEmpty(a.get(this.properties.field, "helper", {}));
    },
    helperLabel() {
      return a.get(this.properties.field.helper, "label", null);
    },
    helperIcon() {
      return a.get(this.properties.field.helper, "icon", void 0);
    },
    helperTooltip() {
      return a.get(this.properties.field.helper, "tooltip", "");
    },
    helperUrl() {
      return a.get(this.properties.field.helper, "url", null);
    },
    helperDialog() {
      return a.get(this.properties.field.helper, "dialog", null);
    },
    helperContext() {
      return a.get(this.properties.field.helper, "context", null);
    },
    hasError() {
      return !a.isEmpty(this.error);
    },
    errorLabel() {
      let e = a.get(this.properties.field, "errorLabel", "");
      return e || (e = this.error), Y.tie(e);
    },
    disabled() {
      return a.get(this.properties.field, "disabled", !1);
    }
  },
  data() {
    return {
      // The model to used for data binding with the field
      model: this.emptyModel(),
      // The error message
      error: ""
    };
  },
  watch: {
    values: function() {
      this.values ? this.updateValue(a.get(this.values, this.properties.name)) : this.clear();
    }
  },
  methods: {
    updateValue(e) {
      a.isNil(e) ? this.clear() : this.fill(e);
    },
    emptyModel() {
      return null;
    },
    isEmpty() {
      return a.isEqual(this.model, this.emptyModel());
    },
    value() {
      return this.model;
    },
    fill(e) {
      this.model = e, this.error = "";
    },
    clear() {
      this.fill(a.get(this.properties, "default", this.emptyModel()));
    },
    validate() {
      this.error = "";
    },
    invalidate(e) {
      this.error = e;
    },
    async onChanged() {
      const e = a.get(this.properties, "nullable", !1);
      a.isNil(this.model) && !e && this.clear(), await this.$nextTick(), this.$emit("field-changed", this.properties.name, this.model);
    },
    apply(e, t) {
      a.set(e, t, this.value());
    },
    submitted(e, t) {
    },
    onHelperDialogConfirmed(e) {
      e.url && Hy(e.url);
    }
  },
  created() {
    this.values && this.updateValue(a.get(this.values, this.properties.name));
  }
}, Zy = {
  props: {
    perspective: {
      type: String,
      default: ""
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    viewerTitle() {
      if (this.getSchema()) {
        const e = this.getSchema().title;
        return this.$t(e, { object: this.getObject() });
      }
      return "";
    }
  },
  methods: {
    getSchemaName() {
      let e = this.service + ".get";
      return this.perspective && (e += "-" + this.perspective), e;
    },
    async refresh() {
      await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]);
    }
  }
}, Qy = {
  emits: ["opened", "closed"],
  props: {
    routerMode: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      isModalOpened: !1,
      isModalMaximized: !1
    };
  },
  methods: {
    openModal(e = !1) {
      this.isModalMaximized = e, this.isModalOpened = !0, this.$emit("opened");
    },
    closeModal() {
      this.isModalOpened = !1, this.routerMode && this.$router.push(this.previousRoute), this.$emit("closed");
    }
  },
  created() {
    this.routerMode && (this.previousRoute = this.$router.options.history.state.back, this.openModal());
  }
}, Jy = {
  props: {
    objectId: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      object: null
    };
  },
  methods: {
    getObject() {
      return this.object;
    },
    getObjectId() {
      return this.object ? this.object._id : "";
    },
    loadObject() {
      if (!this.objectId)
        return this.object = null, Promise.resolve(null);
      const e = this.getObjectId() !== this.objectId;
      return (!this.objectPromise || e) && (this.objectPromise = Nr((t, i) => {
        this.getService().get(this.objectId).then((n) => {
          this.object = n, t(n);
        }).catch((n) => {
          i(n);
        });
      })), this.objectPromise;
    }
  }
}, Yy = {
  props: {
    schemaJson: {
      type: String,
      default: ""
    },
    schemaFunction: {
      type: Function,
      default: null
    },
    schemaProperties: {
      type: [String, Array],
      default: () => []
    }
  },
  data() {
    return {
      schema: null
    };
  },
  methods: {
    getSchema() {
      return this.schema;
    },
    getSchemaId() {
      return a.get(this.schema, "$id", "");
    },
    filterSchema() {
      const e = this.schema.properties;
      let t = typeof this.schemaProperties == "string" ? a.split(this.schemaProperties, ",") : this.schemaProperties;
      typeof t == "string" && (t = [t]), t.length > 0 && (Object.keys(e).forEach((i) => {
        t.includes(i) || delete e[i];
      }), this.schema.$id += t.join(), this.schema.required = a.intersection(this.schema.required, t));
    },
    async loadSchemaFromResource(e) {
      try {
        return this.schema = await wu(e), this.schema = a.cloneDeep(this.schema), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    async loadSchemaFromJson(e) {
      try {
        return this.schema = JSON.parse(e), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    async loadSchemaFromFunction(e) {
      try {
        return this.schema = await e(), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    loadSchema(e) {
      const t = e && !this.getSchemaId().includes(e + ".json");
      return (!this.schemaPromise || t) && (this.schemaPromise = Nr(this.schemaJson ? this.loadSchemaFromJson(this.schemaJson) : this.schemaFunction ? this.loadSchemaFromFunction(this.schemaFunction) : this.loadSchemaFromResource(e))), this.schemaPromise;
    }
  }
}, Xy = {
  props: {
    service: {
      type: String,
      default: ""
    }
  },
  methods: {
    getService() {
      const e = G.getService(this.service);
      if (!e)
        throw new Error("Cannot retrieve target service " + this.service);
      return e;
    }
  }
}, ev = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  baseActivity: Uy,
  baseEditor: Vy,
  baseField: Wy,
  baseItem: Ky,
  baseModal: Qy,
  baseViewer: Zy,
  objectProxy: Jy,
  schemaProxy: Yy,
  service: Xy
}, Symbol.toStringTag, { value: "Module" })), tv = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`[KDK] reading JSON file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let o = s.result;
        try {
          o = JSON.parse(o);
        } catch (l) {
          I.debug(l), r(new Error(Y.t("errors.INVALID_JSON_FILE", { file: i }), { errors: l }));
        }
        n(o);
      }, s.onerror = (o) => {
        I.debug(o), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i }), { errors: o }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, iv = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`[KDK] reading CSV file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let o = s.result;
        const l = Object.assign({ skipEmptyLines: !0 }, t);
        if (o = Zf.parse(o, l), o.errors.length > 0) {
          I.debug(o.errors), r(new Error(Y.t("errors.INVALID_CSV_FILE", { file: i.name }), { errors: o.errors }));
          return;
        }
        n(o.data);
      }, s.onerror = (o) => {
        I.debug(o), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: o }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, nv = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`[KDK] reading Blob file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        const l = s.result;
        if (!l) {
          r(new Error(Y.t("errors.INVALID_BLOB_FILE", { file: i.name })));
          return;
        }
        n(l);
      }, s.onerror = (l) => {
        I.debug(l), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: l }));
      };
      const o = a.get(t, "type", "arrayBuffer");
      o === "dataUrl" ? s.readAsDataURL(i) : (o !== "arrayBuffer" && I.error(`[KDK] Undefined expected type ${o}. Read as Array buffer.`), s.readAsArrayBuffer(i));
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, rv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BLOBReader: nv,
  CSVReader: iv,
  JSONReader: tv
}, Symbol.toStringTag, { value: "Module" })), sv = {
  async query(e, t) {
    const i = [];
    Array.isArray(e) || (e = [e]);
    const n = a.map(e, (s) => {
      const o = G.getService(s.service, s.context), l = Object.assign({}, s.baseQuery);
      return l[s.field] = { $search: t }, o.find({ query: l });
    }), r = await Promise.all(n);
    for (let s = 0; s < r.length; s++) {
      const o = r[s], l = e[s];
      o.total > 0 && o.data.forEach((c) => {
        c.service = l.service, c.context = l.context, c.field = l.field;
        const u = go(c);
        a.isEmpty(u) && a.has(l, "icon") && (c.icon = l.icon, vu(c)), i.push(c);
      });
    }
    return i;
  }
};
async function xu() {
  const e = this;
  I.debug("[KDK] Initializing Core module..."), j.set("kdk", { core: { initialized: !1 }, map: { initialized: !1 } }), Xe.initialize(), Se.initialize(), await It.initialize(), await ur.initialize(), tc.initialize(), Lc.initialize(), Kl.initialize(), be.initialize(), Me.initialize(), nt.initialize(), e.configure(Uc), ee.initialize(), Ec.initialize(), Cc.initialize(), Tc.initialize(), Nc.initialize(a.get(me, "exporter")), Qs.initialize(a.get(me, "schema")), gu(), a.forEach(a.get(me, "readers.core", []), (t) => {
    I.debug(`[KDK] Registering reader ${t.reader} for [${t.mimeTypes}] mime types`), yi.register(t.mimeTypes, rv[t.reader]);
  }), j.set("kdk.core.initialized", !0), I.debug("[KDK] Core module initialized");
}
const M_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Broadcaster: tc,
  Capabilities: ur,
  Context: nt,
  Document: Tc,
  Events: ne,
  Exporter: Nc,
  Filter: Ec,
  Layout: ee,
  LocalCache: Se,
  LocalStorage: Xe,
  Platform: It,
  Reader: yi,
  Schema: Qs,
  Search: sv,
  Sorter: Cc,
  Storage: Lc,
  Store: j,
  TemplateContext: ro,
  Theme: Kl,
  Time: be,
  Units: Me,
  addQueryParameter: Yl,
  get api() {
    return G;
  },
  authenticationGuard: By,
  beforeGuard: bn,
  buildEncodedUrl: Xl,
  buildUrl: Tn,
  composables: jy,
  createClient: eo,
  default: xu,
  directives: Ey,
  errors: Mh,
  hooks: Hh,
  i18n: Y,
  initializeApi: Wh,
  makeDiacriticPattern: jh,
  makeServiceSnapshot: Jl,
  mixins: ev,
  permissions: Nh,
  permissionsGuard: Ry,
  publicRouteGuard: $y,
  services: Uc,
  utils: Ly
}, Symbol.toStringTag, { value: "Module" }));
var He = 63710088e-1, Su = {
  centimeters: He * 100,
  centimetres: He * 100,
  degrees: He / 111325,
  feet: He * 3.28084,
  inches: He * 39.37,
  kilometers: He / 1e3,
  kilometres: He / 1e3,
  meters: He,
  metres: He,
  miles: He / 1609.344,
  millimeters: He * 1e3,
  millimetres: He * 1e3,
  nauticalmiles: He / 1852,
  radians: 1,
  yards: He * 1.0936
};
function jt(e, t, i) {
  i === void 0 && (i = {});
  var n = { type: "Feature" };
  return (i.id === 0 || i.id) && (n.id = i.id), i.bbox && (n.bbox = i.bbox), n.properties = t || {}, n.geometry = e, n;
}
function mt(e, t, i) {
  if (i === void 0 && (i = {}), !e)
    throw new Error("coordinates is required");
  if (!Array.isArray(e))
    throw new Error("coordinates must be an Array");
  if (e.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!qa(e[0]) || !qa(e[1]))
    throw new Error("coordinates must contain numbers");
  var n = {
    type: "Point",
    coordinates: e
  };
  return jt(n, t, i);
}
function yo(e, t, i) {
  i === void 0 && (i = {});
  for (var n = 0, r = e; n < r.length; n++) {
    var s = r[n];
    if (s.length < 4)
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var o = 0; o < s[s.length - 1].length; o++)
      if (s[s.length - 1][o] !== s[0][o])
        throw new Error("First and last Position are not equivalent.");
  }
  var l = {
    type: "Polygon",
    coordinates: e
  };
  return jt(l, t, i);
}
function Eu(e, t, i) {
  if (i === void 0 && (i = {}), e.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var n = {
    type: "LineString",
    coordinates: e
  };
  return jt(n, t, i);
}
function ut(e, t) {
  t === void 0 && (t = {});
  var i = { type: "FeatureCollection" };
  return t.id && (i.id = t.id), t.bbox && (i.bbox = t.bbox), i.features = e, i;
}
function ov(e, t, i) {
  i === void 0 && (i = {});
  var n = {
    type: "MultiLineString",
    coordinates: e
  };
  return jt(n, t, i);
}
function av(e, t) {
  t === void 0 && (t = "kilometers");
  var i = Su[t];
  if (!i)
    throw new Error(t + " units is invalid");
  return e * i;
}
function Cu(e, t) {
  t === void 0 && (t = "kilometers");
  var i = Su[t];
  if (!i)
    throw new Error(t + " units is invalid");
  return e / i;
}
function br(e) {
  var t = e % (2 * Math.PI);
  return t * 180 / Math.PI;
}
function gt(e) {
  var t = e % 360;
  return t * Math.PI / 180;
}
function Tu(e, t, i) {
  if (t === void 0 && (t = "kilometers"), i === void 0 && (i = "kilometers"), !(e >= 0))
    throw new Error("length must be a positive number");
  return av(Cu(e, t), i);
}
function qa(e) {
  return !isNaN(e) && e !== null && !Array.isArray(e);
}
function vo(e) {
  return !!e && e.constructor === Object;
}
function vi(e, t, i) {
  if (e !== null)
    for (var n, r, s, o, l, c, u, d = 0, f = 0, m, g = e.type, v = g === "FeatureCollection", x = g === "Feature", S = v ? e.features.length : 1, A = 0; A < S; A++) {
      u = v ? e.features[A].geometry : x ? e.geometry : e, m = u ? u.type === "GeometryCollection" : !1, l = m ? u.geometries.length : 1;
      for (var p = 0; p < l; p++) {
        var y = 0, w = 0;
        if (o = m ? u.geometries[p] : u, o !== null) {
          c = o.coordinates;
          var C = o.type;
          switch (d = i && (C === "Polygon" || C === "MultiPolygon") ? 1 : 0, C) {
            case null:
              break;
            case "Point":
              if (t(
                c,
                f,
                A,
                y,
                w
              ) === !1)
                return !1;
              f++, y++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < c.length; n++) {
                if (t(
                  c[n],
                  f,
                  A,
                  y,
                  w
                ) === !1)
                  return !1;
                f++, C === "MultiPoint" && y++;
              }
              C === "LineString" && y++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < c.length; n++) {
                for (r = 0; r < c[n].length - d; r++) {
                  if (t(
                    c[n][r],
                    f,
                    A,
                    y,
                    w
                  ) === !1)
                    return !1;
                  f++;
                }
                C === "MultiLineString" && y++, C === "Polygon" && w++;
              }
              C === "Polygon" && y++;
              break;
            case "MultiPolygon":
              for (n = 0; n < c.length; n++) {
                for (w = 0, r = 0; r < c[n].length; r++) {
                  for (s = 0; s < c[n][r].length - d; s++) {
                    if (t(
                      c[n][r][s],
                      f,
                      A,
                      y,
                      w
                    ) === !1)
                      return !1;
                    f++;
                  }
                  w++;
                }
                y++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (vi(o.geometries[n], t, i) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function bi(e, t) {
  if (e.type === "Feature")
    t(e, 0);
  else if (e.type === "FeatureCollection")
    for (var i = 0; i < e.features.length && t(e.features[i], i) !== !1; i++)
      ;
}
function lv(e, t) {
  var i, n, r, s, o, l, c, u, d, f, m = 0, g = e.type === "FeatureCollection", v = e.type === "Feature", x = g ? e.features.length : 1;
  for (i = 0; i < x; i++) {
    for (l = g ? e.features[i].geometry : v ? e.geometry : e, u = g ? e.features[i].properties : v ? e.properties : {}, d = g ? e.features[i].bbox : v ? e.bbox : void 0, f = g ? e.features[i].id : v ? e.id : void 0, c = l ? l.type === "GeometryCollection" : !1, o = c ? l.geometries.length : 1, r = 0; r < o; r++) {
      if (s = c ? l.geometries[r] : l, s === null) {
        if (t(
          null,
          m,
          u,
          d,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            m,
            u,
            d,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (t(
              s.geometries[n],
              m,
              u,
              d,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    m++;
  }
}
function wn(e, t) {
  lv(e, function(i, n, r, s, o) {
    var l = i === null ? null : i.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          jt(i, r, { bbox: s, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var c;
    switch (l) {
      case "MultiPoint":
        c = "Point";
        break;
      case "MultiLineString":
        c = "LineString";
        break;
      case "MultiPolygon":
        c = "Polygon";
        break;
    }
    for (var u = 0; u < i.coordinates.length; u++) {
      var d = i.coordinates[u], f = {
        type: c,
        coordinates: d
      };
      if (t(jt(f, r), n, u) === !1)
        return !1;
    }
  });
}
function hi(e, t) {
  t === void 0 && (t = {});
  var i = 0, n = 0, r = 0;
  return vi(e, function(s) {
    i += s[0], n += s[1], r++;
  }, !0), mt([i / r, n / r], t.properties);
}
function pt(e) {
  if (!e)
    throw new Error("coord is required");
  if (!Array.isArray(e)) {
    if (e.type === "Feature" && e.geometry !== null && e.geometry.type === "Point")
      return e.geometry.coordinates;
    if (e.type === "Point")
      return e.coordinates;
  }
  if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]))
    return e;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function st(e) {
  if (Array.isArray(e))
    return e;
  if (e.type === "Feature") {
    if (e.geometry !== null)
      return e.geometry.coordinates;
  } else if (e.coordinates)
    return e.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function Yt(e) {
  return e.type === "Feature" ? e.geometry : e;
}
function mi(e, t) {
  return e.type === "FeatureCollection" ? "FeatureCollection" : e.type === "GeometryCollection" ? "GeometryCollection" : e.type === "Feature" && e.geometry !== null ? e.geometry.type : e.type;
}
function cv(e, t, i, n) {
  n === void 0 && (n = {});
  var r = pt(e), s = gt(r[0]), o = gt(r[1]), l = gt(i), c = Cu(t, n.units), u = Math.asin(Math.sin(o) * Math.cos(c) + Math.cos(o) * Math.sin(c) * Math.cos(l)), d = s + Math.atan2(Math.sin(l) * Math.sin(c) * Math.cos(o), Math.cos(c) - Math.sin(o) * Math.sin(u)), f = br(d), m = br(u);
  return mt([f, m], n.properties);
}
function uv(e, t, i) {
  i === void 0 && (i = {});
  for (var n = i.steps || 64, r = i.properties ? i.properties : !Array.isArray(e) && e.type === "Feature" && e.properties ? e.properties : {}, s = [], o = 0; o < n; o++)
    s.push(cv(e, t, o * -360 / n, i).geometry.coordinates);
  return s.push(s[0]), yo([s], r);
}
function Pu(e, t) {
  t === void 0 && (t = {});
  var i = Number(e[0]), n = Number(e[1]), r = Number(e[2]), s = Number(e[3]);
  if (e.length === 6)
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  var o = [i, n], l = [i, s], c = [r, s], u = [r, n];
  return yo([[o, u, c, l, o]], t.properties, { bbox: e, id: t.id });
}
function _n(e, t, i) {
  if (i === void 0 && (i = {}), !e)
    throw new Error("point is required");
  if (!t)
    throw new Error("polygon is required");
  var n = pt(e), r = Yt(t), s = r.type, o = t.bbox, l = r.coordinates;
  if (o && dv(n, o) === !1)
    return !1;
  s === "Polygon" && (l = [l]);
  for (var c = !1, u = 0; u < l.length && !c; u++)
    if (ja(n, l[u][0], i.ignoreBoundary)) {
      for (var d = !1, f = 1; f < l[u].length && !d; )
        ja(n, l[u][f], !i.ignoreBoundary) && (d = !0), f++;
      d || (c = !0);
    }
  return c;
}
function ja(e, t, i) {
  var n = !1;
  t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] && (t = t.slice(0, t.length - 1));
  for (var r = 0, s = t.length - 1; r < t.length; s = r++) {
    var o = t[r][0], l = t[r][1], c = t[s][0], u = t[s][1], d = e[1] * (o - c) + l * (c - e[0]) + u * (e[0] - o) === 0 && (o - e[0]) * (c - e[0]) <= 0 && (l - e[1]) * (u - e[1]) <= 0;
    if (d)
      return !i;
    var f = l > e[1] != u > e[1] && e[0] < (c - o) * (e[1] - l) / (u - l) + o;
    f && (n = !n);
  }
  return n;
}
function dv(e, t) {
  return t[0] <= e[0] && t[1] <= e[1] && t[2] >= e[0] && t[3] >= e[1];
}
function Ua(e) {
  if (!e)
    throw new Error("geojson is required");
  var t = [];
  return wn(e, function(i) {
    fv(i, t);
  }), ut(t);
}
function fv(e, t) {
  var i = [], n = e.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        i = st(n);
        break;
      case "LineString":
        i = [st(n)];
    }
    i.forEach(function(r) {
      var s = hv(r, e.properties);
      s.forEach(function(o) {
        o.id = t.length, t.push(o);
      });
    });
  }
}
function hv(e, t) {
  var i = [];
  return e.reduce(function(n, r) {
    var s = Eu([n, r], t);
    return s.bbox = mv(n, r), i.push(s), r;
  }), i;
}
function mv(e, t) {
  var i = e[0], n = e[1], r = t[0], s = t[1], o = i < r ? i : r, l = n < s ? n : s, c = i > r ? i : r, u = n > s ? n : s;
  return [o, l, c, u];
}
var Va = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gv(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function pv(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var i = function n() {
      var r = !1;
      try {
        r = this instanceof n;
      } catch {
      }
      return r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var r = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(i, n, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), i;
}
var Zn = { exports: {} }, er = { exports: {} }, yv = er.exports, Ka;
function vv() {
  return Ka || (Ka = 1, function(e, t) {
    (function(i, n) {
      e.exports = n();
    })(yv, function() {
      function i(p, y, w, C, P) {
        (function M(z, D, T, F, k) {
          for (; F > T; ) {
            if (F - T > 600) {
              var O = F - T + 1, $ = D - T + 1, X = Math.log(O), te = 0.5 * Math.exp(2 * X / 3), H = 0.5 * Math.sqrt(X * te * (O - te) / O) * ($ - O / 2 < 0 ? -1 : 1), oe = Math.max(T, Math.floor(D - $ * te / O + H)), fe = Math.min(F, Math.floor(D + (O - $) * te / O + H));
              M(z, D, oe, fe, k);
            }
            var ce = z[D], de = T, R = F;
            for (n(z, T, D), k(z[F], ce) > 0 && n(z, T, F); de < R; ) {
              for (n(z, de, R), de++, R--; k(z[de], ce) < 0; ) de++;
              for (; k(z[R], ce) > 0; ) R--;
            }
            k(z[T], ce) === 0 ? n(z, T, R) : n(z, ++R, F), R <= D && (T = R + 1), D <= R && (F = R - 1);
          }
        })(p, y, w || 0, C || p.length - 1, P || r);
      }
      function n(p, y, w) {
        var C = p[y];
        p[y] = p[w], p[w] = C;
      }
      function r(p, y) {
        return p < y ? -1 : p > y ? 1 : 0;
      }
      var s = function(p) {
        p === void 0 && (p = 9), this._maxEntries = Math.max(4, p), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function o(p, y, w) {
        if (!w) return y.indexOf(p);
        for (var C = 0; C < y.length; C++) if (w(p, y[C])) return C;
        return -1;
      }
      function l(p, y) {
        c(p, 0, p.children.length, y, p);
      }
      function c(p, y, w, C, P) {
        P || (P = S(null)), P.minX = 1 / 0, P.minY = 1 / 0, P.maxX = -1 / 0, P.maxY = -1 / 0;
        for (var M = y; M < w; M++) {
          var z = p.children[M];
          u(P, p.leaf ? C(z) : z);
        }
        return P;
      }
      function u(p, y) {
        return p.minX = Math.min(p.minX, y.minX), p.minY = Math.min(p.minY, y.minY), p.maxX = Math.max(p.maxX, y.maxX), p.maxY = Math.max(p.maxY, y.maxY), p;
      }
      function d(p, y) {
        return p.minX - y.minX;
      }
      function f(p, y) {
        return p.minY - y.minY;
      }
      function m(p) {
        return (p.maxX - p.minX) * (p.maxY - p.minY);
      }
      function g(p) {
        return p.maxX - p.minX + (p.maxY - p.minY);
      }
      function v(p, y) {
        return p.minX <= y.minX && p.minY <= y.minY && y.maxX <= p.maxX && y.maxY <= p.maxY;
      }
      function x(p, y) {
        return y.minX <= p.maxX && y.minY <= p.maxY && y.maxX >= p.minX && y.maxY >= p.minY;
      }
      function S(p) {
        return { children: p, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function A(p, y, w, C, P) {
        for (var M = [y, w]; M.length; ) if (!((w = M.pop()) - (y = M.pop()) <= C)) {
          var z = y + Math.ceil((w - y) / C / 2) * C;
          i(p, z, y, w, P), M.push(y, z, z, w);
        }
      }
      return s.prototype.all = function() {
        return this._all(this.data, []);
      }, s.prototype.search = function(p) {
        var y = this.data, w = [];
        if (!x(p, y)) return w;
        for (var C = this.toBBox, P = []; y; ) {
          for (var M = 0; M < y.children.length; M++) {
            var z = y.children[M], D = y.leaf ? C(z) : z;
            x(p, D) && (y.leaf ? w.push(z) : v(p, D) ? this._all(z, w) : P.push(z));
          }
          y = P.pop();
        }
        return w;
      }, s.prototype.collides = function(p) {
        var y = this.data;
        if (!x(p, y)) return !1;
        for (var w = []; y; ) {
          for (var C = 0; C < y.children.length; C++) {
            var P = y.children[C], M = y.leaf ? this.toBBox(P) : P;
            if (x(p, M)) {
              if (y.leaf || v(p, M)) return !0;
              w.push(P);
            }
          }
          y = w.pop();
        }
        return !1;
      }, s.prototype.load = function(p) {
        if (!p || !p.length) return this;
        if (p.length < this._minEntries) {
          for (var y = 0; y < p.length; y++) this.insert(p[y]);
          return this;
        }
        var w = this._build(p.slice(), 0, p.length - 1, 0);
        if (this.data.children.length) if (this.data.height === w.height) this._splitRoot(this.data, w);
        else {
          if (this.data.height < w.height) {
            var C = this.data;
            this.data = w, w = C;
          }
          this._insert(w, this.data.height - w.height - 1, !0);
        }
        else this.data = w;
        return this;
      }, s.prototype.insert = function(p) {
        return p && this._insert(p, this.data.height - 1), this;
      }, s.prototype.clear = function() {
        return this.data = S([]), this;
      }, s.prototype.remove = function(p, y) {
        if (!p) return this;
        for (var w, C, P, M = this.data, z = this.toBBox(p), D = [], T = []; M || D.length; ) {
          if (M || (M = D.pop(), C = D[D.length - 1], w = T.pop(), P = !0), M.leaf) {
            var F = o(p, M.children, y);
            if (F !== -1) return M.children.splice(F, 1), D.push(M), this._condense(D), this;
          }
          P || M.leaf || !v(M, z) ? C ? (w++, M = C.children[w], P = !1) : M = null : (D.push(M), T.push(w), w = 0, C = M, M = M.children[0]);
        }
        return this;
      }, s.prototype.toBBox = function(p) {
        return p;
      }, s.prototype.compareMinX = function(p, y) {
        return p.minX - y.minX;
      }, s.prototype.compareMinY = function(p, y) {
        return p.minY - y.minY;
      }, s.prototype.toJSON = function() {
        return this.data;
      }, s.prototype.fromJSON = function(p) {
        return this.data = p, this;
      }, s.prototype._all = function(p, y) {
        for (var w = []; p; ) p.leaf ? y.push.apply(y, p.children) : w.push.apply(w, p.children), p = w.pop();
        return y;
      }, s.prototype._build = function(p, y, w, C) {
        var P, M = w - y + 1, z = this._maxEntries;
        if (M <= z) return l(P = S(p.slice(y, w + 1)), this.toBBox), P;
        C || (C = Math.ceil(Math.log(M) / Math.log(z)), z = Math.ceil(M / Math.pow(z, C - 1))), (P = S([])).leaf = !1, P.height = C;
        var D = Math.ceil(M / z), T = D * Math.ceil(Math.sqrt(z));
        A(p, y, w, T, this.compareMinX);
        for (var F = y; F <= w; F += T) {
          var k = Math.min(F + T - 1, w);
          A(p, F, k, D, this.compareMinY);
          for (var O = F; O <= k; O += D) {
            var $ = Math.min(O + D - 1, k);
            P.children.push(this._build(p, O, $, C - 1));
          }
        }
        return l(P, this.toBBox), P;
      }, s.prototype._chooseSubtree = function(p, y, w, C) {
        for (; C.push(y), !y.leaf && C.length - 1 !== w; ) {
          for (var P = 1 / 0, M = 1 / 0, z = void 0, D = 0; D < y.children.length; D++) {
            var T = y.children[D], F = m(T), k = (O = p, $ = T, (Math.max($.maxX, O.maxX) - Math.min($.minX, O.minX)) * (Math.max($.maxY, O.maxY) - Math.min($.minY, O.minY)) - F);
            k < M ? (M = k, P = F < P ? F : P, z = T) : k === M && F < P && (P = F, z = T);
          }
          y = z || y.children[0];
        }
        var O, $;
        return y;
      }, s.prototype._insert = function(p, y, w) {
        var C = w ? p : this.toBBox(p), P = [], M = this._chooseSubtree(C, this.data, y, P);
        for (M.children.push(p), u(M, C); y >= 0 && P[y].children.length > this._maxEntries; ) this._split(P, y), y--;
        this._adjustParentBBoxes(C, P, y);
      }, s.prototype._split = function(p, y) {
        var w = p[y], C = w.children.length, P = this._minEntries;
        this._chooseSplitAxis(w, P, C);
        var M = this._chooseSplitIndex(w, P, C), z = S(w.children.splice(M, w.children.length - M));
        z.height = w.height, z.leaf = w.leaf, l(w, this.toBBox), l(z, this.toBBox), y ? p[y - 1].children.push(z) : this._splitRoot(w, z);
      }, s.prototype._splitRoot = function(p, y) {
        this.data = S([p, y]), this.data.height = p.height + 1, this.data.leaf = !1, l(this.data, this.toBBox);
      }, s.prototype._chooseSplitIndex = function(p, y, w) {
        for (var C, P, M, z, D, T, F, k = 1 / 0, O = 1 / 0, $ = y; $ <= w - y; $++) {
          var X = c(p, 0, $, this.toBBox), te = c(p, $, w, this.toBBox), H = (P = X, M = te, z = void 0, D = void 0, T = void 0, F = void 0, z = Math.max(P.minX, M.minX), D = Math.max(P.minY, M.minY), T = Math.min(P.maxX, M.maxX), F = Math.min(P.maxY, M.maxY), Math.max(0, T - z) * Math.max(0, F - D)), oe = m(X) + m(te);
          H < k ? (k = H, C = $, O = oe < O ? oe : O) : H === k && oe < O && (O = oe, C = $);
        }
        return C || w - y;
      }, s.prototype._chooseSplitAxis = function(p, y, w) {
        var C = p.leaf ? this.compareMinX : d, P = p.leaf ? this.compareMinY : f;
        this._allDistMargin(p, y, w, C) < this._allDistMargin(p, y, w, P) && p.children.sort(C);
      }, s.prototype._allDistMargin = function(p, y, w, C) {
        p.children.sort(C);
        for (var P = this.toBBox, M = c(p, 0, y, P), z = c(p, w - y, w, P), D = g(M) + g(z), T = y; T < w - y; T++) {
          var F = p.children[T];
          u(M, p.leaf ? P(F) : F), D += g(M);
        }
        for (var k = w - y - 1; k >= y; k--) {
          var O = p.children[k];
          u(z, p.leaf ? P(O) : O), D += g(z);
        }
        return D;
      }, s.prototype._adjustParentBBoxes = function(p, y, w) {
        for (var C = w; C >= 0; C--) u(y[C], p);
      }, s.prototype._condense = function(p) {
        for (var y = p.length - 1, w = void 0; y >= 0; y--) p[y].children.length === 0 ? y > 0 ? (w = p[y - 1].children).splice(w.indexOf(p[y]), 1) : this.clear() : l(p[y], this.toBBox);
      }, s;
    });
  }(er)), er.exports;
}
var ys = {}, Ga;
function Mu() {
  return Ga || (Ga = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.earthRadius = 63710088e-1, e.factors = {
      centimeters: e.earthRadius * 100,
      centimetres: e.earthRadius * 100,
      degrees: e.earthRadius / 111325,
      feet: e.earthRadius * 3.28084,
      inches: e.earthRadius * 39.37,
      kilometers: e.earthRadius / 1e3,
      kilometres: e.earthRadius / 1e3,
      meters: e.earthRadius,
      metres: e.earthRadius,
      miles: e.earthRadius / 1609.344,
      millimeters: e.earthRadius * 1e3,
      millimetres: e.earthRadius * 1e3,
      nauticalmiles: e.earthRadius / 1852,
      radians: 1,
      yards: e.earthRadius * 1.0936
    }, e.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / e.earthRadius,
      yards: 1.0936133
    }, e.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function t(F, k, O) {
      O === void 0 && (O = {});
      var $ = { type: "Feature" };
      return (O.id === 0 || O.id) && ($.id = O.id), O.bbox && ($.bbox = O.bbox), $.properties = k || {}, $.geometry = F, $;
    }
    e.feature = t;
    function i(F, k, O) {
      switch (F) {
        case "Point":
          return n(k).geometry;
        case "LineString":
          return l(k).geometry;
        case "Polygon":
          return s(k).geometry;
        case "MultiPoint":
          return f(k).geometry;
        case "MultiLineString":
          return d(k).geometry;
        case "MultiPolygon":
          return m(k).geometry;
        default:
          throw new Error(F + " is invalid");
      }
    }
    e.geometry = i;
    function n(F, k, O) {
      if (O === void 0 && (O = {}), !F)
        throw new Error("coordinates is required");
      if (!Array.isArray(F))
        throw new Error("coordinates must be an Array");
      if (F.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
      if (!M(F[0]) || !M(F[1]))
        throw new Error("coordinates must contain numbers");
      var $ = {
        type: "Point",
        coordinates: F
      };
      return t($, k, O);
    }
    e.point = n;
    function r(F, k, O) {
      return O === void 0 && (O = {}), u(F.map(function($) {
        return n($, k);
      }), O);
    }
    e.points = r;
    function s(F, k, O) {
      O === void 0 && (O = {});
      for (var $ = 0, X = F; $ < X.length; $++) {
        var te = X[$];
        if (te.length < 4)
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        for (var H = 0; H < te[te.length - 1].length; H++)
          if (te[te.length - 1][H] !== te[0][H])
            throw new Error("First and last Position are not equivalent.");
      }
      var oe = {
        type: "Polygon",
        coordinates: F
      };
      return t(oe, k, O);
    }
    e.polygon = s;
    function o(F, k, O) {
      return O === void 0 && (O = {}), u(F.map(function($) {
        return s($, k);
      }), O);
    }
    e.polygons = o;
    function l(F, k, O) {
      if (O === void 0 && (O = {}), F.length < 2)
        throw new Error("coordinates must be an array of two or more positions");
      var $ = {
        type: "LineString",
        coordinates: F
      };
      return t($, k, O);
    }
    e.lineString = l;
    function c(F, k, O) {
      return O === void 0 && (O = {}), u(F.map(function($) {
        return l($, k);
      }), O);
    }
    e.lineStrings = c;
    function u(F, k) {
      k === void 0 && (k = {});
      var O = { type: "FeatureCollection" };
      return k.id && (O.id = k.id), k.bbox && (O.bbox = k.bbox), O.features = F, O;
    }
    e.featureCollection = u;
    function d(F, k, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiLineString",
        coordinates: F
      };
      return t($, k, O);
    }
    e.multiLineString = d;
    function f(F, k, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiPoint",
        coordinates: F
      };
      return t($, k, O);
    }
    e.multiPoint = f;
    function m(F, k, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiPolygon",
        coordinates: F
      };
      return t($, k, O);
    }
    e.multiPolygon = m;
    function g(F, k, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "GeometryCollection",
        geometries: F
      };
      return t($, k, O);
    }
    e.geometryCollection = g;
    function v(F, k) {
      if (k === void 0 && (k = 0), k && !(k >= 0))
        throw new Error("precision must be a positive number");
      var O = Math.pow(10, k || 0);
      return Math.round(F * O) / O;
    }
    e.round = v;
    function x(F, k) {
      k === void 0 && (k = "kilometers");
      var O = e.factors[k];
      if (!O)
        throw new Error(k + " units is invalid");
      return F * O;
    }
    e.radiansToLength = x;
    function S(F, k) {
      k === void 0 && (k = "kilometers");
      var O = e.factors[k];
      if (!O)
        throw new Error(k + " units is invalid");
      return F / O;
    }
    e.lengthToRadians = S;
    function A(F, k) {
      return y(S(F, k));
    }
    e.lengthToDegrees = A;
    function p(F) {
      var k = F % 360;
      return k < 0 && (k += 360), k;
    }
    e.bearingToAzimuth = p;
    function y(F) {
      var k = F % (2 * Math.PI);
      return k * 180 / Math.PI;
    }
    e.radiansToDegrees = y;
    function w(F) {
      var k = F % 360;
      return k * Math.PI / 180;
    }
    e.degreesToRadians = w;
    function C(F, k, O) {
      if (k === void 0 && (k = "kilometers"), O === void 0 && (O = "kilometers"), !(F >= 0))
        throw new Error("length must be a positive number");
      return x(S(F, k), O);
    }
    e.convertLength = C;
    function P(F, k, O) {
      if (k === void 0 && (k = "meters"), O === void 0 && (O = "kilometers"), !(F >= 0))
        throw new Error("area must be a positive number");
      var $ = e.areaFactors[k];
      if (!$)
        throw new Error("invalid original units");
      var X = e.areaFactors[O];
      if (!X)
        throw new Error("invalid final units");
      return F / $ * X;
    }
    e.convertArea = P;
    function M(F) {
      return !isNaN(F) && F !== null && !Array.isArray(F);
    }
    e.isNumber = M;
    function z(F) {
      return !!F && F.constructor === Object;
    }
    e.isObject = z;
    function D(F) {
      if (!F)
        throw new Error("bbox is required");
      if (!Array.isArray(F))
        throw new Error("bbox must be an Array");
      if (F.length !== 4 && F.length !== 6)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      F.forEach(function(k) {
        if (!M(k))
          throw new Error("bbox must only contain numbers");
      });
    }
    e.validateBBox = D;
    function T(F) {
      if (!F)
        throw new Error("id is required");
      if (["string", "number"].indexOf(typeof F) === -1)
        throw new Error("id must be a number or a string");
    }
    e.validateId = T;
  }(ys)), ys;
}
var Oe = {}, Ha;
function bv() {
  if (Ha) return Oe;
  Ha = 1, Object.defineProperty(Oe, "__esModule", { value: !0 });
  var e = /* @__PURE__ */ Mu();
  function t(p, y, w) {
    if (p !== null)
      for (var C, P, M, z, D, T, F, k = 0, O = 0, $, X = p.type, te = X === "FeatureCollection", H = X === "Feature", oe = te ? p.features.length : 1, fe = 0; fe < oe; fe++) {
        F = te ? p.features[fe].geometry : H ? p.geometry : p, $ = F ? F.type === "GeometryCollection" : !1, D = $ ? F.geometries.length : 1;
        for (var ce = 0; ce < D; ce++) {
          var de = 0, R = 0;
          if (z = $ ? F.geometries[ce] : F, z !== null) {
            T = z.coordinates;
            var J = z.type;
            switch (k = w && (J === "Polygon" || J === "MultiPolygon") ? 1 : 0, J) {
              case null:
                break;
              case "Point":
                if (y(
                  T,
                  O,
                  fe,
                  de,
                  R
                ) === !1)
                  return !1;
                O++, de++;
                break;
              case "LineString":
              case "MultiPoint":
                for (C = 0; C < T.length; C++) {
                  if (y(
                    T[C],
                    O,
                    fe,
                    de,
                    R
                  ) === !1)
                    return !1;
                  O++, J === "MultiPoint" && de++;
                }
                J === "LineString" && de++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (C = 0; C < T.length; C++) {
                  for (P = 0; P < T[C].length - k; P++) {
                    if (y(
                      T[C][P],
                      O,
                      fe,
                      de,
                      R
                    ) === !1)
                      return !1;
                    O++;
                  }
                  J === "MultiLineString" && de++, J === "Polygon" && R++;
                }
                J === "Polygon" && de++;
                break;
              case "MultiPolygon":
                for (C = 0; C < T.length; C++) {
                  for (R = 0, P = 0; P < T[C].length; P++) {
                    for (M = 0; M < T[C][P].length - k; M++) {
                      if (y(
                        T[C][P][M],
                        O,
                        fe,
                        de,
                        R
                      ) === !1)
                        return !1;
                      O++;
                    }
                    R++;
                  }
                  de++;
                }
                break;
              case "GeometryCollection":
                for (C = 0; C < z.geometries.length; C++)
                  if (t(z.geometries[C], y, w) === !1)
                    return !1;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
  }
  function i(p, y, w, C) {
    var P = w;
    return t(
      p,
      function(M, z, D, T, F) {
        z === 0 && w === void 0 ? P = M : P = y(
          P,
          M,
          z,
          D,
          T,
          F
        );
      },
      C
    ), P;
  }
  function n(p, y) {
    var w;
    switch (p.type) {
      case "FeatureCollection":
        for (w = 0; w < p.features.length && y(p.features[w].properties, w) !== !1; w++)
          ;
        break;
      case "Feature":
        y(p.properties, 0);
        break;
    }
  }
  function r(p, y, w) {
    var C = w;
    return n(p, function(P, M) {
      M === 0 && w === void 0 ? C = P : C = y(C, P, M);
    }), C;
  }
  function s(p, y) {
    if (p.type === "Feature")
      y(p, 0);
    else if (p.type === "FeatureCollection")
      for (var w = 0; w < p.features.length && y(p.features[w], w) !== !1; w++)
        ;
  }
  function o(p, y, w) {
    var C = w;
    return s(p, function(P, M) {
      M === 0 && w === void 0 ? C = P : C = y(C, P, M);
    }), C;
  }
  function l(p) {
    var y = [];
    return t(p, function(w) {
      y.push(w);
    }), y;
  }
  function c(p, y) {
    var w, C, P, M, z, D, T, F, k, O, $ = 0, X = p.type === "FeatureCollection", te = p.type === "Feature", H = X ? p.features.length : 1;
    for (w = 0; w < H; w++) {
      for (D = X ? p.features[w].geometry : te ? p.geometry : p, F = X ? p.features[w].properties : te ? p.properties : {}, k = X ? p.features[w].bbox : te ? p.bbox : void 0, O = X ? p.features[w].id : te ? p.id : void 0, T = D ? D.type === "GeometryCollection" : !1, z = T ? D.geometries.length : 1, P = 0; P < z; P++) {
        if (M = T ? D.geometries[P] : D, M === null) {
          if (y(
            null,
            $,
            F,
            k,
            O
          ) === !1)
            return !1;
          continue;
        }
        switch (M.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (y(
              M,
              $,
              F,
              k,
              O
            ) === !1)
              return !1;
            break;
          }
          case "GeometryCollection": {
            for (C = 0; C < M.geometries.length; C++)
              if (y(
                M.geometries[C],
                $,
                F,
                k,
                O
              ) === !1)
                return !1;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      $++;
    }
  }
  function u(p, y, w) {
    var C = w;
    return c(
      p,
      function(P, M, z, D, T) {
        M === 0 && w === void 0 ? C = P : C = y(
          C,
          P,
          M,
          z,
          D,
          T
        );
      }
    ), C;
  }
  function d(p, y) {
    c(p, function(w, C, P, M, z) {
      var D = w === null ? null : w.type;
      switch (D) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return y(
            e.feature(w, P, { bbox: M, id: z }),
            C,
            0
          ) === !1 ? !1 : void 0;
      }
      var T;
      switch (D) {
        case "MultiPoint":
          T = "Point";
          break;
        case "MultiLineString":
          T = "LineString";
          break;
        case "MultiPolygon":
          T = "Polygon";
          break;
      }
      for (var F = 0; F < w.coordinates.length; F++) {
        var k = w.coordinates[F], O = {
          type: T,
          coordinates: k
        };
        if (y(e.feature(O, P), C, F) === !1)
          return !1;
      }
    });
  }
  function f(p, y, w) {
    var C = w;
    return d(
      p,
      function(P, M, z) {
        M === 0 && z === 0 && w === void 0 ? C = P : C = y(
          C,
          P,
          M,
          z
        );
      }
    ), C;
  }
  function m(p, y) {
    d(p, function(w, C, P) {
      var M = 0;
      if (w.geometry) {
        var z = w.geometry.type;
        if (!(z === "Point" || z === "MultiPoint")) {
          var D, T = 0, F = 0, k = 0;
          if (t(
            w,
            function(O, $, X, te, H) {
              if (D === void 0 || C > T || te > F || H > k) {
                D = O, T = C, F = te, k = H, M = 0;
                return;
              }
              var oe = e.lineString(
                [D, O],
                w.properties
              );
              if (y(
                oe,
                C,
                P,
                H,
                M
              ) === !1)
                return !1;
              M++, D = O;
            }
          ) === !1)
            return !1;
        }
      }
    });
  }
  function g(p, y, w) {
    var C = w, P = !1;
    return m(
      p,
      function(M, z, D, T, F) {
        P === !1 && w === void 0 ? C = M : C = y(
          C,
          M,
          z,
          D,
          T,
          F
        ), P = !0;
      }
    ), C;
  }
  function v(p, y) {
    if (!p) throw new Error("geojson is required");
    d(p, function(w, C, P) {
      if (w.geometry !== null) {
        var M = w.geometry.type, z = w.geometry.coordinates;
        switch (M) {
          case "LineString":
            if (y(w, C, P, 0, 0) === !1)
              return !1;
            break;
          case "Polygon":
            for (var D = 0; D < z.length; D++)
              if (y(
                e.lineString(z[D], w.properties),
                C,
                P,
                D
              ) === !1)
                return !1;
            break;
        }
      }
    });
  }
  function x(p, y, w) {
    var C = w;
    return v(
      p,
      function(P, M, z, D) {
        M === 0 && w === void 0 ? C = P : C = y(
          C,
          P,
          M,
          z,
          D
        );
      }
    ), C;
  }
  function S(p, y) {
    if (y = y || {}, !e.isObject(y)) throw new Error("options is invalid");
    var w = y.featureIndex || 0, C = y.multiFeatureIndex || 0, P = y.geometryIndex || 0, M = y.segmentIndex || 0, z = y.properties, D;
    switch (p.type) {
      case "FeatureCollection":
        w < 0 && (w = p.features.length + w), z = z || p.features[w].properties, D = p.features[w].geometry;
        break;
      case "Feature":
        z = z || p.properties, D = p.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        D = p;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (D === null) return null;
    var T = D.coordinates;
    switch (D.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return M < 0 && (M = T.length + M - 1), e.lineString(
          [T[M], T[M + 1]],
          z,
          y
        );
      case "Polygon":
        return P < 0 && (P = T.length + P), M < 0 && (M = T[P].length + M - 1), e.lineString(
          [
            T[P][M],
            T[P][M + 1]
          ],
          z,
          y
        );
      case "MultiLineString":
        return C < 0 && (C = T.length + C), M < 0 && (M = T[C].length + M - 1), e.lineString(
          [
            T[C][M],
            T[C][M + 1]
          ],
          z,
          y
        );
      case "MultiPolygon":
        return C < 0 && (C = T.length + C), P < 0 && (P = T[C].length + P), M < 0 && (M = T[C][P].length - M - 1), e.lineString(
          [
            T[C][P][M],
            T[C][P][M + 1]
          ],
          z,
          y
        );
    }
    throw new Error("geojson is invalid");
  }
  function A(p, y) {
    if (y = y || {}, !e.isObject(y)) throw new Error("options is invalid");
    var w = y.featureIndex || 0, C = y.multiFeatureIndex || 0, P = y.geometryIndex || 0, M = y.coordIndex || 0, z = y.properties, D;
    switch (p.type) {
      case "FeatureCollection":
        w < 0 && (w = p.features.length + w), z = z || p.features[w].properties, D = p.features[w].geometry;
        break;
      case "Feature":
        z = z || p.properties, D = p.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        D = p;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (D === null) return null;
    var T = D.coordinates;
    switch (D.type) {
      case "Point":
        return e.point(T, z, y);
      case "MultiPoint":
        return C < 0 && (C = T.length + C), e.point(T[C], z, y);
      case "LineString":
        return M < 0 && (M = T.length + M), e.point(T[M], z, y);
      case "Polygon":
        return P < 0 && (P = T.length + P), M < 0 && (M = T[P].length + M), e.point(T[P][M], z, y);
      case "MultiLineString":
        return C < 0 && (C = T.length + C), M < 0 && (M = T[C].length + M), e.point(T[C][M], z, y);
      case "MultiPolygon":
        return C < 0 && (C = T.length + C), P < 0 && (P = T[C].length + P), M < 0 && (M = T[C][P].length - M), e.point(
          T[C][P][M],
          z,
          y
        );
    }
    throw new Error("geojson is invalid");
  }
  return Oe.coordAll = l, Oe.coordEach = t, Oe.coordReduce = i, Oe.featureEach = s, Oe.featureReduce = o, Oe.findPoint = A, Oe.findSegment = S, Oe.flattenEach = d, Oe.flattenReduce = f, Oe.geomEach = c, Oe.geomReduce = u, Oe.lineEach = v, Oe.lineReduce = x, Oe.propEach = n, Oe.propReduce = r, Oe.segmentEach = m, Oe.segmentReduce = g, Oe;
}
var Wa;
function wv() {
  if (Wa) return Zn.exports;
  Wa = 1;
  var e = vv(), t = /* @__PURE__ */ Mu(), i = /* @__PURE__ */ bv(), n = wi.default, r = i.featureEach;
  i.coordEach, t.polygon;
  var s = t.featureCollection;
  function o(l) {
    var c = new e(l);
    return c.insert = function(u) {
      if (u.type !== "Feature") throw new Error("invalid feature");
      return u.bbox = u.bbox ? u.bbox : n(u), e.prototype.insert.call(this, u);
    }, c.load = function(u) {
      var d = [];
      return Array.isArray(u) ? u.forEach(function(f) {
        if (f.type !== "Feature") throw new Error("invalid features");
        f.bbox = f.bbox ? f.bbox : n(f), d.push(f);
      }) : r(u, function(f) {
        if (f.type !== "Feature") throw new Error("invalid features");
        f.bbox = f.bbox ? f.bbox : n(f), d.push(f);
      }), e.prototype.load.call(this, d);
    }, c.remove = function(u, d) {
      if (u.type !== "Feature") throw new Error("invalid feature");
      return u.bbox = u.bbox ? u.bbox : n(u), e.prototype.remove.call(this, u, d);
    }, c.clear = function() {
      return e.prototype.clear.call(this);
    }, c.search = function(u) {
      var d = e.prototype.search.call(this, this.toBBox(u));
      return s(d);
    }, c.collides = function(u) {
      return e.prototype.collides.call(this, this.toBBox(u));
    }, c.all = function() {
      var u = e.prototype.all.call(this);
      return s(u);
    }, c.toJSON = function() {
      return e.prototype.toJSON.call(this);
    }, c.fromJSON = function(u) {
      return e.prototype.fromJSON.call(this, u);
    }, c.toBBox = function(u) {
      var d;
      if (u.bbox) d = u.bbox;
      else if (Array.isArray(u) && u.length === 4) d = u;
      else if (Array.isArray(u) && u.length === 6) d = [u[0], u[1], u[3], u[4]];
      else if (u.type === "Feature") d = n(u);
      else if (u.type === "FeatureCollection") d = n(u);
      else throw new Error("invalid geojson");
      return {
        minX: d[0],
        minY: d[1],
        maxX: d[2],
        maxY: d[3]
      };
    }, c;
  }
  return Zn.exports = o, Zn.exports.default = o, Zn.exports;
}
var _v = wv();
const Lv = /* @__PURE__ */ gv(_v);
function bo(e, t) {
  var i = {}, n = [];
  if (e.type === "LineString" && (e = jt(e)), t.type === "LineString" && (t = jt(t)), e.type === "Feature" && t.type === "Feature" && e.geometry !== null && t.geometry !== null && e.geometry.type === "LineString" && t.geometry.type === "LineString" && e.geometry.coordinates.length === 2 && t.geometry.coordinates.length === 2) {
    var r = Za(e, t);
    return r && n.push(r), ut(n);
  }
  var s = Lv();
  return s.load(Ua(t)), bi(Ua(e), function(o) {
    bi(s.search(o), function(l) {
      var c = Za(o, l);
      if (c) {
        var u = st(c).join(",");
        i[u] || (i[u] = !0, n.push(c));
      }
    });
  }), ut(n);
}
function Za(e, t) {
  var i = st(e), n = st(t);
  if (i.length !== 2)
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (n.length !== 2)
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  var r = i[0][0], s = i[0][1], o = i[1][0], l = i[1][1], c = n[0][0], u = n[0][1], d = n[1][0], f = n[1][1], m = (f - u) * (o - r) - (d - c) * (l - s), g = (d - c) * (s - u) - (f - u) * (r - c), v = (o - r) * (s - u) - (l - s) * (r - c);
  if (m === 0)
    return null;
  var x = g / m, S = v / m;
  if (x >= 0 && x <= 1 && S >= 0 && S <= 1) {
    var A = r + x * (o - r), p = s + x * (l - s);
    return mt([A, p]);
  }
  return null;
}
function Os(e, t) {
  t === void 0 && (t = {});
  var i = Yt(e);
  switch (!t.properties && e.type === "Feature" && (t.properties = e.properties), i.type) {
    case "Polygon":
      return xv(i, t);
    case "MultiPolygon":
      return Sv(i, t);
    default:
      throw new Error("invalid poly");
  }
}
function xv(e, t) {
  t === void 0 && (t = {});
  var i = Yt(e), n = i.coordinates, r = t.properties ? t.properties : e.type === "Feature" ? e.properties : {};
  return ku(n, r);
}
function Sv(e, t) {
  t === void 0 && (t = {});
  var i = Yt(e), n = i.coordinates, r = t.properties ? t.properties : e.type === "Feature" ? e.properties : {}, s = [];
  return n.forEach(function(o) {
    s.push(ku(o, r));
  }), ut(s);
}
function ku(e, t) {
  return e.length > 1 ? ov(e, t) : Eu(e[0], t);
}
function Ev(e, t) {
  var i = !0;
  return wn(e, function(n) {
    wn(t, function(r) {
      if (i === !1)
        return !1;
      i = Cv(n.geometry, r.geometry);
    });
  }), i;
}
function Cv(e, t) {
  switch (e.type) {
    case "Point":
      switch (t.type) {
        case "Point":
          return !kv(e.coordinates, t.coordinates);
        case "LineString":
          return !Qa(t, e);
        case "Polygon":
          return !_n(e, t);
      }
      break;
    case "LineString":
      switch (t.type) {
        case "Point":
          return !Qa(e, t);
        case "LineString":
          return !Tv(e, t);
        case "Polygon":
          return !Ja(t, e);
      }
      break;
    case "Polygon":
      switch (t.type) {
        case "Point":
          return !_n(t, e);
        case "LineString":
          return !Ja(e, t);
        case "Polygon":
          return !Pv(t, e);
      }
  }
  return !1;
}
function Qa(e, t) {
  for (var i = 0; i < e.coordinates.length - 1; i++)
    if (Mv(e.coordinates[i], e.coordinates[i + 1], t.coordinates))
      return !0;
  return !1;
}
function Tv(e, t) {
  var i = bo(e, t);
  return i.features.length > 0;
}
function Ja(e, t) {
  for (var i = 0, n = t.coordinates; i < n.length; i++) {
    var r = n[i];
    if (_n(r, e))
      return !0;
  }
  var s = bo(t, Os(e));
  return s.features.length > 0;
}
function Pv(e, t) {
  for (var i = 0, n = e.coordinates[0]; i < n.length; i++) {
    var r = n[i];
    if (_n(r, t))
      return !0;
  }
  for (var s = 0, o = t.coordinates[0]; s < o.length; s++) {
    var l = o[s];
    if (_n(l, e))
      return !0;
  }
  var c = bo(Os(e), Os(t));
  return c.features.length > 0;
}
function Mv(e, t, i) {
  var n = i[0] - e[0], r = i[1] - e[1], s = t[0] - e[0], o = t[1] - e[1], l = n * o - r * s;
  return l !== 0 ? !1 : Math.abs(s) >= Math.abs(o) ? s > 0 ? e[0] <= i[0] && i[0] <= t[0] : t[0] <= i[0] && i[0] <= e[0] : o > 0 ? e[1] <= i[1] && i[1] <= t[1] : t[1] <= i[1] && i[1] <= e[1];
}
function kv(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function Fu(e, t) {
  var i = !1;
  return wn(e, function(n) {
    wn(t, function(r) {
      if (i === !0)
        return !0;
      i = !Ev(n.geometry, r.geometry);
    });
  }), i;
}
function jr(e, t, i = !1) {
  if (i) {
    let n = 0;
    for (; n < t.length && !(e.valueOf() < t[n].valueOf()); n++)
      ;
    return n > 0 && n--, { index: n, difference: Math.abs(e.diff(t[n])) };
  } else {
    let n = -1, r = 1 / 0;
    return t.forEach((s, o) => {
      const l = Math.abs(e.diff(s));
      l < r && (r = l, n = o);
    }), { index: n, difference: r };
  }
}
function Fv(e, t = "minimum") {
  let i = t === "minimum" ? 1 / 0 : 0;
  return e.forEach((n, r) => {
    if (r < e.length - 1) {
      const s = Math.abs(n.diff(e[r + 1]));
      t === "minimum" ? s < i && (i = s) : s > i && (i = s);
    }
  }), i;
}
function Et(e, t) {
  let i = a.get(t, "featureId");
  return i || (i = "_id"), i = Array.isArray(i) ? i : [i], i.map((n) => a.get(e, "properties." + n, a.get(e, n))).join("-");
}
function Dv(e, t) {
  let i = t.featureLabel || "name";
  return i = Array.isArray(i) ? i : [i], i.reduce((n, r) => (r = a.get(e, `properties.${r}`), n ? n + ` - ${r}` : r), "");
}
function Av(e, t, i, n) {
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: [t, e]
    },
    properties: {
      name: Es(e, t).format(i, n)
    }
  };
}
function Ne(e) {
  return Array.isArray(e) ? e : e.type === "FeatureCollection" ? e.features : [e];
}
const Ya = ["right", "left", "top", "bottom", "top-left", "top-right", "bottom-right", "bottom-left"];
async function Ov(e) {
  const { kActivity: t } = ni(), i = t.value.getContextParameters("layers").layers, n = t.value.getContextParameters("view"), r = j.get("capabilities.api.gateway") + "/capture", s = {
    method: "POST",
    mode: "cors",
    headers: {
      "Content-Type": "application/json"
    }
  }, o = await G.get("storage").getItem(me.gatewayJwt);
  o && (s.headers.Authorization = "Bearer " + o);
  let l = null;
  l = et.create({
    group: "capture",
    icon: "las la-hourglass-half",
    message: Y.t("KCapture.PRINTING_VIEW"),
    color: "primary",
    timeout: 0,
    spinner: !0
  });
  const c = [], u = Iv(e.dateTime.start, e.dateTime.end);
  try {
    for (let d = 0; d < u.length; d++) {
      s.body = JSON.stringify({
        activity: t.value.is3D() ? "globe" : "map",
        layers: i,
        bbox: [n.west, n.south, n.east, n.north],
        size: { width: +e.resolution.width, height: +e.resolution.height },
        layout: Bv(e),
        time: u[d],
        basePath: a.has(e, "basePath") ? e.basePath : "/#/home/",
        lang: Dt()
      });
      const f = await fetch(r, s);
      if (f.ok) {
        const m = await f.arrayBuffer();
        c.push(m);
      } else
        ne.emit("error", { message: Y.t("errors." + f.status) });
    }
    if (e.format === "pdf") {
      const d = await Nv(c, a.toNumber(e.resolution.width), a.toNumber(e.resolution.height));
      yr(Y.t("utils.capture.CAPTURE_PDF_FILE", { time: a.get(u, "[0]", "") }), d);
    } else
      a.forEach(c, (d, f) => {
        const m = u[f];
        yr(Y.t("utils.capture.CAPTURE_IMAGE_FILE", { time: a.get(u, `[${f}]`, "") }), new Uint8Array(d));
      });
    l();
  } catch (d) {
    l(), I.error(d), ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
  }
}
function Bv(e) {
  const t = {
    panes: {
      left: { opener: !1, visible: !1 },
      top: { opener: !1, visible: !1 },
      right: { opener: !1, visible: !1 },
      bottom: { opener: !1, visible: !1 }
    },
    fab: { visible: !1 }
  };
  return a.has(e, "header") && !a.isEmpty(e.header) && a.set(t, "header", Xa(e.header, "header")), a.has(e, "footer") && !a.isEmpty(e.footer) && a.set(t, "footer", Xa(e.footer, "footer")), a.includes(Ya, e.north) && a.set(t, "stickies", Rv(e.north)), a.includes(Ya, e.legend) && a.set(t, `windows.${e.legend}`, $v()), t;
}
function Xa(e, t) {
  return { content: [{ component: a.get(me, `capture.${t}.component`, "KCaptureTextArea"), text: e, position: t }], visible: !0 };
}
function Rv(e) {
  return { content: [{ ...ee.findSticky("north-sticky"), position: e, offset: [0, 5], visible: !0 }] };
}
function $v() {
  return {
    content: [{ id: "legend-widget", label: "KLegend.LABEL", icon: "las la-list", scrollable: !0, content: { component: "legend/KLegend" } }],
    current: "legend-widget",
    state: "pinned",
    controls: {
      pin: !1,
      unpin: !1,
      maximize: !1,
      restore: !1,
      close: !1,
      resize: !1
    },
    sizePolicy: {
      pinned: {
        xs: [35, 100],
        sm: [30, 100],
        md: [25, 100],
        lg: [20, 100],
        xl: [15, 100]
      }
    },
    visible: !0
  };
}
function Iv(e, t) {
  if (e === t) return [e];
  const i = he.utc(e), n = he.utc(t), r = j.get("time.interval"), s = [];
  let o = i.clone();
  for (; o.isSameOrBefore(n); )
    s.push(o.toISOString()), o.add(r, "minutes");
  return s;
}
function zv(e, t) {
  const i = { type: "image", rotate: 0 };
  return e > t ? (i.width = 287, i.height = 287 * t / e, i.position = { x: 5, y: (210 - i.height) / 2 }) : (i.height = 200, i.width = 200 * e / t, i.position = { y: 5, x: (297 - i.width) / 2 }), i;
}
async function Nv(e, t, i) {
  const n = {
    schemas: [{ capture: zv(t, i) }],
    basePdf: "data:application/pdf;base64,JVBERi0xLjQKJeLjz9MKMSAwIG9iaiA8PC9UeXBlL1hPYmplY3QvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHRdL0ZvbnQgMiAwIFI+Pi9TdWJ0eXBlL0Zvcm0vQkJveFswIDAgMjk4IDQyMF0vTWF0cml4WzEgMCAwIDEgMCAwXS9MZW5ndGggNDQvRm9ybVR5cGUgMS9GaWx0ZXIvRmxhdGVEZWNvZGU+PnN0cmVhbQp4nDPQM1Qo5ypUMFAw0DNRMLI01zNXMDG01DNTKEpVCNdSyOMKVAAAiEAHjgplbmRzdHJlYW0KZW5kb2JqCjMgMCBvYmogPDwvTGVuZ3RoIDgxL0ZpbHRlci9GbGF0ZURlY29kZT4+c3RyZWFtCnicK+RyCuEyNlMwNbXUMzZVCEnhcg3hCuQqVDDQMzMwNDNUMABBKNvY2FDP2ETB2MBMz8xcITlXQT8izVDBJV8hkAukzFAhyJ0rmAsAxQ8Q1AplbmRzdHJlYW0KZW5kb2JqCjQgMCBvYmo8PC9UeXBlL1BhZ2VzL0NvdW50IDEvS2lkc1s1IDAgUl0+PgplbmRvYmoKNSAwIG9iajw8L1BhcmVudCA0IDAgUi9UeXBlL1BhZ2UvQ29udGVudHMgMyAwIFIvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHQvSW1hZ2VCL0ltYWdlQy9JbWFnZUldL1hPYmplY3Q8PC9YZjEgMSAwIFI+Pj4+L01lZGlhQm94WzAgMCA4NDEuOTUgNTk1LjM1XT4+CmVuZG9iagoyIDAgb2JqPDw+PgplbmRvYmoKNiAwIG9iajw8L1R5cGUvQ2F0YWxvZy9QYWdlcyA0IDAgUj4+CmVuZG9iago3IDAgb2JqPDwvUHJvZHVjZXIoUERGaWxsOiBGcmVlIFBERiBXcml0ZXIgYW5kIFRvb2xzKS9Nb2REYXRlKEQ6MjAwOTEwMTgyMjMwMTArMDInMDAnKS9DcmVhdGlvbkRhdGUoRDoyMDA5MTAxODIyMzAxMCswMicwMCcpPj4KZW5kb2JqCnhyZWYKMCA4CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDAxNSAwMDAwMCBuIAowMDAwMDAwNjAyIDAwMDAwIG4gCjAwMDAwMDAyNDQgMDAwMDAgbiAKMDAwMDAwMDM5MSAwMDAwMCBuIAowMDAwMDAwNDQxIDAwMDAwIG4gCjAwMDAwMDA2MjEgMDAwMDAgbiAKMDAwMDAwMDY2NSAwMDAwMCBuIAp0cmFpbGVyCjw8L1Jvb3QgNiAwIFIvSW5mbyA3IDAgUi9TaXplIDg+PgpzdGFydHhyZWYKNzk5CiUlRU9GCg=="
  }, r = { image: Qf }, s = [];
  return a.forEach(e, (o) => {
    s.push({ capture: `data:image/png;base64,${pu(o)}` });
  }), await Jf({ template: n, plugins: r, inputs: s });
}
function lt(e, t, i, n, r) {
  const s = a.get(e, t);
  if (s && s.startsWith(i))
    if (t === "cesium.url" && a.get(e, "cesium.type") === "OpenStreetMap") {
      const o = a.get(e, "cesium.fileExtension", "png");
      a.set(e, "cesium.fileExtension", o + `?${n}=${r}`);
    } else
      a.set(e, t, Tn(s, { [n]: r }));
}
async function wo(e, t) {
  t || (t = G);
  let i = t.hasConfig("gatewayJwt") ? await t.get("storage").getItem(t.getConfig("gatewayJwt")) : null, n = t.getConfig("gatewayJwtField");
  const r = t.hasConfig("gateway") ? t.getConfig("gateway") : j.get("capabilities.api.gateway");
  i && e.forEach((o) => {
    lt(o, "iconUrl", r, n, i), lt(o, "leaflet.source", r, n, i), lt(o, "leaflet.url", r, n, i), lt(o, "opendap.url", r, n, i), lt(o, "geotiff.url", r, n, i), lt(o, "wfs.url", r, n, i), lt(o, "wcs.url", r, n, i), lt(o, "cesium.url", r, n, i), lt(o, "cesium.source", r, n, i);
  }), i = t.hasConfig("apiJwt") ? await t.get("storage").getItem(t.getConfig("apiJwt")) : null, n = "jwt";
  const s = t.getConfig("domain");
  return i && (e.forEach((o) => {
    lt(o, "geotiff.url", s, n, i);
  }), e.forEach((o) => {
    lt(o, "geotiff.url", "/", n, i);
  })), e;
}
function Du(e, t) {
  const i = a.clone(e), n = {};
  return a.forEach(t, (r) => {
    let s = null;
    a.has(r, "options.filter") ? s = a.get(r, "options.filter") : a.has(r, "layers") && (s = { name: { $in: a.get(r, "layers") } }), n[r.name] = s ? a.remove(i, Te(s)) : [], n[r.name] = a.orderBy(
      n[r.name],
      [(o) => a.get(o, a.get(r, "options.orderBy", "_id"))],
      [a.get(r, "options.order", "asc")]
    ), e.length > 0 && r?.layers && (n[r.name] = r.layers.map((o) => e.find((l) => l.name === o)));
  }), n;
}
function Au(e, t) {
  const i = a.flatten(a.values(t)), n = a.difference(e, i);
  return a.orderBy(n, [(r) => a.get(r, "_id")], ["asc"]);
}
function Ur(e) {
  e.i18n && Y.registerTranslation(e.i18n), a.has(e, "label") || (e.label = Y.tie(e.name)), a.has(e, "description") && (e.description = Y.tie(e.description));
}
async function wr(e = {}) {
  a.defaults(e, {
    query: {},
    context: "",
    planetApi: G
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: e.query });
    a.forEach(n.data, Ur), t = t.concat(n.data.map((r) => Object.assign(r, { getPlanetApi: () => e.planetApi })));
  }
  return await wo(t, e.planetApi), t;
}
async function _r(e = {}) {
  a.defaults(e, {
    query: {},
    context: "",
    planetApi: G
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Category" }, e.query) });
    a.forEach(n.data, Ur), t = t.concat(n.data);
  }
  return t;
}
async function Lr(e = {}) {
  a.defaults(e, {
    query: {},
    context: "",
    planetApi: G
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Sublegend" }, e.query) });
    a.forEach(n.data, Ur), t = t.concat(n.data);
  }
  return t;
}
function qv(e, t) {
  const i = a.clone(e), n = {};
  return a.forEach(t, (r) => {
    let s = null;
    a.has(r, "options.filter") && (s = a.get(r, "options.filter")), n[r.name] = s ? a.remove(i, Te(s)) : [];
  }), n;
}
async function Ou(e = {}) {
  a.defaults(e, {
    query: {},
    context: "",
    planetApi: G
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Context" }, e.query) });
    a.forEach(n.data, Ur), t = t.concat(n.data);
  }
  return t;
}
function Bu(e) {
  var t = [];
  return e.type === "FeatureCollection" ? bi(e, function(i) {
    vi(i, function(n) {
      t.push(mt(n, i.properties));
    });
  }) : vi(e, function(i) {
    t.push(mt(i, e.properties));
  }), ut(t);
}
function jv(e) {
  var t, i, n = {
    type: "FeatureCollection",
    features: []
  };
  if (e.type === "Feature" ? i = e.geometry : i = e, i.type === "LineString")
    t = [i.coordinates];
  else if (i.type === "MultiLineString")
    t = i.coordinates;
  else if (i.type === "MultiPolygon")
    t = [].concat.apply([], i.coordinates);
  else if (i.type === "Polygon")
    t = i.coordinates;
  else
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  return t.forEach(function(r) {
    t.forEach(function(s) {
      for (var o = 0; o < r.length - 1; o++)
        for (var l = o; l < s.length - 1; l++)
          if (!(r === s && (Math.abs(o - l) === 1 || // segments are first and last segment of lineString
          o === 0 && l === r.length - 2 && // lineString is closed
          r[o][0] === r[r.length - 1][0] && r[o][1] === r[r.length - 1][1]))) {
            var c = Uv(r[o][0], r[o][1], r[o + 1][0], r[o + 1][1], s[l][0], s[l][1], s[l + 1][0], s[l + 1][1]);
            c && n.features.push(mt([c[0], c[1]]));
          }
    });
  }), n;
}
function Uv(e, t, i, n, r, s, o, l) {
  var c, u, d, f, m, g = {
    x: null,
    y: null,
    onLine1: !1,
    onLine2: !1
  };
  return c = (l - s) * (i - e) - (o - r) * (n - t), c === 0 ? g.x !== null && g.y !== null ? g : !1 : (u = t - s, d = e - r, f = (o - r) * u - (l - s) * d, m = (i - e) * u - (n - t) * d, u = f / c, d = m / c, g.x = e + u * (i - e), g.y = t + u * (n - t), u >= 0 && u <= 1 && (g.onLine1 = !0), d >= 0 && d <= 1 && (g.onLine2 = !0), g.onLine1 && g.onLine2 ? [g.x, g.y] : !1);
}
function Vv(e, t) {
  t === void 0 && (t = {});
  var i = typeof t == "object" ? t.mutate : t;
  if (!e)
    throw new Error("geojson is required");
  var n = mi(e), r = [];
  switch (n) {
    case "LineString":
      r = vs(e);
      break;
    case "MultiLineString":
    case "Polygon":
      st(e).forEach(function(o) {
        r.push(vs(o));
      });
      break;
    case "MultiPolygon":
      st(e).forEach(function(o) {
        var l = [];
        o.forEach(function(c) {
          l.push(vs(c));
        }), r.push(l);
      });
      break;
    case "Point":
      return e;
    case "MultiPoint":
      var s = {};
      st(e).forEach(function(o) {
        var l = o.join("-");
        Object.prototype.hasOwnProperty.call(s, l) || (r.push(o), s[l] = !0);
      });
      break;
    default:
      throw new Error(n + " geometry not supported");
  }
  return e.coordinates ? i === !0 ? (e.coordinates = r, e) : { type: n, coordinates: r } : i === !0 ? (e.geometry.coordinates = r, e) : jt({ type: n, coordinates: r }, e.properties, {
    bbox: e.bbox,
    id: e.id
  });
}
function vs(e) {
  var t = st(e);
  if (t.length === 2 && !el(t[0], t[1]))
    return t;
  var i = [], n = t.length - 1, r = i.length;
  i.push(t[0]);
  for (var s = 1; s < n; s++) {
    var o = i[i.length - 1];
    t[s][0] === o[0] && t[s][1] === o[1] || (i.push(t[s]), r = i.length, r > 2 && tl(i[r - 3], i[r - 1], i[r - 2]) && i.splice(i.length - 2, 1));
  }
  if (i.push(t[t.length - 1]), r = i.length, el(t[0], t[t.length - 1]) && r < 4)
    throw new Error("invalid polygon");
  return tl(i[r - 3], i[r - 1], i[r - 2]) && i.splice(i.length - 2, 1), i;
}
function el(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function tl(e, t, i) {
  var n = i[0], r = i[1], s = e[0], o = e[1], l = t[0], c = t[1], u = n - s, d = r - o, f = l - s, m = c - o, g = u * m - d * f;
  return g !== 0 ? !1 : Math.abs(f) >= Math.abs(m) ? f > 0 ? s <= n && n <= l : l <= n && n <= s : m > 0 ? o <= r && r <= c : c <= r && r <= o;
}
function _o(e, t, i) {
  i === void 0 && (i = {});
  var n;
  i.final ? n = il(pt(t), pt(e)) : n = il(pt(e), pt(t));
  var r = n > 180 ? -(360 - n) : n;
  return r;
}
function il(e, t) {
  var i = gt(e[1]), n = gt(t[1]), r = gt(t[0] - e[0]);
  r > Math.PI && (r -= 2 * Math.PI), r < -Math.PI && (r += 2 * Math.PI);
  var s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)), o = Math.atan2(r, s);
  return (br(o) + 360) % 360;
}
function Lo(e, t, i) {
  i === void 0 && (i = {});
  var n = pt(e), r = pt(t);
  r[0] += r[0] - n[0] > 180 ? -360 : n[0] - r[0] > 180 ? 360 : 0;
  var s = Kv(n, r), o = Tu(s, "meters", i.units);
  return o;
}
function Kv(e, t, i) {
  i = i === void 0 ? He : Number(i);
  var n = i, r = e[1] * Math.PI / 180, s = t[1] * Math.PI / 180, o = s - r, l = Math.abs(t[0] - e[0]) * Math.PI / 180;
  l > Math.PI && (l -= 2 * Math.PI);
  var c = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)), u = Math.abs(c) > 1e-11 ? o / c : Math.cos(r), d = Math.sqrt(o * o + u * u * l * l), f = d * n;
  return f;
}
function xo(e, t, i, n) {
  n === void 0 && (n = {});
  var r = t < 0, s = Tu(Math.abs(t), n.units, "meters");
  r && (s = -Math.abs(s));
  var o = pt(e), l = Gv(o, s, i);
  return l[0] += l[0] - o[0] > 180 ? -360 : o[0] - l[0] > 180 ? 360 : 0, mt(l, n.properties);
}
function Gv(e, t, i, n) {
  n = n === void 0 ? He : Number(n);
  var r = t / n, s = e[0] * Math.PI / 180, o = gt(e[1]), l = gt(i), c = r * Math.cos(l), u = o + c;
  Math.abs(u) > Math.PI / 2 && (u = u > 0 ? Math.PI - u : -Math.PI - u);
  var d = Math.log(Math.tan(u / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)), f = Math.abs(d) > 1e-11 ? c / d : Math.cos(o), m = r * Math.sin(l) / f, g = s + m;
  return [
    (g * 180 / Math.PI + 540) % 360 - 180,
    u * 180 / Math.PI
  ];
}
function So(e) {
  if (!e)
    throw new Error("geojson is required");
  switch (e.type) {
    case "Feature":
      return Ru(e);
    case "FeatureCollection":
      return Hv(e);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return Eo(e);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Ru(e) {
  var t = { type: "Feature" };
  return Object.keys(e).forEach(function(i) {
    switch (i) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        t[i] = e[i];
    }
  }), t.properties = $u(e.properties), t.geometry = Eo(e.geometry), t;
}
function $u(e) {
  var t = {};
  return e && Object.keys(e).forEach(function(i) {
    var n = e[i];
    typeof n == "object" ? n === null ? t[i] = null : Array.isArray(n) ? t[i] = n.map(function(r) {
      return r;
    }) : t[i] = $u(n) : t[i] = n;
  }), t;
}
function Hv(e) {
  var t = { type: "FeatureCollection" };
  return Object.keys(e).forEach(function(i) {
    switch (i) {
      case "type":
      case "features":
        return;
      default:
        t[i] = e[i];
    }
  }), t.features = e.features.map(function(i) {
    return Ru(i);
  }), t;
}
function Eo(e) {
  var t = { type: e.type };
  return e.bbox && (t.bbox = e.bbox), e.type === "GeometryCollection" ? (t.geometries = e.geometries.map(function(i) {
    return Eo(i);
  }), t) : (t.coordinates = Iu(e.coordinates), t);
}
function Iu(e) {
  var t = e;
  return typeof t[0] != "object" ? t.slice() : t.map(function(i) {
    return Iu(i);
  });
}
function Wv(e, t, i) {
  if (i = i || {}, !vo(i)) throw new Error("options is invalid");
  var n = i.pivot, r = i.mutate;
  if (!e) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("angle is required");
  return t === 0 || (n || (n = hi(e)), (r === !1 || r === void 0) && (e = So(e)), vi(e, function(s) {
    var o = _o(n, s), l = o + t, c = Lo(n, s), u = st(xo(n, c, l));
    s[0] = u[0], s[1] = u[1];
  })), e;
}
function Zv(e, t) {
  t === void 0 && (t = {});
  var i = wi(e), n = (i[0] + i[2]) / 2, r = (i[1] + i[3]) / 2;
  return mt([n, r], t.properties, t);
}
function Qv(e, t, i) {
  if (i = i || {}, !vo(i)) throw new Error("options is invalid");
  var n = i.origin, r = i.mutate;
  if (!e) throw new Error("geojson required");
  if (typeof t != "number" || t === 0)
    throw new Error("invalid factor");
  var s = Array.isArray(n) || typeof n == "object";
  return r !== !0 && (e = So(e)), e.type === "FeatureCollection" && !s ? (bi(e, function(o, l) {
    e.features[l] = nl(o, t, n);
  }), e) : nl(e, t, n);
}
function nl(e, t, i) {
  var n = mi(e) === "Point";
  return i = Jv(e, i), t === 1 || n || vi(e, function(r) {
    var s = Lo(i, r), o = _o(i, r), l = s * t, c = st(xo(i, l, o));
    r[0] = c[0], r[1] = c[1], r.length === 3 && (r[2] *= t);
  }), e;
}
function Jv(e, t) {
  if (t == null && (t = "centroid"), Array.isArray(t) || typeof t == "object")
    return pt(t);
  var i = e.bbox ? e.bbox : wi(e), n = i[0], r = i[1], s = i[2], o = i[3];
  switch (t) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return mt([n, r]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return mt([s, r]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return mt([n, o]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return mt([s, o]);
    case "center":
      return Zv(e);
    case void 0:
    case null:
    case "centroid":
      return hi(e);
    default:
      throw new Error("invalid origin");
  }
}
function Yv(e, t, i, n) {
  if (n = n || {}, !vo(n)) throw new Error("options is invalid");
  var r = n.units, s = n.zTranslation, o = n.mutate;
  if (!e) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("distance is required");
  if (s && typeof s != "number" && isNaN(s))
    throw new Error("zTranslation is not a number");
  if (s = s !== void 0 ? s : 0, t === 0 && s === 0) return e;
  if (i == null || isNaN(i))
    throw new Error("direction is required");
  return t < 0 && (t = -t, i = i + 180), (o === !1 || o === void 0) && (e = So(e)), vi(e, function(l) {
    var c = st(
      xo(l, t, i, { units: r })
    );
    l[0] = c[0], l[1] = c[1], s && l.length === 3 && (l[2] += s);
  }), e;
}
function zu(e) {
  const t = e.params;
  a.has(t, "query.east") && (a.set(t, "east", a.get(t, "query.east")), a.unset(t, "query.east")), a.has(t, "query.west") && (a.set(t, "west", a.get(t, "query.west")), a.unset(t, "query.west")), a.has(t, "query.north") && (a.set(t, "north", a.get(t, "query.north")), a.unset(t, "query.north")), a.has(t, "query.south") && (a.set(t, "south", a.get(t, "query.south")), a.unset(t, "query.south"));
}
async function Bs(e, t, i) {
  const n = await e._get(t), r = a.get(n, "referenceCount", 0) + i;
  return await e._patch(t, { referenceCount: r });
}
async function Nu(e) {
  const t = e.service, i = Array.isArray(e.data) ? e.data : [e.data];
  for (let n = 0; n < i.length; n++) {
    const r = i[n];
    try {
      await Bs(t, r._id, 1);
    } catch {
      r.referenceCount = 1, await t._create(r);
    }
  }
  e.result = e.data;
}
async function qu(e) {
  const t = e.service;
  if (e.id) {
    const i = await Bs(t, e.id, -1);
    i.referenceCount <= 0 && await t._remove(e.id), e.result = i;
  } else {
    e.result = await t._find(Object.assign(e.params, { paginate: !1 }));
    for (let i = 0; i < e.result.length; i++) {
      const n = e.result[i];
      try {
        const { referenceCount: r } = await Bs(t, n._id, -1);
        r <= 0 && await t._remove(n._id);
      } catch (r) {
        I.debug("[KDK] reference count update failed: ", r);
      }
    }
  }
}
function ju(e) {
  const t = e.result, i = t.data;
  a.get(i, "[0].type") === "Feature" && (e.result = Object.assign({
    type: "FeatureCollection",
    features: t.data
  }, a.pick(t, ["total", "skip", "limit"])));
}
async function Uu(e) {
  const t = e.params;
  if (!a.has(t, "east") || !a.has(t, "west") || !a.has(t, "north") || !a.has(t, "south")) return e;
  const r = (await e.service._find(a.omit(t, ["east", "west", "north", "south"]))).data, s = yo([[[t.east, t.south], [t.west, t.south], [t.west, t.north], [t.east, t.north], [t.east, t.south]]]);
  let o = [];
  for (let l of r)
    Fu(s, l) && o.push(l);
  a.set(e, "result.data", o);
}
const Xv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geoJsonPaginationHook: ju,
  intersectBBoxHook: Uu,
  referenceCountCreateHook: Nu,
  referenceCountRemoveHook: qu,
  removeServerSideParameters: zu
}, Symbol.toStringTag, { value: "Module" })), un = Symbol.for("leaflet-event-listeners");
function kt(e, t, i, n) {
  e[un] = [], t.forEach((r) => {
    const s = (...o) => {
      n ? i.$engineEvents.emit(r, n, ...o) : i.$engineEvents.emit(r, ...o);
    };
    e[un].push(s), e.on(r, s);
  });
}
function xr(e, t) {
  e[un] && (t.forEach((n, r) => {
    e.off(n, e[un][r]);
  }), delete e[un]);
}
const Ln = ["touchstart", "touchmove", "touchend", "touchcancel"], Zt = {
  Map: [
    "baselayerchange",
    "overlayadd",
    "overlayremove",
    "layeradd",
    "layerremove",
    "zoomlevelschange",
    "resize",
    "unload",
    "viewreset",
    "load",
    "zoomstart",
    "boxzoomstart",
    "boxselectionstart",
    "movestart",
    "zoom",
    "move",
    "rotate",
    "zoomend",
    "boxzoomend",
    "boxselectionend",
    "moveend",
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "mousemove",
    "contextmenu",
    "keypress",
    "preclick",
    "moveend",
    "zoomanim",
    "fullscreenchange"
  ].concat(Ln),
  Popup: ["add", "remove"],
  Tooltip: ["add", "remove"],
  Layer: ["add", "remove", "popupopen", "popupclose", "tooltipopen", "tooltipclose"],
  Feature: [
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "contextmenu",
    "dragstart",
    "dragend",
    "drag",
    "movestart",
    "moveend",
    "move"
  ].concat(Ln),
  Cluster: ["spiderfied", "unspiderfied"]
};
function rl(e) {
  const t = [], i = [], n = e.properties.gradient, r = wi(e);
  let s = r[2] - r[0], o = r[3] - r[1];
  s === 0 && (s = 0.1), o === 0 && (o = 0.1), r[0] -= s * 0.1, r[1] -= o * 0.1, r[2] += s * 0.1, r[3] += o * 0.1;
  const l = B.Projection.SphericalMercator.project(B.GeoJSON.coordsToLatLng(r.slice(0, 2))), c = B.Projection.SphericalMercator.project(B.GeoJSON.coordsToLatLng(r.slice(2, 4))), u = { x: Math.min(l.x, c.x), y: Math.min(l.y, c.y) }, d = { x: Math.max(l.x, c.x), y: Math.max(l.y, c.y) }, f = { x: d.x - u.x, y: d.y - u.y }, m = { x: f.x > f.y ? 1 : f.x / f.y, y: f.y > f.x ? 1 : f.y / f.x }, g = (p) => [m.x * ((p.x - u.x) / f.x), m.y * (1 - (p.y - u.y) / f.y)], v = `${r.join("_")}_${n.length}`, S = B.GeoJSON.coordsToLatLngs(e.geometry.coordinates).map((p) => g(B.Projection.SphericalMercator.project(p)));
  for (let p = 0; p < n.length - 1; ++p) {
    const y = S[p], w = S[p + 1];
    t.push(`<linearGradient gradientUnits="userSpaceOnUse" x1="${y[0]}" y1="${y[1]}" x2="${w[0]}" y2="${w[1]}" id="gradient${p}_${v}"><stop offset="0" stop-color="${n[p]}"/><stop offset="1" stop-color="${n[p + 1]}"/></linearGradient>`), i.push(`<path d="M ${y[0]} ${y[1]} L ${w[0]} ${w[1]}" stroke="url(#gradient${p}_${v})" vector-effect="non-scaling-stroke" class="leaflet-interactive"/>`);
  }
  var A = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  return A.setAttribute("xmlns", "http://www.w3.org/2000/svg"), A.setAttribute("viewBox", `0 0 ${m.x} ${m.y}`), A.innerHTML = `<g stroke-linecap="round" stroke-width="${e.properties.weight}"><defs>${t.join("")}</defs>${i.join("")}</g>`, { svg: A, bounds: B.latLngBounds(B.latLng(r[1], r[0]), B.latLng(r[3], r[2])) };
}
const Vu = B.SVGOverlay.extend({
  initialize(e, t) {
    const i = rl(e);
    B.SVGOverlay.prototype.initialize.call(this, i.svg, i.bounds, Object.assign({ interactive: !1 }, t));
    const n = a.get(e.properties, "opacity");
    n !== void 0 && this.setOpacity(n);
  },
  getCenter() {
    return this._bounds.getCenter();
  },
  // This method is called when source data changes
  setData(e) {
    this.onRemove();
    const t = rl(e);
    this._url = t.svg, this._initImage(), this.setBounds(t.bounds);
    const i = a.get(e.properties, "opacity");
    i !== void 0 && this.setOpacity(i), this.onAdd();
  },
  onAdd() {
    B.SVGOverlay.prototype.onAdd.call(this), this.addInteractiveTarget(this._image);
  }
}), Ku = B.PixiOverlay.extend({
  initialize(e, t) {
    B.setOptions(this, Object.assign({ stroke: "#FFFFFF", weight: 8 }, t)), this.path = {
      geometry: null,
      bounds: null
    }, this.rope = null, this.container = new Ee.Container(), Object.assign(this.container, {
      interactive: !0,
      buttonMode: !0
    }), B.PixiOverlay.prototype.initialize.call(
      this,
      (i) => this.render(i),
      this.container,
      {
        autoPreventDefault: !1,
        // see: https://github.com/kalisio/kdk/issues/424
        projectionZoom: () => 12
      }
    ), this.currentZoom = -1, e && this.setData(e);
  },
  setData(e) {
    const t = a.get(e, "type"), i = a.get(e, "geometry.type"), n = a.get(e, "geometry.coordinates");
    if (t !== "Feature" || i !== "LineString" || !Array.isArray(n)) {
      I.warn("Invalid/Unsupported GeoJson object for Gradient Path");
      return;
    }
    this.path.bounds = new B.LatLngBounds(), n.forEach((o) => this.path.bounds.extend([o[1], o[0]]));
    const r = a.get(e, "properties.gradient", a.get(e, "properties.stroke", a.get(this.options, "stroke"))), s = a.get(e, "properties.weight", a.get(this.options, "weight"));
    this.path.geometry = { coords: n, gradient: r, weight: s }, this.currentZoom = -1, this.redraw();
  },
  onAdd(e) {
    this.clickEventHandler = this.handleClickEvent.bind(this), e.on("click", this.clickEventHandler), this.moveEventHandler = this.handleMoveEvent.bind(this), e.on("mousemove", this.moveEventHandler), B.PixiOverlay.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    e.off("click", this.clickEventHandler), e.off("mousemove", this.moveEventHandler), this.rope && (this.container.removeChild(this.rope), this.rope.texture.destroy(!0), this.rope.destroy(!0), this.rope = null), this.container.destroy(!0), B.PixiOverlay.prototype.onRemove.call(this, e);
  },
  getBounds() {
    return this.path.bounds;
  },
  getCenter() {
    const e = Math.floor(this.path.geometry.coords.length / 2), t = this.path.geometry.coords[e];
    return [t[1], t[0]];
  },
  getObjectUnderPointer(e) {
    const t = new Ee.Point();
    return this.renderer.events.mapPositionToPoint(t, e.originalEvent.clientX, e.originalEvent.clientY), new Ee.EventBoundary(this.container).hitTest(t.x, t.y);
  },
  handleClickEvent(e) {
    if (!this.getPopup()) return;
    this.getObjectUnderPointer(e) ? this.isPopupOpen() ? this.closePopup() : this.openPopup(e.latlng) : this.isPopupOpen() && this.closePopup();
  },
  handleMoveEvent(e) {
    if (!this.getTooltip()) return;
    this.getObjectUnderPointer(e) ? (this.isTooltipOpen() || this.openTooltip(), this._moveTooltip(e)) : this.isTooltipOpen() && this.closeTooltip();
  },
  createSolidTexture(e, t) {
    const i = document.createElement("canvas");
    i.width = 8, i.height = t;
    const n = i.getContext("2d");
    return n.fillStyle = e, n.fillRect(0, 0, i.width, i.height), Ee.Texture.from(i);
  },
  createGradientTexture(e, t) {
    const i = document.createElement("canvas");
    i.width = e.length, i.height = t;
    const n = i.getContext("2d"), r = n.createLinearGradient(0, 0, i.width, 1);
    for (let s = 0; s < e.length; s++)
      r.addColorStop(s / (e.length - 1), e[s]);
    return n.fillStyle = r, n.fillRect(0, 0, i.width, i.height), Ee.Texture.from(i);
  },
  render(e) {
    const t = e.getMap().getZoom();
    if (t !== this.currentZoom) {
      this.renderer = e.getRenderer();
      let i = null;
      const n = Math.max(1, 2048 * this.path.geometry.weight / Math.pow(2, t));
      Array.isArray(this.path.geometry.gradient) ? i = this.createGradientTexture(this.path.geometry.gradient, n) : i = this.createSolidTexture(this.path.geometry.gradient, n);
      const r = this.path.geometry.coords.map((s) => e.latLngToLayerPoint([s[1], s[0]]));
      this.rope && (this.container.removeChild(this.rope), this.rope.texture.destroy(!0), this.rope.destroy(!0)), this.rope = new Ee.SimpleRope(i, r), this.container.addChild(this.rope), this.currentZoom = t;
    }
    this.renderer.render(this.container);
  }
});
B.GradientPath = Ku;
B.SVGGradientPath = Vu;
B.gradientPath = function(e) {
  return new B.GradientPath(e);
};
B.svgGradientPath = function(e) {
  return new B.SVGGradientPath(e);
};
function sl(e) {
  const t = [];
  return Object.keys(e).forEach((n) => t.push(e[n])), t;
}
const eb = B.Realtime.extend({
  // Override default remove handler for leaflet-realtime due to
  // https://github.com/perliedman/leaflet-realtime/issues/177
  remove(e) {
    return typeof e > "u" ? B.Layer.prototype.remove.call(this) : B.Realtime.prototype.remove.call(this, e);
  },
  // Add FeatureGroup interface so that layer edition works as well
  toGeoJSON() {
    return { type: "FeatureCollection", features: sl(this._features) };
  },
  clearLayers() {
    this._onNewData(!0, { type: "FeatureCollection", features: [] });
  },
  getLayers() {
    return sl(this._featureLayers);
  },
  addLayer(e) {
    this._onNewData(!1, e.toGeoJSON());
  },
  removeLayer(e) {
    this.remove(e.toGeoJSON());
  },
  // Additional missing features
  bringToFront() {
    this.options.pane !== "overlayPane" ? B.DomUtil.toFront(this.getPane(this.options.pane)) : this._container && this._container.bringToFront();
  },
  bringToBack() {
    this.options.pane !== "overlayPane" ? B.DomUtil.toBack(this.getPane(this.options.pane)) : this._container && this._container.bringToBack();
  }
});
B.realtime = function(e, t) {
  return new eb(e, t);
};
const tb = B.MarkerClusterGroup.extend({
  // Override invoke as used by eg bringToFront/bringToBack
  invoke(e, ...t) {
    return B.MarkerClusterGroup.prototype.invoke.call(this, e, t), this._featureGroup.invoke(e, t), this._nonPointGroup.invoke(e, t), this;
  }
});
B.markerClusterGroup = function(e) {
  return new tb(e);
};
const ib = B.Polyline.prototype._simplifyPoints;
B.Polyline.include({
  _simplifyPoints: function() {
    if (ib.call(this), this.options.offset) {
      const e = this.getBounds().getCenter().lat, t = 156543 / Math.pow(2, this._map.getZoom()) / Math.cos(e * Math.PI / 180), i = Math.max(1, this.options.offset * t);
      for (let n = 0; n < this._parts.length; n++) {
        let r = this._parts[n].map((l) => this._map.layerPointToLatLng(l));
        const s = B.GeoJSON.latLngsToCoords(r, 0, !1, 12), o = lh({ type: "LineString", coordinates: s }, i, { units: "meters" });
        r = B.GeoJSON.coordsToLatLngs(o.geometry.coordinates, 0), this._parts[n] = r.map((l) => this._map.latLngToLayerPoint(l));
      }
    }
  }
});
const nb = B.GeoJSON.geometryToLayer;
B.GeoJSON.geometryToLayer = function(e, t) {
  const i = e.geometry, n = e.properties;
  if (i && n && n.geodesic) {
    if (i.type === "LineString")
      return new B.Geodesic(
        [B.GeoJSON.coordsToLatLngs(i.coordinates, 0)],
        Object.assign({ steps: 4 }, t.style(e))
      );
    if (i.type === "MultiLineString") {
      const s = i.coordinates.map((o) => B.GeoJSON.coordsToLatLngs(o, 0));
      return new B.Geodesic(s, Object.assign({ steps: 4 }, t.style(e)));
    } else if (i.type === "Point")
      return new B.GeodesicCircle(
        B.GeoJSON.coordsToLatLng(i.coordinates),
        Object.assign({ fill: !0, steps: 360, radius: n.radius }, t.style(e))
      );
  }
  if (i && n && n.gradient) {
    const s = t.style(e);
    return n.svg ? new Vu(e, s) : new Ku(e, s);
  }
  if (i && n && n.mask && (i.type === "Polygon" || i.type === "MultiPolygon"))
    return new MaskLayer(e, t.style(e));
  i && n && n.offset && i.type === "LineString" && (t = Object.assign({ offset: n.offset }, t));
  const r = nb(e, t);
  return i && (t.arrowheads || n && n.arrowheads) && r instanceof B.Polyline && r.arrowheads(t.arrowheads || n.arrowheads), r;
};
function Gu(e) {
  return (i, n) => {
    if (!n) return;
    const r = a.get(n, "feature.geometry.type"), s = a.get(i, "geometry.type"), o = a.get(e, "staticGeometry", !1);
    if (!o && s !== r) return;
    if (o && (i.geometry = a.get(n, "feature.geometry")), e.onEachFeature(i, n), n.setStyle) {
      if (i.geometry.type === "Point")
        return;
      if (a.get(n.feature, "style.pane") !== a.get(i, "style.pane")) return;
      n.setStyle(e.style(i));
    }
    a.defaultsDeep(i, a.pick(n.feature, ["time", "runTime"]));
    const l = a.get(n.feature, "properties");
    if (l && (i.properties || (i.properties = {}), a.defaults(i.properties, l)), n.setIcon)
      return;
    if (o) return n;
    const c = i.geometry.coordinates;
    switch (s) {
      case "Point":
        n.setLatLng(B.GeoJSON.coordsToLatLngs(c));
        break;
      case "LineString":
      case "MultiLineString":
        if (typeof n.setData == "function")
          n.setData(i);
        else if (i.properties.geodesic) {
          const u = s === "LineString" ? [B.GeoJSON.coordsToLatLngs(c, 0)] : c.map((d) => B.GeoJSON.coordsToLatLngs(d, 0));
          n.setLatLngs(u);
        } else
          n.setLatLngs(B.GeoJSON.coordsToLatLngs(c, s === "LineString" ? 0 : 1));
        break;
      case "Polygon":
      case "MultiPolygon":
        n.setLatLngs(B.GeoJSON.coordsToLatLngs(c, s === "Polygon" ? 1 : 2));
        break;
    }
    return n;
  };
}
const tr = {
  // Filter to identify layers that require an update at a given frequency
  TimeUpdate: {
    // Possible for realtime layers only
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    $or: [
      // Supported by template URL or time-based features service
      { "leaflet.sourceTemplate": { $exists: !0 } },
      { service: { $exists: !0 } }
    ],
    // Skip layers powered by realtime service events
    serviceEvents: { $ne: !0 },
    // Skip invisible layers
    isVisible: !0
  },
  // Filter to identify layers with variables affected by a unit change
  UnitUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    // Not sure why but this does not seem to work with sift
    //'variables': { $elemMatch: { unit: { $in: units } } },
    variables: { $exists: !0 },
    isVisible: !0,
    $or: [{
      "leaflet.style": { $exists: !0 },
      "leaflet.template": { $exists: !0 }
    }, {
      "leaflet.tooltip.template": { $exists: !0 }
    }]
  },
  // Filter to identify layers with tooltip defining a minZoom/maxZoom
  // thus affected by a zoom change
  TooltipUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    isVisible: !0,
    // Supported by permanent tooltips only
    "leaflet.tooltip.options.permanent": !0,
    $or: [
      { "leaflet.tooltip.minZoom": { $exists: !0 } },
      { "leaflet.tooltip.maxZoom": { $exists: !0 } }
    ]
  }
};
function Hu(e, t) {
  const i = a.intersection(e, a.map(t.variables, "unit"));
  if (a.isEmpty(i)) return !1;
  if (a.get(t, "leaflet.tooltip.template", "").includes("Units")) return !0;
  for (const n of t.leaflet.template)
    if (n.startsWith("style.")) {
      const r = a.get(t.leaflet, n);
      if (typeof r == "string" && r.includes("Units")) return !0;
    }
  return !1;
}
function Wu(e) {
  e = Dn(e), e = a.pickBy(e, (n) => !a.isNil(n));
  const t = a.keys(e);
  let i;
  if (t.length === 0) return null;
  if (t.length === 1) i = a.get(e, t[0]);
  else {
    const n = ' style="border: 1px solid black; border-collapse: collapse;"';
    i = "<table" + n + ">", i += t.map((r) => "<tr" + n + "><th" + n + ">" + r + "</th><th>" + a.get(e, r) + "</th></tr>").join(""), i += "</table>";
  }
  return i;
}
const Zu = {
  size: "marker-size",
  color: "marker-color",
  url: "marker-symbol"
}, Qu = {
  shape: "marker-symbol",
  size: "marker-size",
  color: "marker-color",
  "icon.url": "marker-symbol"
}, Ju = {
  fill: "color",
  "fill-opacity": "opacity",
  radius: "radius",
  stroke: "stroke.color",
  "marker-symbol": "shape",
  "marker-size": "size",
  "marker-color": "color",
  "marker-anchor": "anchor",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  icon: "icon.url",
  "icon-url": "icon.url",
  "icon-html": "html",
  "icon-color": "icon.color",
  "icon-size": "icon.size",
  "icon-anchor": "anchor",
  "icon-class": "icon.classes",
  "icon-opacity": "icon.opacity",
  "icon-classes": "icon.classes",
  "icon-translate": "icon.translate",
  "icon-rotate": "icon.rotate",
  "z-index": "pane",
  pane: "pane"
}, Yu = {
  stroke: "style.point.stroke.color",
  "stroke-color": "style.point.stroke.color",
  "stroke-opacity": "style.point.stroke.opacity",
  "stroke-width": "style.point.stroke.width",
  fill: "style.point.color",
  "fill-opacity": "style.point.opacity",
  "fill-color": "style.point.color",
  weight: "style.point.stroke.width",
  radius: "style.point.radius",
  "line-cap": "style.point.stroke.lineCap",
  "line-join": "style.point.stroke.lineJoin",
  "dash-array": "style.point.stroke.dashArray",
  "dash-offset": "style.point.stroke.dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-translate": "style.point.icon.translate",
  "z-index": "style.point.pane",
  pane: "style.point.pane"
}, Xu = {
  color: "stroke",
  width: "stroke-width",
  opacity: "stroke-opacity"
}, ed = {
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "width",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  weight: "width",
  "z-index": "pane",
  pane: "pane"
}, td = {
  stroke: "style.line.color",
  "stroke-color": "style.line.color",
  "stroke-opacity": "style.line.opacity",
  "stroke-width": "style.line.width",
  weight: "style.line.width",
  "line-cap": "style.line.cap",
  "line-join": "style.line.join",
  "dash-array": "style.line.dashArray",
  "dash-offset": "style.line.dashOffset",
  "z-index": "style.line.pane",
  pane: "style.line.pane"
}, id = {
  color: "fill",
  opacity: "fill-opacity"
}, nd = {
  stroke: "stroke.color",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  fill: "color",
  "fill-color": "color",
  "fill-opacity": "opacity",
  "z-index": "pane",
  pane: "pane"
}, rd = {
  stroke: "style.polygon.stroke.color",
  "stroke-color": "style.polygon.stroke.color",
  "stroke-opacity": "style.polygon.stroke.opacity",
  "stroke-width": "style.polygon.stroke.width",
  fill: "style.polygon.color",
  "fill-opacity": "style.polygon.opacity",
  "fill-color": "style.polygon.color",
  weight: "style.polygon.stroke.width",
  "line-cap": "style.polygon.stroke.cap",
  "line-join": "style.polygon.stroke.join",
  "dash-array": "style.polygon.stroke.dashArray",
  "dash-offset": "style.polygon.stroke.dashOffset",
  "z-index": "style.polygon.pane",
  pane: "style.polygon.pane"
}, xn = ["marker-size", "stroke-width", "stroke-opacity", "fill-opacity"], Co = {
  isVisible: !0,
  isSelectable: !0,
  point: {
    color: "red",
    opacity: 0.5,
    size: 24,
    shape: "circle",
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    },
    icon: {
      classes: "",
      color: "black",
      opacity: 1,
      size: 12
    }
  },
  line: {
    color: "red",
    width: 3,
    opacity: 1
  },
  polygon: {
    color: "red",
    opacity: 0.5,
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    }
  },
  leaflet: {
    cluster: { disableClusteringAtZoom: 18 }
  },
  cesium: {
    cluster: { pixelRange: 80 }
  }
};
function Ot(e, t, i = []) {
  let n = {};
  return a.forOwn(e, (r, s) => {
    const o = a.get(t, s);
    o && a.set(n, o, i.includes(o) ? a.toNumber(r) : r);
  }), n;
}
function rb(e) {
  return a.forOwn(e, (t, i) => {
    if (["stroke", "fill", "marker-color"].includes(i)) {
      const n = Vl(t);
      n && a.set(e, i, n);
    }
  }), e;
}
function sb(e) {
  return e ? Object.assign(Ot(e.icon, Zu, xn), Ot(e, Qu, xn)) : {};
}
function An(e) {
  return e ? Ot(e, Ju) : {};
}
function sd(e) {
  return e ? Ot(e, Xu, xn) : {};
}
function On(e) {
  return e ? Ot(e, ed) : {};
}
function ob(e) {
  return e ? Object.assign(Ot(e, id, xn), sd(e.stroke)) : {};
}
function Bn(e) {
  return e ? Ot(e, nd) : {};
}
function ab(e, t = [20, 20]) {
  let i = a.get(e, "stroke");
  if (i) {
    let n = a.get(i, "width", 1);
    n > 1 && (n = n / 4), i = { stroke: { width: n } };
  }
  return a.merge({}, e, { size: t }, i);
}
function lb(e, t = [20, 20]) {
  let i = a.get(e, "width", 1);
  return i > 1 && (i = i / 4), { shape: "polyline", stroke: a.merge({}, e, { width: i }), size: t };
}
function cb(e, t = [20, 20]) {
  let i = a.get(e, "stroke");
  if (i) {
    let n = a.get(i, "width", 1);
    n > 1 && (n = n / 4), i = { stroke: { width: n } };
  }
  return a.merge({}, e, { shape: "polygon" }, { size: t }, i);
}
function Vr(e) {
  const t = {};
  return e = Dn(e), a.forIn(e, (i, n) => {
    if (!a.isString(i)) {
      a.set(t, n, i);
      return;
    }
    const r = i.match(/} else { %>(.*)<% } %>/);
    r ? a.set(t, n, r[1]) : a.set(t, n, i);
  }), t;
}
function To(e, t, i = !0) {
  const n = t.length > 0, r = {}, s = a.keys(Dn(a.pick(Co, ["point", "line", "polygon"]))), o = s.map((l) => "");
  return t.forEach((l) => {
    let c = "";
    l.conditions.forEach((u, d) => {
      const f = d === 0 ? "" : u.booleanOperator === "and" ? " && " : " || ", m = typeof u.value != "number" ? `${u.property}.toString()` : u.property;
      if (["in", "nin"].includes(u.comparisonOperator)) {
        const g = u.value.map((x) => typeof x != "number" ? `"${x}"` : x).join(","), v = u.comparisonOperator === "nin" ? "!" : "";
        c += `${f}${v}[${g}].includes(properties.${m})`;
      } else {
        const g = { eq: "===", ne: "!==", gt: ">", gte: ">=", lt: "<", lte: "<=" }[u.comparisonOperator], v = typeof u.value != "number" ? `"${u.value}"` : u.value;
        c += `${f}properties.${m} ${g} ${v}`;
      }
    }), s.forEach((u, d) => {
      if (!a.has(l.values, u)) return;
      const f = u.includes("color") ? As(a.get(l.values, u)) : a.get(l.values, u);
      o[d] += `if (${c}) { %>${f}<% } else `;
    });
  }), s.forEach((l, c) => {
    if (!a.has(e, l)) return;
    const u = l.includes("color") ? As(a.get(e, l)) : a.get(e, l);
    n ? o[c] += `{ %>${u}<% }` : o[c] = u;
  }), s.forEach((l, c) => {
    a.has(e, l) && (i ? r[`style.${l}`] = n ? `<% ${o[c]} %>` : o[c] : a.set(r, `style.${l}`, n ? `<% ${o[c]} %>` : o[c]));
  }), r.template = (n ? s : []).map((l) => `style.${l}`), r;
}
function Po(e) {
  const t = (n, r, s = null) => {
    if (!n) return;
    const o = a.keys(n)[0];
    let l, c, u;
    o === "$and" || o === "$or" ? (l = a.keys(n[o][0])[0], c = a.keys(n[o][0][l])[0], u = n[o][0][l][c]) : (l = a.keys(n)[0], a.isObject(n[l]) ? (c = a.keys(n[l])[0], u = n[l][c]) : (c = "$eq", u = n[l])), r.push({
      index: r.length,
      booleanOperator: s && s.replace("$", ""),
      property: l.replace("properties.", ""),
      comparisonOperator: c.replace("$", ""),
      value: u
    }), (o === "$and" || o === "$or") && t(n[o][1], r, o);
  }, i = [];
  return t(e, i), i;
}
const ub = B.Marker.extend({
  // Constructor
  initialize(e, t) {
    const i = a.get(t, "options", {});
    if (Object.assign(i, a.pick(t, ["interactive", "draggable", "pane", "shadowPane"])), t.icon instanceof B.Icon)
      B.Marker.prototype.initialize.call(this, e, {
        icon: t.icon,
        ...i
      });
    else {
      const n = du(t);
      n ? B.Marker.prototype.initialize.call(this, e, {
        icon: B.divIcon({
          iconSize: [n.size.width, n.size.height],
          iconAnchor: this.getAnchor(n.anchor, n.size),
          popupAnchor: [0, -n.size.height / 2],
          html: n.html,
          className: ""
        }),
        ...i
      }) : I.warn(`[KDK] unable to create the shape with the options: ${t}`);
    }
  },
  getAnchor(e, t) {
    return e === "top-left" ? [0, 0] : e === "top-center" ? [t.width / 2, 0] : e === "top-right" ? [t.width, 0] : e === "middle-left" ? [0, t.height / 2] : e === "middle-right" ? [t.width, t.height / 2] : e === "middle-left" ? [0, t.height / 2] : e === "bottom-left" ? [0, t.height] : e === "bottom-center" ? [t.width / 2, t.height] : e === "bottom-right" ? [t.width, t.height] : [t.width / 2, t.height / 2];
  },
  // Additional missing features
  bringToFront() {
    this._icon && B.DomUtil.toFront(this._icon), this._shadow && B.DomUtil.toFront(this._shadow);
  },
  bringToBack() {
    this._icon && B.DomUtil.toBack(this._icon), this._shadow && B.DomUtil.toBack(this._shadow);
  }
});
B.shapeMarker = function(e, t) {
  return new ub(e, t);
};
const Rs = {
  "z-index": "pane",
  pane: "pane",
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "weight",
  fill: "fillColor",
  "fill-opacity": "fillOpacity",
  "fill-color": "fillColor",
  weight: "weight",
  radius: "radius",
  "line-cap": "lineCap",
  "line-join": "lineJoin",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-x-offset": "style.point.icon.xOffset",
  "icon-y-offset": "style.point.icon.yOffset",
  "style-line-color": "color",
  "style-line-width": "weight",
  "style-line-opacity": "opacity",
  "style-line-cap": "lineCap",
  "style-line-join": "lineJoin",
  "style-line-dash-array": "dashArray",
  "style-line-dash-offset": "dashOffset",
  "style-polygon-color": "fillColor",
  "style-polygon-opacity": "fillOpacity",
  "style-polygon-rule": "fillRule",
  "style-polygon-stroke-color": "color",
  "style-polygon-stroke-width": "weight",
  "style-polygon-stroke-opacity": "opacity",
  "style-polygon-stroke-cap": "lineCap",
  "style-polygon-stroke-join": "lineJoin",
  "style-polygon-stroke-dash-array": "dashArray",
  "style-polygon-stroke-dash-offset": "dashOffset"
}, db = {
  color: "color",
  width: "weight",
  opacity: "opacity",
  cap: "lineCap",
  join: "lineJoin",
  dashArray: "dashArray",
  dashOffset: "dashOffset",
  pane: "pane"
}, fb = {
  color: "fillColor",
  opacity: "fillOpacity",
  rule: "fillRule",
  pane: "pane"
};
function hb(e, t) {
  if (!e) return {};
  const i = t ? e : {};
  let n = a.has(e, "icon");
  return n && a.set(i, "icon", a.get(e, "icon")), a.forOwn(e, (r, s) => {
    if (a.has(Rs, s)) {
      const o = a.get(Rs, s);
      switch (s) {
        case "marker-size":
        case "marker-anchor":
        case "icon-anchor":
          Array.isArray(r) || (r = [r, r]), a.set(i, o, r);
          break;
        default:
          a.set(i, o, r);
      }
      t && a.unset(e, s), o.startsWith("icon") && (n = !0);
    }
  }), n && (a.has(e, "marker.type") || (a.has(e, "icon-url") || a.has(e, "icon-html") ? a.set(i, "type", "marker") : a.has(e, "icon-classes") && a.set(i, "type", "shapeMarker"))), a.has(i, "pane") && a.set(i, "pane", a.get(i, "pane").toString()), a.has(i, "shadowPane") && a.set(i, "shadowPane", a.get(i, "shadowPane").toString()), i;
}
function Mo(e, t) {
  if (!e) {
    I.warn("[KDK] 'latlng' should be defined");
    return;
  }
  const i = a.get(t, "shape", "circle");
  return i === "none" || a.has(Ni, i) ? B.shapeMarker(e, t) : B[i](e, t);
}
function ko(e) {
  if (!e) return;
  let t = Ot(e, db);
  return t.color = Qt(t.color, "black"), t;
}
function Fo(e) {
  if (!e) return;
  let t = Ot(e, fb);
  return e.stroke ? Object.assign(t, ko(e.stroke)) : t.stroke = !1, t.fillColor = Qt(t.fillColor, "black"), t;
}
function Do(e, t, i, n, r) {
  if (!i) return;
  const s = i.leaflet || i, o = Object.assign({ properties: t.properties, feature: t, zoom: r, chroma: Xt, moment: he, Units: Me, Time: be }, ro.get());
  s.template && (i.variables && (o.variables = a.reduce(
    i.variables,
    (u, d) => Object.assign(u, { [d.name]: d }),
    {}
  )), s.template.forEach((u) => {
    a.set(e, a.get(n, a.kebabCase(u.property), u.property), u.compiler(o));
  }));
  const l = Xr(t);
  let c = a.get(e, `style.${l}.visibility`, a.get(e, "style.visibility", !0));
  return typeof c == "string" && (c = c === "true"), c || a.set(e, `style.${l}.pane`, "kdk-hidden-features"), s.pane && !a.has(e, `style.${l}.pane`) && a.set(e, `style.${l}.pane`, s.pane), s.shadowPane && !a.has(e, `style.${l}.shadowPane`) && a.set(e, `style.${l}.shadowPane`, s.shadowPane), a.has(s, "interactive") && !a.has(e, `style.${l}.interactive`) && a.set(e, `style.${l}.interactive`, s.interactive), e;
}
function Ao(e, t, i = {}, n) {
  const r = t ? a.get(t.leaflet || t, "layerPointStyle") : {}, s = Do({ style: { point: a.merge({}, i, r) } }, e, t, Yu, n), o = a.get(t, "ignoreFeatureStyle") ? {} : e.style ? a.get(e, "style", {}) : An(e.properties);
  return a.merge({}, i, r, s ? s.style.point : {}, o);
}
function Oo(e, t, i = {}, n) {
  const r = t ? a.get(t.leaflet || t, "layerLineStyle") : {}, s = Do({ style: { line: a.merge({}, i, r) } }, e, t, td, n), o = a.get(t, "ignoreFeatureStyle") ? {} : e.style ? a.get(e, "style", {}) : On(e.properties), l = a.merge({}, i, r, s ? s.style.line : {}, o);
  return ko(l);
}
function Bo(e, t, i = {}, n) {
  const r = t ? a.get(t.leaflet || t, "layerPolygonStyle") : {}, s = Do({ style: { polygon: a.merge({}, i, r) } }, e, t, rd, n), o = a.get(t, "ignoreFeatureStyle") ? {} : e.style ? a.get(e, "style", {}) : Bn(e.properties), l = a.merge({}, i, r, s ? s.style.polygon : {}, o);
  return Fo(l);
}
function Pt(e) {
  return e.x * 536870912 + e.y * 32 + e.z;
}
function mb(e) {
  const t = Math.floor(e / 536870912), i = Math.floor((e - t * 536870912) / 32), n = L.point(t, i);
  return n.z = e - (t * 536870912 + i * 32), n;
}
function od(e, t) {
  const i = {
    x: t.x,
    y: t.y,
    z: t.z
  };
  for (; i.z > 1; ) {
    const n = Pt(i);
    if (e.has(n)) return !0;
    i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1;
  }
  return !1;
}
function ad(e, t) {
  const i = {
    x: t.x,
    y: t.y,
    z: t.z
  };
  for (i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1; i.z > 1; ) {
    const n = Pt(i);
    if (e.has(n)) return i;
    i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1;
  }
}
function gb(e, t, i) {
  const n = t.getNorthWest();
  let r = 1;
  for (; ; ) {
    const o = e._map.project(n, r).unscaleBy(e.getTileSize());
    o.x = Math.floor(o.x), o.y = Math.floor(o.y), o.z = r;
    const l = e._tileCoordsToBounds(o), c = l.getEast() - l.getWest(), u = l.getNorth() - l.getSouth();
    if (c < i.lng || u < i.lat) break;
    r += 1;
  }
  return Math.max(1, r - 1);
}
const pb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DefaultStyle: Co,
  GeoJsonLeafletLayerFilters: tr,
  IconStyleToSimpleStyle: Zu,
  LeafletEvents: Zt,
  LeafletStyleMappings: Rs,
  LineStyleTemplateMappings: td,
  LineStyleToSimpleStyle: Xu,
  PointStyleTemplateMappings: Yu,
  PointStyleToSimpleStyle: Qu,
  PolygonStyleTemplateMappings: rd,
  PolygonStyleToSimpleStyle: id,
  SimpleStyleNumbers: xn,
  SimpleStyleToLineStyle: ed,
  SimpleStyleToPointStyle: Ju,
  SimpleStyleToPolygonStyle: nd,
  TouchEvents: Ln,
  bindLeafletEvents: kt,
  buildGradientPath: Dd,
  cacheView: Fb,
  capture: Ov,
  checkFeatures: zo,
  computeIdealMaxNativeZoom: gb,
  convertLineStyleToLeafletPath: ko,
  convertLineStyleToSimpleStyle: sd,
  convertPointStyleToSimpleStyle: sb,
  convertPolygonStyleToLeafletPath: Fo,
  convertPolygonStyleToSimpleStyle: ob,
  convertSimpleStyleColors: rb,
  convertSimpleStyleToLineStyle: On,
  convertSimpleStyleToPointStyle: An,
  convertSimpleStyleToPolygonStyle: Bn,
  convertStyle: Ot,
  convertToLeafletFromSimpleStyleSpec: hb,
  coordinatesToGeoJSON: Av,
  createFeatures: No,
  createMarkerFromPointStyle: Mo,
  createOfflineServices: kb,
  editFeaturesGeometry: Id,
  editFeaturesProperties: zd,
  editFeaturesStyle: Nd,
  editFilterStyle: Tb,
  editLayerStyle: Td,
  fetchGeoJson: Oi,
  filterGeocoders: Ud,
  filterQueryToConditions: Po,
  formatForwardGeocodingResult: jd,
  formatUserCoordinates: es,
  generateLayerDefinition: Pd,
  generatePropertiesSchema: Vd,
  generateStyleTemplates: To,
  getBaseQueryForFeatures: Wr,
  getCatalogProjectQuery: Sn,
  getCategories: _r,
  getDefaultLineStyle: Oo,
  getDefaultPointStyle: Ao,
  getDefaultPolygonStyle: Bo,
  getDefaultStyleFromTemplates: Vr,
  getFeatureId: Et,
  getFeatureLabel: Dv,
  getFeatureStyleType: Xr,
  getFeaturesFromQuery: Sr,
  getFeaturesQuery: Io,
  getFeaturesQueryInterval: Yr,
  getFeaturesUpdateInterval: Jr,
  getFilterQueryForFeatures: Zr,
  getForecastTimeSeries: Ab,
  getGeoJsonFeatures: Ne,
  getHtmlTable: Wu,
  getLayers: wr,
  getLayersByCategory: Du,
  getLayersBySublegend: qv,
  getMeasureForFeature: $d,
  getMeasureForFeatureBaseQuery: Er,
  getMeasureForFeatureFromQuery: Cr,
  getMeasureForFeatureQuery: Rd,
  getMeasureTimeSeries: Ob,
  getNearestTime: jr,
  getOrphanLayers: Au,
  getParentTileInTileSet: ad,
  getProbeFeatures: Od,
  getShapeFromLineStyle: lb,
  getShapeFromPointStyle: ab,
  getShapeFromPolygonStyle: cb,
  getSortQueryForFeatures: Qr,
  getSublegends: Lr,
  getTimeInterval: Fv,
  getUpdateFeatureFunction: Gu,
  getUpdatedLayerLegend: dn,
  getViews: Ou,
  hasFeatureSchema: cd,
  hasUnitInLeafletLayerTemplate: Hu,
  isFeatureInQueryInterval: Bd,
  isFeatureLayer: Ki,
  isInMemoryLayer: Jt,
  isLayerCachable: Kr,
  isLayerCached: gd,
  isLayerDataEditable: Ld,
  isLayerEditable: md,
  isLayerFilterEditable: xd,
  isLayerHighlightable: dd,
  isLayerProbable: fd,
  isLayerRemovable: wd,
  isLayerSelectable: ud,
  isLayerStorable: hd,
  isLayerStyleEditable: _d,
  isMeasureLayer: Sd,
  isTerrainLayer: $s,
  isUserLayer: ri,
  key2tile: mb,
  listenToFeaturesServiceEventsForLayer: Rn,
  parseCoordinates: qd,
  processFeatures: Gr,
  removeFeatures: qo,
  removeLayer: Fd,
  saveGeoJsonLayer: Md,
  saveLayer: kd,
  setBaseLayerCached: pd,
  setEngineJwt: wo,
  setGeojsonLayerCached: yd,
  setLayerCached: Ro,
  setLayerUncached: $o,
  setPMTilesLayerCached: bd,
  setUrlJwt: lt,
  shouldSkipFeaturesUpdate: Ad,
  tile2key: Pt,
  tileSetContainsParent: od,
  transformFeatures: Hr,
  unbindLeafletEvents: xr,
  uncacheView: Db,
  unlistenToFeaturesServiceEventsForLayer: Gi,
  updateLayerWithFiltersStyle: Cb
}, Symbol.toStringTag, { value: "Module" })), ld = ["actions", "label", "isVisible", "isDisabled"];
function Jt(e) {
  return e._id === void 0;
}
function ri(e) {
  return a.get(e, "scope") === "user";
}
function Ki(e) {
  return a.get(e, "service") === "features";
}
function cd(e) {
  return a.has(e, "schema");
}
function ud(e) {
  return a.get(e, "isSelectable", !0);
}
function dd(e) {
  return a.get(e, "isHighlightable", !0);
}
function fd(e) {
  return a.get(e, "isProbable", !1);
}
function hd(e) {
  return e._id ? !1 : a.get(e, "isStorable", ri(e));
}
function md(e) {
  return a.get(e, "isEditable", ri(e));
}
function Kr(e) {
  return a.get(e, "isCachable", e.type === "BaseLayer" || a.has(e, "service") || a.get(e, "leaflet.type") === "pmtiles" || a.get(e, "leaflet.type") === "geoJson");
}
async function gd(e) {
  return await Se.has(a.get(e, "leaflet.source"));
}
async function Ro(e, t) {
  Kr(e) && (e.type === "BaseLayer" ? await pd(e, t) : e.service ? await yb(e, t) : a.get(e, "leaflet.type") === "geoJson" ? await yd(e) : a.get(e, "leaflet.type") === "pmtiles" && await bd(e, t));
}
async function bs(e, t, i, n) {
  const r = e.replace("{z}", n).replace("{x}", t).replace("{y}", i), s = new URL(r);
  s.searchParams.delete("jwt"), await Se.set("layers", s.href, r);
}
async function pd(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || a.get(e, "leaflet.maxNativeZoom"), s = t.nbConcurrentRequests || 10, o = a.get(e, "leaflet.source");
  let l = [];
  for (let c = n; c <= r; c++) {
    let d = new Or().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], c, a.get(e, "leaflet.tms"));
    for (let f = d.minY; f <= d.maxY; f++)
      for (let m = d.minX; m <= d.maxX; m++)
        l.push(bs(o, m, f, c)), l.length === s && (await Promise.all(l), l = []);
  }
  l.push(bs(o, 0, 0, 0)), e.iconUrl && l.push(bs(e.iconUrl)), await Promise.all(l);
}
async function yb(e, t) {
  await G.createOfflineFeaturesService(e.service, {
    baseQuery: {
      south: t.bounds[0][0],
      north: t.bounds[1][0],
      west: t.bounds[0][1],
      east: t.bounds[1][1]
    },
    clear: !1
  });
}
async function yd(e) {
  const t = a.get(e, "leaflet.source");
  let i = new URL(t);
  i.searchParams.delete("jwt"), await Se.set("layers", i.href, t);
}
async function vd(e, t, i, n, r) {
  const s = Yf(n, t, i), o = await e.getHeader();
  let l = o.rootDirectoryOffset, c = o.rootDirectoryLength;
  for (let u = 0; u <= 3; u++) {
    r.add(`${l}-${l + c - 1}`);
    const d = await e.cache.getDirectory(e.source, l, c, o), f = Xf(d, s);
    if (f) {
      if (f.runLength > 0)
        return {
          start: o.tileDataOffset + f.offset,
          end: o.tileDataOffset + f.offset + f.length - 1
        };
      l = o.leafDirectoryOffset + f.offset, c = f.length;
    } else
      return;
  }
}
async function vb(e, t, i, n, r, s) {
  const o = new URL(e);
  if (o.searchParams.delete("jwt"), !await t.getZxy(r, i, n)) return;
  const c = await vd(t, i, n, r, s);
  await Se.set("layers", `${o.href}/${c.start}/${c.end}`, e, { headers: { Range: `bytes=${c.start}-${c.end}` } });
}
async function bb(e, t, i) {
  const n = new URL(e);
  n.searchParams.delete("jwt"), await Se.set("layers", `${n.href}/0/16383`, e, { headers: { Range: "bytes=0-16383" } }), i = Array.from(i);
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    await Se.set("layers", `${n.href}/${s.replace("-", "/")}`, e, { headers: { Range: `bytes=${s}` } });
  }
}
async function bd(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || a.get(e, "leaflet.maxDataZoom"), s = t.nbConcurrentRequests || 10, o = a.get(e, "leaflet.url"), l = new Ol(o), c = /* @__PURE__ */ new Set(), u = Rl(e.leaflet);
  let d = [];
  for (let f = n; f <= r; f++) {
    let g = new Or().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], f, a.get(e, "leaflet.tms"));
    for (let v = g.minY; v <= g.maxY; v++)
      for (let x = g.minX; x <= g.maxX; x++)
        for (const [S, A] of u) {
          const p = A.dataTileForDisplayTile({ x, y: v, z: f });
          d.push(vb(o, l, p.dataTile.x, p.dataTile.y, p.dataTile.z, c)), d.length === s && (await Promise.all(d), d = []);
        }
  }
  await bb(o, l, c), await Promise.all(d);
}
async function $o(e, t) {
  Kr(e) && (e.type === "BaseLayer" ? await wb(e, t) : e.service ? await _b(e, t) : a.get(e, "leaflet.type") === "geoJson" ? await Lb(e) : a.get(e, "leaflet.type") === "pmtiles" && await Eb(e, t));
}
async function ws(e, t, i, n) {
  const r = e.replace("{z}", n).replace("{x}", t).replace("{y}", i), s = new URL(r);
  s.searchParams.delete("jwt"), await Se.unset("layers", s.href);
}
async function wb(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || a.get(e, "leaflet.maxNativeZoom"), s = a.get(e, "leaflet.source");
  for (let o = n; o <= r; o++) {
    let c = new Or().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], o, a.get(e, "leaflet.tms"));
    for (let u = c.minY; u <= c.maxY; u++)
      for (let d = c.minX; d <= c.maxX; d++)
        await ws(s, d, u, o);
  }
  await ws(s, 0, 0, 0), e.iconUrl && await ws(e.iconUrl);
}
async function _b(e, t) {
  const n = (await Se.getItem("services") || {})[e.service];
  n && await G.getOfflineService(e.service, n.context).remove(null, {
    query: {
      south: t.bounds[0][0],
      north: t.bounds[1][0],
      west: t.bounds[0][1],
      east: t.bounds[1][1]
    }
  });
}
async function Lb(e) {
  const t = a.get(e, "leaflet.source");
  let i = new URL(t);
  i.searchParams.delete("jwt"), await Se.unset("layers", i.href);
}
async function xb(e, t, i, n, r, s) {
  const o = new URL(e);
  if (o.searchParams.delete("jwt"), !await t.getZxy(r, i, n)) return;
  const c = await vd(t, i, n, r, s);
  await Se.unset("layers", `${o.href}/${c.start}/${c.end}`);
}
async function Sb(e, t, i) {
  const n = new URL(e);
  n.searchParams.delete("jwt"), await Se.unset("layers", `${n.href}/0/16383`), i = Array.from(i);
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    await Se.unset("layers", `${n.href}/${s.replace("-", "/")}`);
  }
}
async function Eb(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || a.get(e, "leaflet.maxDataZoom"), s = a.get(e, "leaflet.url"), o = new Ol(s), l = /* @__PURE__ */ new Set(), c = Rl(e.leaflet);
  for (let u = n; u <= r; u++) {
    let f = new Or().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], u, a.get(e, "leaflet.tms"));
    for (let m = f.minY; m <= f.maxY; m++)
      for (let g = f.minX; g <= f.maxX; g++)
        for (const [v, x] of c) {
          const S = x.dataTileForDisplayTile({ x: g, y: m, z: u });
          await xb(s, o, S.dataTile.x, S.dataTile.y, S.dataTile.z, l);
        }
  }
  await Sb(s, o, l);
}
function wd(e) {
  return a.get(e, "isRemovable", ri(e));
}
function _d(e) {
  return a.get(e, "isStyleEditable", ri(e));
}
function Ld(e) {
  return a.get(e, "isDataEditable", ri(e) && Ki(e));
}
function xd(e) {
  return a.get(e, "isFilterEditable", ri(e) && Ki(e));
}
function $s(e) {
  if (e.type === "TerrainLayer") return !0;
  const t = e.cesium || e;
  return t.type === "Cesium" || t.type === "Ellipsoid";
}
function Sd(e) {
  return e.variables && e.service;
}
async function Ed(e) {
  const t = a.get(e, "filters", []);
  if (!t.length) return [];
  const i = G.getService("styles"), n = [];
  for (const r of t)
    r.style && n.push({
      conditions: Po(r.active),
      values: a.isObject(r.style) ? r.style : await i.get(r.style)
    });
  return n;
}
async function Cd(e, t) {
  const i = await Ed(e);
  if (!i.length) return;
  const n = To(t, i);
  return Object.assign(
    {},
    a.mapKeys(n, (s, o) => `leaflet.${o}`),
    a.mapKeys(n, (s, o) => `cesium.${o}`)
  );
}
async function Td(e, t, i = !1) {
  if (t = a.pick(t, ["point", "line", "polygon"]), e._id) {
    const n = await Cd(e, t);
    if (n)
      Object.assign(n, await dn(Object.assign({}, e, n))), i && (n.ignoreFeatureStyle = !0), await G.getService("catalog").patch(e._id, n);
    else {
      const r = await dn(Object.assign({}, e, { "cesium.style": t, "leaflet.style": t })), s = Object.assign({}, { "cesium.style": t, "leaflet.style": t }, r);
      i && (s.ignoreFeatureStyle = !0), await G.getService("catalog").patch(e._id, s);
    }
  } else
    a.set(e, "cesium.style", t), a.set(e, "leaflet.style", t), Object.assign(e, await dn(e)), i && (e.ignoreFeatureStyle = !0);
  return e;
}
async function Cb(e) {
  if (!e._id) return;
  const t = Vr(a.get(e, "leaflet.style", {})), i = await Cd(e, t);
  i && await G.getService("catalog").patch(e._id, i);
}
async function Tb(e, t, i, n, r = !1) {
  if (!e._id) return;
  const s = Vr(a.get(e, "leaflet.style", {})), o = await Ed(e), l = Po(t.active);
  a.forEach(o, (f) => {
    a.isEqual(f.conditions, l) && (f.values = n);
  });
  const c = To(a.merge({}, Co, i, s), o), u = a.cloneDeep(a.get(e, "filters", []));
  a.forEach(u, (f) => {
    a.isEqual(f.label, t.label) && a.isEqual(f.active, t.active) && (f.style = n._id);
  });
  const d = Object.assign(
    {},
    a.mapKeys(c, (f, m) => `leaflet.${m}`),
    a.mapKeys(c, (f, m) => `cesium.${m}`),
    { filters: u }
  );
  r && (d.ignoreFeatureStyle = !0), Object.assign(d, await dn(Object.assign({}, e, { filters: u }))), await G.getService("catalog").patch(e._id, d);
}
async function Pb(e) {
  const t = a.get(e, "filters", []);
  if (!t.length) return [];
  const i = G.getService("styles"), n = [];
  for (const r of t) {
    const s = a.cloneDeep(r);
    r.style && (s.linkedStyle = a.isObject(r.style) ? r.style : await i.get(r.style)), n.push(s);
  }
  return n;
}
async function dn(e) {
  const t = (n, r) => {
    if (a.has(n, "legend"))
      a.isArray(a.get(n, "legend")) ? a.forEach(n.legend, (s) => {
        i(s, r);
      }) : i(n.legend, r);
    else {
      const s = [{ shape: "circle", type: "point" }, { shape: "polyline", type: "line" }, { shape: "rect", type: "polygon" }];
      n.legend = {
        type: "symbols",
        label: a.get(e, "label", a.get(e, "name")),
        content: {
          symbols: a.map(s, (o) => ({
            symbol: { "media/KShape": { options: a.merge({ shape: o.shape }, a.omit(a.get(r, o.type), ["size"])) } },
            label: a.get(n, "label", a.get(n, "name"))
          }))
        }
      };
    }
  }, i = (n, r) => {
    n.type === "symbols" && n.content && n.content.symbols && a.forEach(n.content.symbols, (s) => {
      if (s.symbol && s.symbol["media/KShape"] && s.symbol["media/KShape"].options)
        switch (s.symbol["media/KShape"].options.shape) {
          case "rect":
            s.symbol["media/KShape"].options = a.omit(a.merge({ shape: "rect" }, a.get(r, "polygon")), ["size"]);
            break;
          case "polyline":
            s.symbol["media/KShape"].options = a.omit(a.merge({ shape: "polyline" }, a.get(r, "line")), ["size"]);
            break;
          default:
            s.symbol["media/KShape"].options = a.omit(a.merge({ shape: "circle" }, a.get(r, "point")), ["size"]);
            break;
        }
    });
  };
  if (a.has(e, "filters") && !a.isEmpty(e.filters)) {
    const n = await Pb(e);
    let r = !1;
    a.forEach(n, (o) => {
      a.has(o, "linkedStyle") && (r = !0, t(o, o.linkedStyle));
    });
    const s = { filters: a.map(n, (o) => a.omit(o, "linkedStyle")) };
    return r && Object.assign(s, { $unset: { legend: "" } }), s;
  } else {
    const n = Vr(a.get(e, "leaflet.style", {}));
    return t(e, n), { legend: e.legend };
  }
}
function Pd(e, t) {
  if (t.type !== "FeatureCollection" && t.type !== "Feature") {
    I.error("invalid geoJson content");
    return;
  }
  const i = {
    type: "geoJson",
    isVisible: !0,
    realtime: !0
  }, n = {
    type: "OverlayLayer",
    scope: "user",
    isDataEditable: !0,
    leaflet: i,
    // Avoid sharing reference to the same object although options are similar
    // otherwise updating one will automatically update the other one
    cesium: Object.assign({}, i)
  };
  if (a.defaults(e, n), !e.schema) {
    const r = Vd(t, e.name);
    e.schema = { name: e.name, content: r };
  }
  if (e.featureId || (t.type === "FeatureCollection" ? a.forEach(t.features, (r) => {
    r._id = ti().toString();
  }) : t._id = ti().toString()), t.type === "FeatureCollection" && (a.defaultsDeep(e, a.omit(t, ["type", "properties", "features"])), !a.has(e, "leaflet.panes"))) {
    const r = [];
    a.forEach(t.features, (s) => {
      const o = a.get(s, "style.pane");
      o && r.push({
        name: o
      });
    }), a.isEmpty(r) || a.set(e, "leaflet.panes", r);
  }
  return !0;
}
async function Md(e, t, i = 5e3) {
  const n = zo(t);
  if (n.kinks.length > 0) {
    const l = await mo({
      title: Y.t("utils.layers.INVALID_FEATURES_DIALOG_TITLE", { total: n.kinks.length }),
      message: Y.t("utils.layers.INVALID_FEATURES_DIALOG_MESSAGE", { total: n.kinks.length }),
      options: {
        type: "toggle",
        model: [],
        items: [
          { label: Y.t("utils.layers.DOWNLOAD_INVALID_FEATURES_LABEL"), value: "download" }
        ]
      },
      html: !0,
      ok: {
        label: Y.t("OK"),
        flat: !0
      },
      cancel: {
        label: Y.t("CANCEL"),
        flat: !0
      }
    });
    if (!l.ok) return;
    a.get(l, "data", []).includes("download") && yu(
      JSON.stringify({ type: "FeatureCollection", features: n.kinks }),
      Y.t("utils.layers.INVALID_FEATURES_FILE"),
      "application/json;charset=utf-8;"
    );
  }
  a.set(e, "service", "features"), a.has(e, "leaflet") && a.set(e, "leaflet.source", "/api/features"), a.has(e, "cesium") && a.set(e, "cesium.source", "/api/features");
  const r = Ne(t);
  let s = 0;
  r.forEach((l) => {
    s += Bu(l).features.length;
  }), s > 5e3 && (a.set(e, "leaflet.tiled", !0), a.set(e, "leaflet.minZoom", 15)), Be.show({ message: Y.t("utils.layers.SAVING_LABEL", { processed: 0, total: r.length }), html: !0 });
  let o;
  try {
    o = await G.getService("catalog").create(a.omit(e, ld));
    let l = 0;
    await No(t, o, i, (c, u) => {
      l += u.length, Be.show({
        message: Y.t("utils.layers.SAVING_LABEL", { processed: l, total: r.length }),
        html: !0
      });
    }), o = await G.getService("catalog").patch(o._id, { baseQuery: { layer: o._id } }), a.get(e, "leaflet.tiled") && et.create({ type: "positive", message: Y.t("utils.layers.SAVE_DIALOG_MESSAGE"), timeout: 1e4, html: !0 });
  } catch (l) {
    I.error(`[KDK] ${l}`);
  }
  return Be.hide(), o;
}
async function kd(e) {
  return e = await G.getService("catalog").create(a.omit(e, ld)), e;
}
async function Fd(e) {
  if (!(await mo({
    title: Y.t("utils.layers.REMOVE_DIALOG_TITLE", { layer: e.label || e.name }),
    message: Y.t("utils.layers.REMOVE_DIALOG_MESSAGE", { layer: e.label || e.name }),
    html: !0,
    ok: {
      label: Y.t("OK"),
      flat: !0
    },
    cancel: {
      label: Y.t("CANCEL"),
      flat: !0
    }
  })).ok) return !1;
  Be.show({ message: Y.t("utils.layers.REMOVING_LABEL"), html: !0 });
  try {
    e._id && (Ki(e) && await qo(null, e), await G.getService("catalog").remove(e._id));
  } catch (i) {
    I.error(`[KDK] ${i}`);
  }
  return Be.hide(), !0;
}
function Gr(e, t) {
  const i = Ne(e);
  if (typeof t == "function")
    i.forEach((n) => t(n));
  else if (typeof t == "string") {
    const n = a.template(t);
    i.forEach((r) => n({ feature: r, properties: r.properties }));
  }
}
function Hr(e, t) {
  Ne(e).forEach((n) => {
    const r = a.get(t, "scale"), s = a.get(t, "rotate"), o = a.get(t, "translate");
    r && Qv(
      n,
      r.factor,
      Object.assign(a.omit(r, ["factor"]), { mutate: !0 })
    ), s && Wv(
      n,
      s.angle,
      Object.assign(a.omit(s, ["angle"]), { mutate: !0 })
    ), o && (o.point && (o.distance = Lo(o.pivot || [0, 0], o.point), o.direction = _o(o.pivot || [0, 0], o.point), delete o.pivot, delete o.point), Yv(
      n,
      o.distance,
      o.direction,
      Object.assign(a.omit(o, ["direction", "distance"]), { mutate: !0 })
    ));
  });
}
async function Dd(e, t) {
  const i = t.build.variable;
  if (!e || e.type !== "FeatureCollection") {
    console.error("Invalid GeoJSON, a FeatureCollection is required to build a gradient path");
    return;
  }
  if (!i.chromajs.colors) {
    console.error(`Invalid chromajs on variable ${i.name}, missing colors.`);
    return;
  }
  let n;
  if (i.chromajs.domain ? n = Xt.scale(i.chromajs.colors).domain(i.chromajs.domain) : i.chromajs.classes && (n = Xt.scale(i.chromajs.colors).classes(i.chromajs.classes)), !n) {
    console.error(`Invalid chromajs on variable ${i.name}, missing domain or classes.`);
    return;
  }
  e.features = e.features.map((r) => {
    const s = r.geometry.geometries.map((c) => c.coordinates), l = r.properties[i.name].map((c) => n(c).hex());
    return s.length < 2 ? {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: [s[0], s[0]]
      },
      properties: Object.assign({ gradient: [l[0], l[0]] }, a.omit(r.properties, i.name), i.gradientPath.properties)
    } : {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: s
      },
      properties: Object.assign({ gradient: l }, a.omit(r.properties, i.name), i.gradientPath.properties)
    };
  }), e.total = e.features.length;
}
async function Mb(e) {
  const t = ["gradientPath"];
  if (e.variables)
    for (const i of t) {
      const n = a.find(e.variables, (r) => a.has(r, i));
      if (n)
        return { instruct: i, variable: n };
    }
}
async function Wr(e) {
  const t = {};
  if (e.baseQuery)
    if (typeof e.baseQuery == "function") {
      const i = await e.baseQuery();
      if (i) Object.assign(t, i);
      else return;
    } else
      Object.assign(t, e.baseQuery);
  return t;
}
async function Zr(e) {
  const t = {};
  if (e.filterQuery)
    if (typeof e.filterQuery == "function") {
      const n = await e.filterQuery();
      Object.assign(t, n);
    } else
      Object.assign(t, e.filterQuery);
  const i = a.get(e, "filters", []);
  if (!a.isEmpty(i)) {
    const n = a.get(e, "filterOperators", { active: "$or", inactive: "$and" }), r = i.filter((o) => o.isActive).map((o) => o.active).filter((o) => !a.isEmpty(o));
    a.isEmpty(r) || (t[n.active] = r);
    const s = i.filter((o) => !o.isActive).map((o) => o.inactive).filter((o) => !a.isEmpty(o));
    a.isEmpty(s) || (t[n.inactive] = s);
  }
  return t;
}
async function Qr(e) {
  const t = {};
  if (e.sortQuery)
    if (typeof e.sortQuery == "function") {
      const i = await e.sortQuery();
      Object.assign(t, i);
    } else
      Object.assign(t, e.sortQuery);
  return { $sort: t };
}
function Jr(e) {
  const t = a.get(e, "every");
  return t ? he.duration(t) : null;
}
function Yr(e) {
  const t = Jr(e);
  let i = a.get(e, "queryFrom");
  return !i && t && (i = he.duration(-2 * t.asMilliseconds())), i ? he.duration(i) : null;
}
function Ad(e, t, i) {
  if (i || (i = Jr(t)), !i) return !0;
  const n = be.getCurrentTime(), r = he.duration(n.diff(e));
  return Math.abs(r.asMilliseconds()) < i.asMilliseconds();
}
async function Od(e) {
  const t = await Wr(e), i = await Zr(e), n = await Qr(e);
  Object.assign(t, i, n);
  const s = await (typeof e.getPlanetApi == "function" ? e.getPlanetApi() : G).getService(e.probeService).find(Object.assign({ query: t }, e.baseParams));
  return e.processor && Gr(s, e.processor), e.transform && Hr(s, e.transform), s;
}
async function Io(e, t, i) {
  t || (t = Yr(e));
  let n = await Wr(e);
  const r = await Mb(e);
  if (e.build = r, t) {
    r ? n = Object.assign({
      $groupBy: e.featureId,
      $aggregate: ["geometry", r.variable.name]
    }, n) : e.variables ? n = Object.assign({
      $groupBy: e.featureId,
      // Take care we might have multiple variables targetting the same value name
      // but that differentiate using others properties (compound feature ID)
      $aggregate: a.uniq(e.variables.map((c) => c.name))
    }, n) : e.featureId && (n = Object.assign({
      $groupBy: e.featureId,
      $aggregate: ["geometry"]
    }, n));
    const l = be.getCurrentTime();
    if (he.isDuration(t)) {
      const c = t.asMilliseconds() > 0 ? l.clone().subtract(t) : l.clone().add(t), u = l;
      Object.assign(n, {
        $sort: { time: -1, runTime: -1 },
        time: {
          $gte: c.toISOString(),
          $lte: u.toISOString()
        }
      }), e.featureId && !r && (n.$limit = 1);
    } else typeof t == "object" ? n.time = t : (Object.assign(n, {
      $sort: { time: -1, runTime: -1 },
      time: { $lte: l.toISOString() }
    }), e.featureId && !r && (n.$limit = 1));
  }
  a.isNil(i) || (n.level = i);
  const s = await Zr(e), o = await Qr(e);
  return a.merge(n, s, o), n;
}
function Bd(e, t) {
  if (!e.time) return !0;
  const i = Yr(t);
  if (!he.isDuration(i)) return !0;
  const n = be.getCurrentTime(), r = he.utc(e.time), s = i.asMilliseconds() > 0 ? n.clone().subtract(i) : n.clone().add(i), o = n;
  return be.isRealtime() && o.add(be.get().interval, "s"), r.isSameOrAfter(s) && r.isSameOrBefore(o);
}
async function Sr(e, t) {
  const n = await (typeof e.getPlanetApi == "function" ? e.getPlanetApi() : G).getService(e.service).find(Object.assign({ query: t }, e.baseParams));
  if (e.processor && Gr(n, e.processor), e.transform && Hr(n, e.transform), e.build) {
    switch (e.build.instruct) {
      case "gradientPath":
        await Dd(n, e);
        break;
    }
    delete e.build;
  }
  return n;
}
function Er(e, t) {
  let i = e.chronicleId || e.featureId;
  i = Array.isArray(i) ? i : [i];
  const n = i.reduce(
    (r, s) => Object.assign(r, { ["properties." + s]: a.get(t, "properties." + s) }),
    {}
  );
  return n.$groupBy = i, n;
}
async function Rd(e, t, i, n, r) {
  return await Io(a.merge({
    baseQuery: Er(e, t)
  }, e), {
    $gte: i.toISOString(),
    $lte: n.toISOString()
  }, r);
}
async function Cr(e, t, i) {
  const n = await Sr(e, i);
  return a.get(n, "features[0]");
}
async function $d(e, t, i, n, r) {
  let s;
  try {
    const o = await Rd(e, t, i, n, r);
    s = await Cr(e, t, o);
  } catch (o) {
    I.error(o);
  }
  return s;
}
function zo(e, t = {
  kinks: !0,
  redundantCoordinates: !0
}) {
  const i = Ne(e);
  t.redundantCoordinates && i.forEach((r) => Vv(r, { mutate: !0 }));
  let n;
  return t.kinks && (n = a.remove(i, (r) => {
    const s = mi(r);
    if (s === "MultiPolygon" || s === "Polygon") {
      const o = jv(r);
      return a.get(o, "features", []).length > 0;
    } else
      return !1;
  })), { kinks: n };
}
async function No(e, t, i = 5e3, n) {
  if (!t) return;
  const r = Ne(e);
  if (r.forEach((s) => {
    delete s._id, s.layer = t._id;
  }), r.length === 1)
    return await G.getService(t.service).create(r[0]);
  {
    const s = [];
    let o = 0, l = [];
    r.forEach((c) => {
      const d = Bu(c).features.length;
      o + d <= i ? (o += d, l.push(c)) : (l.length > 0 && s.push(l), l = [c], o = d);
    }), l.length > 0 && s.push(l);
    for (let c = 0; c < s.length; c++)
      await G.getService(t.service).create(s[c]), typeof n == "function" && await n(c, s[c]);
  }
}
async function Id(e, t) {
  const i = Ne(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (s._id) {
      const o = await G.getService(t.service).patch(s._id, a.pick(s, ["geometry"]));
      n.push(o);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function zd(e, t) {
  const i = Ne(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (s._id) {
      const o = await G.getService(t.service).patch(s._id, a.pick(s, ["properties"]));
      n.push(o);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function Nd(e, t) {
  const i = Ne(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (t._id) {
      const o = await G.getService(t.service).patch(s._id, a.pick(s, ["style"]));
      n.push(o);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function qo(e, t) {
  if (!e)
    await G.getService(t.service).remove(null, { query: { layer: t._id } });
  else {
    const i = Ne(e);
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      r._id && await G.getService(t.service).remove(r._id);
    }
  }
}
async function Oi(e, t = {}) {
  const i = await fetch(e);
  if (i.status !== 200)
    throw new Error(`Impossible to fetch ${e}: ` + i.status);
  const n = await i.json();
  return t.processor && Gr(n, t.processor), t.transform && Hr(n, t.transform), n;
}
function Xr(e) {
  const t = a.get(e, "geometry.type");
  if (!t) {
    I.warn("[KDK] feature has undefined geometry");
    return;
  }
  if (["Point", "MultiPoint"].includes(t)) return "point";
  if (["LineString", "MultiLineString"].includes(t)) return "line";
  if (["Polygon", "MultiPolygon"].includes(t)) return "polygon";
  I.warn(`[KDK] unsupported geometry of type of ${t}`);
}
function Rn(e, {
  context: t = null,
  created: i = null,
  updated: n = null,
  patched: r = null,
  removed: s = null,
  all: o = null
} = {}, l) {
  if (!e.service || Jt(e) || !Ki(e) && !e.serviceEvents) return;
  Gi(e, l);
  const c = (u, d) => u ? (f, m) => {
    !mi(f) || !Yt(f) || (f.layer ? f.layer === d._id && u(f, d, m) : u(f, d, m));
  } : null;
  return qt(e.service, {
    context: t,
    created: c(i, e),
    updated: c(n, e),
    patched: c(r, e),
    removed: c(s, e),
    all: c(o, e)
  });
}
function Gi(e, t) {
  At(t);
}
function qd(e) {
  let t, i;
  const n = /(-?\d+(?:\.\d+)?)°\s*([NSEW])\s+(-?\d+(?:\.\d+)?)°\s*([NSEW])/;
  let r = e.match(n);
  if (r)
    return r[2] === "N" || r[2] === "S" ? (i = parseFloat(r[1]), r[2] === "S" && (i = -i), t = parseFloat(r[3]), r[4] === "W" && (t = -t), { longitude: t, latitude: i }) : (t = parseFloat(r[1]), r[2] === "W" && (t = -t), i = parseFloat(r[3]), r[4] === "S" && (i = -i), { longitude: t, latitude: i });
  const s = /(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/;
  if (r = e.match(s), r)
    return t = parseFloat(r[1]), i = parseFloat(r[2]), { longitude: t, latitude: i };
}
function es(e, t, i, n) {
  if (i === "aeronautical") {
    const r = Es(e, t), s = r.latValues.degreesInt.toString().padStart(2, "0"), o = Math.floor(r.latValues.secondsTotal / 6).toString().padStart(3, "0"), l = r.north ? "N" : "S", c = r.lonValues.degreesInt.toString().padStart(3, "0"), u = Math.floor(r.lonValues.secondsTotal / 6).toString().padStart(3, "0"), d = r.east ? "E" : "W";
    return `${s}${o}${l} ${c}${u}${d}`;
  }
  return Es(e, t).format(i, n);
}
function jd(e) {
  const t = e.properties;
  if (!t) {
    I.warn("[KDK] invalid geocoding result: missing 'properties' property");
    return;
  }
  let i = t.formattedAddress || "";
  if (i || (t.streetNumber && (i += t.streetNumber + ", "), t.streetName && (i += t.streetName + " "), t.city && (i += t.city + " "), t.zipcode && (i += " (" + t.zipcode + ")")), !i) {
    if (!a.has(e, "geokoder.matchProp")) {
      I.warn("[KDK] invalid geocoding result: missing 'geokoder.matchProp' property");
      return;
    }
    i = a.get(e, e.geokoder.matchProp, "");
  }
  return i;
}
function Ud(e, t) {
  return e.filter((i) => {
    const n = i.value || i;
    if (t && n.includes("kano:")) {
      const r = a.replace(n, /^(.*:)?kano:/g, "");
      let s = a.find(t.layers, { service: r });
      return s || (s = a.find(t.layers, { probeService: r })), s;
    }
    return !0;
  });
}
async function kb() {
  const e = await Se.getItem("services");
  if (e) {
    const t = Object.keys(e);
    for (let i = 0; i < t.length; i++) {
      const n = t[i], r = e[n];
      r.features ? await G.createOfflineFeaturesService(n, { snapshot: !1, ...r }) : await G.createOfflineService(n, { snapshot: !1, ...r });
    }
  }
}
async function Fb(e, t, i = {}) {
  const n = await Se.getItem("views");
  n ? (n[e._id] = i, await Se.setItem("views", n)) : await Se.setItem("views", { [e._id]: i });
  const r = [{ type: { $nin: ["Context", "Service", "Category"] } }, { type: { $in: ["Context", "Service", "Category"] } }];
  await G.createOfflineService("catalog", {
    baseQueries: r
  }), i.contextId && await G.createOfflineService("catalog", {
    baseQueries: r,
    context: i.contextId
  });
  const s = { populate: !0 };
  await G.createOfflineService("projects", {
    baseQuery: s
  }), await G.createOfflineFeaturesService("features", {
    context: i.contextId
  });
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    await Ro(l, Object.assign({ bounds: [[e.south, e.west], [e.north, e.east]] }, i));
  }
}
async function Db(e, t, i = {}) {
  const n = await Se.getItem("views") || {};
  if (n[e._id]) {
    Object.assign(i, n[e._id] || {});
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      await $o(s, Object.assign({ bounds: [[e.south, e.west], [e.north, e.east]] }, i));
    }
    if (delete n[e._id], a.isEmpty(n)) {
      await Se.removeItem("views");
      const r = await Se.getItem("services") || {}, s = Object.keys(r);
      for (let o = 0; o < s.length; o++) {
        const l = s[o], c = r[l];
        await G.getOfflineService(l, c.context).remove(null, { query: {} }), G.removeService(l, c.context);
      }
      await Se.removeItem("services");
    } else
      await Se.setItem("views", n);
  }
}
function Sn(e) {
  const t = { _id: { $in: a.map(a.filter(e.layers, "_id"), "_id") } }, i = { name: { $in: a.map(a.filter(e.layers, "name"), "name") } };
  return { $or: [t, i] };
}
function Vd(e, t) {
  const i = {
    $id: `http://www.kalisio.xyz/schemas/${a.kebabCase(t)}#`,
    title: t,
    $schema: "http://json-schema.org/draft-07/schema#",
    type: "object",
    properties: {}
  };
  return Ne(e).forEach((r) => {
    const s = r.properties ? Dn(r.properties) : {};
    a.forOwn(s, (o, l) => {
      if (i.properties["{key}"]) {
        const c = i.properties[`${l}`];
        a.isNil(c) && (i.properties[`${l}`] = o);
      } else
        i.properties[`${l}`] = o;
    });
  }), a.forOwn(i.properties, (r, s) => {
    let o = typeof r;
    (o === "object" || o === "undefined") && (o = "string"), i.properties[`${s}`] = {
      type: o,
      nullable: !0,
      field: {
        component: o === "number" ? "form/KNumberField" : o === "boolean" ? "form/KToggleField" : "form/KTextField",
        label: s
      }
    };
  }), i;
}
async function Is({ longitude: e, latitude: t, startTime: i, endTime: n, forecastModel: r, forecastLevel: s, weacastApi: o }) {
  if (!r) return;
  const l = {
    type: "Point",
    coordinates: [e, t]
  }, c = {
    forecastTime: {
      $gte: i.format(),
      $lte: n.format()
    },
    geometry: {
      $geoIntersects: {
        $geometry: l
      }
    }
  };
  let u;
  try {
    let d = r.elements.map((m) => m.name);
    s ? d = d.filter((m) => m.endsWith(s.toString())) : d = d.filter((m) => {
      const g = m.split("-");
      return g.length === 0 || !a.isFinite(a.toNumber(g[g.length - 1]));
    });
    const f = await o.getService("probes").create({
      forecast: r.name,
      elements: d
    }, { query: c });
    if (f.features.length > 0)
      u = f.features[0];
    else throw new Error("Cannot find valid forecast at location");
  } catch (d) {
    I.error(d);
  }
  return u;
}
async function Kd({ name: e, forecastModel: t, weacastApi: i }) {
  const n = await i.getService("probes").find({
    query: {
      name: e,
      forecast: t.name,
      $paginate: !1,
      $select: ["elements", "forecast", "featureId"]
    }
  });
  return n.length > 0 ? n[0] : null;
}
async function Gd({ probe: e, featureId: t, startTime: i, endTime: n, forecastModel: r, forecastLevel: s, weacastApi: o }) {
  let l;
  try {
    let c = r.elements.map((m) => m.name);
    s ? c = c.filter((m) => m.endsWith(s.toString())) : c = c.filter((m) => {
      const g = m.split("-");
      return g.length === 0 || !a.isFinite(a.toNumber(g[g.length - 1]));
    });
    const u = s ? `windDirection-${s}` : "windDirection", d = s ? `windSpeed-${s}` : "windSpeed";
    c = c.concat([u, d]);
    const f = await o.getService("probe-results").find({
      query: {
        probeId: e._id,
        forecastTime: {
          $gte: i.format(),
          $lte: n.format()
        },
        [e.featureId]: t,
        $groupBy: e.featureId,
        $aggregate: c
      }
    });
    if (f.length > 0)
      l = f[0];
    else throw new Error("Cannot find valid forecast for feature");
  } catch (c) {
    I.error(c);
  }
  return l;
}
async function Tr(e, t, i, n) {
  e = await e;
  const r = a.get(e, "time", a.get(e, "forecastTime", {})), s = a.get(e, "runTime", {}), o = a.get(e, "properties", {}), l = i ? `${t.name}-${i}` : t.name;
  let c = [];
  return o[l] && Array.isArray(o[l]) && (c = o[l].map((u, d) => (u = Me.convert(u, t.unit, t.targetUnit), { time: he.utc(r[l][d]).valueOf(), [l]: u })), t.runTimes && n && !a.isEmpty(a.get(s, l)) ? c = c.filter((u, d) => s[l][d] === n.toISOString()) : c = a.uniqBy(c, "time")), c;
}
async function ol({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  forecastModel: s,
  forecastLevel: o,
  weacastApi: l
}) {
  const { start: c, end: u } = be.getRange();
  n || (n = c), r || (r = u);
  let d;
  if (!e)
    d = await Is({ longitude: t.lng, latitude: t.lat, startTime: n, endTime: r, forecastModel: s, forecastLevel: o, weacastApi: l });
  else if (i.probe) {
    const f = await Kd({ name: i.probe, forecastModel: s, weacastApi: l });
    f && (d = await Gd({ probe: f, featureId: a.get(e, f.featureId), startTime: n, endTime: r, forecastModel: s, forecastLevel: o, weacastApi: l }));
  } else {
    const f = hi(e), m = a.get(f, "geometry.coordinates[0]"), g = a.get(f, "geometry.coordinates[1]");
    d = await Is({ longitude: m, latitude: g, startTime: n, endTime: r, forecastModel: s, forecastLevel: o, weacastApi: l });
  }
  return d;
}
async function al({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  level: s,
  probeFunction: o
}) {
  const { start: l, end: c } = be.getRange();
  n || (n = l), r || (r = c);
  let u;
  return o ? u = await o({ feature: e, location: t, layer: i, level: s, startTime: n, endTime: r }) : Sd(i) && (u = await $d(i, e, n, r, s)), u;
}
function Ab({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  runTime: s,
  forecastLayers: o,
  forecastModel: l,
  forecastLevel: c,
  weacastApi: u,
  fetchDelay: d
}) {
  let f = [];
  if (o && o.length > 0 && o.forEach((S) => {
    f = f.concat(a.get(S, "variables", []));
  }), f = a.uniqBy(f, "name"), f.length === 0) return [];
  const m = a.get(e, "properties", {}), g = ol({
    feature: e,
    location: t,
    layer: i,
    startTime: n,
    endTime: r,
    forecastModel: l,
    forecastLevel: c,
    weacastApi: u
  }), v = a.debounce(() => ol({
    feature: e,
    location: t,
    layer: i,
    startTime: n,
    endTime: r,
    forecastModel: l,
    forecastLevel: c,
    weacastApi: u
  }), d || 250, { leading: !0, trailing: !1 });
  return f.map((S) => {
    const A = a.get(m, "unit", S.unit), p = Me.getUnit(A), y = Me.getTargetUnit(A), w = {
      probedLocationData: g,
      data: Tr(g, S, c, s),
      variable: {
        name: S.name,
        label: `${Y.tie(S.label)} (${Me.getTargetUnitSymbol(A)})`,
        unit: p,
        targetUnit: y,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: c ? `${S.name}-${c}` : S.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, a.cloneDeep(S.chartjs))
      }
    };
    return w.fetch = () => (w.probedLocationData = v(), w.data = Tr(w.probedLocationData, S, c, s), w.data), w;
  });
}
function Ob({
  feature: e,
  location: t,
  layer: i,
  layers: n,
  startTime: r,
  endTime: s,
  runTime: o,
  level: l,
  probeFunction: c,
  fetchDelay: u
}) {
  let d = a.get(i, "variables", []);
  if (n && n.length > 0 && n.forEach((x) => {
    d = d.concat(a.get(x, "variables", []));
  }), d = a.uniqBy(d, "name"), d.length === 0) return [];
  const f = a.get(e, "properties", {}), m = al({
    feature: e,
    location: t,
    layer: i,
    startTime: r,
    endTime: s,
    level: l,
    probeFunction: c
  }), g = a.debounce(() => al({
    feature: e,
    location: t,
    layer: i,
    startTime: r,
    endTime: s,
    level: l,
    probeFunction: c
  }), u || 250, { leading: !0, trailing: !1 });
  return d.map((x) => {
    const S = a.get(f, "unit", x.unit), A = Me.getUnit(S), p = Me.getTargetUnit(S), y = {
      probedLocationData: m,
      data: Tr(m, x),
      variable: {
        name: x.name,
        label: `${Y.tie(x.label)} (${Me.getTargetUnitSymbol(S)})`,
        unit: A,
        targetUnit: p,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: x.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, a.cloneDeep(x.chartjs))
      }
    };
    return y.fetch = () => (y.probedLocationData = g(), y.data = Tr(y.probedLocationData, x), y.data), y;
  });
}
function Hd(e, t = {}) {
  let i = {};
  const n = po(e, t), { get: r, has: s, set: o } = Ft(`selections.${e}`);
  t = r("options", Object.assign({
    // Specific selection item comparator
    matches: (q) => (ie) => {
      const le = a.get(q, "layer.name"), pe = a.get(ie, "layer.name");
      if (le && pe) {
        if (le !== pe) return !1;
        if (q.feature && ie.feature) {
          const ge = Et(q.feature, q.layer), ye = Et(ie.feature, ie.layer);
          return ge === ye;
        } else
          return !1;
      } else {
        if (le || pe) return !1;
        const ge = a.get(q, "location"), ye = a.get(ie, "location");
        return ge.lat === ye.lat && ge.lon === ye.lon;
      }
    },
    // Multiple selection key
    multiple: "ctrlKey",
    // Buffer selection width (10px)
    buffer: 10,
    showBuffer: !1,
    showBufferDelay: 250,
    boxSelection: !0,
    clusterSelection: !1
  }, t)), s("options") || o("options", t);
  const { kActivity: l } = ni();
  let c = Bi(l);
  function u(q) {
    c !== q && (c && c.$engineEvents && (R(), n.setSelectionEnabled(), n.clearSelection(), c.$engineEvents.off("click", X), t.boxSelection && c.$engineEvents.off("boxselectionend", te), t.clusterSelection && c.$engineEvents.off("spiderfied", H), c.$engineEvents.off("layer-added", fe), c.$engineEvents.off("layer-removed", ce), c.$engineEvents.off("layer-hidden", oe)), c = q, c && c.$engineEvents && (de(), c.$engineEvents.on("click", X), t.boxSelection && c.$engineEvents.on("boxselectionend", te), t.clusterSelection && c.$engineEvents.on("spiderfied", H), c.$engineEvents.on("layer-added", fe), c.$engineEvents.on("layer-removed", ce), c.$engineEvents.on("layer-hidden", oe)));
  }
  function d(q) {
    t.boxSelection !== q && (t.boxSelection = q, c && (q ? (c.$engineEvents.on("boxselectionend", te), c.map.boxSelection.enable()) : (c.$engineEvents.off("boxselectionend", te), c.map.boxSelection.disable())));
  }
  function f(q) {
    t.clusterSelection !== q && (t.clusterSelection = q, c && (q ? c.$engineEvents.on("spiderfied", H) : c.$engineEvents.off("spiderfied", H)));
  }
  function m(q) {
    t.buffer = q;
  }
  function g() {
    return n.hasSelectedItem() && n.getSelectedItem().feature;
  }
  function v() {
    return n.getSelectedItem().feature;
  }
  function x() {
    return n.getSelectedItems().filter((q) => q.feature).map((q) => q.feature);
  }
  function S() {
    return { type: "FeatureCollection", features: n.getSelectedItems().filter((q) => q.feature).map((q) => q.feature) };
  }
  function A() {
    const q = {};
    return n.getSelectedItems().filter((le) => le.feature && le.layer).forEach((le) => {
      const pe = le.layer._id || le.layer.name;
      q[pe] || (q[pe] = { layer: le.layer, features: [] }), q[pe].features.push(le.feature);
    }), a.values(q);
  }
  function p() {
    return n.hasSelectedItem() && n.getSelectedItem().layer;
  }
  function y() {
    return n.getSelectedItem().layer;
  }
  function w() {
    return n.getSelectedItem().filter((q) => q.layer).map((q) => q.layer);
  }
  function C() {
    return n.hasSelectedItem() && n.getSelectedItem().location;
  }
  function P() {
    return n.getSelectedItem().location;
  }
  function M(q, ie) {
    const le = n.getSelectedItems();
    for (let pe = 0; pe < le.length; pe++) {
      const ge = le[pe];
      if (ge.feature && ge.layer && ge.layer.name === ie.name) {
        const ye = Et(ge.feature, ge.layer);
        if (Et(q, ie) === ye) return ge;
      }
    }
    return null;
  }
  function z(q, ie) {
    return M(q, ie) !== null;
  }
  function D() {
    let q;
    if (p()) {
      const ie = y();
      q = a.get(ie, "widget"), q ? typeof q != "string" && (q = a.get(q, "type", "information-box")) : a.has(ie, "probe") || // Static probe on pre-defined sites
      a.has(ie, "variables") ? q = "time-series" : a.get(ie, "leaflet.type") === "mapillary" ? q = "mapillary-viewer" : q = "information-box";
    }
    return q;
  }
  function T() {
    g() ? c.center(...a.get(hi(v()), "geometry.coordinates")) : C() && c.center(P().lng, P().lat);
  }
  function F(q, ie) {
    Array.isArray(q) || (q = [q]);
    const le = [], pe = [];
    q.forEach((ge) => {
      const { location: ye, feature: tt, layer: Je } = ge;
      tt && Je ? z(tt, Je) ? pe.push(ge) : le.push(ge) : ye && Je && le.push(ge);
    }), (ie || a.isEmpty(le) && a.isEmpty(pe)) && n.clearSelection(), pe.forEach((ge) => n.unselectItem(ge)), le.forEach((ge) => n.selectItem(ge));
  }
  function k(q) {
    const ie = [];
    return a.values(c.layers).filter(Te({
      scope: { $ne: "system" },
      "leaflet.type": "geoJson",
      isVisible: !0
    })).forEach((pe) => {
      if (!c.isLayerSelectable(pe)) return;
      const ge = c.toGeoJson(pe.name);
      bi(ge, (ye) => {
        if (Fu(ye, q)) {
          const tt = hi(ye), Je = a.get(tt, "geometry.coordinates[0]"), ot = a.get(tt, "geometry.coordinates[1]");
          ie.push({ feature: ye, layer: pe, location: { lng: Je, lat: ot } });
        }
      });
    }), ie;
  }
  let O, $;
  function X(q, ie) {
    if (!n.isSelectionEnabled()) return;
    const le = a.get(ie, "containerPoint");
    if (O && le.equals(O)) {
      O = null;
      return;
    }
    if ($ && le.equals($)) {
      $ = null;
      return;
    }
    O = le;
    const pe = t.multiple ? a.get(ie, `originalEvent.${t.multiple}`) : !1;
    let ge;
    const ye = a.get(ie, "latlng");
    if (n.getSelectionMode() === "buffer") {
      if (c.is2D() && t.showBuffer) {
        const zn = a.get(me, `engines.${c.engine}.style.selection.polygon`, {}), Qi = B.circleMarker(ye, Object.assign({ radius: t.buffer }, Fo(zn))).addTo(c.map);
        setTimeout(() => Qi.removeFrom(c.map), t.showBufferDelay);
      }
      const Je = c.getCenter(), ot = 40075016686e-3 * Math.abs(Math.cos(ye.lat * Math.PI / 180)) / Math.pow(2, Je.zoomLevel + 8);
      ge = k(uv([ye.lng, ye.lat], t.buffer * ot, { steps: 100, units: "meters" }));
    } else {
      let Je;
      q && q.name ? (q = c.getLayerByName(q.name), q && c.isLayerSelectable(q) ? Je = a.get(ie, "target.feature") : q = void 0) : q = void 0, ge = [{ location: ye, feature: Je, layer: q }];
    }
    const tt = n.isSingleSelectionMode() || !pe;
    t.handler ? t.handler(ge, tt) : F(ge, tt);
  }
  function te(q, ie) {
    if (!n.isSelectionEnabled()) return;
    $ = a.get(ie, "containerPoint");
    const { bounds: le } = ie;
    let pe = k(Pu([
      le.getWest(),
      le.getSouth(),
      le.getEast(),
      le.getNorth()
    ]));
    !a.isEmpty(pe) && n.isSingleSelectionMode() && (pe = a.last(pe)), t.handler ? t.handler(pe, !0) : F(pe, !0);
  }
  function H(q, ie) {
    if (!n.isSelectionEnabled() || n.isSingleSelectionMode()) return;
    const le = a.get(ie, "markers", []).map((pe) => {
      const ge = pe.feature, ye = hi(ge), tt = a.get(ye, "geometry.coordinates[0]"), Je = a.get(ye, "geometry.coordinates[1]");
      return { feature: ge, layer: q, location: { lng: tt, lat: Je } };
    });
    t.handler ? t.handler(le, !0) : F(le, !0);
  }
  function oe(q) {
    n.getSelectedItems().filter((le) => q.name === a.get(le, "layer.name")).forEach((le) => n.unselectItem(le));
  }
  function fe(q) {
    const ie = Rn(q, {
      all: J,
      removed: we
    }, i[q._id]);
    ie && (i[q._id] = ie);
  }
  function ce(q) {
    Gi(q, i[q._id]), delete i[q._id];
  }
  function de() {
    i = {}, a.forEach(c.getLayers(), fe);
  }
  function R() {
    a.forOwn(i, ce), i = {};
  }
  function J(q, ie) {
    if (!ie && q.layer && (ie = c.getLayerById(q.layer)), !ie) return;
    const le = M(q, ie);
    le && Object.assign(le.feature, q);
  }
  function we(q, ie) {
    if (!ie && q.layer && (ie = c.getLayerById(q.layer)), !ie) return;
    const le = M(q, ie);
    le && n.unselectItem(le);
  }
  return {
    ...n,
    getSelectionOptions: () => r("options"),
    setCurrentActivity: u,
    hasSelectedFeature: g,
    getSelectedFeature: v,
    getSelectedFeatures: x,
    getSelectedFeatureCollection: S,
    getSelectedFeaturesByLayer: A,
    hasSelectedLayer: p,
    getSelectedLayer: y,
    getSelectedLayers: w,
    hasSelectedLocation: C,
    getSelectedLocation: P,
    getWidgetForSelection: D,
    centerOnSelection: T,
    setBoxSelectionEnabled: d,
    setClusterSelectionEnabled: f,
    setBufferWidth: m
  };
}
function Wd(e, t = {}) {
  const { kActivity: i } = ni();
  let n = Bi(i);
  const { store: r, set: s, get: o, has: l } = Ft(`probes.${e}`);
  function c(P) {
    n !== P && (n && n.$engineEvents && n.$engineEvents.off("click", w), n = P, P && P.$engineEvents && P.$engineEvents.on("click", w));
  }
  function u() {
    s("item", null);
  }
  function d(P) {
    s("item", P);
  }
  function f() {
    return n && n.isCursor("probe-cursor");
  }
  function m() {
    return o("item") && o("item").layer;
  }
  function g() {
    return o("item").layer;
  }
  function v() {
    return o("item") && o("item").location;
  }
  function x() {
    return o("item").location;
  }
  function S() {
    let P;
    return v() && (P = "time-series"), P;
  }
  function A() {
    v() && n.center(x().lng, x().lat);
  }
  function p(P) {
    d(P);
  }
  let y;
  function w(P, M) {
    if (!f()) {
      o("item") && (a.get(M, "target.feature") || u());
      return;
    }
    const z = a.get(M, "containerPoint");
    if (y && z.equals(y)) {
      y = null;
      return;
    }
    y = z;
    const D = a.get(M, "latlng");
    let T;
    P && P.name ? (P = n.getLayerByName(P.name), P && n.isLayerProbable(P) ? T = a.get(M, "target.feature") : P = void 0) : P = void 0, t.handler ? t.handler({ location: D, feature: T, layer: P }) : p({ location: D, feature: T, layer: P });
  }
  function C() {
    n.setCursor("probe-cursor"), n.$engineEvents.once("click", () => {
      setTimeout(() => {
        n.unsetCursor("probe-cursor");
      }, t.timeout || 500);
    });
  }
  return l("item") || u(), {
    setCurrentActivity: c,
    probe: r,
    clearProbe: u,
    setProbe: d,
    hasProbedLayer: m,
    getProbedLayer: g,
    hasProbedLocation: v,
    getProbedLocation: x,
    probeAtLocation: C,
    getWidgetForProbe: S,
    centerOnProbe: A
  };
}
const ai = ti(), Zd = 999, ir = 8;
function Qd(e, t = {}) {
  let i = "highlightable-layers", n = {};
  t = Object.assign({ updateDelay: 250 }, t);
  const { kActivity: r } = ni();
  let s = Bi(r);
  const { store: o, clear: l, set: c, get: u, unset: d, has: f } = Ft(`highlights.${e}`), { forOwn: m } = Ft("highlights");
  function g(R) {
    s !== R && (s && (O(), s.$engineEvents.off("layer-added", te), s.$engineEvents.off("layer-removed", H), s.$engineEvents.off("layer-added", T), s.$engineEvents.off("layer-disabled", $), s.$engineEvents.off("layer-enabled", X)), s = R, s && (s.$engineEvents.on("layer-added", te), s.$engineEvents.on("layer-removed", H), s.$engineEvents.on("layer-added", T), s.$engineEvents.on("layer-disabled", $), s.$engineEvents.on("layer-enabled", X)));
  }
  function v(R, J) {
    let we = `${e}`;
    if (J && (we += `-${a.kebabCase(J.name)}`), R) {
      const q = Et(R, J);
      q && (we += `-${q}`);
    }
    return we;
  }
  function x(R, J, we) {
    return we ? R.includes(`-${Et(we, J)}`) : R.includes(`-${a.kebabCase(J.name)}`);
  }
  function S(R, J) {
    return f(v(R, J));
  }
  function A(R, J) {
    return u(v(R, J));
  }
  function p(R, J) {
    Object.assign(
      J,
      R.geometry ? { geometry: R.geometry } : { geometry: { type: "Point", coordinates: [a.get(R, "lng", 0), a.get(R, "lat", 0)] } }
    ), t.asBbox && J.geometry.type !== "Point" && Object.assign(J, Pu(wi(J))), k();
  }
  function y(R = "highlightable-layers") {
    i = R;
  }
  function w(R, J, we = !0) {
    if (J && i === "highlightable-layers" && !dd(J)) return;
    const q = v(R, J), ie = {
      highlightId: q,
      type: "Feature",
      properties: Object.assign({
        zOrder: 0
      }, t)
    };
    if (p(R, ie), we) {
      const le = `engines.${s.engine}.style.selection.${Xr(ie)}`;
      let pe = a.cloneDeep(a.get(me, le, {}));
      if (s.is2D()) {
        let ge = a.get(R, "style.radius"), ye = a.get(R, "style.size");
        ye && !Array.isArray(ye) && (ye = [ye, ye]), !ye && !ge && (ye = a.get(J, `${s.engine}.style.point.size`), ge = a.get(J, `${s.engine}.style.point.radius`), ye && !Array.isArray(ye) && (ye = [ye, ye])), ge ? Object.assign(pe, { radius: ge + 0.5 * ir }) : ye && Object.assign(pe, { size: [ye[0] + ir, ye[1] + ir] }), Object.assign(ie, { style: pe });
      } else
        Object.assign(ie, { style: a.defaults({}, pe, R.style) });
    } else
      Object.assign(ie, { style: R.style });
    return a.merge(ie, a.omit(R, ["geometry", "style"])), c(q, ie), P(R, J, J ? !J.isDisabled : !0), ie;
  }
  function C(R, J) {
    const we = v(R, J);
    d(we), k();
  }
  function P(R, J, we = !0) {
    const q = A(R, J);
    a.set(q, "style.visibility", we), k();
  }
  function M(R, J = !0) {
    D(R).forEach((we) => P(we, R, J));
  }
  function z() {
    l(), k();
  }
  function D(R, J) {
    let we = [];
    return m((q) => {
      a.forOwn(q, (ie, le) => {
        (!R || R && x(le, R, J)) && we.push(ie);
      });
    }), we;
  }
  async function T() {
    s.getLayerByName(ai) || await s.addLayer({
      name: ai,
      type: "OverlayLayer",
      scope: "system",
      isSelectable: !1,
      featureId: "highlightId",
      leaflet: {
        type: "geoJson",
        isVisible: !0,
        realtime: !0,
        interactive: !1,
        cluster: !1,
        removeMissing: !0,
        popup: { pick: [] },
        zIndex: Zd,
        interactive: !1
      },
      cesium: {
        type: "geoJson",
        isVisible: !0,
        realtime: !0,
        cluster: !1,
        removeMissing: !0,
        popup: { pick: [] }
      }
    }), s.isLayerVisible(ai) || await s.showLayer(ai);
  }
  function F() {
    let R = D();
    R = R.filter((J) => !J.isDisabled), R = a.sortBy(R, (J) => a.get(J, "properties.zOrder")), s && s.updateLayer(ai, {
      type: "FeatureCollection",
      features: R
    }, { replace: !0 });
  }
  const k = a.debounce(F, t.updateDelay);
  function O() {
    s && s.removeLayer(ai);
  }
  function $(R) {
    D(R).forEach((J) => {
      P(J, R, !1);
    });
  }
  function X(R) {
    D(R).forEach((J) => {
      P(J, R, !0);
    });
  }
  function te(R) {
    const J = Rn(R, {
      all: ce,
      removed: de
    }, n[R._id]);
    J && (n[R._id] = J);
  }
  function H(R) {
    Gi(R, n[R._id]), delete n[R._id];
  }
  function oe() {
    n = {}, a.forEach(s.getLayers(), te);
  }
  function fe() {
    a.forOwn(n, H), n = {};
  }
  function ce(R, J) {
    !J && R.layer && (J = s.getLayerById(R.layer)), J && S(R, J) && p(R, A(R, J));
  }
  function de(R, J) {
    !J && R.layer && (J = s.getLayerById(R.layer)), J && S(R, J) && C(R, J);
  }
  return Cn(() => {
    oe();
  }), je(() => {
    fe(), z();
  }), {
    setCurrentActivity: g,
    highlights: o,
    setHighlightMode: y,
    hasHighlight: S,
    getHighlight: A,
    getHighlights: D,
    highlight: w,
    unhighlight: C,
    setHighlightEnabled: P,
    setHighlightsEnabled: M,
    clearHighlights: z
  };
}
const Jd = {};
function Bb(e, t = {}) {
  a.defaults(t, { selection: !0, probe: !0, highlight: !0 });
  const i = Lu(e, t), { CurrentActivityContext: n } = i;
  let r, s, o;
  function l(u) {
    i.setCurrentActivity(u), r && r.setCurrentActivity(u), s && s.setCurrentActivity(u), o && o.setCurrentActivity(u);
  }
  const c = {
    ...i
  };
  return t.selection && (r = Hd(e, a.get(n, "config.selection")), Object.assign(c, {
    ...r
  })), t.probe && (s = Wd(e, a.get(n, "config.probe")), Object.assign(c, {
    ...s
  })), t.highlight && (o = Qd(e, a.get(n, "config.highlight")), Object.assign(c, {
    ...o
  })), Object.assign(c, {
    setCurrentActivity: l
  }), a.set(Jd, e, c), c;
}
const ll = Fl(null);
function jo(e = {}) {
  a.defaults(e, { selection: !0, probe: !0 });
  const t = ni(), { CurrentActivityContext: i } = t;
  function n(o) {
    ll.value = Bi(o);
  }
  function r() {
    return ll.value;
  }
  const s = {
    ...t,
    setActivityProject: n,
    getActivityProject: r
  };
  return i.name && Object.assign(s, a.get(Jd, i.name)), s;
}
class Yd extends Gl {
}
const Rb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KGeolocationError: Yd
}, Symbol.toStringTag, { value: "Module" }));
function $b(e, t, i) {
  t("service", "geocoder"), t("create", "geocoder"), t("service", "catalog"), t("read", "catalog"), t("service", "projects"), t("read", "projects"), t("service", "alerts"), t("read", "alerts"), t("service", "styles"), t("read", "styles");
}
const Ib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defineUserAbilities: $b
}, Symbol.toStringTag, { value: "Module" })), Ke = {
  ASCENDING: 0,
  DESCENDING: 1
}, Kt = {}, Hi = {}, cl = function() {
  const e = new Float32Array(1), t = new Int32Array(e.buffer);
  return function(n) {
    e[0] = n;
    const r = t[0];
    let s = r >> 16 & 32768, o = r >> 12 & 2047;
    const l = r >> 23 & 255;
    return l < 103 ? s : l > 142 ? (s |= 31744, s |= (l === 255 ? 0 : 1) && r & 8388607, s) : l < 113 ? (o |= 2048, s |= (o >> 114 - l) + (o >> 113 - l & 1), s) : (s |= l - 112 << 10 | o >> 1, s += o & 1, s);
  };
}();
class Wi {
  constructor(t, i, n, r) {
    if (this.sourceKey = t, this.bbox = i, this.dimensions = n, this.resolution = [(i[2] - i[0]) / (n[0] - 1), (i[3] - i[1]) / (n[1] - 1)], this.nodata = r, this.bbox[0] >= this.bbox[2] || this.bbox[1] >= this.bbox[3])
      throw new Error("Grid bbox seems weird");
    if (this.dimensions[0] <= 0 || this.dimensions[1] <= 0)
      throw new Error("Grid dimension is < 0, something's wrong");
    if (this.resolution[0] <= 0 || this.resolution[1] <= 0)
      throw new Error("Grid resolution is < 0, something's wrong");
  }
  getDimensions() {
    return this.dimensions;
  }
  getResolution() {
    return this.resolution;
  }
  getBBox() {
    return this.bbox;
  }
  hasData() {
    for (let t = 0; t < this.dimensions[0]; ++t)
      for (let i = 0; i < this.dimensions[1]; ++i)
        if (this.getValue(t, i) !== this.nodata)
          return !0;
    return !1;
  }
  getDataBounds() {
    if (this.dataBounds)
      return this.dataBounds;
    let t = 0, i = 0, n, r;
    for (; t < this.dimensions[0] && r === void 0; ++t)
      for (; i < this.dimensions[1] && r === void 0; ++i) {
        const s = this.getValue(t, i);
        s !== this.nodata && (n = r = s);
      }
    for (; t < this.dimensions[0]; ++t)
      for (; i < this.dimensions[1]; ++i) {
        const s = this.getValue(t, i);
        s !== this.nodata && (n = Math.min(n, s), r = Math.max(r, s));
      }
    return this.dataBounds = [n, r], this.dataBounds;
  }
  getLat(t) {
    return this.bbox[0] + t * this.resolution[0];
  }
  getLon(t) {
    return this.bbox[1] + t * this.resolution[1];
  }
  getValue(t, i) {
    throw new Error("Not implemented");
  }
  getIndices(t, i) {
    if (t < this.bbox[0] || t > this.bbox[2] || i < this.bbox[1] || i > this.bbox[2])
      return null;
    const n = (t - this.bbox[0]) / this.resolution[0], r = (i - this.bbox[1]) / this.resolution[1];
    return [Math.floor(n), Math.floor(r)];
  }
  getBestFit(t) {
    let i = -1;
    for (let o = 0; o < this.dimensions[0] - 1 && i === -1; ++o)
      this.getLat(o + 1) > t[0] && (i = o);
    let n = -1;
    for (let o = this.dimensions[0] - 1; o > 0 && n === -1; --o)
      this.getLat(o - 1) < t[2] && (n = o);
    let r = -1;
    for (let o = 0; o < this.dimensions[1] - 1 && r === -1; ++o)
      this.getLon(o + 1) > t[1] && (r = o);
    let s = -1;
    for (let o = this.dimensions[1] - 1; o > 0 && s === -1; --o)
      this.getLon(o - 1) < t[3] && (s = o);
    return [i, r, n, s];
  }
  genCoordsBuffer() {
    const t = this.dimensions[0] * this.dimensions[1], i = new Uint16Array(2 * t), n = this.getLat(0), r = this.getLat(this.dimensions[0] - 1), s = this.getLon(0), o = this.getLon(this.dimensions[1] - 1), l = r - n, c = o - s;
    let u = 0;
    for (let d = 0; d < this.dimensions[1]; ++d) {
      const f = this.getLon(d);
      for (let m = 0; m < this.dimensions[0]; ++m) {
        const g = this.getLat(m);
        i[u * 2] = cl((g - n) / l), i[u * 2 + 1] = cl((f - s) / c), ++u;
      }
    }
    return { coords: i, minLat: n, maxLat: r, minLon: s, maxLon: o, deltaLat: l, deltaLon: c };
  }
  genValuesBuffer() {
    const t = this.dimensions[0] * this.dimensions[1], i = new Float32Array(t);
    let n = 0;
    for (let r = 0; r < this.dimensions[1]; ++r)
      for (let s = 0; s < this.dimensions[0]; ++s)
        i[n] = this.getValue(s, r), ++n;
    return i;
  }
  genMeshIndexBuffer() {
    let t = 0;
    const i = this.dimensions[0] * this.dimensions[1] - 1, n = (this.dimensions[1] - 1) * (this.dimensions[0] * 2 + 1) - 1, r = i > 65534 ? 4294967295 : 65535, s = i > 65534 ? new Uint32Array(n) : new Uint16Array(n);
    for (let o = 0; o < this.dimensions[1] - 1; ++o) {
      for (let l = 0; l < this.dimensions[0]; ++l)
        s[t++] = l + o * this.dimensions[0], s[t++] = l + (o + 1) * this.dimensions[0];
      o !== this.dimensions[1] - 2 && (s[t++] = r);
    }
    return s;
  }
  genWireframeIndexBuffer() {
    const t = this.dimensions[0] * this.dimensions[1] - 1, i = this.dimensions[1] * (this.dimensions[0] + 1) + (this.dimensions[0] * (this.dimensions[1] + 1) - 1), n = t > 65534 ? 4294967295 : 65535, r = t > 65534 ? new Uint32Array(i) : new Uint16Array(i);
    let s = 0;
    for (let o = 0; o < this.dimensions[1]; ++o) {
      for (let l = 0; l < this.dimensions[0]; ++l)
        r[s++] = l + o * this.dimensions[0];
      r[s++] = n;
    }
    for (let o = 0; o < this.dimensions[0]; ++o) {
      for (let l = 0; l < this.dimensions[1]; ++l)
        r[s++] = o + l * this.dimensions[0];
      o !== this.dimensions[0] - 1 && (r[s++] = n);
    }
    return r;
  }
}
class Zi {
  constructor(t) {
    this.events = {}, this.sourceKey = 0;
  }
  getBBox() {
    return null;
  }
  getDataBounds() {
    throw new Error("Not implemented");
  }
  supportsNoData() {
    return this.nodata !== void 0;
  }
  /**
     * @returns {Number} Returns a new longitude with the value wrapped so it's always in the same range than the given bounding box (e.g. between -180 and +180 degrees).
     */
  wrapLongitude(t, i) {
    return i[0] < 0 ? t > 180 ? t - 360 : t : i[2] > 180 && t < 0 ? t + 360 : t;
  }
  async setup(t) {
    throw new Error("Not implemented");
  }
  async fetch(t, i, n) {
    throw new Error("Not implemented");
  }
  on(t, i) {
    const n = a.get(this.events, t, []);
    n.push(i), n.length === 1 && (this.events[t] = n);
  }
  off(t, i) {
    a.get(this.events, t, []).splice(0, 0, i);
  }
  emit(t) {
    const i = a.get(this.events, t, []), n = { source: this, event: t };
    for (const r of i)
      r(n);
  }
  dataChanged() {
    this.emit("data-changed");
  }
}
function qi(e, t = null) {
  const i = a.get(Kt, e, null);
  return i ? i(t) : null;
}
function $n(e) {
  for (const t of Object.keys(e))
    if (a.get(Kt, t, null))
      return [t, e[t]];
  return [null, null];
}
const zb = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i * n + t];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(r - (i + 1)) * n + t];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i * n + (n - (t + 1))];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(r - (i + 1)) * n + (n - (t + 1))];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[t * r + i];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[t * r + (r - (i + 1))];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[(n - (t + 1)) * r + i];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(n - (t + 1)) * r + (r - (i + 1))];
  }
];
class En extends Wi {
  constructor(t, i, n, r, s, o, l, c = void 0, u = null) {
    super(t, i, n, c), this.data = r;
    const d = l + o * 2 + (s ? 1 : 0) * 4;
    if (this.getByIndex = zb[d], u)
      for (let f = 0; f < r.length; ++f)
        r[f] = u(r[f]);
  }
  getValue(t, i) {
    return this.getByIndex(this.data, t, i, this.dimensions[0], this.dimensions[1]);
  }
}
const Nb = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i][t];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[r - (i + 1)][t];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i][n - (t + 1)];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[r - (i + 1)][n - (t + 1)];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[t][i];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[t][r - (i + 1)];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[n - (t + 1)][i];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[n - (t + 1)][r - (i + 1)];
  }
];
class Xd extends Wi {
  constructor(t, i, n, r, s, o, l, c = void 0, u = null) {
    super(t, i, n, c), this.data = r;
    const d = l + o * 2 + (s ? 1 : 0) * 4;
    if (this.getByIndex = Nb[d], u)
      for (let f = 0; f < r.length; ++f) {
        const m = r[f];
        for (let g = 0; g < m.length; ++g)
          m[g] = u(m[g]);
      }
  }
  getValue(t, i) {
    return this.getByIndex(this.data, t, i, this.dimensions[0], this.dimensions[1]);
  }
}
class zs extends Wi {
  constructor(t, i, n = void 0) {
    const r = i[0].getBBox(), s = i[0].getDimensions(), o = i[0].getResolution();
    super(t, r, s, n), this.dimensions = [0, 0], this.bbox = [r[0], r[1], r[2], r[3]], this.resolution = [o[0], o[1]];
    for (const l of i) {
      const c = l.getResolution();
      if (c[0] !== o[0] || c[1] !== o[1])
        throw new Error("Resolution does not match between tiles");
      const u = l.getBBox();
      this.bbox[0] = Math.min(this.bbox[0], u[0]), this.bbox[1] = Math.min(this.bbox[1], u[1]), this.bbox[2] = Math.max(this.bbox[2], u[2]), this.bbox[3] = Math.max(this.bbox[3], u[3]);
    }
    this.dimensions[0] = 1 + Math.trunc((this.bbox[2] - this.bbox[0]) / this.resolution[0]), this.dimensions[1] = 1 + Math.trunc((this.bbox[3] - this.bbox[1]) / this.resolution[1]), this.tiles = [];
    for (const l of i) {
      const c = l.getBBox(), u = {
        tile: l,
        iLatMin: Math.floor((c[0] - this.bbox[0]) / this.resolution[0]),
        iLatMax: Math.floor((c[2] - this.bbox[0]) / this.resolution[0]),
        iLonMin: Math.floor((c[1] - this.bbox[1]) / this.resolution[1]),
        iLonMax: Math.floor((c[3] - this.bbox[1]) / this.resolution[1])
      };
      this.tiles.push(u);
    }
  }
  getValue(t, i) {
    let n = null;
    for (const r of this.tiles)
      if (!(t < r.iLatMin || t > r.iLatMax || i < r.iLonMin || i > r.iLonMax)) {
        n = r;
        break;
      }
    return n ? n.tile.getValue(t - n.iLatMin, i - n.iLonMin) : 0;
  }
}
class ef extends Wi {
  constructor(t, i, n) {
    const [r, s, o, l] = i.getBestFit(n), c = [1 + o - r, 1 + l - s], u = [i.getLat(r), i.getLon(s), i.getLat(o), i.getLon(l)];
    super(t, u, c, i.nodata), this.latOffset = r, this.lonOffset = s, this.implGrid = i;
  }
  getValue(t, i) {
    return this.implGrid.getValue(t + this.latOffset, i + this.lonOffset);
  }
}
const qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseGrid: Wi,
  Grid1D: En,
  Grid2D: Xd,
  GridSource: Zi,
  SortOrder: Ke,
  SubGrid: ef,
  TiledGrid: zs,
  extractGridSourceConfig: $n,
  gridSourceFactories: Kt,
  makeGridSource: qi,
  unitConverters: Hi
}, Symbol.toStringTag, { value: "Module" })), tf = /* @__PURE__ */ new Set(["Float32", "Float64"]);
async function nf(e) {
  const t = e.indexOf("?"), i = t === -1 ? `${e}.dds` : `${e.substring(0, t)}.dds${e.substring(t)}`, n = t === -1 ? `${e}.das` : `${e.substring(0, t)}.das${e.substring(t)}`, r = fetch(i).then((d) => d.text()), s = fetch(n).then((d) => d.text()), [o, l] = await Promise.all([r, s]), c = new Cs.ddsParser(o).parse();
  return new Cs.dasParser(l, c).parse();
}
async function nr(e, t = null) {
  const i = t ? { signal: t } : {};
  let n = null, r = null, s = 0;
  for (; !r; ) {
    ++s;
    try {
      const l = await fetch(e, i).then((f) => f.arrayBuffer()), c = new DataView(l);
      let u = "", d = 0;
      for (; d < c.byteLength; ) {
        const f = c.getUint8(d);
        if ((f === `
` || f === 10) && String.fromCodePoint(
          c.getUint8(d + 1),
          c.getUint8(d + 2),
          c.getUint8(d + 3),
          c.getUint8(d + 4),
          c.getUint8(d + 5),
          c.getUint8(d + 6)
        ) === `Data:
`)
          break;
        u += String.fromCodePoint(f), ++d;
      }
      n = new Cs.ddsParser(u).parse(), r = new uh.dapUnpacker(l.slice(d + 7), n).getValue();
    } catch (l) {
      if (s >= 2) throw l;
    }
  }
  const o = {};
  if (n && r) {
    let l = 0;
    for (const c in n)
      n[c].type && (o[c] = r[l], l += 1);
  }
  return o;
}
function rf(e, t) {
  const i = e[t];
  return i === void 0 ? !1 : i.type === "Grid";
}
function Ns(e, t) {
  const i = e[t];
  return i === void 0 || i.shape === void 0 ? !1 : i.shape.length === 1 && tf.has(i.type);
}
function jb(e, t) {
  return e[t].shape[0];
}
function qs(e, t, i) {
  return e[t].array.shape[i];
}
function sf(e, t, i) {
  const n = e[t], r = [];
  for (let s = 0; s < n.array.dimensions.length; ++s) {
    const o = i[n.array.dimensions[s]];
    if (o === void 0)
      return [];
    r.push(o);
  }
  return r;
}
function rr(e, t) {
  let i;
  Array.isArray(t) ? i = t : i = a.keys(t).map((s) => `${s}[${t[s]}]`);
  const n = e.indexOf("?"), r = (n === -1 ? `${e}.dods?` : `${e.substring(0, n)}.dods${e.substring(n)}&`) + i.join(",");
  return encodeURI(r);
}
function js(e, t, i) {
  const n = e[t];
  return n === void 0 ? -1 : n.array.dimensions.indexOf(i);
}
function of(e) {
  return e.reduce((i, n) => (i[0] = Math.min(i[0], n), i[1] = Math.max(i[1], n), i), [e[0], e[0]]);
}
function Pr(e, t) {
  let i = 0, n = e;
  for (; i < t.length - 1; ++i)
    n = n[t[i]];
  return n[t[i]];
}
function Ub(e, t) {
  let i = 0, n = e;
  for (; i < t - 1; ++i)
    n = n[0];
  return n[0];
}
function af(e, t) {
  if (t > 1) {
    const i = Ub(e, t);
    return e.reduce((n, r) => {
      const s = af(r, t - 1);
      return [Math.min(n[0], s[0]), Math.max(n[1], s[1])];
    }, [i, i]);
  } else
    return of(e);
}
const Vb = [
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.ASCENDING
  function(e, t, i, n, r, s, o) {
    const l = [...e];
    return l.fill(0), l[t] = n, l[i] = r, l;
  },
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.DESCENDING
  function(e, t, i, n, r, s, o) {
    const l = [...e];
    return l.fill(0), l[t] = n, l[i] = o - (r + 1), l;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.ASCENDING
  function(e, t, i, n, r, s, o) {
    const l = [...e];
    return l.fill(0), l[t] = s - (n + 1), l[i] = r, l;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.DESCENDING
  function(e, t, i, n, r, s, o) {
    const l = [...e];
    return l.fill(0), l[t] = s - (n + 1), l[i] = o - (r + 1), l;
  }
];
class lf extends Wi {
  constructor(t, i, n, r, s, o, l, c, u, d = void 0, f = null) {
    super(t, i, n, d), this.data = r, this.indices = s, this.latIndex = o, this.lonIndex = l;
    const m = u + c * 2;
    if (this.makeIndices = Vb[m], f) {
      const g = [...s];
      g.fill(0);
      for (let v = 0; v < n[0]; ++v) {
        g[o] = v;
        for (let x = 0; x < n[1]; ++x) {
          g[l] = x;
          const S = Pr(r, g.slice(0, g.length - 1));
          S[g[g.length - 1]] = f(S[g[g.length - 1]]);
        }
      }
    }
  }
  getValue(t, i) {
    const n = this.makeIndices(this.indices, this.latIndex, this.lonIndex, t, i, this.dimensions[0], this.dimensions[1]);
    return Pr(this.data, n);
  }
}
const Kb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OpenDAPGrid: lf,
  fetchData: nr,
  fetchDescriptor: nf,
  getArrayVariableLength: jb,
  getGridDimensionIndex: js,
  getGridDimensionLength: qs,
  getGridValue: Pr,
  getMinMaxArray: of,
  getMinMaxGrid: af,
  makeGridIndices: sf,
  makeQuery: rr,
  opendapTypes: tf,
  variableIsArray: Ns,
  variableIsGrid: rf
}, Symbol.toStringTag, { value: "Module" }));
class ul extends Zi {
  static getKey() {
    return "opendap";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.descriptor = null, this.indices = null, this.latCount = 0, this.latIndex = 0, this.lonCount = 0, this.lonIndex = 0, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.latStep = 0, this.lonStep = 0, this.latSortOrder = Ke.ASCENDING, this.lonSortOrder = Ke.ASCENDING, this.canUseGrid2D = !1, this.config = t, this.converter = Hi[this.config.converter];
    try {
      this.descriptor = await nf(this.config.url);
    } catch {
      this.descriptor = null, console.log(`Failed fetching opendap descriptor from ${this.config.url}`);
    }
    if (this.descriptor) {
      const i = rf(this.descriptor, this.config.variable), n = Ns(this.descriptor, this.config.latitude), r = Ns(this.descriptor, this.config.longitude);
      if (i && n && r) {
        this.latIndex = js(this.descriptor, this.config.variable, this.config.latitude), this.latCount = qs(this.descriptor, this.config.variable, this.latIndex), this.lonIndex = js(this.descriptor, this.config.variable, this.config.longitude), this.lonCount = qs(this.descriptor, this.config.variable, this.lonIndex);
        const s = await this.getDimensionsAsIndices();
        if (s[this.config.latitude] = `0:${this.latCount - 1}`, s[this.config.longitude] = `0:${this.lonCount - 1}`, this.indices = sf(this.descriptor, this.config.variable, s), this.indices.length !== 0) {
          const o = this.indices.length - 1;
          (this.latIndex === o && this.lonIndex === o - 1 || this.latIndex === o - 1 && this.lonIndex === o) && (this.canUseGrid2D = !0), await this.computeMetaDataFromData(), this.usable = !0;
        } else
          console.log("Couldn't create index array for grid");
      } else
        i || console.log(`${this.config.variable} is not a grid variable!`), n || console.log(`${this.config.latitude} is expected to be an array variable!`), r || console.log(`${this.config.longitude} is expected to be an array variable!`);
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.makeQuery(i, n);
    if (!r)
      return null;
    const s = this.sourceKey, l = (await nr(r, t))[this.config.variable], c = l[0], u = l[this.latIndex + 1], d = l[this.lonIndex + 1], f = u[0], m = u[u.length - 1];
    let g = d[0], v = d[d.length - 1];
    g > 180 && (g -= 360), v > 180 && (v -= 360);
    const x = [Math.min(f, m), Math.min(g, v), Math.max(f, m), Math.max(g, v)];
    if (this.canUseGrid2D) {
      const S = this.indices.slice(0, this.indices.length - 2);
      S.fill(0);
      const A = Pr(c, S);
      return new Xd(
        s,
        x,
        [u.length, d.length],
        A,
        this.latIndex < this.lonIndex,
        this.latSortOrder,
        this.lonSortOrder,
        this.nodata,
        this.converter
      );
    }
    return new lf(
      s,
      x,
      [u.length, d.length],
      c,
      this.indices,
      this.latIndex,
      this.lonIndex,
      this.latSortOrder,
      this.lonSortOrder,
      this.nodata,
      this.converter
    );
  }
  makeQuery(t, i) {
    const n = t[0], r = t[1], s = t[2], o = t[3];
    let l = Math.floor((n - this.minMaxLat[0]) / this.latStep), c = Math.floor((r - this.minMaxLon[0]) / this.lonStep), u = Math.ceil((s - this.minMaxLat[0]) / this.latStep), d = Math.ceil((o - this.minMaxLon[0]) / this.lonStep);
    if (l = Math.min(Math.max(l, 0), this.latCount - 1), c = Math.min(Math.max(c, 0), this.lonCount - 1), u = Math.min(Math.max(u, 0), this.latCount - 1), d = Math.min(Math.max(d, 0), this.lonCount - 1), this.latSortOrder === Ke.DESCENDING) {
      const x = l;
      l = this.latCount - 1 - u, u = this.latCount - 1 - x;
    }
    if (this.lonSortOrder === Ke.DESCENDING) {
      const x = c;
      c = this.lonCount - 1 - d, d = this.lonCount - 1 - x;
    }
    const f = Math.max(1, Math.floor(i[0] / this.latStep)), m = Math.max(1, Math.floor(i[1] / this.lonStep));
    f > 1 && (u = Math.min(this.latCount - 1, u + f)), m > 1 && (d = Math.min(this.lonCount - 1, d + m));
    const g = [...this.indices];
    g[this.latIndex] = `${l}:${f}:${u}`, g[this.lonIndex] = `${c}:${m}:${d}`;
    const v = {};
    return v[this.config.variable] = g.join("]["), rr(this.config.url, v);
  }
  async computeMetaDataFromData() {
    const t = {};
    t[this.config.latitude] = `0:${this.latCount - 1}:${this.latCount - 1}`, t[this.config.longitude] = `0:${this.lonCount - 1}:${this.lonCount - 1}`;
    const i = rr(this.config.url, t), n = await nr(i), r = n[this.config.latitude], s = n[this.config.longitude], o = r[0], l = r[r.length - 1];
    this.minMaxLat = [Math.min(o, l), Math.max(o, l)];
    const c = s[0] > 180 ? s[0] - 360 : s[0], u = s[s.length - 1] > 180 ? s[s.length - 1] - 360 : s[s.length - 1];
    this.minMaxLon = [Math.min(c, u), Math.max(c, u)], this.latStep = (this.minMaxLat[1] - this.minMaxLat[0]) / (this.latCount - 1), this.lonStep = (this.minMaxLon[1] - this.minMaxLon[0]) / (this.lonCount - 1), this.latSortOrder = o < l ? Ke.ASCENDING : Ke.DESCENDING, this.lonSortOrder = c < u ? Ke.ASCENDING : Ke.DESCENDING;
  }
  async getDimensionsAsIndices() {
    const t = {};
    if (this.config.dimensionsAsIndices && Object.assign(t, this.config.dimensionsAsIndices), this.config.dimensionsAsValues) {
      const i = a.keys(this.config.dimensionsAsValues), n = rr(this.config.url, i), r = await nr(n, null);
      for (let s = 0; s < i.length; ++s) {
        const o = r[i[s]], l = this.config.dimensionsAsValues[i[s]];
        let c = -1;
        for (let u = 0; u < o.length && c === -1; ++u)
          o[u] === l && (c = u);
        if (c === -1)
          throw new Error(`Failed looking up value '${l}' for dimension named '${i[s]}'`);
        t[i[s]] = c;
      }
    }
    return t;
  }
}
function Gb(e, t = {}) {
  return fetch(e, { redirect: "follow", headers: t }).then((i) => i.text()).then((i) => lr.parseStringPromise(i, { tagNameProcessors: [lr.processors.stripPrefix] }));
}
async function Hb(e, t, i, n = {}, r = {}) {
  const s = Tn(e, Object.assign({
    SERVICE: "WCS",
    VERSION: t,
    REQUEST: "DescribeCoverage",
    COVERAGE: i
  }, n));
  return Gb(s, r);
}
async function Wb(e, t, i, n, r, s, o, l, c = {}, u = {}) {
  const d = Tn(t, Object.assign({
    SERVICE: "WCS",
    VERSION: i,
    REQUEST: "GetCoverage",
    COVERAGE: n,
    CRS: "EPSG:4326",
    BBOX: `${s.join(",")}`,
    WIDTH: o,
    HEIGHT: l,
    FORMAT: r
  }, c));
  return fetch(d, { method: "get", signal: e, headers: u }).then((f) => f.arrayBuffer());
}
function Zb(e) {
  const t = a.get(e, "CoverageDescription.CoverageOffering[0].lonLatEnvelope[0].pos", null);
  if (!t)
    return null;
  const i = [], n = [];
  for (const o of t) {
    const l = o.split(" ");
    n.push(parseFloat(l[0])), i.push(parseFloat(l[1]));
  }
  const r = [Math.min(...i), Math.min(...n)], s = [Math.max(...i), Math.max(...n)];
  return [r[0], r[1], s[0], s[1]];
}
function Qb(e) {
  const t = a.get(e, "CoverageDescription.CoverageOffering[0].supportedFormats[0]", null);
  return a.get(t, "formats");
}
class dl extends Zi {
  static getKey() {
    return "wcs";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.queryFormat = null, this.config = t, this.converter = Hi[t.converter];
    try {
      const i = await Hb(this.config.url, this.config.version, this.config.coverage, this.config.searchParams, this.config.headers), n = Zb(i), r = Qb(i);
      this.queryFormat = r[0], this.minMaxLat = [n[0], n[2]], this.minMaxLon = [n[1], n[3]], this.usable = !0;
    } catch {
      console.log(`Failed fetching wcs from ${this.config.url}`);
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.sourceKey, s = i[0], o = i[1], l = i[2], c = i[3], u = 1 + Math.trunc((i[3] - i[1]) / n[1]), d = 1 + Math.trunc((i[2] - i[0]) / n[0]), f = [o, s, c, l], m = await Wb(t, this.config.url, this.config.version, this.config.coverage, this.queryFormat, f, u, d, this.config.searchParams, this.config.headers).then((A) => ql.fromArrayBuffer(A)).then((A) => A.getImage()), g = m.readRasters(), v = m.getBoundingBox(), x = [v[1], v[0], v[3], v[2]], S = [m.getHeight(), m.getWidth()];
    return new En(
      r,
      x,
      S,
      (await g)[0],
      !0,
      Ke.DESCENDING,
      Ke.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function cf(e, t, i) {
  return e | t << 8 | i << 16 | 62 << 24;
}
function Jb(e) {
  const t = new Uint32Array(1), i = new Float32Array(t.buffer);
  return t[0] = e, i[0];
}
function Yb(e) {
  const t = 8 * (e.BYTES_PER_ELEMENT - 1), i = new Float32Array(e.length / 3), n = new Uint32Array(i.buffer);
  for (let r = 0; r < i.length; r++)
    n[r] = cf(e[r * 3] >> t, e[r * 3 + 1] >> t, e[r * 3 + 2] >> t);
  return i;
}
class fl extends Zi {
  static getKey() {
    return "geotiff";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.nodata = t.nodata, this.converter = Hi[t.converter], this.rgb = t.rgb;
    try {
      this.geotiff = await ql.fromUrl(t.url);
    } catch {
      this.geotiff = null, console.error(`Failed fetching geotiff from ${t.url}`);
    }
    if (this.geotiff) {
      if (this.imageCount = await this.geotiff.getImageCount(), this.refImage = await this.geotiff.getImage(), this.nodata === void 0) {
        const n = this.refImage.getFileDirectory(), r = parseFloat(n.GDAL_NODATA);
        r && !isNaN(r) && (this.nodata = r);
      }
      this.rgb === void 0 && (this.rgb = this.refImage.getSamplesPerPixel() > 1), this.rgb && this.nodata && this.nodata.length === 3 && (this.nodata = Jb(cf(this.nodata[0], this.nodata[1], this.nodata[2])));
      const i = this.refImage.getBoundingBox();
      this.minMaxLat = [i[1], i[3]], this.minMaxLon = [i[0], i[2]], this.usable = !0;
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.sourceKey;
    let s = await this.geotiff.getImage(0);
    for (let w = 1; w < this.imageCount; ++w) {
      const C = await this.geotiff.getImage(w), [P, M] = C.getResolution(this.refImage);
      if (Math.abs(P) > n[1] || Math.abs(M) > n[0]) break;
      s = C;
    }
    const [o, l] = s.getResolution(this.refImage), [c, u] = this.refImage.getOrigin(), [d, f] = [s.getWidth(), s.getHeight()];
    let m = (i[1] - c) / o, g = (i[3] - c) / o, v = (i[0] - u) / l, x = (i[2] - u) / l;
    o < 0 && ([m, g] = [g, m]), l < 0 && ([v, x] = [x, v]), m = Math.min(d - 1, Math.max(0, Math.floor(m))), g = Math.min(d - 1, Math.max(0, Math.ceil(g))), v = Math.min(f - 1, Math.max(0, Math.floor(v))), x = Math.min(f - 1, Math.max(0, Math.ceil(x)));
    const S = [m, v, g + 1, x + 1], A = this.rgb ? await s.readRGB({ window: S }) : await s.readRasters({ window: S, fillValue: this.nodata }), p = this.rgb ? Yb(A) : A[0];
    o < 0 && ([m, g] = [g, m]), l < 0 && ([v, x] = [x, v]);
    const y = [
      u + v * l,
      c + m * o,
      u + x * l,
      c + g * o
    ];
    return new En(
      r,
      y,
      [A.height, A.width],
      p,
      !0,
      Ke.DESCENDING,
      Ke.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function hl(e, t, i, n) {
  const r = i - t, s = Math.ceil(r / n) - 1;
  return Math.max(0, s);
}
function Xb(e, t) {
  const i = hl(e[0], e[1], e[3], t), n = hl(e[2], e[1], e[3], t), r = e[3] - e[1], s = [];
  for (let o = 0; o < i + 2; ++o) {
    const l = e[1] + o / (i + 1) * r;
    s.push([l, e[0]]);
  }
  for (let o = 0; o < n + 2; ++o) {
    const l = e[3] - o / (n + 1) * r;
    s.push([l, e[2]]);
  }
  return s.push([e[1], e[0]]), s;
}
function Qn(e, t) {
  return e * 4294967296 + t;
}
function e0(e) {
  const t = Math.floor(e / 4294967296);
  return [t, e - t * 4294967296];
}
class ml extends Zi {
  static getKey() {
    return "weacast";
  }
  constructor(t) {
    super(t), this.api = t.weacastApi, this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    if (this.usable = !1, ++this.sourceKey, !this.api) return;
    const i = this.api.models.find((o) => o.name === t.model);
    if (!i) return;
    this.converter = Hi[t.converter], this.time = he(t.forecastTime).utc().format(), this.service = t.model + "/" + t.element, this.lonResolution = i.tileResolution[0], this.useCache = a.get(t, "useCache", !0), this.maxCacheSize = a.get(t, "maxCacheSize", 0), this.useCache ? (this.tileCache = /* @__PURE__ */ new Map(), this.tileCounter = 0, this.tileOrigin = [i.origin[1], i.origin[0]], this.tileSize = [i.tileResolution[1], i.tileResolution[0]], this.wrapLon = i.bounds[2] > 180, this.maxTileX = (i.bounds[2] - i.bounds[0]) / i.tileResolution[0] - 1, this.maxTileY = (i.bounds[3] - i.bounds[1]) / i.tileResolution[1] - 1) : this.tileCache = null, this.minMaxLat = [i.bounds[1], i.bounds[3]];
    const n = i.bounds[2] === 360;
    this.minMaxLon = [n ? -180 : i.bounds[0], n ? 180 : i.bounds[2]], this.minMaxVal = null;
    const r = {
      time: this.time,
      $select: ["forecastTime", "minValue", "maxValue"],
      $paginate: !1
    }, s = await this.api.getService(this.service).find({ query: r });
    s.length > 0 && (this.minMaxVal = [s[0].minValue, s[0].maxValue]), this.usable = !0, this.dataChanged();
  }
  fetch(t, i, n) {
    return this.usable ? this.useCache ? this.fetchWithCache(t, i, n) : this.fetchWithoutCache(t, i, n) : null;
  }
  async fetchWithCache(t, i, n) {
    const r = this.wrapLon && i[1] < 0 ? i[1] + 360 : i[1], s = this.wrapLon && i[3] < 0 ? i[3] + 360 : i[3], o = Math.min(Math.max(Math.floor((s - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX), l = Math.min(Math.max(Math.floor((r - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX), c = Math.min(Math.max(Math.floor((this.tileOrigin[0] - i[2]) / this.tileSize[0]), 0), this.maxTileY), u = Math.min(Math.max(Math.floor((this.tileOrigin[0] - i[0]) / this.tileSize[0]), 0), this.maxTileY), d = [];
    for (let y = c; y <= u; ++y)
      if (l > o) {
        for (let w = 0; w <= o; ++w) d.push(Qn(w, y));
        for (let w = l; w <= this.maxTileX; ++w) d.push(Qn(w, y));
      } else
        for (let w = l; w <= o; ++w) d.push(Qn(w, y));
    const f = [], m = [], g = [], v = d.map((y) => this.tileCache.get(y));
    for (let y = 0; y < d.length; ++y)
      v[y] ? v[y].grid ? m.push(v[y].grid) : f.push(v[y].request) : g.push(d[y]);
    const x = this.sourceKey;
    if (g.length) {
      const y = [], w = [this.tileSize[1] * 0.5, this.tileSize[0] * 0.5];
      for (let M = 0; M < g.length; ++M) {
        const [z, D] = e0(g[M]);
        let T = this.tileOrigin[1] + this.tileSize[1] * z;
        const F = this.tileOrigin[0] - this.tileSize[0] * D;
        T >= 180 && (T -= 360), y.push([T + w[0], F - w[1]]);
      }
      const C = {
        time: this.time,
        $select: ["forecastTime", "data", "geometry", "size", "x", "y"],
        $paginate: !1,
        geometry: {
          $geoIntersects: {
            $geometry: {
              type: "MultiPoint",
              coordinates: y
            }
          }
        }
      }, P = new Promise((M, z) => {
        this.api.getService(this.service).find({ query: C }).then((D) => {
          const T = [];
          if (x === this.sourceKey)
            for (const F of D) {
              const k = F.geometry.coordinates[0], O = [k[0][1], k[0][0], k[2][1], k[2][0]];
              O[1] > O[3] && (O[1] -= 360);
              const $ = Qn(F.x, F.y), X = this.tileCache.get($);
              if (X.grid = new En(
                x,
                O,
                F.size,
                F.data,
                !0,
                Ke.DESCENDING,
                Ke.ASCENDING,
                this.nodata,
                this.converter
              ), X.request = null, this.maxCacheSize !== void 0 && (X.tileCounter = this.tileCounter, ++this.tileCounter, this.tileCounter > this.maxCacheSize)) {
                let te = $, H = X.tileCounter;
                for (const [oe, fe] of this.tileCache)
                  fe.tileCounter !== void 0 && fe.tileCounter < H && (H = fe.tileCounter, te = oe);
                this.tileCache.delete(te);
              }
              T.push(X.grid);
            }
          M(T);
        });
      });
      for (let M = 0; M < g.length; ++M)
        this.tileCache.set(g[M], { request: P });
      f.push(P);
    }
    const S = await Promise.all(f), A = m.concat(S.flat());
    if (A.length === 0) return null;
    const p = A.length > 1 ? new zs(x, A) : A[0];
    return new ef(x, p, i);
  }
  async fetchWithoutCache(t, i, n) {
    const r = {
      time: this.time,
      $select: ["forecastTime", "data", "geometry", "size"],
      $paginate: !1,
      // build a polygon with points longitudaly spaced every lonResolution degrees
      // otherwise mongodb will connect points using shortest path on sphere
      // which is not going to be a square lat/lon box
      geometry: {
        $geoIntersects: {
          $geometry: {
            type: "Polygon",
            coordinates: [Xb(i, this.lonResolution)]
          }
        }
      }
    }, s = this.sourceKey, o = await this.api.getService(this.service).find({ query: r });
    if (o.length === 0) return null;
    const l = [];
    for (const c of o) {
      const u = c.geometry.coordinates[0], d = [u[0][1], u[0][0], u[2][1], u[2][0]];
      d[1] > d[3] && (d[1] -= 360);
      const f = new En(
        s,
        d,
        c.size,
        c.data,
        !0,
        Ke.DESCENDING,
        Ke.ASCENDING,
        this.nodata,
        this.converter
      );
      l.push(f);
    }
    return l.length > 1 ? new zs(s, l) : l[0];
  }
}
function uf(e, t) {
  return Math.floor(e / t) * t;
}
function t0(e, t) {
  const i = uf(e.hours(), t / 3600);
  return e.clone().hours(i).minutes(0).seconds(0).milliseconds(0);
}
function i0(e, t) {
  const i = e.clone().add({ seconds: 0.5 * t }), n = uf(i.hours(), t / 3600);
  return i.clone().hours(n).minutes(0).seconds(0).milliseconds(0);
}
class df extends Zi {
  constructor(t) {
    super(t), this.source = null, this.updateId = null, this.updateCtx = {}, this.buildCtx = {}, this.onDataChanged = this.dataChanged.bind(this);
  }
  getBBox() {
    return this.source ? this.source.getBBox() : null;
  }
  getDataBounds() {
    return this.source ? this.source.getDataBounds() : null;
  }
  supportsNoData() {
    return this.source ? this.source.supportsNoData() : !1;
  }
  async fetch(t, i, n) {
    return this.source ? this.source.fetch(t, i, n) : null;
  }
  invalidate() {
    this.forceUpdate = !0;
  }
  queueUpdate() {
    this.updateId || (this.updateId = setTimeout(() => {
      this.update(this.updateCtx), this.updateId = null;
    }, 50));
  }
  update(t) {
    const i = this.makeBuildContext(t), n = this.forceUpdate ? !1 : this.shouldSkipUpdate(i, this.buildCtx);
    if (this.forceUpdate = !1, n) return;
    this.buildCtx = i;
    const [r, s] = this.buildSourceAndConfig(i);
    this.source && this.source.off("data-changed", this.onDataChanged), this.source = r, this.source ? (this.source.on("data-changed", this.onDataChanged), this.source.setup(s), this.sourceKey = this.source.sourceKey) : this.dataChanged();
  }
  makeBuildContext(t) {
    return Object.assign({}, t);
  }
  shouldSkipUpdate(t, i) {
    return !1;
  }
  buildSourceAndConfig(t) {
    throw new Error("Not implemented");
  }
  deriveConfig(t, i, n) {
    const r = Object.assign({}, i);
    for (const s of a.keys(n)) {
      const o = n[s](t);
      if (o != null) {
        let l = r;
        const c = s.split("$");
        for (let u = 0; u < c.length - 1; ++u)
          l[c[u]] === void 0 && (l[c[u]] = {}), l = l[c[u]];
        l[c[c.length - 1]] = o;
      }
    }
    return r;
  }
  dynpropGenerator(t) {
    if (t.strTemplate)
      return a.template(t.strTemplate);
    if (t.intTemplate) {
      const i = a.template(t.intTemplate);
      return function(n) {
        const r = i(n);
        return parseInt(r);
      };
    }
    if (t.floatTemplate) {
      const i = a.template(t.floatTemplate);
      return function(n) {
        const r = i(n);
        return parseFloat(r);
      };
    }
    return null;
  }
}
function Mr(e) {
  let t = null;
  return typeof e == "string" ? (e.charAt(0) === "P" ? t = he.duration(e) : t = he.utc(e), t = t.isValid() ? t : null) : e || (t = he.duration(0)), t;
}
function kr(e, t) {
  return he.isDuration(e) ? t.clone().add(e) : e;
}
class gl extends df {
  static getKey() {
    return "meteo_model";
  }
  constructor(t) {
    super(t), this.options = t, this.updateCtx.level = void 0;
  }
  setModel(t) {
    this.updateCtx.model = t, this.queueUpdate();
  }
  setTime(t) {
    this.updateCtx.time = t.clone(), this.updateCtx.time.utc(), this.updateCtx.runOffset = 0, this.queueUpdate();
  }
  setLevel(t) {
    t !== null ? this.updateCtx.level = t : this.updateCtx.level && delete this.updateCtx.level, this.queueUpdate();
  }
  async setup(t) {
    this.candidates = [];
    for (const i of t.sources) {
      const n = Object.assign(Object.assign({}, t.default), i), [r, s] = $n(n), o = {
        key: r,
        staticProps: s,
        dynamicProps: {},
        from: n.from ? Mr(n.from) : null,
        to: n.to ? Mr(n.to) : null,
        model: n.model
      }, l = a.has(n.dynprops, o.key) ? n.dynprops[o.key] : n.dynprops;
      for (const c of a.keys(l)) {
        const u = l[c], d = this.dynpropGenerator(u);
        d && (o.dynamicProps[c] = d);
      }
      this.candidates.push(o);
    }
  }
  makeBuildContext(t) {
    const i = Object.assign({}, t);
    return i.candidate = this.selectCandidate(t.time, t.model.name), i.candidate && (i.runTime = t0(t.time, t.model.runInterval), i.runTime.subtract(i.runOffset * t.model.runInterval, "seconds"), i.forecastTime = i0(t.time, t.model.interval), i.forecastOffset = he.duration(i.forecastTime.diff(i.runTime)), i.time.utc(), i.runTime.utc(), i.forecastTime.utc()), i;
  }
  shouldSkipUpdate(t, i) {
    return !(i.candidate !== t.candidate || i.runTime && t.runTime && !i.runTime.isSame(t.runTime) || i.forecastTime && t.forecastTime && !i.forecastTime.isSame(t.forecastTime) || i.level !== t.level);
  }
  buildSourceAndConfig(t) {
    let i = null, n = null;
    return t.candidate && (n = this.deriveConfig(t, t.candidate.staticProps, t.candidate.dynamicProps), n && (i = qi(t.candidate.key, this.options))), [i, n];
  }
  selectCandidate(t, i) {
    const n = he();
    let r = null;
    for (const s of this.candidates) {
      if (s.model !== i) continue;
      const o = s.from ? kr(s.from, n) : null, l = s.to ? kr(s.to, n) : null;
      if (o && l ? r = t.isBetween(o, l) ? s : null : o ? r = t.isSameOrAfter(o) ? s : null : l && (r = t.isSameOrBefore(l) ? s : null), r) break;
    }
    return r;
  }
  dataChanged() {
    if (this.source && !this.source.usable && this.updateCtx.runOffset === 0) {
      this.updateCtx.runOffset = 1, this.queueUpdate();
      return;
    }
    super.dataChanged();
  }
}
class pl extends df {
  static getKey() {
    return "time_based";
  }
  constructor(t) {
    super(t), this.options = t;
  }
  setTime(t) {
    this.updateCtx.time = t.clone(), this.updateCtx.time.utc(), this.queueUpdate();
  }
  async setup(t) {
    this.candidates = [];
    for (const i of t.sources) {
      const n = Object.assign(Object.assign({}, t.default), i), [r, s] = $n(n), o = {
        key: r,
        staticProps: s,
        dynamicProps: {},
        from: n.from ? Mr(n.from) : null,
        to: n.to ? Mr(n.to) : null,
        every: he.duration(n.every)
      }, l = a.has(n.dynprops, o.key) ? n.dynprops[o.key] : n.dynprops;
      for (const c of a.keys(l)) {
        const u = l[c], d = this.dynpropGenerator(u);
        d && (o.dynamicProps[c] = d);
      }
      this.candidates.push(o);
    }
  }
  makeBuildContext(t) {
    const i = Object.assign({}, t);
    return i.candidate = this.selectCandidate(i.time), i.candidate && (i.stepTime = he(Math.trunc(i.time / i.candidate.every) * i.candidate.every), i.time.utc(), i.stepTime.utc()), i;
  }
  shouldSkipUpdate(t, i) {
    return !(i.candidate !== t.candidate || i.stepTime && t.stepTime && !i.stepTime.isSame(t.stepTime));
  }
  buildSourceAndConfig(t) {
    let i = null, n = null;
    return t.candidate && (n = this.deriveConfig(t, t.candidate.staticProps, t.candidate.dynamicProps), n && (i = qi(t.candidate.key, this.options))), [i, n];
  }
  selectCandidate(t) {
    const i = he();
    let n = null;
    for (const r of this.candidates) {
      const s = r.from ? kr(r.from, i) : null, o = r.to ? kr(r.to, i) : null;
      if (s && o ? n = t.isBetween(s, o) ? r : null : s ? n = t.isSameOrAfter(s) ? r : null : o && (n = t.isSameOrBefore(o) ? r : null), n) break;
    }
    return n;
  }
}
Kt[ul.getKey()] = function(e) {
  return new ul(e);
};
Kt[dl.getKey()] = function(e) {
  return new dl(e);
};
Kt[fl.getKey()] = function(e) {
  return new fl(e);
};
Kt[ml.getKey()] = function(e) {
  return new ml(e);
};
Kt[gl.getKey()] = function(e) {
  return new gl(e);
};
Kt[pl.getKey()] = function(e) {
  return new pl(e);
};
Hi.kelvin2celsius = function(e) {
  return e - 273.15;
};
const Ct = {
  initialize() {
    j.set("geolocation", { location: null, error: void 0 });
  },
  hasLocation() {
    return j.get("geolocation.location");
  },
  get() {
    return j.get("geolocation");
  },
  getLongitude() {
    return j.get("geolocation.location.geometry.coordinates[0]", 0);
  },
  get longitude() {
    return this.getLongitude();
  },
  getLatitude() {
    return j.get("geolocation.location.geometry.coordinates[1]", 0);
  },
  get latitude() {
    return this.getLatitude();
  },
  getAltitude() {
    return j.get("geolocation.location.geometry.coordinates[2]", 0);
  },
  get altitude() {
    return this.getAltitude();
  },
  getGeometry() {
    return j.get("geolocation.location.geometry");
  },
  get geometry() {
    return this.getGeometry();
  },
  getAccuracy() {
    return j.get("geolocation.location.properties.accuracy");
  },
  get accuracy() {
    return this.getAccuracy();
  },
  getAltitudeAccuracy() {
    return j.get("geolocation.location.properties.altitudeAccuracy");
  },
  get altitudeAccuracy() {
    return this.getAltitudeAccuracy();
  },
  async update() {
    let e = null;
    try {
      e = await this.refresh(), j.patch("geolocation", { location: e, error: void 0 }), I.debug("[KDK] Geolocation updated:", e);
    } catch (t) {
      const i = t.code, n = new Yd();
      i === t.PERMISSION_DENIED ? n.code = "GEOLOCATION_PERMISSION_DENIED" : i === t.POSITION_UNAVAILABLE ? n.code = "GEOLOCATION_POSITION_UNAVAILABLE" : i === t.TIMEOUT ? n.code = "GEOLOCATION_POSITION_TIMEOUT" : n.code = "GEOLOCATION_ERROR", j.patch("geolocation", { location: null, error: n }), ne.emit("error", Object.assign(n, {
        // By default we only show geolocation errors, nothing if disabled by user
        ignore: i === t.PERMISSION_DENIED,
        retryHandler: () => this.refresh()
      })), I.debug("[KDK] geolocation failed: ", t);
    }
    return e;
  },
  async refresh() {
    return this.positionPromise = Nr(new Promise((e, t) => {
      if (!window.navigator.geolocation) {
        ne.emit("error", {
          message: "errors.GEOLOCATION_NOT_SUPPORTED",
          // By default we only show geolocation errors, nothing if unsupported
          ignore: !0
        });
        return;
      }
      window.navigator.geolocation.getCurrentPosition(
        (i) => {
          const n = i.coords.longitude, r = i.coords.latitude, s = i.coords.altitude;
          e({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: s ? [n, r, s] : [n, r]
            },
            properties: {
              name: es(r, n, j.get("locationFormat", "FFf")),
              accuracy: i.coords.accuracy,
              altitudeAccuracy: i.coords.altitudeAccuracy
            }
          });
        },
        (i) => t(i),
        { timeout: 3e4, enableHighAccuracy: !0 }
      );
    })), this.positionPromise;
  }
}, ff = {
  initialize() {
    this.availableApps = {
      waze: "https://waze.com/ul?q=<%= lat %>,<%= lon %>",
      "google-maps": "https://www.google.com/maps/dir/?api=1&destination=<%= lat %>,<%= lon %>",
      "apple-plan": "https://maps.apple.com/place?ll=<%= lat %>,<%= lon %>"
    };
    const e = Xe.get("settings");
    if (a.isNil(e)) {
      let t = "google-maps";
      It.ios && (t = "apple-plan"), j.set("navigator", t), I.debug("[KDK] Navigator initialized to:", this.get());
    } else
      I.debug("[KDK] Navigator initialized to:", e.navigator);
  },
  get() {
    return j.get("navigator");
  },
  navigateTo(e, t) {
    const i = this.get();
    if (a.isEmpty(i)) {
      I.debug("[KDK] Default navigator is undefined");
      return;
    }
    const r = a.template(this.availableApps[i])({ lat: e, lon: t });
    window.open(r);
  }
}, n0 = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`reading GeoJSON file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let o = s.result;
        try {
          o = JSON.parse(o);
        } catch (l) {
          r(new Error(Y.t("errors.INVALID_JSON_FILE", { file: i.name }), { errors: l }));
          return;
        }
        if (o.crs) {
          const l = a.get(o.crs, "properties.name");
          if (l) {
            const c = l.toLowerCase(), u = ["epsg:4326", "urn:ogc:def:crs:OGC:1.3:CRS84", "urn:ogc:def:crs:EPSG::4326"];
            if (!a.some(u, (f) => f.toLowerCase() === c)) {
              r(new Error(Y.t("errors.INVALID_GEOJSON_CRS", { file: i.name }), { errors: `Invalid CRS ${l}` }));
              return;
            }
            delete o.crs;
          }
        }
        n(o);
      }, s.onerror = (o) => {
        I.debug(o), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: o }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, r0 = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`reading KML file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let o = s.result;
        try {
          o = hf(new DOMParser().parseFromString(o, "text/xml"));
        } catch (l) {
          I.debug(l), r(new Error(Y.t("errors.INVALID_KML_FILE", { file: i.name }), { errors: l }));
          return;
        }
        n(o);
      }, s.onerror = (o) => {
        I.debug(o), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: o }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
function s0(e) {
  const t = {}, i = ["extrude", "altitudeMode"], n = e.getElementsByTagName("Placemark");
  return a.forEach(n, (r) => {
    const s = r.getElementsByTagName("name");
    if (!s.length) return;
    const o = s[0].textContent;
    a.forEach(i, (l) => {
      const c = r.getElementsByTagName(l);
      if (!c.length) return;
      let u = c[0].textContent;
      ["0", "1"].includes(u) && (u = u === "1"), a.set(t, [o, l].join("."), u);
    });
  }), t;
}
function hf(e) {
  const t = s0(e), i = fh(e);
  return a.forEach(a.get(i, "features", []), (n) => {
    const r = a.get(n, "properties.name", !1), s = a.merge(An(n.properties), On(n.properties), Bn(n.properties));
    r && a.has(t, r) && a.merge(s, t[r]), a.set(n, "style", s);
    const o = a.mapValues(a.get(n, "properties", {}), (l) => typeof l == "string" ? l.trim() : l);
    a.set(n, "properties", o), a.get(n, "geometry.type") === "Point" && a.has(n, "properties.name") && (a.set(n, "properties.icon-text", n.properties.name), a.set(n, "properties.entityStyle.label", {
      heightReference: "Cesium.HeightReference.RELATIVE_TO_GROUND"
    }));
  }), i;
}
const o0 = {
  read(e, t) {
    if (e.length !== 1) {
      I.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return I.debug(`reading GPX file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let o = s.result;
        try {
          o = hh(new DOMParser().parseFromString(o, "text/xml"));
        } catch (l) {
          I.debug(l), r(new Error(Y.t("errors.INVALID_GPX_FILE", { file: i.name }), { errors: l }));
          return;
        }
        n(o);
      }, s.onerror = (o) => {
        I.debug(o), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: o }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, a0 = {
  async read(e, t) {
    if (e.length < 1 || e.length > this.getAdditionalFiles().length + 1) {
      I.info("invalid 'files' arguments");
      return;
    }
    const i = [], n = e[0];
    i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (m) => {
        I.debug(m), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: n.name }), { errors: m }));
      }, f.readAsArrayBuffer(n);
    }));
    const r = a.find(e, (u) => zt.extname(u.name) === ".prj");
    r && i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (m) => {
        I.debug(m), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: r.name }), { errors: m }));
      }, f.readAsText(r);
    }));
    const s = a.find(e, (u) => zt.extname(u.name) === ".dbf");
    s && i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (m) => {
        I.debug(m), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: s.name }), { errors: m }));
      }, f.readAsArrayBuffer(s);
    }));
    const o = await Promise.all(i);
    if (s)
      return r ? Ht.combine([Ht.parseShp(o[0], o[1]), Ht.parseDbf(o[2])]) : Ht.combine([Ht.parseShp(o[0]), Ht.parseDbf(o[1])]);
    let l;
    r && (l = Ht.parseShp(o[0], o[1])), l = Ht.parseShp(o[0]);
    const c = {
      type: "FeatureCollection",
      features: []
    };
    return a.forEach(l, (u) => {
      c.features.push({
        type: "Feature",
        properties: {},
        geometry: u
      });
    }), c;
  },
  getAdditionalFiles() {
    return [".dbf", ".prj", ".shx", ".cpg"];
  }
}, l0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GEOJSONReader: n0,
  GPXReader: o0,
  KMLReader: r0,
  SHPReader: a0,
  convertToGeoJsonWithStyle: hf
}, Symbol.toStringTag, { value: "Module" }));
function c0(e) {
  const t = ["geoJson"];
  return a.omit(e, ...t);
}
function mf(e) {
  const t = this;
  return t.setForecastTime = (i) => {
    t.forecastTime = i, t.emit("forecast-time-changed", i);
  }, t.getForecastTime = () => t.forecastTime, t.createOfflineFeaturesService = async function(i, n = {}) {
    return n = Object.assign(a.omit(n, ["hooks", "dataPath"]), {
      // Set required default hooks and data path for snapshot as the service responds in GeoJson format
      hooks: a.defaultsDeep(a.get(n, "hooks"), {
        before: {
          all: [Xs, Js, zu],
          create: [Ys, Nu],
          remove: qu
        },
        after: {
          find: [ju, Uu]
        }
      }),
      dataPath: "features",
      // Here are service options used to manage offline features services
      features: !0
    }), await t.createOfflineService(i, n);
  }, t;
}
async function gf() {
  const e = this;
  I.debug("[KDK] Initializing Map module..."), e.registerMatcher(c0), e.createService("features-edition", {
    service: dh({
      id: "_id",
      paginate: { default: 10 },
      matcher: e.matcher
    })
  }), Ct.initialize(), Uo.initialize(), Us.initialize(), ff.initialize(), j.set("timeFormat", Rt({
    time: Rt({
      short: "H[h]",
      long: "HH:mm"
    }),
    date: Rt({
      short: "DD/MM",
      long: "dddd D"
    }),
    year: Rt({
      short: "YY",
      long: "YYYY"
    }),
    utc: !1,
    locale: Dt()
  })), j.set("locationFormat", "f"), j.set("restore", Rt({
    view: !0,
    layers: !1
  })), j.set("timeseries", Rt({
    span: 1440,
    // 24H
    groupBy: "feature"
  })), a.forEach(a.get(me, "readers.map", []), (t) => {
    I.debug(`[KDK] Registering mime types [${t.mimeTypes}] to reader ${t.reader}`), yi.register(t.mimeTypes, l0[t.reader]);
  }), Ni.polyline = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M1 44L17 6L33 44L49 6" />',
    clipPath: !1
  }, Ni.polygon = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M10 40L1 24L5 10L20 1L40 10L49 24L40 40L32 49Z" />'
  }, j.set("kdk.map.initialized", !0), I.debug("[KDK] Map module initialized");
}
const Uo = {
  initialize() {
    this.planets = {};
  },
  async connect(e, t = {}) {
    a.defaults(t, {
      origin: window.location.origin,
      apiPath: me.apiPath,
      apiJwt: `${e}-jwt`,
      gatewayJwt: `${e}-gateway-jwt`,
      apiTimeout: me.apiTimeout,
      transport: me.transport,
      appName: `${e}`,
      renewJwt: !1
    });
    const i = await eo(t);
    mf.bind(i)(t), i.on("authenticated", (r) => {
      r.gatewayToken && i.get("storage").setItem(t.gatewayJwt, r.gatewayToken);
    }), i.on("logout", (r) => {
      i.get("storage").removeItem(t.gatewayJwt);
    });
    const n = await i.get("storage").getItem(t.apiJwt);
    if (!n) {
      I.error(new Error(`You must set planet ${e} token first`));
      return;
    }
    return await i.authenticate({
      strategy: "jwt",
      accessToken: n
    }), this.planets[e] = i, i;
  },
  async disconnect(e) {
    await this.planets[e].logout(), delete this.planets[e];
  },
  isConnected(e) {
    return !a.isNil(this.planets[e]);
  },
  get(e) {
    if (!this.planets[e]) I.error(new Error(`You must connect to planet ${e} first`));
    else return this.planets[e];
  },
  // Register an existing planet
  set(e, t) {
    this.planets[e] = t;
  }
}, Us = {
  initialize() {
    j.set("geocoder", a.defaultsDeep(me.geocoder, {
      planet: void 0,
      path: "geocoder"
    })), I.debug("[KDK] Geocoder initialized with configuration:", j.get("geocoder"));
  },
  getApiConfig() {
    const e = j.get("geocoder.planet");
    return e ? Uo.get(e).getConfig() : G.getConfig();
  },
  getApiPath() {
    return j.get("geocoder.path");
  },
  async query(e, t = "") {
    const i = this.getApiConfig();
    if (!a.has(i, "gateway")) {
      I.error("[KDK] Invalid Geocoder configuration: missing 'gateway' property");
      return;
    }
    if (!a.has(i, "gatewayJwt")) {
      I.error("[KDK] Invalid Geocoder configuration: missing 'gatewayJwt' property");
      return;
    }
    const n = `${i.gateway}/${this.getApiPath()}`, r = await G.get("storage").getItem(i.gatewayJwt);
    let s = `${n}/${e}`;
    return t && (s += `?${t}`), (await fetch(s, { headers: { Authorization: `Bearer ${r}` } })).json();
  },
  async getForwardCapabilities() {
    let e;
    try {
      e = await this.query("capabilities/forward"), e.i18n && Y.registerTranslation(e.i18n);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return a.get(e, "geocoders", []);
  },
  async getReverseCapabilities() {
    let e;
    try {
      e = await this.query("capabilities/reverse"), e.i18n && Y.registerTranslation(e.i18n);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return a.get(e, "geocoders", []);
  },
  async queryForward(e, t = {}) {
    const i = [], n = qd(e);
    if (n)
      i.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [n.longitude, n.latitude]
        },
        properties: {
          name: es(n.latitude, n.longitude, j.get("locationFormat", "FFf"))
        }
      });
    else {
      let r = "";
      a.isEmpty(t.geocoders) || (r += "&sources=*(" + t.geocoders.join("|") + ")"), a.isEmpty(t.viewbox) || (r += "&viewbox=" + t.viewbox.join(",")), r += "&limit=" + (t.limit || 20), (await this.query("forward", `q=${e}${r}`)).forEach((o) => {
        i.push(
          Object.assign(
            a.pick(o, ["type", "geometry"]),
            { properties: { name: jd(o), source: o.geokoder.source } }
          )
        );
      });
    }
    return i;
  }
};
function u0() {
  const { getActivityProject: e } = jo({ selection: !1, probe: !1 }), t = ue([]), i = ue([]), n = ue([]);
  async function r(c) {
    if (a.isNull(c))
      t.value = [], i.value = [];
    else {
      let u = await Us.getForwardCapabilities();
      u = Ud(u, e()), a.isEmpty(c) ? (t.value = a.map(u, (d) => ({ value: d, label: Y.tie(`Geocoders.${d}`) })), i.value = u) : (t.value = a.reduce(c, (d, f) => {
        const m = a.replace(f.source, /^services:.*\//g, `services:${nt.getId()}/`), g = a.replace(f.source, /^services:.*\//g, "services:*/");
        return u.includes(m) && d.push({ value: m, label: Y.tie(`Geocoders.${g}`), selected: f.selected }), d;
      }, []), i.value = a.reduce(t.value, (d, f) => (f.selected && d.push(f.value), d), []));
    }
  }
  async function s(c) {
    a.isNull(c) ? n.value = [] : n.value = c;
  }
  async function o() {
    if (await Ct.update(), !j.get("geolocation.error"))
      return j.get("geolocation.location");
  }
  async function l(c, u = 25) {
    return Us.queryForward(c, {
      geocoders: i.value,
      viewbox: n.value,
      limit: u
    });
  }
  return {
    availableGeocoders: t,
    selectedGeocoders: i,
    setGeocoders: r,
    setViewbox: s,
    geolocate: o,
    search: l
  };
}
function d0() {
  function e(i, n) {
    if (Array.isArray(i) && Array.isArray(n)) {
      const r = jr(be.getCurrentTime(), i.map((s) => he.utc(s)));
      return r.index >= 0 ? n[r.index] : null;
    } else
      return n;
  }
  function t(i) {
    const n = a.cloneDeep(i);
    return a.forOwn(n.properties, (r, s) => {
      if (Array.isArray(r)) {
        const o = a.get(n, "time." + s);
        o && (a.set(n, "properties." + s, e(o, r)), a.set(n, "time." + s, e(o, o)));
      }
    }), n;
  }
  return {
    getMeasureValueAtCurrentTime: e,
    getProbedLocationMeasureAtCurrentTime: t
  };
}
function f0(e = {}) {
  const { kActivity: t } = ni();
  let i = Bi(t);
  _e(t, (m) => {
    m = Bi(m), i !== m && m && (i = m);
  });
  function n(m) {
    const g = {
      // Only wind/temperature can be available at different levels now
      windDirection: {
        property: i.forecastLevel ? `properties.windDirection-${i.forecastLevel}` : "properties.windDirection"
      },
      windSpeed: {
        property: i.forecastLevel ? `properties.windSpeed-${i.forecastLevel}` : "properties.windSpeed"
      },
      temperature: {
        property: i.forecastLevel ? `properties.temperature-${i.forecastLevel}` : "properties.temperature"
      },
      gust: {
        property: "properties.gust",
        label: "max"
      },
      precipitations: {
        property: "properties.precipitations"
      },
      humidity: {
        property: "properties.humidity"
      },
      time: {
        property: "forecastTime"
      },
      name: {
        property: "properties.name"
      }
    };
    return m && m.length > 0 && a.forOwn(g, (v, x) => {
      const S = a.find(m, { name: `${v.property.replace("properties.", "")}` });
      S && (v.label = S.label);
    }), g;
  }
  function r(m) {
    const { windDirection: g, windSpeed: v } = n();
    return a.has(m, g.property) && a.has(m, v.property);
  }
  function s(m, g = {}) {
    const v = n(), x = a.get(g, "windDirection.label", v.windDirection.label), S = a.get(g, "windSpeed.label", v.windSpeed.label), A = a.get(g, "gust.label", v.gust.label), p = a.get(g, "temperature.label", v.temperature.label), y = a.get(g, "precipitations.label", v.precipitations.label), w = a.get(g, "humidity.label", v.humidity.label), C = a.get(g, "windDirection.property", v.windDirection.property), P = a.get(g, "windSpeed.property", v.windSpeed.property), M = a.get(g, "gust.property", v.gust.property), z = a.get(g, "temperature.property", v.temperature.property), D = a.get(g, "precipitations.property", v.precipitations.property), T = a.get(g, "humidity.property", v.humidity.property), F = a.get(g, "time.property", v.time.property), k = a.get(g, "name.property", v.name.property), O = a.get(m, `${C}`), $ = a.get(m, `${P}`), X = a.get(m, `${M}`), te = a.get(m, `${z}`), H = a.get(m, `${D}`), oe = a.get(m, `${T}`);
    let fe = a.get(m, `${F}`), ce = !0;
    if (typeof fe == "object") {
      const J = a.uniq(a.values(fe));
      J.length > 1 ? ce = !1 : fe = J[0];
    }
    const de = (J) => !a.isNil(J) && (J = he.utc(J), J.isValid()) ? ` (${be.format(J, "date.short")} - ${be.format(J, "time.long")})` : "";
    let R = "";
    if (!a.isNil($) && a.isFinite($) && (S && (R += `${Y.tie(S)}: `), R += Me.format($, "m/s"), ce || (R += de(a.get(fe, P.replace("properties.", "")))), R += "</br>"), !a.isNil(X) && a.isFinite(X) && (A && (R += `${Y.tie(A)}: `), R += Me.format(X, "m/s"), ce || (R += de(a.get(fe, M.replace("properties.", "")))), R += "</br>"), !a.isNil(O) && a.isFinite(O) && (x && (R += `${Y.tie(x)}: `), R += Me.format(O, "deg"), ce || (R += de(a.get(fe, C.replace("properties.", "")))), R += "</br>"), !a.isNil(H) && a.isFinite(H) && (y && (R += `${Y.tie(y)}: `), R += Me.format(H, "mm/h"), ce || (R += de(a.get(fe, D.replace("properties.", "")))), R += "</br>"), !a.isNil(oe) && a.isFinite(oe) && (w && (R += `${Y.tie(w)}: `), R += `${oe.toFixed(0)} %`, ce || (R += de(a.get(fe, T.replace("properties.", "")))), R += "</br>"), !a.isNil(te) && a.isFinite(te) && (p && (R += `${Y.tie(p)}: `), R += Me.format(te, "degC"), ce || (R += de(a.get(fe, z.replace("properties.", "")))), R += "</br>"), R) {
      const J = a.get(m, `${k}`);
      a.isNil(J) || (R = `<b><u>${J}</u></b></br>` + R), ce && (R += de(fe).trim().replace("(", "").replace(")", ""));
    }
    return R;
  }
  function o(m, g) {
    if (Array.isArray(m) && Array.isArray(g)) {
      const v = jr(be.getCurrentTime(), m.map((x) => he.utc(x)));
      return v.difference / 1e3 > 0.5 * i.forecastModel.interval ? null : g[v.index];
    } else
      return g;
  }
  function l(m) {
    const g = a.cloneDeep(m);
    return a.forOwn(g.properties, (v, x) => {
      if (Array.isArray(v)) {
        const S = a.get(g, "forecastTime." + x);
        S && (a.set(g, "properties." + x, o(S, v)), a.set(g, "forecastTime." + x, o(S, S)));
      }
    }), g;
  }
  function c(m, g = {}) {
    const v = n();
    let x = a.get(g, "windDirection.property", v.windDirection.property), S = a.get(g, "windSpeed.property", v.windSpeed.property);
    return x = a.get(m, `${x}`), S = a.get(m, `${S}`), a.isNil(x) || !a.isFinite(x) || a.isNil(S) || !a.isFinite(S) ? null : {
      deg: x,
      speed: S,
      // Expressed as m/s
      pointRadius: 10,
      pointColor: "#2196f3",
      pointStroke: "#888888",
      strokeWidth: 2,
      strokeColor: "#888888",
      strokeLength: 12,
      fillColor: "#2196f3",
      barbSpaceing: 4,
      barbHeight: 10,
      forceDir: !0
    };
  }
  function u(m, g = {}) {
    const v = c(m, g);
    return v ? new B.WindBarb.Icon(v) : null;
  }
  function d(m, g, v, x = {}) {
    const S = s(m, x);
    return S ? B.tooltip({ permanent: !1 }, g).setContent(`<b>${S}</b>`) : null;
  }
  function f(m, g, v, x = {}) {
    const S = u(m, x);
    return S ? B.marker(g, { icon: S }) : null;
  }
  return {
    getProbedLocationForecastFields: n,
    isWeatherProbe: r,
    getForecastAsHtml: s,
    getWindBarbOptions: c,
    createWindBarbIcon: u,
    getProbedLocationForecastAtCurrentTime: l,
    getProbedLocationForecastTooltip: d,
    getProbedLocationForecastMarker: f
  };
}
function h0(e = {}) {
  a.defaults(e, {
    // Default filter queries
    layers: {},
    categories: {},
    sublegends: {},
    views: {},
    // Default to contextual or global catalog depending on store
    context: "",
    // Default to app API
    planetApi: G
  });
  const t = ue([]), i = ue([]), n = ue([]), r = ue([]), s = W(() => Du(t.value, i.value)), o = W(() => Au(t.value, s.value));
  async function l(f = {}) {
    const m = Object.assign(
      {},
      e.project ? Object.assign(Sn(e.project), e.layers) : e.layers,
      f
    );
    return t.value = await wr({
      query: m,
      context: e.context,
      planetApi: e.planetApi
    }), t.value;
  }
  async function c() {
    return i.value = await _r({
      query: e.categories,
      context: e.context,
      planetApi: e.planetApi
    }), i.value;
  }
  async function u() {
    return n.value = await Lr({
      query: e.sublegends,
      context: e.context,
      planetApi: e.planetApi
    }), n.value;
  }
  async function d() {
    return r.value = await Ou({
      query: e.project ? Object.assign(Sn(e.project), e.views) : e.views,
      context: e.context,
      planetApi: e.planetApi
    }), r.value;
  }
  return {
    layers: t,
    categories: i,
    sublegends: n,
    layersByCategory: s,
    orphanLayers: o,
    views: r,
    getLayers: l,
    getCategories: c,
    getSublegends: u,
    getViews: d
  };
}
function m0(e = {}) {
  const { setActivityProject: t } = jo({ selection: !1, probe: !1 });
  a.defaults(e, {
    // Set if project should be extracted from route
    // otherwise it should be loaded manually
    route: !0,
    // Default to contextual or global service depending on store
    context: "",
    // Default to target activity
    updateActivity: !0,
    // Default to app API
    planetApi: G
  });
  const i = Ws(), n = Hs(), r = ue(null), s = ue(null);
  let o;
  const l = W(() => a.isEmpty(r.value) ? {} : { project: r.value }), c = W(() => a.isEmpty(s.value) ? {} : Sn(s.value));
  function u() {
    return r.value;
  }
  function d() {
    return s.value;
  }
  async function f(x) {
    v();
    const S = x ? a.cloneDeep(x) : {};
    if (a.defaults(S, { populate: !0 }), r.value)
      s.value = await e.planetApi.getService("projects", e.context).get(r.value, { query: S });
    else if (s.value = null, x) {
      const A = await e.planetApi.getService("projects", e.context).find({ query: S });
      s.value = a.get(A, "data[0]"), s.value && (r.value = s.value._id);
    }
    e.updateActivity && t(s.value), s.value && (s.value.getPlanetApi = () => e.planetApi);
  }
  function m(x) {
    s.value && x._id === s.value._id && (s.value = x, e.updateActivity && t(x));
  }
  function g(x) {
    s.value && x._id === s.value._id && (s.value = null, r.value = null, e.route && n.push({
      name: i.name,
      query: a.omit(i.query, ["project"]),
      params: i.params
    }));
  }
  function v() {
    if (!e.route) return;
    const x = a.get(i, "query.project", null);
    r.value !== x && (r.value = x);
  }
  return e.route && _e(() => i.query.project, v), Cn(() => {
    v(), o = qt(e.planetApi.getService("projects", e.context), {
      patched: m,
      updated: m,
      removed: g
    });
  }), je(() => {
    At(o);
  }), {
    project: s,
    projectId: r,
    hasProject: u,
    isProjectLoaded: d,
    loadProject: f,
    projectQuery: l,
    catalogProjectQuery: c
  };
}
const g0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HighlightMargin: ir,
  HighlightsLayerName: ai,
  HighlightsZIndex: Zd,
  useActivity: Bb,
  useCatalog: h0,
  useCurrentActivity: jo,
  useHighlight: Qd,
  useLocation: u0,
  useMeasure: d0,
  useProbe: Wd,
  useProject: m0,
  useSelection: Hd,
  useWeather: f0
}, Symbol.toStringTag, { value: "Module" })), p0 = {
  emits: [
    "layer-filter-toggled"
  ],
  data() {
    return {
      layerCategories: [],
      variables: [],
      engine: "leaflet",
      engineReady: !1,
      engineContainerWidth: null,
      engineContainerHeight: null
    };
  },
  computed: {
    viewStyle() {
      return "width: 100%; height: 100%; fontWeight: normal; zIndex: 0; position: absolute;";
    },
    variablesForCurrentLevel() {
      return this.variables.map((e) => Object.assign({ name: `${e.name}-${this.selectedLevel}` }, a.omit(e, ["name"])));
    },
    currentVariables() {
      return this.forecastLevel ? this.variablesForCurrentLevel : this.variables;
    }
  },
  methods: {
    is2D() {
      return this.engine === "leaflet";
    },
    is3D() {
      return this.engine === "cesium";
    },
    // This method should be overriden in activities
    getFeatureActions(e, t) {
      return [];
    },
    async getCatalogLayers() {
      const e = {};
      this.project ? Object.assign(e, this.catalogProjectQuery ? this.catalogProjectQuery : Sn(this.project)) : this.project = null;
      let t = await wr({ query: e });
      const i = j.get("context");
      return i && (t = t.concat(await wr({ query: e, context: i }))), t;
    },
    async addCatalogLayer(e) {
      if (e[this.engine]) {
        if (a.get(e, `${this.engine}.type`, "").startsWith("weacast.") && (!this.getWeacastApi() || !this.forecastModel)) return;
        await this.addLayer(e);
      }
      e.variables && (this.variables = a.uniqBy(this.variables.concat(e.variables), (t) => t.name));
    },
    async removeCatalogLayer(e) {
      e[this.engine] && await this.removeLayer(e.name);
    },
    async getCatalogCategories() {
      let e = await _r();
      const t = j.get("context");
      return t && (e = e.concat(await _r({ context: t }))), e;
    },
    async getCatalogSublegends() {
      let e = await Lr();
      const t = j.get("context");
      return t && (e = e.concat(await Lr({ context: t }))), e;
    },
    async addCatalogCategory(e) {
      this.layerCategories.push(e);
    },
    async refreshLayerCategories() {
      this.layerCategories.splice(0, this.layerCategories.length);
      const e = await this.getCatalogCategories();
      for (let t = 0; t < e.length; t++)
        this.addCatalogCategory(e[t]);
      await this.refreshOrphanLayers();
    },
    async updateCategoriesOrder(e, t) {
      this.reorganizeLayers();
    },
    async updateLayersOrder(e, t) {
      this.reorganizeLayers();
    },
    async updateOrphanLayersOrder(e) {
      this.reorganizeLayers();
    },
    async refreshLayers() {
      this.clearLayers(), this.variables = [];
      const e = await this.getCatalogLayers();
      for (let i = 0; i < e.length; i++)
        await this.addCatalogLayer(e[i]);
      if (!e.find((i) => i.type === "BaseLayer" && i.isVisible)) {
        const i = e.find((n) => n.type === "BaseLayer");
        i && await this.showLayer(i.name);
      }
    },
    async refreshOrphanLayers() {
      typeof this.reorganizeLayers == "function" && this.reorganizeLayers();
    },
    isInMemoryLayer: Jt,
    isUserLayer: ri,
    isFeatureLayer: Ki,
    hasFeatureSchema: cd,
    isLayerSelectable(e) {
      return typeof this.isLayerEdited == "function" && this.isLayerEdited(e) ? !1 : ud(e);
    },
    isLayerProbable: fd,
    isLayerStorable: hd,
    isLayerCached: gd,
    isLayerCachable: Kr,
    setLayerCached: Ro,
    setLayerUncached: $o,
    isLayerEditable: md,
    isLayerFilterEditable: xd,
    isLayerRemovable: wd,
    isLayerStyleEditable: _d,
    isLayerDataEditable: Ld,
    canCreateLayer() {
      return G.can("create", "catalog");
    },
    canUpdateLayer(e) {
      return Jt(e) || G.can("update", "catalog");
    },
    canRemoveLayer(e) {
      return Jt(e) || G.can("remove", "catalog");
    },
    async resetLayer(e) {
      if (this.isLayerVisible(e.name)) {
        let i;
        Jt(e) && typeof this.toGeoJson == "function" && (i = await this.toGeoJson(e.name)), await this.hideLayer(e.name), await this.showLayer(e.name), i && this.updateLayer(e.name, i), typeof this.updateLayerDisabled == "function" && this.updateLayerDisabled(e);
      }
    },
    configureLayerActions(e) {
      let t = a.get(this, "activityOptions.layers.actions", []);
      return t = Ai(t, a.get(this, "activityOptions.layers.filter", {})), t = kn(a.cloneDeep(t), this, ["dialog"]), t.push({ id: "toggle", handler: () => this.onTriggerLayer(e) }), t.push({ id: "toggle-filter", handler: (i) => this.onTriggerLayerFilter(e, i) }), e.actions = t, t;
    },
    async onTriggerLayer(e) {
      this.isLayerVisible(e.name) ? await this.hideLayer(e.name) : await this.showLayer(e.name), typeof this.storeContext == "function" && this.storeContext("layers");
    },
    async onTriggerLayerFilter(e, t) {
      typeof this.updateLayer == "function" && await this.updateLayer(e.name, null, { removeMissing: !0 }), this.$emit("layer-filter-toggled", e, t), this.$engineEvents.emit("layer-filter-toggled", e, t);
    },
    onZoomIn() {
      const e = this.getCenter();
      this.center(e.longitude, e.latitude, e.zoomLevel ? e.zoomLevel + 1 : e.altitude * 0.5);
    },
    onZoomOut() {
      const e = this.getCenter();
      this.center(e.longitude, e.latitude, e.zoomLevel ? e.zoomLevel - 1 : e.altitude * 2);
    },
    onZoomToLayer(e) {
      this.zoomToLayer(e.name);
    },
    onBringLayerToFront(e) {
      typeof this.bringLayerToFront == "function" && this.bringLayerToFront(e.name);
    },
    onBringLayerToBack(e) {
      typeof this.bringLayerToBack == "function" && this.bringLayerToBack(e.name);
    },
    async onSaveLayer(e) {
      typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("accept");
      let t;
      if (!a.has(e, "wfs") && a.get(e, `${this.engine}.type`) === "geoJson") {
        const i = this.toGeoJson(e.name);
        t = await Md(e, i, a.get(this, "activityOptions.featuresChunkSize", 5e3));
      } else
        t = await kd(e);
      this.project && this.project.getPlanetApi() === G && (this.project.layers.push({ _id: t._id }), await G.getService("projects").patch(this.project._id, {
        layers: this.project.layers
      })), t && (e._id = t._id, await this.resetLayer(t));
    },
    editLayerByName(e, t = {}) {
      const i = this.getLayerByName(e);
      i && this.startEditLayer(i, t);
    },
    async onEditLayerData(e) {
      this.isLayerEdited(e) ? await this.stopEditLayer("accept") : await this.startEditLayer(e, { editMode: "edit-properties" });
    },
    async onEndLayerEdition(e = "accept") {
      await this.stopEditLayer(e);
    },
    async onResetLayerStyle(e) {
      await Td(e, {}), e._id || await this.resetLayer(e);
    },
    async onRemoveLayer(e) {
      typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("reject"), await Fd(e) && this.removeLayer(e.name), await this.refreshOrphanLayers();
    },
    onEngineReady(e) {
      this.engine = e, this.engineReady = !0;
    },
    onToggleFullscreen() {
      this.$q.fullscreen.isActive ? this.$q.fullscreen.exit() : this.$q.fullscreen.request();
    },
    listenToCatalogServiceEvents() {
      const e = G.getService("catalog", "global"), t = G.getService("catalog");
      this.globalCatalogListeners = qt("catalog", {
        context: "global",
        all: this.onCatalogUpdated,
        removed: (i) => this.onCatalogUpdated(i, "removed")
      }, this.globalCatalogListeners), t && t !== e && (this.catalogListeners = qt("catalog", {
        all: this.onCatalogUpdated,
        removed: (i) => this.onCatalogUpdated(i, "removed")
      }, this.catalogListeners));
    },
    unlistenToCatalogServiceEvents() {
      this.globalCatalogListeners && At(this.globalCatalogListeners), this.catalogListeners && At(this.catalogListeners), this.globalCatalogListeners = null, this.catalogListeners = null;
    },
    resetCatalogServiceEventsListeners() {
      this.listenToCatalogServiceEvents();
    },
    async initialize() {
      const e = typeof this.restoreContext == "function", t = a.get(me, "weacast.enabled", !0);
      if (t && this.setupWeacast)
        try {
          await this.setupWeacast();
        } catch (n) {
          I.error("[KDK]", n);
        }
      else
        t ? I.warn("[KDK] Weacast setup function is missing") : I.debug("[KDK] disabling Weacast");
      try {
        await this.refreshLayerCategories(), await this.refreshLayers(), e && await this.restoreContext("layers");
      } catch (n) {
        I.error("[KDK]", n);
      }
      e && await this.restoreContext("time"), !(e ? await this.restoreContext("view") : !1) && a.get(this, "activityOptions.restore.geolocation", !0) && (await Ct.update(), Ct.hasLocation() && this.center(Ct.getLongitude(), Ct.getLatitude())), this.listenToCatalogServiceEvents();
    },
    finalize() {
      this.unlistenToCatalogServiceEvents();
    },
    async refreshLayer(e, t) {
      let i;
      e && typeof e.getPlanetApi == "function" && (i = e.getPlanetApi()), e && (typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("reject"), await this.removeCatalogLayer(e)), t !== "removed" && (i && Object.assign(e, { getPlanetApi: () => i }), await wo([e], i), await this.addCatalogLayer(e));
    },
    requestRefreshLayer(e, t) {
      this.pendingLayerRefresh || (this.pendingLayerRefresh = {}), this.pendingLayerRefresh[e] && clearTimeout(this.pendingLayerRefresh[e]), this.pendingLayerRefresh[e] = setTimeout(() => {
        delete this.pendingLayerRefresh[e], this.refreshLayer(e, t);
      }, 500);
    },
    async onCatalogUpdated(e, t) {
      switch (e.type) {
        case "Category":
          await this.requestRefreshLayerCategories();
          break;
        case "Context":
        case "Service":
          break;
        default: {
          await this.requestRefreshLayer(e, t);
          break;
        }
      }
    }
  },
  // Need to be in the first lifecycle hook as others mixins might use activity options
  created() {
    const e = a.get(me, `engines.${this.engine}`);
    e && (I.debug(`[KDK] Configuring '${this.engine}' engine with options:`, e), this.activityOptions.engine = a.defaultsDeep(a.get(this.activityOptions, "engine", {}), e)), this.$engineEvents.on("map-ready", this.onEngineReady), this.$engineEvents.on("globe-ready", this.onEngineReady), this.$engineEvents.on("layer-added", this.configureLayerActions);
  },
  mounted() {
    this.requestRefreshLayerCategories = a.debounce(this.refreshLayerCategories, 200), ne.on("navigator-disconnected", this.resetCatalogServiceEventsListeners), ne.on("navigator-reconnected", this.resetCatalogServiceEventsListeners), ne.on("websocket-disconnected", this.resetCatalogServiceEventsListeners), ne.on("websocket-reconnected", this.resetCatalogServiceEventsListeners);
  },
  beforeUnmount() {
    this.$engineEvents.off("map-ready", this.onEngineReady), this.$engineEvents.off("globe-ready", this.onEngineReady), this.$engineEvents.off("layer-added", this.configureLayerActions), ne.off("navigator-disconnected", this.resetCatalogServiceEventsListeners), ne.off("navigator-reconnected", this.resetCatalogServiceEventsListeners), ne.off("websocket-disconnected", this.resetCatalogServiceEventsListeners), ne.off("websocket-reconnected", this.resetCatalogServiceEventsListeners), this.finalize();
  }
}, y0 = {
  methods: {
    getContextKey(e) {
      return `${this.activityName}-${e}`;
    },
    shouldRestoreContext(e) {
      return a.has(this, `activityOptions.restore.${e}`) && !a.get(this, `activityOptions.restore.${e}`) ? !1 : j.get(`restore.${e}`);
    },
    getRouteContext(e) {
      switch (e) {
        case "layers":
          if (a.get(this.$route, "query.layers"))
            return a.pick(this.$route.query, ["layers"]);
          break;
        case "time":
          if (a.get(this.$route, "query.time"))
            return a.pick(this.$route.query, ["time"]);
          break;
        case "view":
        default:
          if (a.get(this.$route, "params.south") && a.get(this.$route, "params.west") && a.get(this.$route, "params.north") && a.get(this.$route, "params.east")) {
            const t = a.pick(this.$route.params, ["south", "west", "north", "east"]);
            return a.mapValues(t, (i) => a.toNumber(i));
          }
          break;
      }
      return {};
    },
    contextAsQuery(e) {
      switch (e) {
        case "layers":
          return !0;
        case "time":
          return !0;
        case "view":
        default:
          return !1;
      }
    },
    getContextParameters(e) {
      let t;
      switch (e) {
        case "layers":
          t = {
            layers: a.values(this.layers).filter(Te({ isVisible: !0, scope: { $nin: ["system"] }, _id: { $exists: !0 } })).map((i) => i.name)
          };
          break;
        case "time": {
          t = {
            time: be.getCurrentTime()
          };
          break;
        }
        case "view":
        default: {
          const i = this.getBounds(), n = i[0][0], r = i[0][1], s = i[1][0], o = i[1][1];
          t = { south: n, west: r, north: s, east: o };
        }
      }
      return t;
    },
    updateRouteContext(e, t) {
      const i = this.contextAsQuery(e), n = {
        query: Object.assign({}, a.get(this.$route, "query", {})),
        params: Object.assign({}, a.get(this.$route, "params", {}))
      };
      switch (e) {
        case "layers": {
          t = a.pick(t, ["layers"]);
          break;
        }
        case "time": {
          t = a.pick(t, ["time"]);
          break;
        }
        case "view":
        default:
          t = a.pick(t, ["south", "west", "north", "east"]);
      }
      Object.assign(i ? n.query : n.params, t), this.$router && this.$router.replace(n).catch((r) => {
      });
    },
    async setContextParameters(e, t) {
      switch (e) {
        case "layers": {
          if (!a.has(t, "layers")) return;
          const i = a.values(this.layers).filter(Te({ isVisible: !0, scope: { $nin: ["system"] }, _id: { $exists: !0 } })).map((c) => c.name);
          let n = a.isArray(t.layers) ? t.layers : [t.layers];
          if (n = n.map((c) => (this.hasLayer(c) || a.startsWith(c, "Layers.") || (a.startsWith(c, "layers-") || (c = "layers-" + c), c = a.replace(a.replace(a.upperCase(c), / /g, "_"), "LAYERS_", "Layers.")), c)), n = n.filter((c) => this.hasLayer(c)), a.isEmpty(n)) return;
          const r = a.difference(n, i), s = a.difference(i, n), o = a.find(s, (c) => this.hasLayer(c) && $s(this.getLayerByName(c))), l = a.find(r, (c) => this.hasLayer(c) && $s(this.getLayerByName(c)));
          o && !l && a.pull(s, o), await Promise.all(r.map((c) => this.showLayer(c))), await Promise.all(s.map((c) => this.hideLayer(c)));
          break;
        }
        case "time": {
          if (!a.has(t, "time")) return;
          j.set("time.currentTime", he(t.time).utc());
          break;
        }
        case "view":
        default:
          if (!a.has(t, "south") || !a.has(t, "west") || !a.has(t, "north") || !a.has(t, "east")) return;
          this.zoomToBounds([
            [t.south, t.west],
            [t.north, t.east]
          ]);
          break;
      }
    },
    storeContext(e) {
      const t = this.getContextParameters(e);
      this.shouldRestoreContext(e) && (a.isEqual(this.getRouteContext(e), t) || this.updateRouteContext(e, t), Xe.set(this.getContextKey(e), t));
    },
    async restoreContext(e) {
      let t = this.getRouteContext(e);
      if (a.isEmpty(t)) {
        const i = Xe.get(this.getContextKey(e));
        if (this.shouldRestoreContext(e))
          if (!a.isEmpty(i))
            t = i, Array.isArray(t) && (t = {
              south: t[0][0],
              west: t[0][1],
              north: t[1][0],
              east: t[1][1]
            });
          else {
            if (a.isUndefined(this.homeContext)) {
              const n = await G.getService("catalog").find({ query: { type: "Context", isDefault: !0 } });
              this.homeContext = n.data.length > 0 ? n.data[0] : null;
            }
            this.homeContext && (t = this.homeContext);
          }
      }
      return a.isEmpty(t) || (this.shouldRestoreContext(e) && !a.isEqual(this.getRouteContext(e), t) && this.updateRouteContext(e, t), this.setContextParameters(e, t)), t;
    },
    clearContext(e) {
      let t;
      switch (e) {
        case "layers":
          t = { layers: void 0 };
          break;
        case "time":
          t = { time: void 0 };
          break;
        case "view":
        default:
          t = { south: void 0, west: void 0, north: void 0, east: void 0 };
          break;
      }
      this.updateRouteContext(e, t), window.localStorage.removeItem(this.getContextKey(e));
    },
    async saveContext(e) {
      e = Object.assign({}, e);
      const t = e.layers;
      return delete e.layers, e.type = "Context", Object.assign(e, this.getContextParameters("view")), t && Object.assign(e, this.getContextParameters("layers")), e = await G.getService("catalog").create(e), e;
    },
    async loadContext(e) {
      if (typeof e == "string")
        if (bu(e))
          e = await G.getService("catalog").get(e);
        else {
          const t = await G.getService("catalog").find({ query: { type: "Context", name: e } });
          e = t.data.length > 0 ? t.data[0] : null;
        }
      if (!e) throw new Error("Cannot find or invalid context");
      return this.setContextParameters("view", e), this.setContextParameters("layers", e), e;
    },
    updateViewSettings(e) {
      e || this.clearContext("view");
    },
    updateLayersSettings(e) {
      e || this.clearContext("layers");
    }
  },
  mounted() {
    ne.on("restore-view-changed", this.updateViewSettings), ne.on("restore-layers-changed", this.updateLayersSettings);
  },
  beforeUnmount() {
    ne.off("restore-view-changed", this.updateViewSettings), ne.off("restore-layers-changed", this.updateLayersSettings);
  }
}, v0 = {
  watch: {
    "selection.items": {
      handler() {
        this.updateHighlights(), this.handleWidget(this.getWidgetForSelection());
      }
    },
    "probe.item": {
      handler() {
        this.updateHighlights(), this.handleWidget(this.getWidgetForProbe());
      }
    }
  },
  methods: {
    updateHighlights() {
      this.clearHighlights(), this.getSelectedItems().forEach((e) => {
        this.highlight(e.feature || e.location, e.layer);
      }), this.hasProbedLocation() && this.highlight(this.getProbedLocation(), this.getProbedLayer());
    },
    handleWidget(e) {
      e && e !== "none" && !this.isWidgetWindowVisible(e) && this.openWidget(e);
    }
  }
}, b0 = {
  methods: {
    getBaseQueryForFeatures: Wr,
    getFilterQueryForFeatures: Zr,
    getSortQueryForFeatures: Qr,
    getFeaturesUpdateInterval: Jr,
    getFeaturesQueryInterval: Yr,
    shouldSkipFeaturesUpdate: Ad,
    getFeaturesLevel(e) {
      return this.selectableLevelsLayer && this.selectableLevelsLayer.name === e.name ? this.selectedLevel : null;
    },
    getProbeFeatures: Od,
    async getProbeFeaturesFromLayer(e) {
      const t = this.getLayerByName(e);
      if (t)
        return this.getProbeFeatures(t);
    },
    async getFeaturesQuery(e, t, i) {
      return i || (i = this.getFeaturesLevel(e)), Io(e, t, i);
    },
    getFeaturesFromQuery: Sr,
    async getFeatures(e, t, i) {
      const n = await this.getFeaturesQuery(e, t, i);
      return await Sr(e, n);
    },
    async getFeaturesFromLayer(e, t) {
      const i = this.getLayerByName(e);
      if (i)
        return this.getFeatures(i, t);
    },
    getMeasureForFeatureBaseQuery: Er,
    async getMeasureForFeatureQuery(e, t, i, n) {
      return await this.getFeaturesQuery(a.merge({
        baseQuery: Er(e, t)
      }, e), {
        $gte: i.toISOString(),
        $lte: n.toISOString()
      });
    },
    getMeasureForFeatureFromQuery: Cr,
    async getMeasureForFeature(e, t, i, n) {
      let r;
      this.setCursor("processing-cursor");
      try {
        const s = await this.getMeasureForFeatureQuery(e, t, i, n);
        r = await Cr(e, t, s);
      } catch (s) {
        I.error(s);
      }
      return this.unsetCursor("processing-cursor"), r;
    },
    checkFeatures: zo,
    createFeatures: No,
    editFeaturesGeometry: Id,
    editFeaturesProperties: zd,
    editFeaturesStyle: Nd,
    removeFeatures: qo,
    onFeatureUpdated(e, t) {
      !t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerVisible(t.name)) && (typeof this.isLayerEdited == "function" && this.isLayerEdited(t) || Bd(e, t) && typeof this.updateLayer == "function" && [e].filter(Te(a.omit(t.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"]))).length > 0 && this.updateLayer(t.name, e, { removeMissing: !1 }));
    },
    onFeatureRemoved(e, t) {
      !t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerVisible(t.name)) && (typeof this.isLayerEdited == "function" && this.isLayerEdited(t) || typeof this.updateLayer == "function" && [e].filter(Te(a.omit(t.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"]))).length > 0 && this.updateLayer(t.name, e, { remove: !0 }));
    },
    listenToFeaturesServiceEventsForLayer(e) {
      const t = Rn(e, {
        created: this.onFeatureUpdated,
        updated: this.onFeatureUpdated,
        patched: this.onFeatureUpdated,
        removed: this.onFeatureRemoved
      }, this.layerServiceEventListeners[e._id]);
      t && (this.layerServiceEventListeners[e._id] = t);
    },
    unlistenToFeaturesServiceEventsForLayer(e) {
      Gi(e, this.layerServiceEventListeners[e._id]), delete this.layerServiceEventListeners[e._id];
    },
    listenToFeaturesServiceEventsForLayers() {
      this.layerServiceEventListeners = {}, a.forEach(this.getLayers(), this.listenToFeaturesServiceEventsForLayer);
    },
    unlistenToFeaturesServiceEventsForLayers() {
      a.forOwn(this.layerServiceEventListeners, this.unlistenToFeaturesServiceEventsForLayer), this.layerServiceEventListeners = {};
    }
  },
  created() {
    G.getService("features").timeout = 3600 * 1e3;
  },
  mounted() {
    this.listenToFeaturesServiceEventsForLayers(), this.$engineEvents.on("layer-added", this.listenToFeaturesServiceEventsForLayer), this.$engineEvents.on("layer-removed", this.unlistenToFeaturesServiceEventsForLayer), ne.on("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  },
  beforeUnmount() {
    this.unlistenToFeaturesServiceEventsForLayers(), this.$engineEvents.off("layer-added", this.listenToFeaturesServiceEventsForLayer), this.$engineEvents.off("layer-removed", this.unlistenToFeaturesServiceEventsForLayer), ne.off("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  }
}, w0 = {
  methods: {
    getDefaultInfoBox(e, t) {
      let i = e.properties;
      if (i) {
        const n = a.get(t, this.engine, t);
        if (a.has(n, "infobox") && !a.get(n, "infobox")) return [];
        if (a.has(i, "infobox") && !a.get(i, "infobox")) return [];
        const r = Object.assign(
          {},
          a.get(this, "activityOptions.engine.infobox"),
          n.infobox,
          i.infobox
        );
        r.pick ? i = a.pick(i, r.pick) : r.omit && (i = a.omit(i, r.omit));
      }
      return i;
    }
  },
  created() {
    this.registerStyle("infobox", this.getDefaultInfoBox);
  }
}, _0 = {
  emits: [
    "selected-level-changed"
  ],
  data() {
    return {
      selectedLevel: null,
      selectableLevels: {},
      selectableLevelsLayer: null
    };
  },
  computed: {
    hasSelectableLevels() {
      return a.get(this.selectableLevels, "values", []).length > 0;
    }
  },
  methods: {
    setSelectableLevels(e, t, i) {
      this.selectableLevels = t, this.selectableLevelsLayer = e, a.isNil(i) && (i = a.get(t, "values[0]", a.get(t, "range.min"))), this.setSelectedLevel(i);
    },
    clearSelectableLevels(e) {
      this.selectableLevelsLayer && (this.selectableLevels = {}, this.selectableLevelsLayer = null, this.setSelectedLevel(null));
    },
    setSelectedLevel(e) {
      this.selectedLevel !== e && (this.selectedLevel = e, this.onSelectedLevelChanged(e));
    },
    onSelectedLevelChanged(e) {
      this.$emit("selected-level-changed", e), this.$engineEvents.emit("selected-level-changed", e);
    },
    onShowSelectableLevelsLayer(e) {
      const t = a.get(e, "levels");
      t && this.setSelectableLevels(e, t);
    },
    onHideSelectableLevelsLayer(e) {
      a.get(e, "levels") && this.clearSelectableLevels(e);
    }
  },
  created() {
    this.$engineEvents.on("layer-shown", this.onShowSelectableLevelsLayer), this.$engineEvents.on("layer-hidden", this.onHideSelectableLevelsLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-shown", this.onShowSelectableLevelsLayer), this.$engineEvents.off("layer-hidden", this.onHideSelectableLevelsLayer);
  }
}, L0 = {
  methods: {
    registerStyle(e, t) {
      this[e + "Factory"] || (this[e + "Factory"] = []), this[e + "Factory"].push(t);
    },
    unregisterStyle(e, t) {
      a.pull(this[e + "Factory"], t);
    },
    generateStyle() {
      const e = Array.from(arguments), t = e[0];
      if (!this[t + "Factory"]) return;
      e.shift();
      let i;
      for (let n = this[t + "Factory"].length - 1; n >= 0; n--) {
        const r = this[t + "Factory"][n];
        if (i = r(...e), i) break;
      }
      return i;
    }
  }
}, x0 = {
  emits: [
    "forecast-model-changed",
    "forecast-level-changed"
  ],
  data() {
    return {
      forecastModel: null,
      forecastModels: []
    };
  },
  methods: {
    getWeacastApi() {
      return G;
    },
    async setupWeacast() {
      try {
        await this.setupForecastModels();
      } catch (e) {
        I.error("Cannot retrieve available Weacast forecast models", e);
      }
    },
    async setupForecastModels() {
      if (!this.getWeacastApi() || this.getWeacastApi().isDisconnected || this.getWeacastApi().useLocalFirst) return;
      const e = await this.getWeacastApi().getService("forecasts").find();
      this.forecastModels.splice(0, this.forecastModels.length, ...e.data), this.getWeacastApi().models = this.forecastModels, this.forecastModels.forEach((i) => {
        i.actions = [{ id: "toggle", handler: () => this.setForecastModel(i) }];
      });
      let t = this.forecastModels.find((i) => i.isDefault);
      t || (t = this.forecastModels.length > 0 ? this.forecastModels[0] : null), this.setForecastModel(t);
    },
    setForecastModel(e) {
      this.forecastModel !== e && (this.forecastModel = e, this.onForecastModelChanged(e));
    },
    onForecastModelChanged(e) {
      this.$emit("forecast-model-changed", e), this.$engineEvents.emit("forecast-model-changed", e);
    },
    setForecastLevel(e) {
      this.forecastLevel !== e && (this.forecastLevel = e, this.onForecastLevelChanged(e));
    },
    onForecastLevelChanged(e) {
      this.$emit("forecast-level-changed", e), this.$engineEvents.emit("forecast-level-changed", e);
    },
    async getForecastForLocation(e, t, i, n) {
      if (!this.forecastModel) return;
      this.setCursor("processing-cursor");
      const r = await Is({
        startTime: i,
        endTime: n,
        forecastModel: this.forecastModel,
        forecastLevel: this.forecastLevel,
        weacastApi: this.getWeacastApi()
      });
      return this.unsetCursor("processing-cursor"), r;
    },
    async getForecastProbe(e) {
      if (this.forecastModel)
        return this.probe && this.probe.name === e && this.probe.forecast === this.forecastModel.name ? this.probe : (this.probe = await Kd({ name: e, forecastModel: this.forecastModel, weacastApi: this.getWeacastApi() }), this.probe);
    },
    async getForecastForFeature(e, t, i) {
      if (!this.forecastModel || !this.probe) return;
      this.setCursor("processing-cursor");
      const n = await Gd({ probe: this.probe, featureId: e, startTime: t, endTime: i, forecastModel: this.forecastModel, forecastLevel: this.forecastLevel, weacastApi: this.getWeacastApi() });
      return this.unsetCursor("processing-cursor"), n;
    },
    onCurrentForecastTimeChanged(e) {
      this.getWeacastApi() && this.getWeacastApi().setForecastTime(e);
    },
    onWeacastSelectedLevelChanged(e) {
      if (a.isNil(e)) {
        this.setForecastLevel(null);
        return;
      }
      const t = this.selectableLevelsLayer;
      if (t) {
        const i = a.get(t, `${this.engine}.type`), r = a.get(t, "meteo_model.sources", []).find((s) => a.has(s, "weacast"));
        (i.startsWith("weacast") || r) && this.setForecastLevel(e);
      }
    }
  },
  created() {
    ne.on("time-current-time-changed", this.onCurrentForecastTimeChanged), this.$engineEvents.on("selected-level-changed", this.onWeacastSelectedLevelChanged);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentForecastTimeChanged), this.$engineEvents.off("selected-level-changed", this.onWeacastSelectedLevelChanged);
  }
}, S0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: p0,
  context: y0,
  featureSelection: v0,
  featureService: b0,
  infobox: w0,
  levels: _0,
  style: L0,
  weacast: x0
}, Symbol.toStringTag, { value: "Module" }));
(function() {
  function e(h, b, E) {
    try {
      return window.URL.createObjectURL(new Blob([Uint8Array.from(h.split("").map(function(N) {
        return N.charCodeAt(0);
      }))], { type: b }));
    } catch {
      return "data:" + b + "," + h;
    }
  }
  (function(h) {
    if (h.fetch)
      return;
    var b = {
      searchParams: "URLSearchParams" in h,
      iterable: "Symbol" in h && "iterator" in Symbol,
      blob: "FileReader" in h && "Blob" in h && function() {
        try {
          return new Blob(), !0;
        } catch {
          return !1;
        }
      }(),
      formData: "FormData" in h,
      arrayBuffer: "ArrayBuffer" in h
    };
    if (b.arrayBuffer)
      var E = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ], N = function(V) {
        return V && DataView.prototype.isPrototypeOf(V);
      }, U = ArrayBuffer.isView || function(V) {
        return V && E.indexOf(Object.prototype.toString.call(V)) > -1;
      };
    function Q(V) {
      if (typeof V != "string" && (V = String(V)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(V))
        throw new TypeError("Invalid character in header field name");
      return V.toLowerCase();
    }
    function Z(V) {
      return typeof V != "string" && (V = String(V)), V;
    }
    function ae(V) {
      var se = {
        next: function() {
          var ve = V.shift();
          return { done: ve === void 0, value: ve };
        }
      };
      return b.iterable && (se[Symbol.iterator] = function() {
        return se;
      }), se;
    }
    function re(V) {
      this.map = {}, V instanceof re ? V.forEach(function(se, ve) {
        this.append(ve, se);
      }, this) : Array.isArray(V) ? V.forEach(function(se) {
        this.append(se[0], se[1]);
      }, this) : V && Object.getOwnPropertyNames(V).forEach(function(se) {
        this.append(se, V[se]);
      }, this);
    }
    re.prototype.append = function(V, se) {
      V = Q(V), se = Z(se);
      var ve = this.map[V];
      this.map[V] = ve ? ve + "," + se : se;
    }, re.prototype.delete = function(V) {
      delete this.map[Q(V)];
    }, re.prototype.get = function(V) {
      return V = Q(V), this.has(V) ? this.map[V] : null;
    }, re.prototype.has = function(V) {
      return this.map.hasOwnProperty(Q(V));
    }, re.prototype.set = function(V, se) {
      this.map[Q(V)] = Z(se);
    }, re.prototype.forEach = function(V, se) {
      var ve = this;
      for (var Ue in this.map)
        ve.map.hasOwnProperty(Ue) && V.call(se, ve.map[Ue], Ue, ve);
    }, re.prototype.keys = function() {
      var V = [];
      return this.forEach(function(se, ve) {
        V.push(ve);
      }), ae(V);
    }, re.prototype.values = function() {
      var V = [];
      return this.forEach(function(se) {
        V.push(se);
      }), ae(V);
    }, re.prototype.entries = function() {
      var V = [];
      return this.forEach(function(se, ve) {
        V.push([ve, se]);
      }), ae(V);
    }, b.iterable && (re.prototype[Symbol.iterator] = re.prototype.entries);
    function Le(V) {
      if (V.bodyUsed)
        return Promise.reject(new TypeError("Already read"));
      V.bodyUsed = !0;
    }
    function xe(V) {
      return new Promise(function(se, ve) {
        V.onload = function() {
          se(V.result);
        }, V.onerror = function() {
          ve(V.error);
        };
      });
    }
    function Fe(V) {
      var se = new FileReader(), ve = xe(se);
      return se.readAsArrayBuffer(V), ve;
    }
    function Ze(V) {
      var se = new FileReader(), ve = xe(se);
      return se.readAsText(V), ve;
    }
    function De(V) {
      for (var se = new Uint8Array(V), ve = new Array(se.length), Ue = 0; Ue < se.length; Ue++)
        ve[Ue] = String.fromCharCode(se[Ue]);
      return ve.join("");
    }
    function Qe(V) {
      if (V.slice)
        return V.slice(0);
      var se = new Uint8Array(V.byteLength);
      return se.set(new Uint8Array(V)), se.buffer;
    }
    function Re() {
      return this.bodyUsed = !1, this._initBody = function(V) {
        if (this._bodyInit = V, !V)
          this._bodyText = "";
        else if (typeof V == "string")
          this._bodyText = V;
        else if (b.blob && Blob.prototype.isPrototypeOf(V))
          this._bodyBlob = V;
        else if (b.formData && FormData.prototype.isPrototypeOf(V))
          this._bodyFormData = V;
        else if (b.searchParams && URLSearchParams.prototype.isPrototypeOf(V))
          this._bodyText = V.toString();
        else if (b.arrayBuffer && b.blob && N(V))
          this._bodyArrayBuffer = Qe(V.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);
        else if (b.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(V) || U(V)))
          this._bodyArrayBuffer = Qe(V);
        else
          throw new Error("unsupported BodyInit type");
        this.headers.get("content-type") || (typeof V == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : b.searchParams && URLSearchParams.prototype.isPrototypeOf(V) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
      }, b.blob && (this.blob = function() {
        var V = Le(this);
        if (V)
          return V;
        if (this._bodyBlob)
          return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]));
      }, this.arrayBuffer = function() {
        return this._bodyArrayBuffer ? Le(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(Fe);
      }), this.text = function() {
        var V = Le(this);
        if (V)
          return V;
        if (this._bodyBlob)
          return Ze(this._bodyBlob);
        if (this._bodyArrayBuffer)
          return Promise.resolve(De(this._bodyArrayBuffer));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText);
      }, b.formData && (this.formData = function() {
        return this.text().then(ts);
      }), this.json = function() {
        return this.text().then(JSON.parse);
      }, this;
    }
    var Gt = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
    function Si(V) {
      var se = V.toUpperCase();
      return Gt.indexOf(se) > -1 ? se : V;
    }
    function Tt(V, se) {
      se = se || {};
      var ve = se.body;
      if (V instanceof Tt) {
        if (V.bodyUsed)
          throw new TypeError("Already read");
        this.url = V.url, this.credentials = V.credentials, se.headers || (this.headers = new re(V.headers)), this.method = V.method, this.mode = V.mode, !ve && V._bodyInit != null && (ve = V._bodyInit, V.bodyUsed = !0);
      } else
        this.url = String(V);
      if (this.credentials = se.credentials || this.credentials || "omit", (se.headers || !this.headers) && (this.headers = new re(se.headers)), this.method = Si(se.method || this.method || "GET"), this.mode = se.mode || this.mode || null, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && ve)
        throw new TypeError("Body not allowed for GET or HEAD requests");
      this._initBody(ve);
    }
    Tt.prototype.clone = function() {
      return new Tt(this, { body: this._bodyInit });
    };
    function ts(V) {
      var se = new FormData();
      return V.trim().split("&").forEach(function(ve) {
        if (ve) {
          var Ue = ve.split("="), yt = Ue.shift().replace(/\+/g, " "), Pe = Ue.join("=").replace(/\+/g, " ");
          se.append(decodeURIComponent(yt), decodeURIComponent(Pe));
        }
      }), se;
    }
    function Pf(V) {
      var se = new re();
      return V.split(/\r?\n/).forEach(function(ve) {
        var Ue = ve.split(":"), yt = Ue.shift().trim();
        if (yt) {
          var Pe = Ue.join(":").trim();
          se.append(yt, Pe);
        }
      }), se;
    }
    Re.call(Tt.prototype);
    function Bt(V, se) {
      se || (se = {}), this.type = "default", this.status = "status" in se ? se.status : 200, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in se ? se.statusText : "OK", this.headers = new re(se.headers), this.url = se.url || "", this._initBody(V);
    }
    Re.call(Bt.prototype), Bt.prototype.clone = function() {
      return new Bt(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new re(this.headers),
        url: this.url
      });
    }, Bt.error = function() {
      var V = new Bt(null, { status: 0, statusText: "" });
      return V.type = "error", V;
    };
    var Mf = [301, 302, 303, 307, 308];
    Bt.redirect = function(V, se) {
      if (Mf.indexOf(se) === -1)
        throw new RangeError("Invalid status code");
      return new Bt(null, { status: se, headers: { location: V } });
    }, h.Headers = re, h.Request = Tt, h.Response = Bt, h.fetch = function(V, se) {
      return new Promise(function(ve, Ue) {
        var yt = new Tt(V, se), Pe = new XMLHttpRequest();
        Pe.onload = function() {
          var Ji = {
            status: Pe.status,
            statusText: Pe.statusText,
            headers: Pf(Pe.getAllResponseHeaders() || "")
          };
          Ji.url = "responseURL" in Pe ? Pe.responseURL : Ji.headers.get("X-Request-URL");
          var is = "response" in Pe ? Pe.response : Pe.responseText;
          ve(new Bt(is, Ji));
        }, Pe.onerror = function() {
          Ue(new TypeError("Network request failed"));
        }, Pe.ontimeout = function() {
          Ue(new TypeError("Network request failed"));
        }, Pe.open(yt.method, yt.url, !0), yt.credentials === "include" && (Pe.withCredentials = !0), "responseType" in Pe && b.blob && (Pe.responseType = "blob"), yt.headers.forEach(function(Ji, is) {
          Pe.setRequestHeader(is, Ji);
        }), Pe.send(typeof yt._bodyInit > "u" ? null : yt._bodyInit);
      });
    }, h.fetch.polyfill = !0;
  })(typeof self < "u" ? self : void 0);
  var t = function(h, b, E, N, U) {
    var Q, Z, ae = U * 8 - N - 1, re = (1 << ae) - 1, Le = re >> 1, xe = -7, Fe = E ? U - 1 : 0, Ze = E ? -1 : 1, De = h[b + Fe];
    for (Fe += Ze, Q = De & (1 << -xe) - 1, De >>= -xe, xe += ae; xe > 0; Q = Q * 256 + h[b + Fe], Fe += Ze, xe -= 8)
      ;
    for (Z = Q & (1 << -xe) - 1, Q >>= -xe, xe += N; xe > 0; Z = Z * 256 + h[b + Fe], Fe += Ze, xe -= 8)
      ;
    if (Q === 0)
      Q = 1 - Le;
    else {
      if (Q === re)
        return Z ? NaN : (De ? -1 : 1) * (1 / 0);
      Z = Z + Math.pow(2, N), Q = Q - Le;
    }
    return (De ? -1 : 1) * Z * Math.pow(2, Q - N);
  }, i = function(h, b, E, N, U, Q) {
    var Z, ae, re, Le = Q * 8 - U - 1, xe = (1 << Le) - 1, Fe = xe >> 1, Ze = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, De = N ? 0 : Q - 1, Qe = N ? 1 : -1, Re = b < 0 || b === 0 && 1 / b < 0 ? 1 : 0;
    for (b = Math.abs(b), isNaN(b) || b === 1 / 0 ? (ae = isNaN(b) ? 1 : 0, Z = xe) : (Z = Math.floor(Math.log(b) / Math.LN2), b * (re = Math.pow(2, -Z)) < 1 && (Z--, re *= 2), Z + Fe >= 1 ? b += Ze / re : b += Ze * Math.pow(2, 1 - Fe), b * re >= 2 && (Z++, re /= 2), Z + Fe >= xe ? (ae = 0, Z = xe) : Z + Fe >= 1 ? (ae = (b * re - 1) * Math.pow(2, U), Z = Z + Fe) : (ae = b * Math.pow(2, Fe - 1) * Math.pow(2, U), Z = 0)); U >= 8; h[E + De] = ae & 255, De += Qe, ae /= 256, U -= 8)
      ;
    for (Z = Z << U | ae, Le += U; Le > 0; h[E + De] = Z & 255, De += Qe, Z /= 256, Le -= 8)
      ;
    h[E + De - Qe] |= Re * 128;
  }, n = {
    read: t,
    write: i
  }, r = o, s = n;
  function o(h) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(h) ? h : new Uint8Array(h || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  o.Varint = 0, o.Fixed64 = 1, o.Bytes = 2, o.Fixed32 = 5;
  var l = 65536 * 65536, c = 1 / l;
  o.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(h, b, E) {
      var N = this;
      for (E = E || this.length; this.pos < E; ) {
        var U = N.readVarint(), Q = U >> 3, Z = N.pos;
        N.type = U & 7, h(Q, b, N), N.pos === Z && N.skip(U);
      }
      return b;
    },
    readMessage: function(h, b) {
      return this.readFields(h, b, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var h = D(this.buf, this.pos);
      return this.pos += 4, h;
    },
    readSFixed32: function() {
      var h = F(this.buf, this.pos);
      return this.pos += 4, h;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var h = D(this.buf, this.pos) + D(this.buf, this.pos + 4) * l;
      return this.pos += 8, h;
    },
    readSFixed64: function() {
      var h = D(this.buf, this.pos) + F(this.buf, this.pos + 4) * l;
      return this.pos += 8, h;
    },
    readFloat: function() {
      var h = s.read(this.buf, this.pos, !0, 23, 4);
      return this.pos += 4, h;
    },
    readDouble: function() {
      var h = s.read(this.buf, this.pos, !0, 52, 8);
      return this.pos += 8, h;
    },
    readVarint: function(h) {
      var b = this.buf, E, N;
      return N = b[this.pos++], E = N & 127, N < 128 || (N = b[this.pos++], E |= (N & 127) << 7, N < 128) || (N = b[this.pos++], E |= (N & 127) << 14, N < 128) || (N = b[this.pos++], E |= (N & 127) << 21, N < 128) ? E : (N = b[this.pos], E |= (N & 15) << 28, u(E, h, this));
    },
    readVarint64: function() {
      return this.readVarint(!0);
    },
    readSVarint: function() {
      var h = this.readVarint();
      return h % 2 === 1 ? (h + 1) / -2 : h / 2;
    },
    readBoolean: function() {
      return !!this.readVarint();
    },
    readString: function() {
      var h = this.readVarint() + this.pos, b = k(this.buf, this.pos, h);
      return this.pos = h, b;
    },
    readBytes: function() {
      var h = this.readVarint() + this.pos, b = this.buf.subarray(this.pos, h);
      return this.pos = h, b;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(h, b) {
      var E = this, N = d(this);
      for (h = h || []; this.pos < N; )
        h.push(E.readVarint(b));
      return h;
    },
    readPackedSVarint: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readSVarint());
      return h;
    },
    readPackedBoolean: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readBoolean());
      return h;
    },
    readPackedFloat: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readFloat());
      return h;
    },
    readPackedDouble: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readDouble());
      return h;
    },
    readPackedFixed32: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readFixed32());
      return h;
    },
    readPackedSFixed32: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readSFixed32());
      return h;
    },
    readPackedFixed64: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readFixed64());
      return h;
    },
    readPackedSFixed64: function(h) {
      var b = this, E = d(this);
      for (h = h || []; this.pos < E; )
        h.push(b.readSFixed64());
      return h;
    },
    skip: function(h) {
      var b = h & 7;
      if (b === o.Varint)
        for (; this.buf[this.pos++] > 127; )
          ;
      else if (b === o.Bytes)
        this.pos = this.readVarint() + this.pos;
      else if (b === o.Fixed32)
        this.pos += 4;
      else if (b === o.Fixed64)
        this.pos += 8;
      else
        throw new Error("Unimplemented type: " + b);
    },
    // === WRITING =================================================================
    writeTag: function(h, b) {
      this.writeVarint(h << 3 | b);
    },
    realloc: function(h) {
      for (var b = this.length || 16; b < this.pos + h; )
        b *= 2;
      if (b !== this.length) {
        var E = new Uint8Array(b);
        E.set(this.buf), this.buf = E, this.length = b;
      }
    },
    finish: function() {
      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
    },
    writeFixed32: function(h) {
      this.realloc(4), T(this.buf, h, this.pos), this.pos += 4;
    },
    writeSFixed32: function(h) {
      this.realloc(4), T(this.buf, h, this.pos), this.pos += 4;
    },
    writeFixed64: function(h) {
      this.realloc(8), T(this.buf, h & -1, this.pos), T(this.buf, Math.floor(h * c), this.pos + 4), this.pos += 8;
    },
    writeSFixed64: function(h) {
      this.realloc(8), T(this.buf, h & -1, this.pos), T(this.buf, Math.floor(h * c), this.pos + 4), this.pos += 8;
    },
    writeVarint: function(h) {
      if (h = +h || 0, h > 268435455 || h < 0) {
        m(h, this);
        return;
      }
      this.realloc(4), this.buf[this.pos++] = h & 127 | (h > 127 ? 128 : 0), !(h <= 127) && (this.buf[this.pos++] = (h >>>= 7) & 127 | (h > 127 ? 128 : 0), !(h <= 127) && (this.buf[this.pos++] = (h >>>= 7) & 127 | (h > 127 ? 128 : 0), !(h <= 127) && (this.buf[this.pos++] = h >>> 7 & 127)));
    },
    writeSVarint: function(h) {
      this.writeVarint(h < 0 ? -h * 2 - 1 : h * 2);
    },
    writeBoolean: function(h) {
      this.writeVarint(!!h);
    },
    writeString: function(h) {
      h = String(h), this.realloc(h.length * 4), this.pos++;
      var b = this.pos;
      this.pos = O(this.buf, h, this.pos);
      var E = this.pos - b;
      E >= 128 && x(b, E, this), this.pos = b - 1, this.writeVarint(E), this.pos += E;
    },
    writeFloat: function(h) {
      this.realloc(4), s.write(this.buf, h, this.pos, !0, 23, 4), this.pos += 4;
    },
    writeDouble: function(h) {
      this.realloc(8), s.write(this.buf, h, this.pos, !0, 52, 8), this.pos += 8;
    },
    writeBytes: function(h) {
      var b = this, E = h.length;
      this.writeVarint(E), this.realloc(E);
      for (var N = 0; N < E; N++)
        b.buf[b.pos++] = h[N];
    },
    writeRawMessage: function(h, b) {
      this.pos++;
      var E = this.pos;
      h(b, this);
      var N = this.pos - E;
      N >= 128 && x(E, N, this), this.pos = E - 1, this.writeVarint(N), this.pos += N;
    },
    writeMessage: function(h, b, E) {
      this.writeTag(h, o.Bytes), this.writeRawMessage(b, E);
    },
    writePackedVarint: function(h, b) {
      this.writeMessage(h, S, b);
    },
    writePackedSVarint: function(h, b) {
      this.writeMessage(h, A, b);
    },
    writePackedBoolean: function(h, b) {
      this.writeMessage(h, w, b);
    },
    writePackedFloat: function(h, b) {
      this.writeMessage(h, p, b);
    },
    writePackedDouble: function(h, b) {
      this.writeMessage(h, y, b);
    },
    writePackedFixed32: function(h, b) {
      this.writeMessage(h, C, b);
    },
    writePackedSFixed32: function(h, b) {
      this.writeMessage(h, P, b);
    },
    writePackedFixed64: function(h, b) {
      this.writeMessage(h, M, b);
    },
    writePackedSFixed64: function(h, b) {
      this.writeMessage(h, z, b);
    },
    writeBytesField: function(h, b) {
      this.writeTag(h, o.Bytes), this.writeBytes(b);
    },
    writeFixed32Field: function(h, b) {
      this.writeTag(h, o.Fixed32), this.writeFixed32(b);
    },
    writeSFixed32Field: function(h, b) {
      this.writeTag(h, o.Fixed32), this.writeSFixed32(b);
    },
    writeFixed64Field: function(h, b) {
      this.writeTag(h, o.Fixed64), this.writeFixed64(b);
    },
    writeSFixed64Field: function(h, b) {
      this.writeTag(h, o.Fixed64), this.writeSFixed64(b);
    },
    writeVarintField: function(h, b) {
      this.writeTag(h, o.Varint), this.writeVarint(b);
    },
    writeSVarintField: function(h, b) {
      this.writeTag(h, o.Varint), this.writeSVarint(b);
    },
    writeStringField: function(h, b) {
      this.writeTag(h, o.Bytes), this.writeString(b);
    },
    writeFloatField: function(h, b) {
      this.writeTag(h, o.Fixed32), this.writeFloat(b);
    },
    writeDoubleField: function(h, b) {
      this.writeTag(h, o.Fixed64), this.writeDouble(b);
    },
    writeBooleanField: function(h, b) {
      this.writeVarintField(h, !!b);
    }
  };
  function u(h, b, E) {
    var N = E.buf, U, Q;
    if (Q = N[E.pos++], U = (Q & 112) >> 4, Q < 128 || (Q = N[E.pos++], U |= (Q & 127) << 3, Q < 128) || (Q = N[E.pos++], U |= (Q & 127) << 10, Q < 128) || (Q = N[E.pos++], U |= (Q & 127) << 17, Q < 128) || (Q = N[E.pos++], U |= (Q & 127) << 24, Q < 128) || (Q = N[E.pos++], U |= (Q & 1) << 31, Q < 128))
      return f(h, U, b);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function d(h) {
    return h.type === o.Bytes ? h.readVarint() + h.pos : h.pos + 1;
  }
  function f(h, b, E) {
    return E ? b * 4294967296 + (h >>> 0) : (b >>> 0) * 4294967296 + (h >>> 0);
  }
  function m(h, b) {
    var E, N;
    if (h >= 0 ? (E = h % 4294967296 | 0, N = h / 4294967296 | 0) : (E = ~(-h % 4294967296), N = ~(-h / 4294967296), E ^ 4294967295 ? E = E + 1 | 0 : (E = 0, N = N + 1 | 0)), h >= 18446744073709552e3 || h < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    b.realloc(10), g(E, N, b), v(N, b);
  }
  function g(h, b, E) {
    E.buf[E.pos++] = h & 127 | 128, h >>>= 7, E.buf[E.pos++] = h & 127 | 128, h >>>= 7, E.buf[E.pos++] = h & 127 | 128, h >>>= 7, E.buf[E.pos++] = h & 127 | 128, h >>>= 7, E.buf[E.pos] = h & 127;
  }
  function v(h, b) {
    var E = (h & 7) << 4;
    b.buf[b.pos++] |= E | ((h >>>= 3) ? 128 : 0), h && (b.buf[b.pos++] = h & 127 | ((h >>>= 7) ? 128 : 0), h && (b.buf[b.pos++] = h & 127 | ((h >>>= 7) ? 128 : 0), h && (b.buf[b.pos++] = h & 127 | ((h >>>= 7) ? 128 : 0), h && (b.buf[b.pos++] = h & 127 | ((h >>>= 7) ? 128 : 0), h && (b.buf[b.pos++] = h & 127)))));
  }
  function x(h, b, E) {
    var N = b <= 16383 ? 1 : b <= 2097151 ? 2 : b <= 268435455 ? 3 : Math.ceil(Math.log(b) / (Math.LN2 * 7));
    E.realloc(N);
    for (var U = E.pos - 1; U >= h; U--)
      E.buf[U + N] = E.buf[U];
  }
  function S(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeVarint(h[E]);
  }
  function A(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeSVarint(h[E]);
  }
  function p(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeFloat(h[E]);
  }
  function y(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeDouble(h[E]);
  }
  function w(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeBoolean(h[E]);
  }
  function C(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeFixed32(h[E]);
  }
  function P(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeSFixed32(h[E]);
  }
  function M(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeFixed64(h[E]);
  }
  function z(h, b) {
    for (var E = 0; E < h.length; E++)
      b.writeSFixed64(h[E]);
  }
  function D(h, b) {
    return (h[b] | h[b + 1] << 8 | h[b + 2] << 16) + h[b + 3] * 16777216;
  }
  function T(h, b, E) {
    h[E] = b, h[E + 1] = b >>> 8, h[E + 2] = b >>> 16, h[E + 3] = b >>> 24;
  }
  function F(h, b) {
    return (h[b] | h[b + 1] << 8 | h[b + 2] << 16) + (h[b + 3] << 24);
  }
  function k(h, b, E) {
    for (var N = "", U = b; U < E; ) {
      var Q = h[U], Z = null, ae = Q > 239 ? 4 : Q > 223 ? 3 : Q > 191 ? 2 : 1;
      if (U + ae > E)
        break;
      var re, Le, xe;
      ae === 1 ? Q < 128 && (Z = Q) : ae === 2 ? (re = h[U + 1], (re & 192) === 128 && (Z = (Q & 31) << 6 | re & 63, Z <= 127 && (Z = null))) : ae === 3 ? (re = h[U + 1], Le = h[U + 2], (re & 192) === 128 && (Le & 192) === 128 && (Z = (Q & 15) << 12 | (re & 63) << 6 | Le & 63, (Z <= 2047 || Z >= 55296 && Z <= 57343) && (Z = null))) : ae === 4 && (re = h[U + 1], Le = h[U + 2], xe = h[U + 3], (re & 192) === 128 && (Le & 192) === 128 && (xe & 192) === 128 && (Z = (Q & 15) << 18 | (re & 63) << 12 | (Le & 63) << 6 | xe & 63, (Z <= 65535 || Z >= 1114112) && (Z = null))), Z === null ? (Z = 65533, ae = 1) : Z > 65535 && (Z -= 65536, N += String.fromCharCode(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), N += String.fromCharCode(Z), U += ae;
    }
    return N;
  }
  function O(h, b, E) {
    for (var N = 0, U, Q; N < b.length; N++) {
      if (U = b.charCodeAt(N), U > 55295 && U < 57344)
        if (Q)
          if (U < 56320) {
            h[E++] = 239, h[E++] = 191, h[E++] = 189, Q = U;
            continue;
          } else
            U = Q - 55296 << 10 | U - 56320 | 65536, Q = null;
        else {
          U > 56319 || N + 1 === b.length ? (h[E++] = 239, h[E++] = 191, h[E++] = 189) : Q = U;
          continue;
        }
      else Q && (h[E++] = 239, h[E++] = 191, h[E++] = 189, Q = null);
      U < 128 ? h[E++] = U : (U < 2048 ? h[E++] = U >> 6 | 192 : (U < 65536 ? h[E++] = U >> 12 | 224 : (h[E++] = U >> 18 | 240, h[E++] = U >> 12 & 63 | 128), h[E++] = U >> 6 & 63 | 128), h[E++] = U & 63 | 128);
    }
    return E;
  }
  var $ = X;
  function X(h, b) {
    this.x = h, this.y = b;
  }
  X.prototype = {
    clone: function() {
      return new X(this.x, this.y);
    },
    add: function(h) {
      return this.clone()._add(h);
    },
    sub: function(h) {
      return this.clone()._sub(h);
    },
    mult: function(h) {
      return this.clone()._mult(h);
    },
    div: function(h) {
      return this.clone()._div(h);
    },
    rotate: function(h) {
      return this.clone()._rotate(h);
    },
    matMult: function(h) {
      return this.clone()._matMult(h);
    },
    unit: function() {
      return this.clone()._unit();
    },
    perp: function() {
      return this.clone()._perp();
    },
    round: function() {
      return this.clone()._round();
    },
    mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    equals: function(h) {
      return this.x === h.x && this.y === h.y;
    },
    dist: function(h) {
      return Math.sqrt(this.distSqr(h));
    },
    distSqr: function(h) {
      var b = h.x - this.x, E = h.y - this.y;
      return b * b + E * E;
    },
    angle: function() {
      return Math.atan2(this.y, this.x);
    },
    angleTo: function(h) {
      return Math.atan2(this.y - h.y, this.x - h.x);
    },
    angleWith: function(h) {
      return this.angleWithSep(h.x, h.y);
    },
    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(h, b) {
      return Math.atan2(
        this.x * b - this.y * h,
        this.x * h + this.y * b
      );
    },
    _matMult: function(h) {
      var b = h[0] * this.x + h[1] * this.y, E = h[2] * this.x + h[3] * this.y;
      return this.x = b, this.y = E, this;
    },
    _add: function(h) {
      return this.x += h.x, this.y += h.y, this;
    },
    _sub: function(h) {
      return this.x -= h.x, this.y -= h.y, this;
    },
    _mult: function(h) {
      return this.x *= h, this.y *= h, this;
    },
    _div: function(h) {
      return this.x /= h, this.y /= h, this;
    },
    _unit: function() {
      return this._div(this.mag()), this;
    },
    _perp: function() {
      var h = this.y;
      return this.y = this.x, this.x = -h, this;
    },
    _rotate: function(h) {
      var b = Math.cos(h), E = Math.sin(h), N = b * this.x - E * this.y, U = E * this.x + b * this.y;
      return this.x = N, this.y = U, this;
    },
    _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
  }, X.convert = function(h) {
    return h instanceof X ? h : Array.isArray(h) ? new X(h[0], h[1]) : h;
  };
  var te = $, H = oe;
  function oe(h, b, E, N, U) {
    this.properties = {}, this.extent = E, this.type = 0, this._pbf = h, this._geometry = -1, this._keys = N, this._values = U, h.readFields(fe, this, b);
  }
  function fe(h, b, E) {
    h == 1 ? b.id = E.readVarint() : h == 2 ? ce(E, b) : h == 3 ? b.type = E.readVarint() : h == 4 && (b._geometry = E.pos);
  }
  function ce(h, b) {
    for (var E = h.readVarint() + h.pos; h.pos < E; ) {
      var N = b._keys[h.readVarint()], U = b._values[h.readVarint()];
      b.properties[N] = U;
    }
  }
  oe.types = ["Unknown", "Point", "LineString", "Polygon"], oe.prototype.loadGeometry = function() {
    var h = this._pbf;
    h.pos = this._geometry;
    for (var b = h.readVarint() + h.pos, E = 1, N = 0, U = 0, Q = 0, Z = [], ae; h.pos < b; ) {
      if (!N) {
        var re = h.readVarint();
        E = re & 7, N = re >> 3;
      }
      if (N--, E === 1 || E === 2)
        U += h.readSVarint(), Q += h.readSVarint(), E === 1 && (ae && Z.push(ae), ae = []), ae.push(new te(U, Q));
      else if (E === 7)
        ae && ae.push(ae[0].clone());
      else
        throw new Error("unknown command " + E);
    }
    return ae && Z.push(ae), Z;
  }, oe.prototype.bbox = function() {
    var h = this._pbf;
    h.pos = this._geometry;
    for (var b = h.readVarint() + h.pos, E = 1, N = 0, U = 0, Q = 0, Z = 1 / 0, ae = -1 / 0, re = 1 / 0, Le = -1 / 0; h.pos < b; ) {
      if (!N) {
        var xe = h.readVarint();
        E = xe & 7, N = xe >> 3;
      }
      if (N--, E === 1 || E === 2)
        U += h.readSVarint(), Q += h.readSVarint(), U < Z && (Z = U), U > ae && (ae = U), Q < re && (re = Q), Q > Le && (Le = Q);
      else if (E !== 7)
        throw new Error("unknown command " + E);
    }
    return [Z, re, ae, Le];
  }, oe.prototype.toGeoJSON = function(h, b, E) {
    var N = this.extent * Math.pow(2, E), U = this.extent * h, Q = this.extent * b, Z = this.loadGeometry(), ae = oe.types[this.type], re, Le;
    function xe(De) {
      for (var Qe = 0; Qe < De.length; Qe++) {
        var Re = De[Qe], Gt = 180 - (Re.y + Q) * 360 / N;
        De[Qe] = [
          (Re.x + U) * 360 / N - 180,
          360 / Math.PI * Math.atan(Math.exp(Gt * Math.PI / 180)) - 90
        ];
      }
    }
    switch (this.type) {
      case 1:
        var Fe = [];
        for (re = 0; re < Z.length; re++)
          Fe[re] = Z[re][0];
        Z = Fe, xe(Z);
        break;
      case 2:
        for (re = 0; re < Z.length; re++)
          xe(Z[re]);
        break;
      case 3:
        for (Z = de(Z), re = 0; re < Z.length; re++)
          for (Le = 0; Le < Z[re].length; Le++)
            xe(Z[re][Le]);
        break;
    }
    Z.length === 1 ? Z = Z[0] : ae = "Multi" + ae;
    var Ze = {
      type: "Feature",
      geometry: {
        type: ae,
        coordinates: Z
      },
      properties: this.properties
    };
    return "id" in this && (Ze.id = this.id), Ze;
  };
  function de(h) {
    var b = h.length;
    if (b <= 1)
      return [h];
    for (var E = [], N, U, Q = 0; Q < b; Q++) {
      var Z = R(h[Q]);
      Z !== 0 && (U === void 0 && (U = Z < 0), U === Z < 0 ? (N && E.push(N), N = [h[Q]]) : N.push(h[Q]));
    }
    return N && E.push(N), E;
  }
  function R(h) {
    for (var b = 0, E = 0, N = h.length, U = N - 1, Q, Z; E < N; U = E++)
      Q = h[E], Z = h[U], b += (Z.x - Q.x) * (Q.y + Z.y);
    return b;
  }
  var J = H, we = q;
  function q(h, b) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = h, this._keys = [], this._values = [], this._features = [], h.readFields(ie, this, b), this.length = this._features.length;
  }
  function ie(h, b, E) {
    h === 15 ? b.version = E.readVarint() : h === 1 ? b.name = E.readString() : h === 5 ? b.extent = E.readVarint() : h === 2 ? b._features.push(E.pos) : h === 3 ? b._keys.push(E.readString()) : h === 4 && b._values.push(le(E));
  }
  function le(h) {
    for (var b = null, E = h.readVarint() + h.pos; h.pos < E; ) {
      var N = h.readVarint() >> 3;
      b = N === 1 ? h.readString() : N === 2 ? h.readFloat() : N === 3 ? h.readDouble() : N === 4 ? h.readVarint64() : N === 5 ? h.readVarint() : N === 6 ? h.readSVarint() : N === 7 ? h.readBoolean() : null;
    }
    return b;
  }
  q.prototype.feature = function(h) {
    if (h < 0 || h >= this._features.length)
      throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[h];
    var b = this._pbf.readVarint() + this._pbf.pos;
    return new J(this._pbf, b, this.extent, this._keys, this._values);
  };
  var pe = we, ge = ye;
  function ye(h, b) {
    this.layers = h.readFields(tt, {}, b);
  }
  function tt(h, b, E) {
    if (h === 3) {
      var N = new pe(E, E.readVarint() + E.pos);
      N.length && (b[N.name] = N);
    }
  }
  var Je = ge;
  L.SVG.Tile = L.SVG.extend({
    initialize: function(h, b, E) {
      L.SVG.prototype.initialize.call(this, E), this._tileCoord = h, this._size = b, this._initContainer(), this._container.setAttribute("width", this._size.x), this._container.setAttribute("height", this._size.y), this._container.setAttribute("viewBox", [0, 0, this._size.x, this._size.y].join(" ")), this._layers = {};
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    onAdd: L.Util.falseFn,
    addTo: function(h) {
      if (this._map = h, this.options.interactive)
        for (var b in this._layers) {
          var E = this._layers[b];
          E._path.style.pointerEvents = "auto", this._map._targets[L.stamp(E._path)] = E;
        }
    },
    removeFrom: function(h) {
      if (this.options.interactive)
        for (var b in this._layers) {
          var E = this._layers[b];
          delete this._map._targets[L.stamp(E._path)];
        }
      delete this._map;
    },
    _initContainer: function() {
      L.SVG.prototype._initContainer.call(this), L.SVG.create("rect");
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _addPath: function(h) {
      this._rootGroup.appendChild(h._path), this._layers[L.stamp(h)] = h;
    },
    _updateIcon: function(h) {
      var b = h._path = L.SVG.create("image"), E = h.options.icon, N = E.options, U = L.point(N.iconSize), Q = N.iconAnchor || U && U.divideBy(2, !0), Z = h._point.subtract(Q);
      b.setAttribute("x", Z.x), b.setAttribute("y", Z.y), b.setAttribute("width", U.x + "px"), b.setAttribute("height", U.y + "px"), b.setAttribute("href", N.iconUrl);
    }
  }), L.svg.tile = function(h, b, E) {
    return new L.SVG.Tile(h, b, E);
  };
  var ot = L.Class.extend({
    // 🍂method initialize(feature: GeoJSON, pxPerExtent: Number)
    // Initializes a new Line Symbolizer given a GeoJSON feature and the
    // pixel-to-coordinate-units ratio. Internal use only.
    // 🍂method render(renderer, style)
    // Renders this symbolizer in the given tiled renderer, with the given
    // `L.Path` options.  Internal use only.
    render: function(h, b) {
      this._renderer = h, this.options = b, h._initPath(this), h._updateStyle(this);
    },
    // 🍂method render(renderer, style)
    // Updates the `L.Path` options used to style this symbolizer, and re-renders it.
    // Internal use only.
    updateStyle: function(h, b) {
      this.options = b, h._updateStyle(this);
    },
    _getPixelBounds: function() {
      for (var h = this._parts, b = L.bounds([]), E = 0; E < h.length; E++)
        for (var N = h[E], U = 0; U < N.length; U++)
          b.extend(N[U]);
      var Q = this._clickTolerance(), Z = new L.Point(Q, Q);
      return b.min._subtract(Z), b.max._add(Z), b;
    },
    _clickTolerance: L.Path.prototype._clickTolerance
  }), zn = {
    _makeFeatureParts: function(h, b) {
      var E = h.geometry, N;
      this._parts = [];
      for (var U = 0; U < E.length; U++) {
        for (var Q = E[U], Z = [], ae = 0; ae < Q.length; ae++)
          N = Q[ae], Z.push(L.point(N).scaleBy(b));
        this._parts.push(Z);
      }
    },
    makeInteractive: function() {
      this._pxBounds = this._getPixelBounds();
    }
  }, Qi = L.CircleMarker.extend({
    includes: ot.prototype,
    statics: {
      iconCache: {}
    },
    initialize: function(h, b) {
      this.properties = h.properties, this._makeFeatureParts(h, b);
    },
    render: function(h, b) {
      ot.prototype.render.call(this, h, b), this._radius = b.radius || L.CircleMarker.prototype.options.radius, this._updatePath();
    },
    _makeFeatureParts: function(h, b) {
      var E = h.geometry[0];
      typeof E[0] == "object" && "x" in E[0] ? (this._point = L.point(E[0]).scaleBy(b), this._empty = L.Util.falseFn) : (this._point = L.point(E).scaleBy(b), this._empty = L.Util.falseFn);
    },
    makeInteractive: function() {
      this._updateBounds();
    },
    updateStyle: function(h, b) {
      return this._radius = b.radius || this._radius, this._updateBounds(), ot.prototype.updateStyle.call(this, h, b);
    },
    _updateBounds: function() {
      var h = this.options.icon;
      if (h) {
        var b = L.point(h.options.iconSize), E = h.options.iconAnchor || b && b.divideBy(2, !0), N = this._point.subtract(E);
        this._pxBounds = new L.Bounds(N, N.add(h.options.iconSize));
      } else
        L.CircleMarker.prototype._updateBounds.call(this);
    },
    _updatePath: function() {
      this.options.icon ? this._renderer._updateIcon(this) : L.CircleMarker.prototype._updatePath.call(this);
    },
    _getImage: function() {
      if (this.options.icon) {
        var h = this.options.icon.options.iconUrl, b = Qi.iconCache[h];
        if (!b) {
          var E = this.options.icon;
          b = Qi.iconCache[h] = E.createIcon();
        }
        return b;
      } else
        return null;
    },
    _containsPoint: function(h) {
      var b = this.options.icon;
      return b ? this._pxBounds.contains(h) : L.CircleMarker.prototype._containsPoint.call(this, h);
    }
  }), Ef = L.Polyline.extend({
    includes: [ot.prototype, zn],
    initialize: function(h, b) {
      this.properties = h.properties, this._makeFeatureParts(h, b);
    },
    render: function(h, b) {
      b.fill = !1, ot.prototype.render.call(this, h, b), this._updatePath();
    },
    updateStyle: function(h, b) {
      b.fill = !1, ot.prototype.updateStyle.call(this, h, b);
    }
  }), Cf = L.Polygon.extend({
    includes: [ot.prototype, zn],
    initialize: function(h, b) {
      this.properties = h.properties, this._makeFeatureParts(h, b);
    },
    render: function(h, b) {
      ot.prototype.render.call(this, h, b), this._updatePath();
    }
  });
  L.VectorGrid = L.GridLayer.extend({
    options: {
      // 🍂option rendererFactory = L.svg.tile
      // A factory method which will be used to instantiate the per-tile renderers.
      rendererFactory: L.svg.tile,
      // 🍂option vectorTileLayerStyles: Object = {}
      // A data structure holding initial symbolizer definitions for the vector features.
      vectorTileLayerStyles: {},
      // 🍂option interactive: Boolean = false
      // Whether this `VectorGrid` fires `Interactive Layer` events.
      interactive: !1
      // 🍂option getFeatureId: Function = undefined
      // A function that, given a vector feature, returns an unique identifier for it, e.g.
      // `function(feat) { return feat.properties.uniqueIdField; }`.
      // Must be defined for `setFeatureStyle` to work.
    },
    initialize: function(h) {
      L.setOptions(this, h), L.GridLayer.prototype.initialize.apply(this, arguments), this.options.getFeatureId && (this._vectorTiles = {}, this._overriddenStyles = {}, this.on("tileunload", function(b) {
        var E = this._tileCoordsToKey(b.coords), N = this._vectorTiles[E];
        N && this._map && N.removeFrom(this._map), delete this._vectorTiles[E];
      }, this)), this._dataLayerNames = {};
    },
    createTile: function(h, b) {
      var E = this.options.getFeatureId, N = this.getTileSize(), U = this.options.rendererFactory(h, N, this.options), Q = this._getVectorTilePromise(h);
      return E && (this._vectorTiles[this._tileCoordsToKey(h)] = U, U._features = {}), Q.then((function(ae) {
        for (var re in ae.layers) {
          this._dataLayerNames[re] = !0;
          for (var Le = ae.layers[re], xe = this.getTileSize().divideBy(Le.extent), Fe = this.options.vectorTileLayerStyles[re] || L.Path.prototype.options, Ze = 0; Ze < Le.features.length; Ze++) {
            var De = Le.features[Ze], Qe, Re = Fe;
            if (E) {
              Qe = this.options.getFeatureId(De);
              var Gt = this._overriddenStyles[Qe];
              Gt && (Gt[re] ? Re = Gt[re] : Re = Gt);
            }
            if (Re instanceof Function && (Re = Re(De.properties, h.z)), Re instanceof Array || (Re = [Re]), !!Re.length) {
              for (var Si = this._createLayer(De, xe), Tt = 0; Tt < Re.length; Tt++) {
                var ts = L.extend({}, L.Path.prototype.options, Re[Tt]);
                Si.render(U, ts), U._addPath(Si);
              }
              this.options.interactive && Si.makeInteractive(), E && (U._features[Qe] = {
                layerName: re,
                feature: Si
              });
            }
          }
        }
        this._map != null && U.addTo(this._map), L.Util.requestAnimFrame(b.bind(h, null, null));
      }).bind(this)), U.getContainer();
    },
    // 🍂method setFeatureStyle(id: Number, layerStyle: L.Path Options): this
    // Given the unique ID for a vector features (as per the `getFeatureId` option),
    // re-symbolizes that feature across all tiles it appears in.
    setFeatureStyle: function(h, b) {
      this._overriddenStyles[h] = b;
      for (var E in this._vectorTiles) {
        var N = this._vectorTiles[E], U = N._features, Q = U[h];
        if (Q) {
          var Z = Q.feature, ae = b;
          b[Q.layerName] && (ae = b[Q.layerName]), this._updateStyles(Z, N, ae);
        }
      }
      return this;
    },
    // 🍂method setFeatureStyle(id: Number): this
    // Reverts the effects of a previous `setFeatureStyle` call.
    resetFeatureStyle: function(h) {
      delete this._overriddenStyles[h];
      for (var b in this._vectorTiles) {
        var E = this._vectorTiles[b], N = E._features, U = N[h];
        if (U) {
          var Q = U.feature, Z = this.options.vectorTileLayerStyles[U.layerName] || L.Path.prototype.options;
          this._updateStyles(Q, E, Z);
        }
      }
      return this;
    },
    // 🍂method getDataLayerNames(): Array
    // Returns an array of strings, with all the known names of data layers in
    // the vector tiles displayed. Useful for introspection.
    getDataLayerNames: function() {
      return Object.keys(this._dataLayerNames);
    },
    _updateStyles: function(h, b, E) {
      E = E instanceof Function ? E(h.properties, b.getCoord().z) : E, E instanceof Array || (E = [E]);
      for (var N = 0; N < E.length; N++) {
        var U = L.extend({}, L.Path.prototype.options, E[N]);
        h.updateStyle(b, U);
      }
    },
    _createLayer: function(h, b, E) {
      var N;
      switch (h.type) {
        case 1:
          N = new Qi(h, b);
          break;
        case 2:
          N = new Ef(h, b);
          break;
        case 3:
          N = new Cf(h, b);
          break;
      }
      return this.options.interactive && N.addEventParent(this), N;
    }
  }), L.vectorGrid = function(h) {
    return new L.VectorGrid(h);
  }, L.VectorGrid.Protobuf = L.VectorGrid.extend({
    options: {
      // 🍂section
      // As with `L.TileLayer`, the URL template might contain a reference to
      // any option (see the example above and note the `{key}` or `token` in the URL
      // template, and the corresponding option).
      //
      // 🍂option subdomains: String = 'abc'
      // Akin to the `subdomains` option for `L.TileLayer`.
      subdomains: "abc",
      // Like L.TileLayer
      //
      // 🍂option fetchOptions: Object = {}
      // options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
      fetchOptions: {}
    },
    initialize: function(h, b) {
      this._url = h, L.VectorGrid.prototype.initialize.call(this, b);
    },
    // 🍂method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    setUrl: function(h, b) {
      return this._url = h, b || this.redraw(), this;
    },
    _getSubdomain: L.TileLayer.prototype._getSubdomain,
    _getVectorTilePromise: function(h) {
      var b = {
        s: this._getSubdomain(h),
        x: h.x,
        y: h.y,
        z: h.z
        // 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
      };
      if (this._map && !this._map.options.crs.infinite) {
        var E = this._globalTileRange.max.y - h.y;
        this.options.tms && (b.y = E), b["-y"] = E;
      }
      var N = L.Util.template(this._url, L.extend(b, this.options));
      return fetch(N, this.options.fetchOptions).then(function(U) {
        return U.ok ? U.blob().then(function(Q) {
          var Z = new FileReader();
          return new Promise(function(ae) {
            Z.addEventListener("loadend", function() {
              var re = new r(Z.result);
              return ae(new Je(re));
            }), Z.readAsArrayBuffer(Q);
          });
        }) : { layers: [] };
      }).then(function(U) {
        for (var Q in U.layers) {
          for (var Z = [], ae = 0; ae < U.layers[Q].length; ae++) {
            var re = U.layers[Q].feature(ae);
            re.geometry = re.loadGeometry(), Z.push(re);
          }
          U.layers[Q].features = Z;
        }
        return U;
      });
    }
  }), L.vectorGrid.protobuf = function(h, b) {
    return new L.VectorGrid.Protobuf(h, b);
  };
  var Tf = e(`'use strict';

var simplify_1 = simplify$1;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify$1(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

var convert_1 = convert$1;

var simplify = simplify_1;

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert$1(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    if (feature.geometry === null) {
        // ignore features with null geometry
        return;
    }

    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings, projectedRing;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            projectedRing = project(coords[i], tolerance);
            if (type === 'Polygon') { projectedRing.outer = (i === 0); }
            rings.push(projectedRing);
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                projectedRing = project(coords[i][j], tolerance);
                projectedRing.outer = (j === 0);
                rings.push(projectedRing);
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < 0 ? 0 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) { calcRingBBox(min, max, geometry); }
    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

var tile = transformTile;
var point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) { return tile; }

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

var transform$1 = {
	tile: tile,
	point: point
};

var clip_1 = clip$1;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   ____|____/
 *     |        |
 */

function clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept
    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) { continue; } // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) { slice.push(a); }
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            outer = points.outer,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) { slice.push(a); }

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }

        // add the final slice
        newSlice(slices, slice, area, dist, outer);
    }

    return slices;
}

function newSlice(slices, slice, area, dist, outer) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;
        if (outer !== undefined) { slice.outer = outer; }

        slices.push(slice);
    }
    return [];
}

var clip$2 = clip_1;

var wrap_1 = wrap$1;

function wrap$1(features, buffer, intersectX) {
    var merged = features,
        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center
        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

var tile$1 = createTile$1;

function createTile$1(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }
        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }
        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }
        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            if (type === 3) { rewind(simplifiedRing, ring.outer); }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

function rewind(ring, clockwise) {
    var area = signedArea(ring);
    if (area < 0 === clockwise) { ring.reverse(); }
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
}

var index = geojsonvt;

var convert = convert_1;
var transform = transform$1;
var clip = clip_1;
var wrap = wrap_1;
var createTile = tile$1;     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) { console.time('preprocess data'); }

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) { this.splitTile(features, 0, 0, 0); }

    if (debug) {
        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {
    var this$1 = this;


    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this$1.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) { console.time('creation'); }

            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this$1.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this$1.stats[key] = (this$1.stats[key] || 0) + 1;
                this$1.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) { continue; }

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) { solid = z; } // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) { console.time('clipping'); }

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) { console.timeEnd('clipping'); }

        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }
        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }
        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }
        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var this$1 = this;

    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }

    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this$1.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) { return null; }

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }

    if (debug > 1) { console.time('drilling down'); }
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) { console.timeEnd('drilling down'); }

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) { dest[i] = src[i]; }
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) { return false; }

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }

    var len = feature.geometry[0].length;
    if (len !== 5) { return false; }

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }
    }

    return true;
}

var identity = function(x) {
  return x;
};

var transform$3 = function(topology) {
  if ((transform = topology.transform) == null) { return identity; }
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) { x0 = y0 = 0; }
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
    return point;
  };
};

var bbox = function(topology) {
  var bbox = topology.bbox;

  function bboxPoint(p0) {
    p1[0] = p0[0], p1[1] = p0[1], t(p1);
    if (p1[0] < x0) { x0 = p1[0]; }
    if (p1[0] > x1) { x1 = p1[0]; }
    if (p1[1] < y0) { y0 = p1[1]; }
    if (p1[1] > y1) { y1 = p1[1]; }
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  if (!bbox) {
    var t = transform$3(topology), p0, p1 = new Array(2), name,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length;
      while (++i < n) {
        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);
        if (p1[0] < x0) { x0 = p1[0]; }
        if (p1[0] > x1) { x1 = p1[0]; }
        if (p1[1] < y0) { y0 = p1[1]; }
        if (p1[1] > y1) { y1 = p1[1]; }
      }
    });

    for (name in topology.objects) {
      bboxGeometry(topology.objects[name]);
    }

    bbox = topology.bbox = [x0, y0, x1, y1];
  }

  return bbox;
};

var reverse = function(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }
};

var feature = function(topology, o) {
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
      : feature$1(topology, o);
};

function feature$1(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = transform$3(topology),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) { points.pop(); }
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k].slice(), k));
    }
    if (i < 0) { reverse(points, n); }
  }

  function point(p) {
    return transformPoint(p.slice());
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }
    if (points.length < 2) { points.push(points[0].slice()); }
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) { points.push(points[0].slice()); }
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}

var stitch = function(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }
    else { p1 = arc[arc.length - 1]; }
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });

  return fragments;
};

function extractArcs(topology, object$$1, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object$$1);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });

  return arcs;
}

function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }
  return Math.abs(area); // Note: doubled area!
}

var bisect = function(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
};

var slicers = {};
var options;

onmessage = function (e) {
	if (e.data[0] === 'slice') {
		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.
		var geojson = e.data[1];
		options     = e.data[2];

		if (geojson.type && geojson.type === 'Topology') {
			for (var layerName in geojson.objects) {
				slicers[layerName] = index(
					feature(geojson, geojson.objects[layerName])
				, options);
			}
		} else {
			slicers[options.vectorTileLayerName] = index(geojson, options);
		}

	} else if (e.data[0] === 'get') {
		// Gets the vector tile for the given coordinates, sends it back as a message
		var coords = e.data[1];

		var tileLayers = {};
		for (var layerName in slicers) {
			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);

			if (slicedTileLayer) {
				var vectorTileLayer = {
					features: [],
					extent: options.extent,
					name: options.vectorTileLayerName,
					length: slicedTileLayer.features.length
				};

				for (var i in slicedTileLayer.features) {
					var feat = {
						geometry: slicedTileLayer.features[i].geometry,
						properties: slicedTileLayer.features[i].tags,
						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon
					};
					vectorTileLayer.features.push(feat);
				}
				tileLayers[layerName] = vectorTileLayer;
			}
		}
		postMessage({ layers: tileLayers, coords: coords });
	}
};
//# sourceMappingURL=slicerWebWorker.js.worker.map
`, "text/plain; charset=us-ascii");
  L.VectorGrid.Slicer = L.VectorGrid.extend({
    options: {
      // 🍂section
      // Additionally to these options, `VectorGrid.Slicer` can take in any
      // of the [`geojson-vt` options](https://github.com/mapbox/geojson-vt#options).
      // 🍂option vectorTileLayerName: String = 'sliced'
      // Vector tiles contain a set of *data layers*, and those data layers
      // contain features. Thus, the slicer creates one data layer, with
      // the name given in this option. This is important for symbolizing the data.
      vectorTileLayerName: "sliced",
      extent: 4096,
      // Default for geojson-vt
      maxZoom: 14
      // Default for geojson-vt
    },
    initialize: function(h, E) {
      L.VectorGrid.prototype.initialize.call(this, E);
      var E = {};
      for (var N in this.options)
        N !== "rendererFactory" && N !== "vectorTileLayerStyles" && typeof this.options[N] != "function" && (E[N] = this.options[N]);
      this._worker = new Worker(Tf), this._worker.postMessage(["slice", h, E]);
    },
    _getVectorTilePromise: function(h) {
      var b = this, E = new Promise(function(U) {
        b._worker.addEventListener("message", function Q(Z) {
          Z.data.coords && Z.data.coords.x === h.x && Z.data.coords.y === h.y && Z.data.coords.z === h.z && (U(Z.data), b._worker.removeEventListener("message", Q));
        });
      });
      return this._worker.postMessage(["get", h]), E;
    }
  }), L.vectorGrid.slicer = function(h, b) {
    return new L.VectorGrid.Slicer(h, b);
  }, L.Canvas.Tile = L.Canvas.extend({
    initialize: function(h, b, E) {
      L.Canvas.prototype.initialize.call(this, E), this._tileCoord = h, this._size = b, this._initContainer(), this._container.setAttribute("width", this._size.x), this._container.setAttribute("height", this._size.y), this._layers = {}, this._drawnLayers = {}, this._drawing = !0, E.interactive && (this._container.style.pointerEvents = "auto");
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    getOffset: function() {
      return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
    },
    onAdd: L.Util.falseFn,
    addTo: function(h) {
      this._map = h;
    },
    removeFrom: function(h) {
      delete this._map;
    },
    _onClick: function(h) {
      var b = this._map.mouseEventToLayerPoint(h).subtract(this.getOffset()), E, N;
      for (var U in this._layers)
        E = this._layers[U], E.options.interactive && E._containsPoint(b) && !this._map._draggableMoved(E) && (N = E);
      N && (L.DomEvent.fakeStop(h), this._fireEvent([N], h));
    },
    _onMouseMove: function(h) {
      if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
        var b = this._map.mouseEventToLayerPoint(h).subtract(this.getOffset());
        this._handleMouseHover(h, b);
      }
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _updateIcon: function(h) {
      if (this._drawing) {
        var b = h.options.icon, E = b.options, N = L.point(E.iconSize), U = E.iconAnchor || N && N.divideBy(2, !0), Q = h._point.subtract(U), Z = this._ctx, ae = h._getImage();
        ae.complete ? Z.drawImage(ae, Q.x, Q.y, N.x, N.y) : L.DomEvent.on(ae, "load", function() {
          Z.drawImage(ae, Q.x, Q.y, N.x, N.y);
        }), this._drawnLayers[h._leaflet_id] = h;
      }
    }
  }), L.canvas.tile = function(h, b, E) {
    return new L.Canvas.Tile(h, b, E);
  };
})();
var _s = { exports: {} }, yl;
function E0() {
  return yl || (yl = 1, function(e, t) {
    (function(i, n) {
      e.exports = i(B, $l);
    })(function(i, n) {
      if (typeof r > "u")
        var r = { iso8601: n };
      return i.TimeDimension = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        initialize: function(s) {
          i.setOptions(this, s), this._availableTimes = this._generateAvailableTimes(), this._currentTimeIndex = -1, this._loadingTimeIndex = -1, this._loadingTimeout = this.options.loadingTimeout || 3e3, this._syncedLayers = [], this._availableTimes.length > 0 && this.setCurrentTime(this.options.currentTime || this._getDefaultCurrentTime()), this.options.lowerLimitTime && this.setLowerLimit(this.options.lowerLimitTime), this.options.upperLimitTime && this.setUpperLimit(this.options.upperLimitTime);
        },
        getAvailableTimes: function() {
          return this._availableTimes;
        },
        getCurrentTimeIndex: function() {
          return this._currentTimeIndex === -1 ? this._availableTimes.length - 1 : this._currentTimeIndex;
        },
        getCurrentTime: function() {
          var s = -1;
          return this._loadingTimeIndex !== -1 ? s = this._loadingTimeIndex : s = this.getCurrentTimeIndex(), s >= 0 ? this._availableTimes[s] : null;
        },
        isLoading: function() {
          return this._loadingTimeIndex !== -1;
        },
        setCurrentTimeIndex: function(s) {
          var o = this._upperLimit || this._availableTimes.length - 1, l = this._lowerLimit || 0;
          if (s = Math.min(Math.max(l, s), o), !(s < 0)) {
            this._loadingTimeIndex = s;
            var c = this._availableTimes[s];
            this._checkSyncedLayersReady(this._availableTimes[this._loadingTimeIndex]) ? this._newTimeIndexLoaded() : (this.fire("timeloading", {
              time: c
            }), setTimeout((function(u) {
              u == this._loadingTimeIndex && this._newTimeIndexLoaded();
            }).bind(this, s), this._loadingTimeout));
          }
        },
        _newTimeIndexLoaded: function() {
          if (this._loadingTimeIndex !== -1) {
            var s = this._availableTimes[this._loadingTimeIndex];
            this._currentTimeIndex = this._loadingTimeIndex, this.fire("timeload", {
              time: s
            }), this._loadingTimeIndex = -1;
          }
        },
        _checkSyncedLayersReady: function(s) {
          for (var o = 0, l = this._syncedLayers.length; o < l; o++)
            if (this._syncedLayers[o].isReady && !this._syncedLayers[o].isReady(s))
              return !1;
          return !0;
        },
        setCurrentTime: function(s) {
          var o = this._seekNearestTimeIndex(s);
          this.setCurrentTimeIndex(o);
        },
        seekNearestTime: function(s) {
          var o = this._seekNearestTimeIndex(s);
          return this._availableTimes[o];
        },
        nextTime: function(s, o) {
          s || (s = 1);
          var l = this._currentTimeIndex, c = this._upperLimit || this._availableTimes.length - 1, u = this._lowerLimit || 0;
          this._loadingTimeIndex > -1 && (l = this._loadingTimeIndex), l = l + s, l > c && (o ? l = u : l = c), l < u && (o ? l = c : l = u), this.setCurrentTimeIndex(l);
        },
        prepareNextTimes: function(s, o, l) {
          s || (s = 1);
          var c = this._currentTimeIndex, u = c;
          this._loadingTimeIndex > -1 && (c = this._loadingTimeIndex);
          for (var d = 0, f = this._syncedLayers.length; d < f; d++)
            this._syncedLayers[d].setMinimumForwardCache && this._syncedLayers[d].setMinimumForwardCache(o);
          for (var m = o, g = this._upperLimit || this._availableTimes.length - 1, v = this._lowerLimit || 0; m > 0; ) {
            if (c = c + s, c > g)
              if (l)
                c = v;
              else
                break;
            if (c < v)
              if (l)
                c = g;
              else
                break;
            if (u === c)
              break;
            this.fire("timeloading", {
              time: this._availableTimes[c]
            }), m--;
          }
        },
        getNumberNextTimesReady: function(s, o, l) {
          s || (s = 1);
          var c = this._currentTimeIndex;
          this._loadingTimeIndex > -1 && (c = this._loadingTimeIndex);
          for (var u = o, d = 0, f = this._upperLimit || this._availableTimes.length - 1, m = this._lowerLimit || 0; u > 0; ) {
            if (c = c + s, c > f)
              if (l)
                c = m;
              else {
                u = 0, d = o;
                break;
              }
            if (c < m)
              if (l)
                c = f;
              else {
                u = 0, d = o;
                break;
              }
            var g = this._availableTimes[c];
            this._checkSyncedLayersReady(g) && d++, u--;
          }
          return d;
        },
        previousTime: function(s, o) {
          this.nextTime(s * -1, o);
        },
        registerSyncedLayer: function(s) {
          this._syncedLayers.push(s), s.on("timeload", this._onSyncedLayerLoaded, this);
        },
        unregisterSyncedLayer: function(s) {
          var o = this._syncedLayers.indexOf(s);
          o != -1 && this._syncedLayers.splice(o, 1), s.off("timeload", this._onSyncedLayerLoaded, this);
        },
        _onSyncedLayerLoaded: function(s) {
          s.time == this._availableTimes[this._loadingTimeIndex] && this._checkSyncedLayersReady(s.time) && this._newTimeIndexLoaded();
        },
        _generateAvailableTimes: function() {
          if (this.options.times)
            return i.TimeDimension.Util.parseTimesExpression(this.options.times);
          if (this.options.timeInterval) {
            var s = i.TimeDimension.Util.parseTimeInterval(this.options.timeInterval), o = this.options.period || "P1D", l = this.options.validTimeRange || void 0;
            return i.TimeDimension.Util.explodeTimeRange(s[0], s[1], o, l);
          } else
            return [];
        },
        _getDefaultCurrentTime: function() {
          var s = this._seekNearestTimeIndex((/* @__PURE__ */ new Date()).getTime());
          return this._availableTimes[s];
        },
        _seekNearestTimeIndex: function(s) {
          for (var o = 0, l = this._availableTimes.length; o < l && !(s < this._availableTimes[o]); o++)
            ;
          return o > 0 && o--, o;
        },
        setAvailableTimes: function(s, o) {
          var l = this.getCurrentTime(), c = this.getLowerLimit(), u = this.getUpperLimit();
          if (o == "extremes") {
            var d = this.options.period || "P1D";
            this._availableTimes = i.TimeDimension.Util.explodeTimeRange(new Date(s[0]), new Date(s[s.length - 1]), d);
          } else {
            var f = i.TimeDimension.Util.parseTimesExpression(s);
            if (this._availableTimes.length === 0)
              this._availableTimes = f;
            else if (o == "intersect")
              this._availableTimes = i.TimeDimension.Util.intersect_arrays(f, this._availableTimes);
            else if (o == "union")
              this._availableTimes = i.TimeDimension.Util.union_arrays(f, this._availableTimes);
            else if (o == "replace")
              this._availableTimes = f;
            else
              throw "Merge available times mode not implemented: " + o;
          }
          c && this.setLowerLimit(c), u && this.setUpperLimit(u), this.setCurrentTime(l), this.fire("availabletimeschanged", {
            availableTimes: this._availableTimes,
            currentTime: l
          });
        },
        getLowerLimit: function() {
          return this._availableTimes[this.getLowerLimitIndex()];
        },
        getUpperLimit: function() {
          return this._availableTimes[this.getUpperLimitIndex()];
        },
        setLowerLimit: function(s) {
          var o = this._seekNearestTimeIndex(s);
          this.setLowerLimitIndex(o);
        },
        setUpperLimit: function(s) {
          var o = this._seekNearestTimeIndex(s);
          this.setUpperLimitIndex(o);
        },
        setLowerLimitIndex: function(s) {
          this._lowerLimit = Math.min(Math.max(s || 0, 0), this._upperLimit || this._availableTimes.length - 1), this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        setUpperLimitIndex: function(s) {
          this._upperLimit = Math.max(Math.min(s, this._availableTimes.length - 1), this._lowerLimit || 0), this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        getLowerLimitIndex: function() {
          return this._lowerLimit;
        },
        getUpperLimitIndex: function() {
          return this._upperLimit;
        }
      }), i.Map.addInitHook(function() {
        this.options.timeDimension && (this.timeDimension = i.timeDimension(this.options.timeDimensionOptions || {}));
      }), i.timeDimension = function(s) {
        return new i.TimeDimension(s);
      }, i.TimeDimension.Util = {
        getTimeDuration: function(s) {
          if (typeof r > "u")
            throw "iso8601-js-period library is required for Leatlet.TimeDimension: https://github.com/nezasa/iso8601-js-period";
          return r.iso8601.Period.parse(s, !0);
        },
        addTimeDuration: function(s, o, l) {
          typeof l > "u" && (l = !0), (typeof o == "string" || o instanceof String) && (o = this.getTimeDuration(o));
          var c = o.length, u = l ? "getUTC" : "get", d = l ? "setUTC" : "set";
          c > 0 && o[0] != 0 && s[d + "FullYear"](s[u + "FullYear"]() + o[0]), c > 1 && o[1] != 0 && s[d + "Month"](s[u + "Month"]() + o[1]), c > 2 && o[2] != 0 && s[d + "Date"](s[u + "Date"]() + o[2] * 7), c > 3 && o[3] != 0 && s[d + "Date"](s[u + "Date"]() + o[3]), c > 4 && o[4] != 0 && s[d + "Hours"](s[u + "Hours"]() + o[4]), c > 5 && o[5] != 0 && s[d + "Minutes"](s[u + "Minutes"]() + o[5]), c > 6 && o[6] != 0 && s[d + "Seconds"](s[u + "Seconds"]() + o[6]);
        },
        subtractTimeDuration: function(s, o, l) {
          (typeof o == "string" || o instanceof String) && (o = this.getTimeDuration(o));
          for (var c = [], u = 0, d = o.length; u < d; u++)
            c.push(-o[u]);
          this.addTimeDuration(s, c, l);
        },
        parseAndExplodeTimeRange: function(s, o) {
          var l = s.split("/"), c = new Date(Date.parse(l[0])), u = new Date(Date.parse(l[1])), d = l.length > 2 && l[2].length ? l[2] : "P1D";
          return o != null && (d = o), this.explodeTimeRange(c, u, d);
        },
        explodeTimeRange: function(s, o, l, c) {
          var u = this.getTimeDuration(l), d = [], f = new Date(s.getTime()), m = null, g = null, v = null, x = null;
          if (c !== void 0) {
            var S = c.split("/");
            m = S[0].split(":")[0], g = S[0].split(":")[1], v = S[1].split(":")[0], x = S[1].split(":")[1];
          }
          for (; f < o; )
            (c === void 0 || f.getUTCHours() >= m && f.getUTCHours() <= v) && (f.getUTCHours() != m || f.getUTCMinutes() >= g) && (f.getUTCHours() != v || f.getUTCMinutes() <= x) && d.push(f.getTime()), this.addTimeDuration(f, u);
          return f >= o && d.push(o.getTime()), d;
        },
        parseTimeInterval: function(s) {
          var o = s.split("/");
          if (o.length != 2)
            throw "Incorrect ISO9601 TimeInterval: " + s;
          var l = Date.parse(o[0]), c = null, u = null;
          return isNaN(l) ? (u = this.getTimeDuration(o[0]), c = Date.parse(o[1]), l = new Date(c), this.subtractTimeDuration(l, u, !0), c = new Date(c)) : (c = Date.parse(o[1]), isNaN(c) ? (u = this.getTimeDuration(o[1]), c = new Date(l), this.addTimeDuration(c, u, !0)) : c = new Date(c), l = new Date(l)), [l, c];
        },
        parseTimesExpression: function(s, o) {
          var l = [];
          if (!s)
            return l;
          if (typeof s == "string" || s instanceof String)
            for (var c = s.split(","), u, d, f = 0, m = c.length; f < m; f++)
              u = c[f], u.split("/").length == 3 ? l = l.concat(this.parseAndExplodeTimeRange(u, o)) : (d = Date.parse(u), isNaN(d) || l.push(d));
          else
            l = s;
          return l.sort(function(g, v) {
            return g - v;
          });
        },
        intersect_arrays: function(s, o) {
          for (var l = s.slice(0), c = o.slice(0), u = []; l.length > 0 && c.length > 0; )
            l[0] < c[0] ? l.shift() : (l[0] > c[0] || u.push(l.shift()), c.shift());
          return u;
        },
        union_arrays: function(s, o) {
          for (var l = s.slice(0), c = o.slice(0), u = []; l.length > 0 && c.length > 0; )
            l[0] < c[0] ? u.push(l.shift()) : l[0] > c[0] ? u.push(c.shift()) : (u.push(l.shift()), c.shift());
          return l.length > 0 ? u = u.concat(l) : c.length > 0 && (u = u.concat(c)), u;
        },
        sort_and_deduplicate: function(s) {
          s = s.slice(0).sort();
          for (var o = [], l = null, c = 0, u = s.length; c < u; c++)
            s[c] !== l && (o.push(s[c]), l = s[c]);
          return o;
        }
      }, i.TimeDimension.Layer = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        options: {
          opacity: 1,
          zIndex: 1
        },
        initialize: function(s, o) {
          i.setOptions(this, o || {}), this._map = null, this._baseLayer = s, this._currentLayer = null, this._timeDimension = this.options.timeDimension || null;
        },
        addTo: function(s) {
          return s.addLayer(this), this;
        },
        onAdd: function(s) {
          this._map = s, !this._timeDimension && s.timeDimension && (this._timeDimension = s.timeDimension), this._timeDimension.on("timeloading", this._onNewTimeLoading, this), this._timeDimension.on("timeload", this._update, this), this._timeDimension.registerSyncedLayer(this), this._update();
        },
        onRemove: function(s) {
          this._timeDimension.unregisterSyncedLayer(this), this._timeDimension.off("timeloading", this._onNewTimeLoading, this), this._timeDimension.off("timeload", this._update, this), this.eachLayer(s.removeLayer, s), this._map = null;
        },
        eachLayer: function(s, o) {
          return s.call(o, this._baseLayer), this;
        },
        setZIndex: function(s) {
          return this.options.zIndex = s, this._baseLayer.setZIndex && this._baseLayer.setZIndex(s), this._currentLayer && this._currentLayer.setZIndex && this._currentLayer.setZIndex(s), this;
        },
        setOpacity: function(s) {
          return this.options.opacity = s, this._baseLayer.setOpacity && this._baseLayer.setOpacity(s), this._currentLayer && this._currentLayer.setOpacity && this._currentLayer.setOpacity(s), this;
        },
        bringToBack: function() {
          if (this._currentLayer)
            return this._currentLayer.bringToBack(), this;
        },
        bringToFront: function() {
          if (this._currentLayer)
            return this._currentLayer.bringToFront(), this;
        },
        _onNewTimeLoading: function(s) {
          this.fire("timeload", {
            time: s.time
          });
        },
        isReady: function(s) {
          return !0;
        },
        _update: function() {
          return !0;
        },
        getBaseLayer: function() {
          return this._baseLayer;
        },
        getBounds: function() {
          var s = new i.LatLngBounds();
          return this._currentLayer && s.extend(this._currentLayer.getBounds ? this._currentLayer.getBounds() : this._currentLayer.getLatLng()), s;
        }
      }), i.timeDimension.layer = function(s, o) {
        return new i.TimeDimension.Layer(s, o);
      }, i.TimeDimension.Layer.WMS = i.TimeDimension.Layer.extend({
        initialize: function(s, o) {
          i.TimeDimension.Layer.prototype.initialize.call(this, s, o), this._timeCacheBackward = this.options.cacheBackward || this.options.cache || 0, this._timeCacheForward = this.options.cacheForward || this.options.cache || 0, this._wmsVersion = this.options.wmsVersion || this.options.version || s.options.version || "1.1.1", this._getCapabilitiesParams = this.options.getCapabilitiesParams || {}, this._getCapabilitiesAlternateUrl = this.options.getCapabilitiesUrl || null, this._getCapabilitiesAlternateLayerName = this.options.getCapabilitiesLayerName || null, this._proxy = this.options.proxy || null, this._updateTimeDimension = this.options.updateTimeDimension || !1, this._setDefaultTime = this.options.setDefaultTime || !1, this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "intersect", this._period = this.options.period || null, this._layers = {}, this._defaultTime = 0, this._availableTimes = [], this._capabilitiesRequested = !1, (this._updateTimeDimension || this.options.requestTimeFromCapabilities) && this._requestTimeDimensionFromCapabilities(), this._baseLayer.on("load", (function() {
            this._baseLayer.setLoaded(!0), this.fire("timeload", {
              time: this._defaultTime
            });
          }).bind(this));
        },
        getEvents: function() {
          var s = i.bind(this._unvalidateCache, this);
          return {
            moveend: s,
            zoomend: s
          };
        },
        eachLayer: function(s, o) {
          for (var l in this._layers)
            this._layers.hasOwnProperty(l) && s.call(o, this._layers[l]);
          return i.TimeDimension.Layer.prototype.eachLayer.call(this, s, o);
        },
        _onNewTimeLoading: function(s) {
          var o = this._getLayerForTime(s.time);
          this._map.hasLayer(o) || this._map.addLayer(o);
        },
        isReady: function(s) {
          var o = this._getLayerForTime(s);
          return this.options.bounds && this._map && !this._map.getBounds().contains(this.options.bounds) ? !0 : o.isLoaded();
        },
        onAdd: function(s) {
          i.TimeDimension.Layer.prototype.onAdd.call(this, s), this._availableTimes.length == 0 ? this._requestTimeDimensionFromCapabilities() : this._updateTimeDimensionAvailableTimes();
        },
        _update: function() {
          if (this._map) {
            var s = this._timeDimension.getCurrentTime(), o = this._getLayerForTime(s);
            this._currentLayer == null && (this._currentLayer = o), this._map.hasLayer(o) ? this._showLayer(o, s) : this._map.addLayer(o);
          }
        },
        setOpacity: function(s) {
          i.TimeDimension.Layer.prototype.setOpacity.apply(this, arguments);
          for (var o in this._layers)
            this._layers.hasOwnProperty(o) && this._layers[o].setOpacity && this._layers[o].setOpacity(s);
        },
        setZIndex: function(s) {
          i.TimeDimension.Layer.prototype.setZIndex.apply(this, arguments);
          for (var o in this._layers)
            this._layers.hasOwnProperty(o) && this._layers[o].setZIndex && this._layers[o].setZIndex(s);
        },
        setParams: function(s, o) {
          i.extend(this._baseLayer.options, s), this._baseLayer.setParams && this._baseLayer.setParams(s, o);
          for (var l in this._layers)
            this._layers.hasOwnProperty(l) && this._layers[l].setParams && (this._layers[l].setLoaded(!1), this._layers[l].setParams(s, o));
          return this;
        },
        _unvalidateCache: function() {
          var s = this._timeDimension.getCurrentTime();
          for (var o in this._layers)
            s != o && this._layers.hasOwnProperty(o) && (this._layers[o].setLoaded(!1), this._layers[o].redraw());
        },
        _evictCachedTimes: function(s, o) {
          var l = this._getLoadedTimes(), c = String(this._currentTime), u = l.indexOf(c), d = [];
          if (o > -1) {
            var f = u - o;
            f > 0 && (d = l.splice(0, f), this._removeLayers(d));
          }
          if (s > -1) {
            u = l.indexOf(c);
            var f = l.length - u - s - 1;
            f > 0 && (d = l.splice(u + s + 1, f), this._removeLayers(d));
          }
        },
        _showLayer: function(s, o) {
          this._currentLayer && this._currentLayer !== s && this._currentLayer.hide(), s.show(), !(this._currentLayer && this._currentLayer === s) && (this._currentLayer = s, this._currentTime = o, this._evictCachedTimes(this._timeCacheForward, this._timeCacheBackward));
        },
        _getLayerForTime: function(s) {
          if (s == 0 || s == this._defaultTime || s == null)
            return this._baseLayer;
          if (this._layers.hasOwnProperty(s))
            return this._layers[s];
          var o = this._getNearestTime(s);
          if (this._layers.hasOwnProperty(o))
            return this._layers[o];
          var l = this._createLayerForTime(o);
          return this._layers[s] = l, l.on("load", (function(c, u) {
            c.setLoaded(!0), this._layers[u] || (this._layers[u] = c), this._timeDimension && u == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading() && this._showLayer(c, u), this.fire("timeload", {
              time: u
            });
          }).bind(this, l, s)), l.onAdd = (function(c) {
            Object.getPrototypeOf(this).onAdd.call(this, c), this.hide();
          }).bind(l), l;
        },
        _createLayerForTime: function(s) {
          var o = this._baseLayer.options;
          return o.time = new Date(s).toISOString(), new this._baseLayer.constructor(this._baseLayer.getURL(), o);
        },
        _getLoadedTimes: function() {
          var s = [];
          for (var o in this._layers)
            this._layers.hasOwnProperty(o) && s.push(o);
          return s.sort(function(l, c) {
            return l - c;
          });
        },
        _removeLayers: function(s) {
          for (var o = 0, l = s.length; o < l; o++)
            this._map && this._map.removeLayer(this._layers[s[o]]), delete this._layers[s[o]];
        },
        setMinimumForwardCache: function(s) {
          s > this._timeCacheForward && (this._timeCacheForward = s);
        },
        _requestTimeDimensionFromCapabilities: function() {
          if (!this._capabilitiesRequested) {
            this._capabilitiesRequested = !0;
            var s = this._getCapabilitiesUrl();
            this._proxy && (s = this._proxy + "?url=" + encodeURIComponent(s));
            var o = new XMLHttpRequest();
            o.addEventListener("load", (function(l) {
              var c = l.currentTarget.responseXML;
              c !== null && (this._defaultTime = Date.parse(this._getDefaultTimeFromCapabilities(c)), this._setDefaultTime = this._setDefaultTime || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0, this.setAvailableTimes(this._parseTimeDimensionFromCapabilities(c)), this._setDefaultTime && this._timeDimension && this._timeDimension.setCurrentTime(this._defaultTime));
            }).bind(this)), o.overrideMimeType("application/xml"), o.open("GET", s), o.send();
          }
        },
        _getCapabilitiesUrl: function() {
          var s = this._baseLayer.getURL();
          this._getCapabilitiesAlternateUrl && (s = this._getCapabilitiesAlternateUrl);
          var o = i.extend({}, this._getCapabilitiesParams, {
            request: "GetCapabilities",
            service: "WMS",
            version: this._wmsVersion
          });
          return s = s + i.Util.getParamString(o, s, o.uppercase), s;
        },
        _parseTimeDimensionFromCapabilities: function(s) {
          var o = s.querySelectorAll('Layer[queryable="1"]'), l = this._baseLayer.wmsParams.layers, c = null, u = null;
          return o.forEach(function(d) {
            d.querySelector("Name").innerHTML === l && (c = d);
          }), c && (u = this._getTimesFromLayerCapabilities(c), u || (u = this._getTimesFromLayerCapabilities(c.parentNode))), u;
        },
        _getTimesFromLayerCapabilities: function(s) {
          for (var o = null, l = s.children, c = 0, u = l.length; c < u; c++)
            if (!(l[c].nodeName !== "Extent" && l[c].nodeName !== "Dimension") && l[c].getAttribute("name") === "time" && l[c].textContent.length) {
              o = l[c].textContent.trim();
              break;
            }
          return o;
        },
        _getDefaultTimeFromCapabilities: function(s) {
          var o = s.querySelectorAll('Layer[queryable="1"]'), l = this._baseLayer.wmsParams.layers, c = null;
          o.forEach(function(d) {
            d.querySelector("Name").innerHTML === l && (c = d);
          });
          var u = 0;
          return c && (u = this._getDefaultTimeFromLayerCapabilities(c), u == 0 && (u = this._getDefaultTimeFromLayerCapabilities(c.parentNode))), u;
        },
        _getDefaultTimeFromLayerCapabilities: function(s) {
          for (var o = 0, l = s.children, c = 0, u = l.length; c < u; c++)
            if (!(l[c].nodeName !== "Extent" && l[c].nodeName !== "Dimension") && l[c].getAttribute("name") === "time" && l[c].attributes.default && l[c].attributes.default.textContent.length) {
              o = l[c].attributes.default.textContent.trim();
              break;
            }
          return o;
        },
        setAvailableTimes: function(s) {
          this._availableTimes = i.TimeDimension.Util.parseTimesExpression(s, this._period), this._updateTimeDimensionAvailableTimes();
        },
        _updateTimeDimensionAvailableTimes: function() {
          (this._timeDimension && this._updateTimeDimension || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0) && (this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode), this._setDefaultTime && this._defaultTime > 0 && this._timeDimension.setCurrentTime(this._defaultTime));
        },
        _getNearestTime: function(s) {
          if (this._layers.hasOwnProperty(s) || this._availableTimes.length == 0)
            return s;
          for (var o = 0, l = this._availableTimes.length; o < l && !(s < this._availableTimes[o]); o++)
            ;
          return o > 0 && o--, s != this._availableTimes[o], this._availableTimes[o];
        }
      }), i.NonTiledLayer || (i.NonTiledLayer = (i.Layer || i.Class).extend({})), i.NonTiledLayer.include({
        _visible: !0,
        _loaded: !1,
        _originalUpdate: i.NonTiledLayer.prototype._update,
        _originalOnRemove: i.NonTiledLayer.prototype.onRemove,
        _update: function() {
          !this._visible && this._loaded || this._originalUpdate();
        },
        onRemove: function(s) {
          this._loaded = !1, this._originalOnRemove(s);
        },
        setLoaded: function(s) {
          this._loaded = s;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = !1, this._div.style.display = "none";
        },
        show: function() {
          this._visible = !0, this._div.style.display = "block";
        },
        getURL: function() {
          return this._wmsUrl;
        }
      }), i.TileLayer.include({
        _visible: !0,
        _loaded: !1,
        _originalUpdate: i.TileLayer.prototype._update,
        _update: function() {
          !this._visible && this._loaded || this._originalUpdate();
        },
        setLoaded: function(s) {
          this._loaded = s;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = !1, this._container && (this._container.style.display = "none");
        },
        show: function() {
          this._visible = !0, this._container && (this._container.style.display = "block");
        },
        getURL: function() {
          return this._url;
        }
      }), i.timeDimension.layer.wms = function(s, o) {
        return new i.TimeDimension.Layer.WMS(s, o);
      }, i.TimeDimension.Layer.GeoJson = i.TimeDimension.Layer.extend({
        initialize: function(s, o) {
          i.TimeDimension.Layer.prototype.initialize.call(this, s, o), this._updateTimeDimension = this.options.updateTimeDimension || !1, this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "extremes", this._duration = this.options.duration || null, this._addlastPoint = this.options.addlastPoint || !1, this._waitForReady = this.options.waitForReady || !1, this._defaultTime = 0, this._availableTimes = [], this._loaded = !1, this._baseLayer.getLayers().length == 0 ? this._waitForReady ? this._baseLayer.on("ready", this._onReadyBaseLayer, this) : this._loaded = !0 : (this._loaded = !0, this._setAvailableTimes()), this._baseLayer.on("layeradd", (function() {
            this._loaded && this._setAvailableTimes();
          }).bind(this));
        },
        onAdd: function(s) {
          i.TimeDimension.Layer.prototype.onAdd.call(this, s), this._loaded && this._setAvailableTimes();
        },
        eachLayer: function(s, o) {
          return this._currentLayer && s.call(o, this._currentLayer), i.TimeDimension.Layer.prototype.eachLayer.call(this, s, o);
        },
        isReady: function(s) {
          return this._loaded;
        },
        _update: function() {
          if (this._map && this._loaded) {
            this._timeDimension.getCurrentTime();
            var s = this._timeDimension.getCurrentTime(), o = 0;
            if (this._duration) {
              var l = new Date(s);
              i.TimeDimension.Util.subtractTimeDuration(l, this._duration, !0), o = l.getTime();
            }
            for (var c = i.geoJson(null, this._baseLayer.options), u = this._baseLayer.getLayers(), d = 0, f = u.length; d < f; d++) {
              var m = this._getFeatureBetweenDates(u[d].feature, o, s);
              if (m && (c.addData(m), this._addlastPoint && m.geometry.type == "LineString" && m.geometry.coordinates.length > 0)) {
                var g = m.properties;
                g.last = !0, c.addData({
                  type: "Feature",
                  properties: g,
                  geometry: {
                    type: "Point",
                    coordinates: m.geometry.coordinates[m.geometry.coordinates.length - 1]
                  }
                });
              }
            }
            this._currentLayer && this._map.removeLayer(this._currentLayer), c.getLayers().length && (c.addTo(this._map), this._currentLayer = c);
          }
        },
        _setAvailableTimes: function() {
          for (var s = [], o = this._baseLayer.getLayers(), l = 0, c = o.length; l < c; l++)
            if (o[l].feature)
              for (var u = this._getFeatureTimes(o[l].feature), d = 0, f = u.length; d < f; d++)
                s.push(u[d]);
          this._availableTimes = i.TimeDimension.Util.sort_and_deduplicate(s), this._timeDimension && (this._updateTimeDimension || this._timeDimension.getAvailableTimes().length == 0) && this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode);
        },
        _getFeatureTimes: function(s) {
          if (!s.featureTimes) {
            s.properties ? s.properties.hasOwnProperty("coordTimes") ? s.featureTimes = s.properties.coordTimes : s.properties.hasOwnProperty("times") ? s.featureTimes = s.properties.times : s.properties.hasOwnProperty("linestringTimestamps") ? s.featureTimes = s.properties.linestringTimestamps : s.properties.hasOwnProperty("time") ? s.featureTimes = [s.properties.time] : s.featureTimes = [] : s.featureTimes = [];
            for (var o = 0, l = s.featureTimes.length; o < l; o++) {
              var c = s.featureTimes[o];
              (typeof c == "string" || c instanceof String) && (c = Date.parse(c.trim()), s.featureTimes[o] = c);
            }
          }
          return s.featureTimes;
        },
        _getFeatureBetweenDates: function(s, o, l) {
          var c = this._getFeatureTimes(s);
          if (c.length == 0)
            return s;
          var u = null, d = null, f = c.length;
          if (c[0] > l || c[f - 1] < o)
            return null;
          if (c[f - 1] > o) {
            for (var m = 0; m < f; m++)
              if (u === null && c[m] > o && (u = m), c[m] > l) {
                d = m;
                break;
              }
          }
          u === null && (u = 0), d === null && (d = f);
          var g = [];
          return s.geometry.coordinates[0].length ? g = s.geometry.coordinates.slice(u, d) : g = s.geometry.coordinates, {
            type: "Feature",
            properties: s.properties,
            geometry: {
              type: s.geometry.type,
              coordinates: g
            }
          };
        },
        _onReadyBaseLayer: function() {
          this._loaded = !0, this._setAvailableTimes(), this._update();
        }
      }), i.timeDimension.layer.geoJson = function(s, o) {
        return new i.TimeDimension.Layer.GeoJson(s, o);
      }, i.TimeDimension.Player = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        initialize: function(s, o) {
          i.setOptions(this, s), this._timeDimension = o, this._paused = !1, this._buffer = this.options.buffer || 5, this._minBufferReady = this.options.minBufferReady || 1, this._waitingForBuffer = !1, this._loop = this.options.loop || !1, this._steps = 1, this._timeDimension.on("timeload", (function(l) {
            this.release(), this._waitingForBuffer = !1;
          }).bind(this)), this.setTransitionTime(this.options.transitionTime || 1e3), this._timeDimension.on("limitschanged availabletimeschanged timeload", (function(l) {
            this._timeDimension.prepareNextTimes(this._steps, this._minBufferReady, this._loop);
          }).bind(this));
        },
        _tick: function() {
          var s = this._getMaxIndex(), o = this._timeDimension.getCurrentTimeIndex() >= s && this._steps > 0, l = this._timeDimension.getCurrentTimeIndex() == 0 && this._steps < 0;
          if ((o || l) && !this._loop) {
            this.pause(), this.stop(), this.fire("animationfinished");
            return;
          }
          if (!this._paused) {
            var c = 0, u = this._bufferSize;
            if (this._minBufferReady > 0) {
              if (c = this._timeDimension.getNumberNextTimesReady(this._steps, u, this._loop), this._waitingForBuffer)
                if (c < u) {
                  this.fire("waiting", {
                    buffer: u,
                    available: c
                  });
                  return;
                } else
                  this.fire("running"), this._waitingForBuffer = !1;
              else if (c < this._minBufferReady) {
                this._waitingForBuffer = !0, this._timeDimension.prepareNextTimes(this._steps, u, this._loop), this.fire("waiting", {
                  buffer: u,
                  available: c
                });
                return;
              }
            }
            this.pause(), this._timeDimension.nextTime(this._steps, this._loop), u > 0 && this._timeDimension.prepareNextTimes(this._steps, u, this._loop);
          }
        },
        _getMaxIndex: function() {
          return Math.min(
            this._timeDimension.getAvailableTimes().length - 1,
            this._timeDimension.getUpperLimitIndex() || 1 / 0
          );
        },
        start: function(s) {
          this._intervalID || (this._steps = s || 1, this._waitingForBuffer = !1, this.options.startOver && this._timeDimension.getCurrentTimeIndex() === this._getMaxIndex() && this._timeDimension.setCurrentTimeIndex(this._timeDimension.getLowerLimitIndex() || 0), this.release(), this._intervalID = window.setInterval(
            i.bind(this._tick, this),
            this._transitionTime
          ), this._tick(), this.fire("play"), this.fire("running"));
        },
        stop: function() {
          this._intervalID && (clearInterval(this._intervalID), this._intervalID = null, this._waitingForBuffer = !1, this.fire("stop"));
        },
        pause: function() {
          this._paused = !0;
        },
        release: function() {
          this._paused = !1;
        },
        getTransitionTime: function() {
          return this._transitionTime;
        },
        isPlaying: function() {
          return !!this._intervalID;
        },
        isWaiting: function() {
          return this._waitingForBuffer;
        },
        isLooped: function() {
          return this._loop;
        },
        setLooped: function(s) {
          this._loop = s, this.fire("loopchange", {
            loop: s
          });
        },
        setTransitionTime: function(s) {
          this._transitionTime = s, typeof this._buffer == "function" ? this._bufferSize = this._buffer.call(this, this._transitionTime, this._minBufferReady, this._loop) : this._bufferSize = this._buffer, this._intervalID && (this.stop(), this.start(this._steps)), this.fire("speedchange", {
            transitionTime: s,
            buffer: this._bufferSize
          });
        },
        getSteps: function() {
          return this._steps;
        }
      }), i.UI = i.ui = i.UI || {}, i.UI.Knob = i.Draggable.extend({
        options: {
          className: "knob",
          step: 1,
          rangeMin: 0,
          rangeMax: 10
          //minValue : null,
          //maxValue : null
        },
        initialize: function(s, o) {
          i.setOptions(this, o), this._element = i.DomUtil.create("div", this.options.className || "knob", s), i.Draggable.prototype.initialize.call(this, this._element, this._element), this._container = s, this.on("predrag", function() {
            this._newPos.y = 0, this._newPos.x = this._adjustX(this._newPos.x);
          }, this), this.on("dragstart", function() {
            i.DomUtil.addClass(s, "dragging");
          }), this.on("dragend", function() {
            i.DomUtil.removeClass(s, "dragging");
          }), i.DomEvent.on(this._element, "dblclick", function(l) {
            this.fire("dblclick", l);
          }, this), i.DomEvent.disableClickPropagation(this._element), this.enable();
        },
        _getProjectionCoef: function() {
          return (this.options.rangeMax - this.options.rangeMin) / (this._container.offsetWidth || this._container.style.width);
        },
        _update: function() {
          this.setPosition(i.DomUtil.getPosition(this._element).x);
        },
        _adjustX: function(s) {
          var o = this._toValue(s) || this.getMinValue();
          return this._toX(this._adjustValue(o));
        },
        _adjustValue: function(s) {
          return s = Math.max(this.getMinValue(), Math.min(this.getMaxValue(), s)), s = s - this.options.rangeMin, s = Math.round(s / this.options.step) * this.options.step, s = s + this.options.rangeMin, s = Math.round(s * 100) / 100, s;
        },
        _toX: function(s) {
          var o = (s - this.options.rangeMin) / this._getProjectionCoef();
          return o;
        },
        _toValue: function(s) {
          var o = s * this._getProjectionCoef() + this.options.rangeMin;
          return o;
        },
        getMinValue: function() {
          return this.options.minValue || this.options.rangeMin;
        },
        getMaxValue: function() {
          return this.options.maxValue || this.options.rangeMax;
        },
        setStep: function(s) {
          this.options.step = s, this._update();
        },
        setPosition: function(s) {
          i.DomUtil.setPosition(
            this._element,
            i.point(this._adjustX(s), 0)
          ), this.fire("positionchanged");
        },
        getPosition: function() {
          return i.DomUtil.getPosition(this._element).x;
        },
        setValue: function(s) {
          this.setPosition(this._toX(s));
        },
        getValue: function() {
          return this._adjustValue(this._toValue(this.getPosition()));
        }
      }), i.Control.TimeDimension = i.Control.extend({
        options: {
          styleNS: "leaflet-control-timecontrol",
          position: "bottomleft",
          title: "Time Control",
          backwardButton: !0,
          forwardButton: !0,
          playButton: !0,
          playReverseButton: !1,
          loopButton: !1,
          displayDate: !0,
          timeSlider: !0,
          timeSliderDragUpdate: !1,
          limitSliders: !1,
          limitMinimumRange: 5,
          speedSlider: !0,
          minSpeed: 0.1,
          maxSpeed: 10,
          speedStep: 0.1,
          timeSteps: 1,
          autoPlay: !1,
          playerOptions: {
            transitionTime: 1e3
          },
          timeZones: ["UTC", "Local"]
        },
        initialize: function(s) {
          i.setOptions(s), i.Control.prototype.initialize.call(this, s), this._timeZoneIndex = 0, this._timeDimension = this.options.timeDimension || null;
        },
        onAdd: function(s) {
          var o;
          return this._map = s, !this._timeDimension && s.timeDimension && (this._timeDimension = s.timeDimension), this._initPlayer(), o = i.DomUtil.create("div", "leaflet-bar leaflet-bar-horizontal leaflet-bar-timecontrol"), this.options.backwardButton && (this._buttonBackward = this._createButton("Backward", o)), this.options.playReverseButton && (this._buttonPlayReversePause = this._createButton("Play Reverse", o)), this.options.playButton && (this._buttonPlayPause = this._createButton("Play", o)), this.options.forwardButton && (this._buttonForward = this._createButton("Forward", o)), this.options.loopButton && (this._buttonLoop = this._createButton("Loop", o)), this.options.displayDate && (this._displayDate = this._createButton("Date", o)), this.options.timeSlider && (this._sliderTime = this._createSliderTime(this.options.styleNS + " timecontrol-slider timecontrol-dateslider", o)), this.options.speedSlider && (this._sliderSpeed = this._createSliderSpeed(this.options.styleNS + " timecontrol-slider timecontrol-speed", o)), this._steps = this.options.timeSteps || 1, this._timeDimension.on("timeload", this._update, this), this._timeDimension.on("timeload", this._onPlayerStateChange, this), this._timeDimension.on("timeloading", this._onTimeLoading, this), this._timeDimension.on("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this), i.DomEvent.disableClickPropagation(o), o;
        },
        addTo: function() {
          return i.Control.prototype.addTo.apply(this, arguments), this._onPlayerStateChange(), this._onTimeLimitsChanged(), this._update(), this;
        },
        onRemove: function() {
          this._player.off("play stop running loopchange speedchange", this._onPlayerStateChange, this), this._player.off("waiting", this._onPlayerWaiting, this), this._timeDimension.off("timeload", this._update, this), this._timeDimension.off("timeload", this._onPlayerStateChange, this), this._timeDimension.off("timeloading", this._onTimeLoading, this), this._timeDimension.off("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this);
        },
        _initPlayer: function() {
          this._player || (this.options.player ? this._player = this.options.player : this._player = new i.TimeDimension.Player(this.options.playerOptions, this._timeDimension)), this.options.autoPlay && this._player.start(this._steps), this._player.on("play stop running loopchange speedchange", this._onPlayerStateChange, this), this._player.on("waiting", this._onPlayerWaiting, this), this._onPlayerStateChange();
        },
        _onTimeLoading: function(s) {
          s.time == this._timeDimension.getCurrentTime() && this._displayDate && i.DomUtil.addClass(this._displayDate, "loading");
        },
        _onTimeLimitsChanged: function() {
          var s = this._timeDimension.getLowerLimitIndex(), o = this._timeDimension.getUpperLimitIndex(), l = this._timeDimension.getAvailableTimes().length - 1;
          this._limitKnobs && (this._limitKnobs[0].options.rangeMax = l, this._limitKnobs[1].options.rangeMax = l, this._limitKnobs[0].setValue(s || 0), this._limitKnobs[1].setValue(o || l)), this._sliderTime && (this._sliderTime.options.rangeMax = l, this._sliderTime._update());
        },
        _onPlayerWaiting: function(s) {
          this._buttonPlayPause && this._player.getSteps() > 0 && (i.DomUtil.addClass(this._buttonPlayPause, "loading"), this._buttonPlayPause.innerHTML = this._getDisplayLoadingText(s.available, s.buffer)), this._buttonPlayReversePause && this._player.getSteps() < 0 && (i.DomUtil.addClass(this._buttonPlayReversePause, "loading"), this._buttonPlayReversePause.innerHTML = this._getDisplayLoadingText(s.available, s.buffer));
        },
        _onPlayerStateChange: function() {
          if (this._buttonPlayPause && (this._player.isPlaying() && this._player.getSteps() > 0 ? (i.DomUtil.addClass(this._buttonPlayPause, "pause"), i.DomUtil.removeClass(this._buttonPlayPause, "play")) : (i.DomUtil.removeClass(this._buttonPlayPause, "pause"), i.DomUtil.addClass(this._buttonPlayPause, "play")), this._player.isWaiting() && this._player.getSteps() > 0 ? i.DomUtil.addClass(this._buttonPlayPause, "loading") : (this._buttonPlayPause.innerHTML = "", i.DomUtil.removeClass(this._buttonPlayPause, "loading"))), this._buttonPlayReversePause && (this._player.isPlaying() && this._player.getSteps() < 0 ? i.DomUtil.addClass(this._buttonPlayReversePause, "pause") : i.DomUtil.removeClass(this._buttonPlayReversePause, "pause"), this._player.isWaiting() && this._player.getSteps() < 0 ? i.DomUtil.addClass(this._buttonPlayReversePause, "loading") : (this._buttonPlayReversePause.innerHTML = "", i.DomUtil.removeClass(this._buttonPlayReversePause, "loading"))), this._buttonLoop && (this._player.isLooped() ? i.DomUtil.addClass(this._buttonLoop, "looped") : i.DomUtil.removeClass(this._buttonLoop, "looped")), this._sliderSpeed && !this._draggingSpeed) {
            var s = this._player.getTransitionTime() || 1e3;
            s = Math.round(1e4 / s) / 10, this._sliderSpeed.setValue(s);
          }
        },
        _update: function() {
          if (this._timeDimension)
            if (this._timeDimension.getCurrentTimeIndex() >= 0) {
              var s = new Date(this._timeDimension.getCurrentTime());
              this._displayDate && (i.DomUtil.removeClass(this._displayDate, "loading"), this._displayDate.innerHTML = this._getDisplayDateFormat(s)), this._sliderTime && !this._slidingTimeSlider && this._sliderTime.setValue(this._timeDimension.getCurrentTimeIndex());
            } else
              this._displayDate && (this._displayDate.innerHTML = this._getDisplayNoTimeError());
        },
        _createButton: function(s, o) {
          var l = i.DomUtil.create("a", this.options.styleNS + " timecontrol-" + s.toLowerCase(), o);
          return l.href = "#", l.title = s, i.DomEvent.addListener(l, "click", i.DomEvent.stopPropagation).addListener(l, "click", i.DomEvent.preventDefault).addListener(l, "click", this["_button" + s.replace(/ /i, "") + "Clicked"], this), l;
        },
        _createSliderTime: function(s, o) {
          var l, c, u, d, f;
          return l = i.DomUtil.create("div", s, o), c = i.DomUtil.create("div", "slider", l), u = this._timeDimension.getAvailableTimes().length - 1, this.options.limitSliders && (f = this._limitKnobs = this._createLimitKnobs(c)), d = new i.UI.Knob(c, {
            className: "knob main",
            rangeMin: 0,
            rangeMax: u
          }), d.on("dragend", function(m) {
            var g = m.target.getValue();
            this._sliderTimeValueChanged(g), this._slidingTimeSlider = !1;
          }, this), d.on("drag", function(m) {
            this._slidingTimeSlider = !0;
            var g = this._timeDimension.getAvailableTimes()[m.target.getValue()];
            if (g) {
              var v = new Date(g);
              this._displayDate && (this._displayDate.innerHTML = this._getDisplayDateFormat(v)), this.options.timeSliderDragUpdate && this._sliderTimeValueChanged(m.target.getValue());
            }
          }, this), d.on("predrag", function() {
            var m, g;
            f && (m = f[0].getPosition(), g = f[1].getPosition(), this._newPos.x < m && (this._newPos.x = m), this._newPos.x > g && (this._newPos.x = g));
          }, d), i.DomEvent.on(c, "click", function(m) {
            if (!i.DomUtil.hasClass(m.target, "knob")) {
              var g = m.touches && m.touches.length === 1 ? m.touches[0] : m, v = i.DomEvent.getMousePosition(g, c).x;
              f ? f[0].getPosition() <= v && v <= f[1].getPosition() && (d.setPosition(v), this._sliderTimeValueChanged(d.getValue())) : (d.setPosition(v), this._sliderTimeValueChanged(d.getValue()));
            }
          }, this), d.setPosition(0), d;
        },
        _createLimitKnobs: function(s) {
          i.DomUtil.addClass(s, "has-limits");
          var o = this._timeDimension.getAvailableTimes().length - 1, l = i.DomUtil.create("div", "range", s), c = new i.UI.Knob(s, {
            className: "knob lower",
            rangeMin: 0,
            rangeMax: o
          }), u = new i.UI.Knob(s, {
            className: "knob upper",
            rangeMin: 0,
            rangeMax: o
          });
          return i.DomUtil.setPosition(l, 0), c.setPosition(0), u.setPosition(o), c.on("dragend", function(d) {
            var f = d.target.getValue();
            this._sliderLimitsValueChanged(f, u.getValue());
          }, this), u.on("dragend", function(d) {
            var f = d.target.getValue();
            this._sliderLimitsValueChanged(c.getValue(), f);
          }, this), c.on("drag positionchanged", function() {
            i.DomUtil.setPosition(l, i.point(c.getPosition(), 0)), l.style.width = u.getPosition() - c.getPosition() + "px";
          }, this), u.on("drag positionchanged", function() {
            l.style.width = u.getPosition() - c.getPosition() + "px";
          }, this), u.on("predrag", function() {
            var d = c._toX(c.getValue() + this.options.limitMinimumRange);
            u._newPos.x <= d && (u._newPos.x = d);
          }, this), c.on("predrag", function() {
            var d = u._toX(u.getValue() - this.options.limitMinimumRange);
            c._newPos.x >= d && (c._newPos.x = d);
          }, this), c.on("dblclick", function() {
            this._timeDimension.setLowerLimitIndex(0);
          }, this), u.on("dblclick", function() {
            this._timeDimension.setUpperLimitIndex(this._timeDimension.getAvailableTimes().length - 1);
          }, this), [c, u];
        },
        _createSliderSpeed: function(s, o) {
          var l = i.DomUtil.create("div", s, o), c = i.DomUtil.create("span", "speed", l), u = i.DomUtil.create("div", "slider", l), d = Math.round(1e4 / (this._player.getTransitionTime() || 1e3)) / 10;
          c.innerHTML = this._getDisplaySpeed(d);
          var f = new i.UI.Knob(u, {
            step: this.options.speedStep,
            rangeMin: this.options.minSpeed,
            rangeMax: this.options.maxSpeed
          });
          return f.on("dragend", function(m) {
            var g = m.target.getValue();
            this._draggingSpeed = !1, c.innerHTML = this._getDisplaySpeed(g), this._sliderSpeedValueChanged(g);
          }, this), f.on("drag", function(m) {
            this._draggingSpeed = !0, c.innerHTML = this._getDisplaySpeed(m.target.getValue());
          }, this), f.on("positionchanged", function(m) {
            c.innerHTML = this._getDisplaySpeed(m.target.getValue());
          }, this), i.DomEvent.on(u, "click", function(m) {
            if (m.target !== f._element) {
              var g = m.touches && m.touches.length === 1 ? m.touches[0] : m, v = i.DomEvent.getMousePosition(g, u).x;
              f.setPosition(v), c.innerHTML = this._getDisplaySpeed(f.getValue()), this._sliderSpeedValueChanged(f.getValue());
            }
          }, this), f;
        },
        _buttonBackwardClicked: function() {
          this._timeDimension.previousTime(this._steps);
        },
        _buttonForwardClicked: function() {
          this._timeDimension.nextTime(this._steps);
        },
        _buttonLoopClicked: function() {
          this._player.setLooped(!this._player.isLooped());
        },
        _buttonPlayClicked: function() {
          this._player.isPlaying() ? this._player.stop() : this._player.start(this._steps);
        },
        _buttonPlayReverseClicked: function() {
          this._player.isPlaying() ? this._player.stop() : this._player.start(this._steps * -1);
        },
        _buttonDateClicked: function() {
          this._switchTimeZone();
        },
        _sliderTimeValueChanged: function(s) {
          this._timeDimension.setCurrentTimeIndex(s);
        },
        _sliderLimitsValueChanged: function(s, o) {
          this._timeDimension.setLowerLimitIndex(s), this._timeDimension.setUpperLimitIndex(o);
        },
        _sliderSpeedValueChanged: function(s) {
          this._player.setTransitionTime(1e3 / s);
        },
        _getCurrentTimeZone: function() {
          return this.options.timeZones[this._timeZoneIndex];
        },
        _switchTimeZone: function() {
          this._getCurrentTimeZone().toLowerCase() == "utc" && i.DomUtil.removeClass(this._displayDate, "utc"), this._timeZoneIndex = (this._timeZoneIndex + 1) % this.options.timeZones.length;
          var s = this._getCurrentTimeZone();
          s.toLowerCase() == "utc" ? (i.DomUtil.addClass(this._displayDate, "utc"), this._displayDate.title = "UTC Time") : s.toLowerCase() == "local" ? this._displayDate.title = "Local Time" : this._displayDate.title = s, this._update();
        },
        _getDisplayDateFormat: function(s) {
          var o = this._getCurrentTimeZone();
          return o.toLowerCase() == "utc" ? s.toISOString() : o.toLowerCase() == "local" ? s.toLocaleString() : s.toLocaleString([], { timeZone: o, timeZoneName: "short" });
        },
        _getDisplaySpeed: function(s) {
          return s + "fps";
        },
        _getDisplayLoadingText: function(s, o) {
          return "<span>" + Math.floor(s / o * 100) + "%</span>";
        },
        _getDisplayNoTimeError: function() {
          return "Time not available";
        }
      }), i.Map.addInitHook(function() {
        this.options.timeDimensionControl && (this.timeDimensionControl = i.control.timeDimension(this.options.timeDimensionControlOptions || {}), this.addControl(this.timeDimensionControl));
      }), i.control.timeDimension = function(s) {
        return new i.Control.TimeDimension(s);
      }, i.TimeDimension;
    });
  }(_s)), _s.exports;
}
E0();
(function(e) {
  typeof define == "function" && define.amd ? define(e) : e();
})(function() {
  const e = L.extend({}, L.DomUtil);
  L.extend(L.DomUtil, {
    /**
     * Resets the 3D CSS transform of `el` so it is
     * translated by `offset` pixels and optionally
     * scaled by `scale`. Does not have an effect if
     * the browser doesn't support 3D CSS transforms.
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} offset 
     * @param {Number} scale
     * @param {Number} bearing 
     * @param {L.Point} pivot 
     */
    setTransform: function(d, f, m, g, v) {
      var x = f || new L.Point(0, 0);
      if (!g)
        return f = x._round(), e.setTransform.apply(this, arguments);
      x = x.rotateFrom(g, v), d.style[L.DomUtil.TRANSFORM] = "translate3d(" + x.x + "px," + x.y + "px,0)" + (m ? " scale(" + m + ")" : "") + " rotate(" + g + "rad)";
    },
    /**
     * Sets the position of `el` to coordinates specified by
     * `position`, using CSS translate or top/left positioning
     * depending on the browser (used by Leaflet internally
     * to position its layers).
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} point 
     * @param {Number} bearing
     * @param {L.Point} pivot 
     * @param {Number} scale 
     */
    setPosition: function(d, f, m, g, v) {
      if (!m)
        return e.setPosition.apply(this, arguments);
      d._leaflet_pos = f, L.Browser.any3d ? L.DomUtil.setTransform(d, f, v, m, g) : (d.style.left = f.x + "px", d.style.top = f.y + "px");
    },
    /**
     * @constant radians = degrees × π/180°
     */
    DEG_TO_RAD: Math.PI / 180,
    /**
     * @constant degrees = radians × 180°/π
     */
    RAD_TO_DEG: 180 / Math.PI
  }), L.Draggable.include({
    /** @TODO */
    // updateMapBearing: function(mapBearing) {
    //     this._mapBearing = mapBearing;
    // },
  }), L.extend(L.Point.prototype, {
    /**
     * Rotate around (0,0) by applying the 2D rotation matrix:
     * 
     * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤
     * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦
     * 
     * @param theta must be given in radians.
     */
    rotate: function(d) {
      return this.rotateFrom(d, new L.Point(0, 0));
    },
    /**
     * Rotate around (pivot.x, pivot.y) by:
     * 
     * 1. subtract (pivot.x, pivot.y)
     * 2. rotate around (0, 0)
     * 3. add (pivot.x, pivot.y) back
     * 
     * same as `this.subtract(pivot).rotate(theta).add(pivot)`
     * 
     * @param {Number} theta 
     * @param {L.Point} pivot 
     * 
     * @returns {L.Point}
     */
    rotateFrom: function(d, f) {
      if (!d)
        return this;
      var m = Math.sin(d), g = Math.cos(d), v = f.x, x = f.y, S = this.x - v, A = this.y - x;
      return new L.Point(
        S * g - A * m + v,
        S * m + A * g + x
      );
    }
  });
  const t = L.extend({}, L.DivOverlay.prototype);
  L.DivOverlay.include({
    /**
     * Update L.Popup and L.Tooltip anchor positions after
     * the map is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(t.getEvents.apply(this, arguments), { rotate: this._updatePosition });
    },
    /**
     * 0. update element anchor point (divOverlayProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _updatePosition: function() {
      if (this._map && (t._updatePosition.apply(this, arguments), this._map && this._map._rotate && this._zoomAnimated)) {
        var d = this._getAnchor(), f = L.DomUtil.getPosition(this._container).subtract(d);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(f).add(d));
      }
    }
  });
  const i = L.extend({}, L.Popup.prototype);
  L.Popup.include({
    /**
     * 0. update element anchor point (popupProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _animateZoom: function(d) {
      if (i._animateZoom.apply(this, arguments), this._map && this._map._rotate) {
        var f = this._getAnchor(), m = L.DomUtil.getPosition(this._container).subtract(f);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(m).add(f));
      }
    },
    /**
     * Fix for L.popup({ keepInView = true })
     * 
     * @see https://github.com/fnicollet/Leaflet/pull/21
     */
    _adjustPan: function() {
      if (!(!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress)) {
        if (this._autopanning) {
          this._autopanning = !1;
          return;
        }
        var d = this._map, f = parseInt(L.DomUtil.getStyle(this._container, "marginBottom"), 10) || 0, m = this._container.offsetHeight + f, g = this._containerWidth, v = new L.Point(this._containerLeft, -m - this._containerBottom);
        v._add(L.DomUtil.getPosition(this._container));
        var x = v._add(this._map._getMapPanePos()), S = L.point(this.options.autoPanPadding), A = L.point(this.options.autoPanPaddingTopLeft || S), p = L.point(this.options.autoPanPaddingBottomRight || S), y = d.getSize(), w = 0, C = 0;
        x.x + g + p.x > y.x && (w = x.x + g - y.x + p.x), x.x - w - A.x < 0 && (w = x.x - A.x), x.y + m + p.y > y.y && (C = x.y + m - y.y + p.y), x.y - C - A.y < 0 && (C = x.y - A.y), (w || C) && (this.options.keepInView && (this._autopanning = !0), d.fire("autopanstart").panBy([w, C]));
      }
    }
  });
  const n = L.extend({}, L.Tooltip.prototype);
  L.Tooltip.include({
    _animateZoom: function(d) {
      if (!this._map._rotate)
        return n._animateZoom.apply(this, arguments);
      var f = this._map._latLngToNewLayerPoint(this._latlng, d.zoom, d.center);
      f = this._map.rotatedPointToMapPanePoint(f), this._setPosition(f);
    },
    _updatePosition: function() {
      if (!this._map._rotate)
        return n._updatePosition.apply(this, arguments);
      var d = this._map.latLngToLayerPoint(this._latlng);
      d = this._map.rotatedPointToMapPanePoint(d), this._setPosition(d);
    }
  }), L.extend({}, L.Icon.prototype), L.Icon.include({
    _setIconStyles: function(d, f) {
      var m = this.options, g = m[f + "Size"];
      typeof g == "number" && (g = [g, g]);
      var v = L.point(g), x = L.point(f === "shadow" && m.shadowAnchor || m.iconAnchor || v && v.divideBy(2, !0));
      d.className = "leaflet-marker-" + f + " " + (m.className || ""), x && (d.style.marginLeft = -x.x + "px", d.style.marginTop = -x.y + "px", d.style[L.DomUtil.TRANSFORM + "Origin"] = x.x + "px " + x.y + "px 0px"), v && (d.style.width = v.x + "px", d.style.height = v.y + "px");
    }
  });
  const r = L.extend({}, L.Marker.prototype);
  L.Marker.mergeOptions({
    /**
     * Rotation of this marker in rad
     * 
     * @type {Number}
     */
    rotation: 0,
    /**
     * Rotate this marker when map rotates
     * 
     * @type {Boolean}
     */
    rotateWithView: !1,
    /**
     * Scale of the marker icon
     * 
     * @type {Number}
     */
    scale: void 0
  });
  var s, o = {
    // _onDragStart: function() {
    //     if (!this._marker._map._rotate) {
    //         return markerDragProto._onDragStart.apply(this, arguments);
    //     }
    //     this._draggable.updateMapBearing(this._marker._map._bearing);
    // },
    _onDrag: function(d) {
      var f = this._marker, m = f.options.rotation || f.options.rotateWithView, g = f._shadow, v = L.DomUtil.getPosition(f._icon);
      !m && g && L.DomUtil.setPosition(g, v), f._map._rotate && (v = f._map.mapPanePointToRotatedPoint(v));
      var x = f._map.layerPointToLatLng(v);
      f._latlng = x, d.latlng = x, d.oldLatLng = this._oldLatLng, m ? f.setLatLng(x) : f.fire("move", d), f.fire("drag", d);
    },
    _onDragEnd: function(d) {
      this._marker._map._rotate && this._marker.update(), s._onDragEnd.apply(this, arguments);
    }
  };
  L.Marker.include({
    /**
     * Update L.Marker anchor position after the map
     * is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(r.getEvents.apply(this, arguments), { rotate: this.update });
    },
    _initInteraction: function() {
      var d = r._initInteraction.apply(this, arguments);
      return this.dragging && this.dragging.enabled() && this._map && this._map._rotate && (s = s || Object.getPrototypeOf(this.dragging), this.dragging.disable(), Object.assign(this.dragging, {
        // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),
        _onDrag: o._onDrag.bind(this.dragging),
        _onDragEnd: o._onDragEnd.bind(this.dragging)
      }), this.dragging.enable()), d;
    },
    _setPos: function(d) {
      this._map._rotate && (d = this._map.rotatedPointToMapPanePoint(d));
      var f = this.options.rotation || 0;
      this.options.rotateWithView && (f += this._map._bearing), this._icon && L.DomUtil.setPosition(this._icon, d, f, d, this.options.scale), this._shadow && L.DomUtil.setPosition(this._shadow, d, f, d, this.options.scale), this._zIndex = d.y + this.options.zIndexOffset, this._resetZIndex();
    },
    // _updateZIndex: function(offset) {
    //     if (!this._map._rotate) {
    //         return markerProto._updateZIndex.apply(this, arguments);
    //     }
    //     this._icon.style.zIndex = Math.round(this._zIndex + offset);
    // },
    setRotation: function(d) {
      this.options.rotation = d, this.update();
    }
  });
  const l = L.extend({}, L.GridLayer.prototype);
  L.GridLayer.include({
    /**
     * Redraw L.TileLayer bounds after the map is
     * moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      var d = l.getEvents.apply(this, arguments);
      return this._map._rotate && !this.options.updateWhenIdle && (this._onRotate || (this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this)), d.rotate = this._onRotate), d;
    },
    _getTiledPixelBounds: function(d) {
      return this._map._rotate ? this._map._getNewPixelBounds(d, this._tileZoom) : l._getTiledPixelBounds.apply(this, arguments);
    }
  });
  const c = L.extend({}, L.Renderer.prototype);
  L.Renderer.include({
    /**
     * Redraw L.Canvas and L.SVG renderer bounds after the
     * map is moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(c.getEvents.apply(this, arguments), { rotate: this._update });
    },
    /**
     * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     */
    onAdd: function() {
      c.onAdd.apply(this, arguments), L.version <= "1.9.3" && this._container.classList.add("leaflet-zoom-animated");
    },
    /**
     * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)
     * 
     * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`
     * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`
     * 
     * @example
     *   map.setZoom(2);
     *   path._renderer._update();
     *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     * @see https://github.com/Leaflet/Leaflet/pull/8103
     * @see https://github.com/Leaflet/Leaflet/issues/7466
     * 
     * @TODO rechek this changes from leaflet@v1.9.3
     * 
     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3
     */
    _updateTransform: function(d, f) {
      if (!this._map._rotate)
        return c._updateTransform.apply(this, arguments);
      var m = this._map.getZoomScale(f, this._zoom), g = this._map._latLngToNewLayerPoint(this._topLeft, f, d);
      L.DomUtil.setTransform(this._container, g, m);
    },
    // getEvents() {
    //     const events = {
    //         viewreset: this._reset,
    //         zoom: this._onZoom,
    //         moveend: this._update,
    //         zoomend: this._onZoomEnd
    //     };
    //     if (this._zoomAnimated) {
    //         events.zoomanim = this._onAnimZoom;
    //     }
    //     return events;
    // },
    // _onAnimZoom(ev) {
    //     this._updateTransform(ev.center, ev.zoom);
    // },
    // _onZoom() {
    //     this._updateTransform(this._map.getCenter(), this._map.getZoom());
    // },
    // _onZoomEnd() {
    //     for (const id in this._layers) {
    //         this._layers[id]._project();
    //     }
    // },
    // _reset() {
    //     this._update();
    //     this._updateTransform(this._center, this._zoom);
    //     for (const id in this._layers) {
    //         this._layers[id]._reset();
    //     }
    // },
    // _updatePaths() {
    //     for (const id in this._layers) {
    //         this._layers[id]._update();
    //     }
    // },
    _update: function() {
      if (!this._map._rotate)
        return c._update.apply(this, arguments);
      this._bounds = this._map._getPaddedPixelBounds(this.options.padding), this._topLeft = this._map.layerPointToLatLng(this._bounds.min), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
    }
  });
  const u = L.extend({}, L.Map.prototype);
  L.Map.mergeOptions({ rotate: !1, bearing: 0 }), L.Map.prototype._animateZoomNoDelay = function(d, f, m) {
    this._mapPane && (m && (this._animatingZoom = !0, this._animateToCenter = d, this._animateToZoom = f, this._mapPane.classList.add("leaflet-zoom-anim")), this._onZoomTransitionEnd());
  }, L.Map.include({
    /**
     * @param {(HTMLElement|String)} id html selector
     * @param {Object} [options={}] leaflet map options
     */
    initialize: function(d, f) {
      f.rotate && (this._rotate = !0, this._bearing = 0), u.initialize.apply(this, arguments), this.options.rotate && this.setBearing(this.options.bearing);
    },
    /**
     * Given a pixel coordinate relative to the map container,
     * returns the corresponding pixel coordinate relative to
     * the [origin pixel](#map-getpixelorigin).
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    containerPointToLayerPoint: function(d) {
      return this._rotate ? L.point(d).subtract(this._getMapPanePos()).rotateFrom(-this._bearing, this._getRotatePanePos()).subtract(this._getRotatePanePos()) : u.containerPointToLayerPoint.apply(this, arguments);
    },
    /**
     * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
     * returns the corresponding pixel coordinate relative to the map container.
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    layerPointToContainerPoint: function(d) {
      return this._rotate ? L.point(d).add(this._getRotatePanePos()).rotateFrom(this._bearing, this._getRotatePanePos()).add(this._getMapPanePos()) : u.layerPointToContainerPoint.apply(this, arguments);
    },
    /**
     * Converts a coordinate from the rotated pane reference system
     * to the reference system of the not rotated map pane.
     * 
     * (rotatePane) --> (mapPane)
     * (rotatePane) --> (norotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point}
     * 
     * @since leaflet-rotate (v0.1)
     */
    rotatedPointToMapPanePoint: function(d) {
      return L.point(d).rotate(this._bearing)._add(this._getRotatePanePos());
    },
    /**
     * Converts a coordinate from the not rotated map pane reference system
     * to the reference system of the rotated pane.
     * 
     * (mapPane) --> (rotatePane)
     * (norotatePane) --> (rotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * 
     * @since leaflet-rotate (v0.1)
     */
    mapPanePointToRotatedPoint: function(d) {
      return L.point(d)._subtract(this._getRotatePanePos()).rotate(-this._bearing);
    },
    // latLngToLayerPoint: function (latlng) {
    //     var projectedPoint = this.project(L.latLng(latlng))._round();
    //     return projectedPoint._subtract(this.getPixelOrigin());
    // },
    // latLngToContainerPoint: function (latlng) {
    // 	return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    // },
    /**
     * Given latlng bounds, returns the bounds in projected pixel
     * relative to the map container.
     * 
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135
     * 
     * @param {L.LatLngBounds} bounds 
     * @returns {L.Bounds}
     * 
     * @since leaflet-rotate (v0.2)
     */
    mapBoundsToContainerBounds: function(d) {
      if (!this._rotate && u.mapBoundsToContainerBounds)
        return u.mapBoundsToContainerBounds.apply(this, arguments);
      const f = this.getPixelOrigin(), m = this.layerPointToContainerPoint(this.project(d.getNorthWest())._subtract(f)), g = this.layerPointToContainerPoint(this.project(d.getNorthEast())._subtract(f)), v = this.layerPointToContainerPoint(this.project(d.getSouthWest())._subtract(f)), x = this.layerPointToContainerPoint(this.project(d.getSouthEast())._subtract(f));
      return L.bounds([
        L.point(Math.min(m.x, g.x, x.x, v.x), Math.min(m.y, g.y, x.y, v.y)),
        // [ minX, minY ]
        L.point(Math.max(m.x, g.x, x.x, v.x), Math.max(m.y, g.y, x.y, v.y))
        // [ maxX, maxY ]
      ]);
    },
    /**
     * Returns geographical bounds visible in the current map view
     * 
     * @TODO find out  if map bounds calculated by `L.Map::getBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     * 
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.LatLngBounds}
     */
    getBounds: function() {
      if (!this._rotate)
        return u.getBounds.apply(this, arguments);
      var d = this.getSize();
      return new L.LatLngBounds([
        this.containerPointToLatLng([0, 0]),
        // topleft
        this.containerPointToLatLng([d.x, 0]),
        // topright 
        this.containerPointToLatLng([d.x, d.y]),
        // bottomright
        this.containerPointToLatLng([0, d.y])
        // bottomleft
      ]);
    },
    /**
     * Returns the bounds of the current map view in projected pixel
     * coordinates (sometimes useful in layer and overlay implementations).
     * 
     * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.Bounds}
     */
    // getPixelBounds(center, zoom) {
    //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());
    //     const topLeftPoint = this._getTopLeftPoint(center, zoom);
    //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    // },
    /**
     * Change map rotation
     * 
     * @param {number} theta map degrees
     * @param {L.Point} rotation center offset in screen pixels to apply
     * 
     * @since leaflet-rotate (v0.1)
     */
    setBearing: function(d, f = L.point(0, 0)) {
      if (!(!L.Browser.any3d || !this._rotate)) {
        var m = L.Util.wrapNum(d, [0, 360]) * L.DomUtil.DEG_TO_RAD, g = this._getPixelCenter().add(L.point(f)), v = this._getRotatePanePos().rotateFrom(-this._bearing, g), x = v.rotateFrom(m, g);
        L.DomUtil.setPosition(this._rotatePane, v, m, g), this._pivot = g, this._bearing = m, this._rotatePanePos = x, this.fire("rotate");
      }
    },
    /**
     * Get current map rotation
     * 
     * @returns {number} theta map degrees
     * 
     * @since leaflet-rotate (v0.1)
     */
    getBearing: function() {
      return this._bearing * L.DomUtil.RAD_TO_DEG;
    },
    /**
     * Creates a new [map pane](#map-pane) with the given name if it doesn't
     * exist already, then returns it. The pane is created as a child of
     * `container`, or as a child of the main map pane if not set.
     * 
     * @param {String} name leaflet pane
     * @param {HTMLElement} [container] parent element
     * @returns {HTMLElement} pane container
     */
    // createPane: function(name, container) {
    //     if (!this._rotate || name == 'mapPane') {
    //         return mapProto.createPane.apply(this, arguments);
    //     }
    //     // init "rotatePane"
    //     if (!this._rotatePane) {
    //         // this._pivot = this.getSize().divideBy(2);
    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);
    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);
    //     }
    //     return mapProto.createPane.call(this, name, container || this._rotatePane);
    // },
    /**
     * Panes are DOM elements used to control the ordering of layers on
     * the map. You can access panes with [`map.getPane`](#map-getpane)
     * or [`map.getPanes`](#map-getpanes) methods. New panes can be created
     * with the [`map.createPane`](#map-createpane) method.
     * 
     * Every map has the following default panes that differ only in zIndex:
     * 
     * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes
     * - tilePane    [HTMLElement = 2]      - Pane for tile layers
     * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons
     * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)
     * - markerPane  [HTMLElement = 6]      - Pane for marker icons
     * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.
     * - popupPane   [HTMLElement = 700]    - Pane for popups.
     */
    _initPanes: function() {
      var d = this._panes = {};
      this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0)), this._rotate ? (this._rotatePane = this.createPane("rotatePane", this._mapPane), this._norotatePane = this.createPane("norotatePane", this._mapPane), this.createPane("tilePane", this._rotatePane), this.createPane("overlayPane", this._rotatePane), this.createPane("shadowPane", this._norotatePane), this.createPane("markerPane", this._norotatePane), this.createPane("tooltipPane", this._norotatePane), this.createPane("popupPane", this._norotatePane)) : (this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane")), this.options.markerZoomAnimation || (L.DomUtil.addClass(d.markerPane, "leaflet-zoom-hide"), L.DomUtil.addClass(d.shadowPane, "leaflet-zoom-hide"));
    },
    /**
     * Pans the map the minimum amount to make the `latlng` visible. Use
     * padding options to fit the display to more restricted bounds.
     * If `latlng` is already within the (optionally padded) display bounds,
     * the map will not be panned.
     * 
     * @see https://github.com/Raruto/leaflet-rotate/issues/18
     * 
     * @param {L.LatLng} latlng coordinates
     * @param {Object} [options={}] padding options
     * 
     * @returns {L.Map} current map instance
     */
    panInside(d, f) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1)
        return u.panInside.apply(this, arguments);
      f = f || {};
      const m = L.point(f.paddingTopLeft || f.padding || [0, 0]), g = L.point(f.paddingBottomRight || f.padding || [0, 0]), v = this._container.getBoundingClientRect(), x = this.latLngToContainerPoint(d), S = L.bounds([L.point(v), L.point(v).add(this.getSize())]), A = S.getCenter(), p = L.bounds([S.min.add(m), S.max.subtract(g)]), y = p.getSize();
      if (!p.contains(x)) {
        this._enforcingBounds = !0;
        const w = x.subtract(p.getCenter()), C = p.extend(x).getSize().subtract(y);
        A.x += w.x < 0 ? -C.x : C.x, A.y += w.y < 0 ? -C.y : C.y, this.panTo(this.containerPointToLatLng(A), f), this._enforcingBounds = !1;
      }
      return this;
    },
    /**
     * Pans the map to the closest view that would lie inside the given bounds
     * (if it's not already), controlling the animation using the options specific,
     * if any.
     * 
     * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @param {L.LatLngBounds} bounds coordinates
     * @param {Object} [options] pan options
     * @returns {L.Map} current map instance
     */
    // panInsideBounds: function (bounds, options) {
    //     this._enforcingBounds = true;
    //     var center = this.getCenter(),
    //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));
    //
    //     if (!center.equals(newCenter)) {
    //         this.panTo(newCenter, options);
    //     }
    //
    //     this._enforcingBounds = false;
    //     return this;
    // },
    // adjust center for view to get inside bounds
    // _limitCenter(center, zoom, bounds) {
    //
    //     if (!bounds) { return center; }
    //
    //     const centerPoint = this.project(center, zoom),
    //         viewHalf = this.getSize().divideBy(2),
    //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
    //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);
    //
    //     // If offset is less than a pixel, ignore.
    //     // This prevents unstable projections from getting into
    //     // an infinite loop of tiny offsets.
    //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
    //             return center;
    //     }
    //
    //     return this.unproject(centerPoint.add(offset), zoom);
    // },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    // flyToBounds(bounds, options) {
    //     const target = this._getBoundsCenterZoom(bounds, options);
    //     return this.flyTo(target.center, target.zoom, options);
    // },
    // _getBoundsCenterZoom(bounds, options) {
    //
    //     options = options || {};
    //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
    //
    //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
    //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);
    //
    //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
    //
    //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;
    //
    //     if (zoom === Infinity) {
    //         return { center: bounds.getCenter(), zoom };
    //     }
    //
    //     return { center, zoom };
    //
    // },
    /**
     * Returns the maximum zoom level on which the given bounds fit to the map
     * view in its entirety. If `inside` (optional) is set to `true`, the method
     * instead returns the minimum zoom level on which the map view fits into
     * the given bounds in its entirety.
     * 
     * @param {L.LatLngBounds} bounds
     * @param {Boolean} [inside=false]
     * @param {L.Point} [padding=[0,0]]
     * 
     * @returns {Number} zoom level
     */
    getBoundsZoom(d, f, m) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1)
        return u.getBoundsZoom.apply(this, arguments);
      d = L.latLngBounds(d), m = L.point(m || [0, 0]);
      let g = this.getZoom() || 0;
      const v = this.getMinZoom(), x = this.getMaxZoom(), S = this.getSize().subtract(m), A = this.mapBoundsToContainerBounds(d).getSize(), p = this.options.zoomSnap, y = S.x / A.x, w = S.y / A.y, C = f ? Math.max(y, w) : Math.min(y, w);
      return g = this.getScaleZoom(C, g), p && (g = Math.round(g / (p / 100)) * (p / 100), g = f ? Math.ceil(g / p) * p : Math.floor(g / p) * p), Math.max(v, Math.min(x, g));
    },
    /**
     * Layer point of the current center
     * 
     * @returns {L.Point} layer center
     */
    // _getCenterLayerPoint: function () {
    //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    // },
    /**
     * Offset of the specified place to the current center in pixels
     * 
     * @param {L.LatLng} latlng map coordinates
     */
    _getCenterOffset: function(d) {
      var f = u._getCenterOffset.apply(this, arguments);
      return this._rotate && (f = f.rotate(this._bearing)), f;
    },
    /**
     * @since leaflet-rotate (v0.1)
     */
    _getRotatePanePos: function() {
      return this._rotatePanePos || new L.Point(0, 0);
    },
    // _latLngToNewLayerPoint(latlng, zoom, center) {
    //    const topLeft = this._getNewPixelOrigin(center, zoom);
    //    return this.project(latlng, zoom)._subtract(topLeft);
    //},
    _getNewPixelOrigin: function(d, f) {
      if (!this._rotate)
        return u._getNewPixelOrigin.apply(this, arguments);
      var m = this.getSize()._divideBy(2);
      return this.project(d, f).rotate(this._bearing)._subtract(m)._add(this._getMapPanePos())._add(this._getRotatePanePos()).rotate(-this._bearing)._round();
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\tile\GridLayer::_getTiledPixelBounds()
     */
    _getNewPixelBounds: function(d, f) {
      if (d = d || this.getCenter(), f = f || this.getZoom(), !this._rotate && u._getNewPixelBounds)
        return u._getNewPixelBounds.apply(this, arguments);
      var m = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(), g = this.getZoomScale(m, f), v = this.project(d, f).floor(), x = this.getSize(), S = new L.Bounds([
        this.containerPointToLayerPoint([0, 0]).floor(),
        this.containerPointToLayerPoint([x.x, 0]).floor(),
        this.containerPointToLayerPoint([0, x.y]).floor(),
        this.containerPointToLayerPoint([x.x, x.y]).floor()
      ]).getSize().divideBy(g * 2);
      return new L.Bounds(v.subtract(S), v.add(S));
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @return {L.Point} map pivot point (center)
     */
    _getPixelCenter: function() {
      return !this._rotate && u._getPixelCenter ? u._getPixelCenter.apply(this, arguments) : this.getSize()._divideBy(2)._subtract(this._getMapPanePos());
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\vector\Renderer::_update()
     */
    _getPaddedPixelBounds: function(d) {
      if (!this._rotate && u._getPaddedPixelBounds)
        return u._getPaddedPixelBounds.apply(this, arguments);
      var f = d, m = this.getSize(), g = m.multiplyBy(-f), v = m.multiplyBy(1 + f);
      return new L.Bounds([
        this.containerPointToLayerPoint([g.x, g.y]).floor(),
        this.containerPointToLayerPoint([g.x, v.y]).floor(),
        this.containerPointToLayerPoint([v.x, g.y]).floor(),
        this.containerPointToLayerPoint([v.x, v.y]).floor()
      ]);
    },
    _handleGeolocationResponse: function(d) {
      if (this._container._leaflet_id) {
        var f = d.coords.latitude, m = d.coords.longitude, g = d.coords.heading, v = new L.LatLng(f, m), x = v.toBounds(d.coords.accuracy), S = this._locateOptions;
        if (S.setView) {
          var A = this.getBoundsZoom(x);
          this.setView(v, S.maxZoom ? Math.min(A, S.maxZoom) : A);
        }
        var p = {
          latlng: v,
          bounds: x,
          timestamp: d.timestamp,
          /** @TODO use mapProto._handleGeolocationResponse */
          heading: g
        };
        for (var y in d.coords)
          typeof d.coords[y] == "number" && (p[y] = d.coords[y]);
        this.fire("locationfound", p);
      }
    }
    /**
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264
     * 
     * @param {L.Bounds} points 
     * @returns {L.Bounds}
     */
    // toCircumscribedBounds(points) {
    //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),
    //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),
    //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),
    //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);
    //
    //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));
    // },
  }), L.Map.CompassBearing = L.Handler.extend({
    initialize: function(d) {
      this._map = d, "ondeviceorientationabsolute" in window ? this.__deviceOrientationEvent = "deviceorientationabsolute" : "ondeviceorientation" in window && (this.__deviceOrientationEvent = "deviceorientation"), this._throttled = L.Util.throttle(this._onDeviceOrientation, 100, this);
    },
    addHooks: function() {
      this._map._rotate && this.__deviceOrientationEvent ? L.DomEvent.on(window, this.__deviceOrientationEvent, this._throttled, this) : this.disable();
    },
    removeHooks: function() {
      this._map._rotate && this.__deviceOrientationEvent && L.DomEvent.off(window, this.__deviceOrientationEvent, this._throttled, this);
    },
    /**
     * `DeviceOrientationEvent.absolute` - Indicates whether the device is providing absolute
     *                                     orientation values (relatives to Magnetic North) or
     *                                     using some arbitrary frame determined by the device.
     * 
     * `DeviceOrientationEvent.alpha`    - Returns the rotation of the device around the Z axis;
     *                                     that is, the number of degrees by which the device is
     *                                     being twisted around the center of the screen.
     * 
     * `window.orientation`              - Returns the screen orientation in degrees (in 90-degree increments)
     *                                     of the viewport relative to the device's natural orientation.
     *                                     Its only possible values are -90, 0, 90, and 180. Positive
     *                                     values are counterclockwise; negative values are clockwise.
     * 
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/alpha
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation
     */
    _onDeviceOrientation: function(d) {
      var f = d.webkitCompassHeading || d.alpha, m = 0;
      !d.absolute && d.webkitCompassHeading && (f = 360 - f), !d.absolute && typeof window.orientation < "u" && (m = window.orientation), this._map.setBearing(f - m);
    }
  }), L.Map.addInitHook("addHandler", "compassBearing", L.Map.CompassBearing), L.Map.mergeOptions({
    /**
     * Whether the map uses mutation observers to
     * detect changes in its container and trigger
     * `invalidateSize`. Disabled by default due to
     * support not being available in all web browsers.
     *
     * @type {Boolean}
     * 
     * @see https://developer.mozilla.org/docs/Web/API/MutationObserver
     */
    trackContainerMutation: !1
  }), L.Map.ContainerMutation = L.Handler.extend({
    addHooks: function() {
      this._observer || (this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map))), this._observer.observe(this._map.getContainer(), {
        childList: !1,
        attributes: !0,
        characterData: !1,
        subtree: !1,
        attributeFilter: ["style"]
      });
    },
    removeHooks: function() {
      this._observer.disconnect();
    }
  }), L.Map.addInitHook("addHandler", "trackContainerMutation", L.Map.ContainerMutation), L.Map.mergeOptions({
    /**
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: !0,
    /**
     * Set a minimum bearing value (rotate threshold) to
     * prevent map from rotating when user just wants to
     * zoom.  
     * 
     * @type { number | undefined }
     */
    touchRotateIntertia: 0
  }), L.Map.TouchGestures = L.Handler.extend({
    initialize: function(d) {
      this._map = d, this.rotate = !!this._map.options.touchRotate, this.zoom = !!this._map.options.touchZoom;
    },
    addHooks: function() {
      L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
    },
    _onTouchStart: function(d) {
      var f = this._map;
      if (!(!d.touches || d.touches.length !== 2 || f._animatingZoom || this._zooming || this._rotating)) {
        var m = f.mouseEventToContainerPoint(d.touches[0]), g = f.mouseEventToContainerPoint(d.touches[1]), v = m.subtract(g);
        this._centerPoint = f.getSize()._divideBy(2), this._startLatLng = f.containerPointToLatLng(this._centerPoint), this._center = this._startLatLng, this.zoom ? (f.options.touchZoom !== "center" && (this._pinchStartLatLng = f.containerPointToLatLng(m.add(g)._divideBy(2))), this._startDist = m.distanceTo(g), this._startZoom = f.getZoom(), this._zooming = !0) : this._zooming = !1, this.rotate ? (this._startTheta = Math.atan(v.x / v.y), this._startBearing = f.getBearing(), v.y < 0 && (this._startBearing += 180), this._rotating = !0) : this._rotating = !1, this._moved = !1, f._stop(), L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend touchcancel", this._onTouchEnd, this), L.DomEvent.preventDefault(d);
      }
    },
    _onTouchMove: function(d) {
      if (!(!d.touches || d.touches.length !== 2 || !(this._zooming || this._rotating))) {
        var f = this._map, m = f.mouseEventToContainerPoint(d.touches[0]), g = f.mouseEventToContainerPoint(d.touches[1]), v = m.subtract(g), x = m.distanceTo(g) / this._startDist, S, A;
        if (this._rotating) {
          var p = Math.atan(v.x / v.y), y = (p - this._startTheta) * L.DomUtil.RAD_TO_DEG;
          v.y < 0 && (y += 180), Math.abs(y) > this._map.options.touchRotateInertia && f.setBearing(this._startBearing - y);
        }
        if (this._zooming) {
          if (this._zoom = f.getScaleZoom(x, this._startZoom), !f.options.bounceAtZoomLimits && (this._zoom < f.getMinZoom() && x < 1 || this._zoom > f.getMaxZoom() && x > 1) && (this._zoom = f._limitZoom(this._zoom)), f.options.touchZoom === "center") {
            if (this._center = this._startLatLng, x === 1)
              return;
          } else {
            if (S = m._add(g)._divideBy(2)._subtract(this._centerPoint), x === 1 && S.x === 0 && S.y === 0)
              return;
            var w = -f.getBearing() * L.DomUtil.DEG_TO_RAD;
            this._center = f.unproject(f.project(this._pinchStartLatLng).subtract(S.rotate(w)));
          }
          A = !0;
        }
        this._moved || (f._moveStart(!0, !1), this._moved = !0), L.Util.cancelAnimFrame(this._animRequest), this._animZoomRequest && L.Util.cancelAnimFrame(this._animZoomRequest);
        var C = f._move.bind(f, this._center, this._zoom, { pinch: !0, round: !1 });
        if (this._animRequest = L.Util.requestAnimFrame(C, this, !0), A) {
          var P = f._animateZoomNoDelay.bind(f, this._center, this._map._limitZoom(this._zoom), !0);
          this._animZoomRequest = L.Util.requestAnimFrame(P, this, !0);
        } else
          this._animZoomRequest = null;
        L.DomEvent.preventDefault(d);
      }
    },
    _onTouchEnd: function() {
      if (!this._moved || !(this._zooming || this._rotating)) {
        this._zooming = !1;
        return;
      }
      this._zooming = !1, this._rotating = !1, L.Util.cancelAnimFrame(this._animRequest), L.Util.cancelAnimFrame(this._animZoomRequest), L.DomEvent.off(document, "touchmove", this._onTouchMove, this).off(document, "touchend touchcancel", this._onTouchEnd, this), this.zoom && (this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._animateZoomNoDelay(this._center, this._map._limitZoom(this._zoom), !0));
    }
  }), L.Map.addInitHook("addHandler", "touchGestures", L.Map.TouchGestures), L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with a two-finger rotation gesture
     * 
     * @type {Boolean}
     */
    touchRotate: !1
  }), L.Map.TouchRotate = L.Handler.extend({
    addHooks: function() {
      this._map.touchGestures.enable(), this._map.touchGestures.rotate = !0;
    },
    removeHooks: function() {
      this._map.touchGestures.rotate = !1;
    }
  }), L.Map.addInitHook("addHandler", "touchRotate", L.Map.TouchRotate), L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with shift + wheel scroll
     * @type {Boolean}
     */
    shiftKeyRotate: !0
  }), L.Map.ShiftKeyRotate = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, "wheel", this._handleShiftScroll, this), this._map.shiftKeyRotate.rotate = !0;
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "wheel", this._handleShiftScroll, this), this._map.shiftKeyRotate.rotate = !1;
    },
    _handleShiftScroll: function(d) {
      d.shiftKey ? (d.preventDefault(), this._map.scrollWheelZoom.disable(), this._map.setBearing(this._map._bearing * L.DomUtil.RAD_TO_DEG + Math.sign(d.deltaY) * 5)) : this._map.scrollWheelZoom.enable();
    }
  }), L.Map.addInitHook("addHandler", "shiftKeyRotate", L.Map.ShiftKeyRotate), L.Map.addInitHook(function() {
    this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled() && (this.scrollWheelZoom.disable(), this.scrollWheelZoom.enable());
  }), L.Map.mergeOptions({
    /**
     * Whether the map can be zoomed by touch-dragging
     * with two fingers. If passed `'center'`, it will
     * zoom to the center of the view regardless of
     * where the touch events (fingers) were. Enabled
     * for touch-capable web browsers.
     * 
     * @type {(Boolean|String)}
     */
    touchZoom: L.Browser.touch,
    /**
     * @TODO check if this is a duplicate of `L.Map.TouchGestures::bounceAtZoomLimits`
     * 
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: !1
  }), L.Map.TouchZoom = L.Handler.extend({
    addHooks: function() {
      this._map._handlers.forEach((d) => {
        typeof d._onTouchMove == "function" && d.disable();
      }), L.DomUtil.addClass(this._map._container, "leaflet-touch-zoom"), this._map.touchGestures.enable(), this._map.touchGestures.zoom = !0;
    },
    removeHooks: function() {
      L.DomUtil.removeClass(this._map._container, "leaflet-touch-zoom"), this._map.touchGestures.zoom = !1;
    }
  }), L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom), L.Control.Rotate = L.Control.extend({
    options: {
      position: "topleft",
      closeOnZeroBearing: !0
    },
    onAdd: function(d) {
      var f = this._container = L.DomUtil.create("div", "leaflet-control-rotate leaflet-bar"), m = this._arrow = L.DomUtil.create("span", "leaflet-control-rotate-arrow");
      m.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")`, m.style.cursor = "grab", m.style.display = "block", m.style.width = "100%", m.style.height = "100%", m.style.backgroundRepeat = "no-repeat", m.style.backgroundPosition = "50%";
      var g = this._link = L.DomUtil.create("a", "leaflet-control-rotate-toggle", f);
      return g.appendChild(m), g.href = "#", g.title = "Rotate map", L.DomEvent.on(g, "dblclick", L.DomEvent.stopPropagation).on(g, "mousedown", this._handleMouseDown, this).on(g, "click", L.DomEvent.stop).on(g, "click", this._cycleState, this).on(g, "click", this._refocusOnMap, this), L.Browser.any3d || L.DomUtil.addClass(g, "leaflet-disabled"), this._restyle(), d.on("rotate", this._restyle, this), this._follow = !1, this._canFollow = !1, this.options.closeOnZeroBearing && d.getBearing() === 0 && (f.style.display = "none"), f;
    },
    onRemove: function(d) {
      d.off("rotate", this._restyle, this);
    },
    _handleMouseDown: function(d) {
      L.DomEvent.stop(d), this.dragging = !0, this.dragstartX = d.pageX, this.dragstartY = d.pageY, L.DomEvent.on(document, "mousemove", this._handleMouseDrag, this).on(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseUp: function(d) {
      L.DomEvent.stop(d), this.dragging = !1, L.DomEvent.off(document, "mousemove", this._handleMouseDrag, this).off(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseDrag: function(d) {
      if (this.dragging) {
        var f = d.clientX - this.dragstartX;
        this._map.setBearing(f);
      }
    },
    _cycleState: function(d) {
      if (this._map) {
        var f = this._map;
        !f.touchRotate.enabled() && !f.compassBearing.enabled() ? f.touchRotate.enable() : f.compassBearing.enabled() ? (f.compassBearing.disable(), f.setBearing(0), this.options.closeOnZeroBearing && f.touchRotate.enable()) : (f.touchRotate.disable(), (DeviceOrientationEvent && DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission() : Promise.resolve("granted")).then((m) => m === "granted" && f.compassBearing.enable())), this._restyle();
      }
    },
    _restyle: function() {
      if (!this._map.options.rotate)
        L.DomUtil.addClass(this._link, "leaflet-disabled");
      else {
        var d = this._map, f = d.getBearing();
        this._arrow.style.transform = "rotate(" + f + "deg)", f && this.options.closeOnZeroBearing && (this._container.style.display = "block"), d.compassBearing.enabled() ? this._link.style.backgroundColor = "orange" : d.touchRotate.enabled() ? this._link.style.backgroundColor = null : (this._link.style.backgroundColor = "grey", f === 0 && this.options.closeOnZeroBearing && (this._container.style.display = "none"));
      }
    }
  }), L.control.rotate = function(d) {
    return new L.Control.Rotate(d);
  }, L.Map.mergeOptions({
    rotateControl: !0
  }), L.Map.addInitHook(function() {
    if (this.options.rotateControl) {
      var d = typeof this.options.rotateControl == "object" ? this.options.rotateControl : {};
      this.rotateControl = L.control.rotate(d), this.addControl(this.rotateControl);
    }
  });
});
B.Map.mergeOptions({
  // Deactivate by default
  boxSelection: !1,
  // If active deactivate default box zoom as it will conflict
  // boxZoom: false,
  boxSelectionKey: "shiftKey"
});
const C0 = B.Handler.extend({
  initialize: function(e) {
    this._map = e, this._boxSelectionKey = e.options.boxSelectionKey, this._container = e._container, this._pane = e._panes.overlayPane, this._resetStateTimeout = 0, e.on("unload", this._destroy, this);
  },
  addHooks: function() {
    B.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
  },
  removeHooks: function() {
    B.DomEvent.off(this._container, "mousedown", this._onMouseDown, this);
  },
  moved: function() {
    return this._moved;
  },
  _destroy: function() {
    B.DomUtil.remove(this._pane), delete this._pane;
  },
  _resetState: function() {
    this._resetStateTimeout = 0, this._moved = !1;
  },
  _clearDeferredResetState: function() {
    this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
  },
  _onMouseDown: function(e) {
    if (!e[this._boxSelectionKey] || e.which !== 1 && e.button !== 1)
      return !1;
    this._clearDeferredResetState(), this._resetState(), B.DomUtil.disableTextSelection(), B.DomUtil.disableImageDrag(), this._startPoint = this._map.mouseEventToContainerPoint(e), B.DomEvent.on(document, {
      contextmenu: B.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseMove: function(e) {
    this._moved || (this._moved = !0, this._box = B.DomUtil.create("div", "leaflet-zoom-box", this._container), B.DomUtil.addClass(this._container, "leaflet-crosshair"), this._map.fire("boxselectionstart", Object.assign(e, { containerPoint: this._startPoint }))), this._point = this._map.mouseEventToContainerPoint(e);
    const t = new B.Bounds(this._point, this._startPoint), i = t.getSize();
    B.DomUtil.setPosition(this._box, t.min), this._box.style.width = i.x + "px", this._box.style.height = i.y + "px";
  },
  _finish: function() {
    this._moved && (B.DomUtil.remove(this._box), B.DomUtil.removeClass(this._container, "leaflet-crosshair")), B.DomUtil.enableTextSelection(), B.DomUtil.enableImageDrag(), B.DomEvent.off(document, {
      contextmenu: B.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseUp: function(e) {
    if (e.which !== 1 && e.button !== 1 || (this._finish(), !this._moved))
      return;
    this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(B.Util.bind(this._resetState, this), 0);
    const t = new B.LatLngBounds(
      this._map.containerPointToLatLng(this._startPoint),
      this._map.containerPointToLatLng(this._point)
    );
    this._map.fire("boxselectionend", Object.assign(e, { bounds: t, containerPoint: this._map.mouseEventToContainerPoint(e) }));
  },
  _onKeyDown: function(e) {
    e.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
  }
});
B.Map.addInitHook("addHandler", "boxSelection", C0);
const T0 = B.Icon.extend({
  options: {
    fillColor: "#2B85C7",
    pointRadius: 8,
    pointStroke: "#010101",
    strokeColor: "#010101",
    strokeWidth: 2,
    strokeLength: 15,
    barbSpaceing: 5,
    barbHeight: 15,
    forceDir: !1
  },
  initialize: function(e) {
    e = B.Util.setOptions(this, e);
  },
  createIcon: function() {
    const e = document.createElement("div"), t = this._createPoint();
    return e.appendChild(t), this._setIconStyles(e), e;
  },
  _createPoint: function() {
    const e = this.options.pointStroke, t = this.options.strokeWidth, i = this.options.pointRadius, n = this.options.fillColor, r = 2 * t + 2 * i, s = r, o = "http://www.w3.org/2000/svg", l = document.createElementNS(o, "svg");
    l.setAttributeNS(null, "width", r), l.setAttributeNS(null, "height", s);
    const c = document.createElementNS(o, "circle");
    return c.setAttributeNS(null, "stroke", e), c.setAttributeNS(null, "stroke-width", t), c.setAttributeNS(null, "fill", n), c.setAttributeNS(null, "cx", r / 2), c.setAttributeNS(null, "cy", s / 2), c.setAttributeNS(null, "r", i), l.appendChild(c), l;
  },
  _createBarbs: function(e) {
    let t = e / 0.514;
    const i = { 5: 0, 10: 0, 50: 0 }, n = this.options.barbSpaceing, r = this.options.barbHeight, s = this.options.pointRadius, o = this.options.strokeColor, l = this.options.strokeWidth, c = this.options.strokeLength, u = this.options.forceDir, d = "http://www.w3.org/2000/svg", f = document.createElementNS(d, "svg"), m = document.createElementNS(d, "g");
    t = t % 5 >= 2.5 ? parseInt(t / 5) * 5 + 5 : parseInt(t / 5) * 5;
    for (let F = t; F > 0; )
      if (F - 50 >= 0)
        i[50] += 1, F -= 50;
      else if (F - 10 >= 0)
        i[10] += 1, F -= 10;
      else if (F - 5 >= 0)
        i[5] += 1, F -= 5;
      else
        break;
    const g = i[5] + i[10] + i[50];
    let v;
    g === 0 ? v = 0 : (v = g * n, (i[5] === 1 && i[10] > 0 || i[5] === 1 && i[50] > 0) && (v -= n), i[50] > 0 && (v += 3 * i[50] * n));
    const x = Math.round(Math.sqrt(r * r + v * v)) + 2, S = s * 2 + l * 2 + 2 * (v + c) + 2 * x, A = S, p = S / 2, y = A / 2;
    f.setAttributeNS(null, "width", S), f.setAttributeNS(null, "height", A), f.appendChild(m);
    let w, C, P, M, z, D, T;
    if (u === !0 && (w = p - s - l * 0.5, C = y, M = w + "," + C, z = w - c, P = z - 2 * n, T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " H " + z), m.appendChild(T), w = z), g !== 0) {
      if (u !== !0 && (w = p - s - l * 0.5, C = y, M = w + "," + C, z = w - c, P = z - 2 * n, T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " H " + z), m.appendChild(T), w = z), i[5] === 1) {
        const F = Math.sqrt(2 * n * (2 * n) + r * r), k = Math.atan(r / (2 * n)), O = F / 2;
        M = w + "," + C, D = w - O * Math.cos(k) + "," + (y - r * 0.5), T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " L " + D), m.appendChild(T), i[10] === 0 && i[50] === 0 && (w -= n, z = w, T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " H " + z), m.appendChild(T));
      }
      for (let F = 0; F < i[10]; F++)
        M = w + "," + C, w -= n, z = w, T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " H " + z), m.appendChild(T), M = z + "," + y, P -= n, D = P + "," + (y - r), T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " L " + D), m.appendChild(T);
      if (i[50] > 0) {
        M = w + "," + C, w -= n, z = w, T = document.createElementNS(d, "path"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "stroke-linecap", "butt"), T.setAttributeNS(null, "d", "M " + M + " H " + z), m.appendChild(T);
        for (let F = 0; F < i[50]; F++) {
          P -= n;
          const k = w + "," + y, O = P + "," + (y - r), $ = P + "," + y;
          T = document.createElementNS(d, "polygon"), T.setAttributeNS(null, "stroke", o), T.setAttributeNS(null, "stroke-width", l), T.setAttributeNS(null, "fill", "#000000"), T.setAttributeNS(null, "points", k + " " + O + " " + $), m.appendChild(T), w -= 2 * n, P -= n;
        }
      }
    }
    return { ax: p, ay: y, svg: f };
  },
  _setIconStyles: function(e, t, i) {
    let n;
    const r = this.options, s = B.point(r[t === "shadow" ? "shadowSize" : "iconSize"]), o = this.options.strokeWidth, l = this.options.pointRadius;
    if (t === "shadow")
      n = i, e.style.width = n.x + "px", e.style.height = n.y + "px";
    else {
      e.style.position = "absolute";
      const c = 2 * o + 2 * l, u = c, d = c / 2, f = u / 2;
      n = B.point([d, f]);
    }
    !n && s && (n = s.divideBy(2, !0)), n && (e.style.marginLeft = -n.x + "px", e.style.marginTop = -n.y + "px"), s && (e.style.width = s.x + "px", e.style.height = s.y + "px");
  },
  createShadow: function() {
    const e = this.options.deg + 90, t = this.options.speed, i = this._createBarbs(t), n = document.createElement("div");
    this.options.mirrorVel ? (i.svg.style.transform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.MozTransform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.webkitTransform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.msTransform = "rotate(" + e + "deg) scaleY(-1)") : (i.svg.style.transform = "rotate(" + e + "deg)", i.svg.style.MozTransform = "rotate(" + e + "deg)", i.svg.style.webkitTransform = "rotate(" + e + "deg)", i.svg.style.msTransform = "rotate(" + e + "deg)"), n.appendChild(i.svg);
    const r = { x: i.ax, y: i.ay };
    return this._setIconStyles(n, "shadow", r), n;
  }
});
B.WindBarb = {};
B.WindBarb.version = "0.0.5";
B.WindBarb.Icon = T0;
B.WindBarb.icon = function(e) {
  return new B.WindBarb.Icon(e);
};
const P0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=", M0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7cua5gzeKg8hJo3grY4g7c3grU0gLI2frE0daAubJc2gbQwd6QzeKk2gLMtd5sxdKIua5g1frA2f7IydaM0e6w2fq41fK01eqo3grgubJgta5cxdKI1f7AydaQydaMxc6EubJgvbJkwcZ4ubZkwcJwubZgubJcydqUydKIxapgubJctbJcubZcubJcvbJYubJcvbZkubJctbJctbZcubJg2f7AubJcrbZcubJcubJcua5g3grY0fq8ubJcubJdEkdEwhsw6i88vhswuhcsuhMtBjMgthMsrg8srgss6is8qgcs8i9A9iMYtg8spgcoogMo7hcMngMonf8olfso4gr8kfck5iM8jfMk4iM8he8k1fro7itAgesk2hs8eecgzfLcofssdeMg0hc4cd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqhUndROmdM1fK0wcZ8vb5w0eqpQm9MzeKhXoNVcpdYydKNWn9VZotVKltJFjsIwcJ1Rms9OlslLmtH///8+kc9epdYzd6dbo9VHkMM2f7FHmNBClM8ydqVcpNY9hro3gLM9hLczealQmcw3fa46f7A8gLMxc6I3eagyc6FIldJMl9JSnNRSntNNl9JPnNJFi75UnM9ZodVKksg8kM45jc09e6ZHltFBk883gbRBh7pDk9EwcaBzn784g7dKkcY2i81Om9M7j85Llc81is09g7Q4grY/j9A0eqxKmdFFltBEjcXf6fFImdBCiLxJl9FGlNFBi78yiMxVndEvbpo6js74+vx+psPP3+o/ks5HkcpGmNCjwdZCkNDM3ehYoNJEls+lxNkxh8xHks0+jdC1zd5Lg6r+/v/H2ufz9/o3jM3t8/edvdM/k89Th61OiLBSjbZklbaTt9BfptdjmL1AicBHj8hGk9FAgK1dkLNTjLRekrdClc/k7fM0icy0y9tgp9c4jc2NtM9Dlc8zicxeXZn3AAAAQ3RSTlMAHDdTb4yPA+LtnEQmC4L2EmHqB7XA0d0sr478x4/Yd5i1zOfyPkf1sLVq4Nh3FvjxopQ2/STNuFzUwFIwxKaejILpIBEV9wAABhVJREFUeF6s1NdyFEcYBeBeoQIhRAkLlRDGrhIgY3BJL8CVeKzuyXFzzjkn5ZxzzuScg3PO8cKzu70JkO0LfxdTU//pM9vTu7Xgf6KqOVTb9X7toRrVEfBf1HTVjZccrT/2by1VV928Yty9ZbVuucdz90frG8DBjl9pVApbOstvmMuvVgaNXSfAAd6pGxpy6yxf5ph43pS/4f3uoaGm2rdu72S9xzOvMymkZFq/ptDrk90mhW7e4zl7HLzhxGWPR20xmSxJ/VqldG5m9XhaVOA1DadsNh3Pu5L2N6QtPO/32JpqQBVVk20oy/Pi2s23WEvyfHbe1thadVQttvm7Llf65gGmXK67XtupyoM7HQhmXdLS8oGWJNeOJ3C5fG5XCEJnkez3/oFdsvgJ4l2ANZwhrJKk/7OSXa+3Vw2WJMlKnGkobouYk6T0TyX30klOUnTD9HJ5qpckL3EW/w4XF3Xd0FGywXUrstrclVsqz5Pd/sXFYyDnPdrLcQODmGOK47IZb4CmibmMn+MYRzFZ5jg33ZL/EJrWcszHmANy3ARBK/IXtciJy8VsitPSdE3uuHxzougojcUdr8/32atnz/ev3f/K5wtpxUTpcaI45zusVDpYtZi+jg0oU9b3x74h7+n9ABvYEZeKaVq0sh0AtLKsFtqNBdeT0MrSzwwlq9+x6xAO4tgOtSzbCjrNQQiNvQUbUEubvzBUeGw26yDCsRHCoLkTHDa7IdOLIThs/gHvChszh2CimE8peRs47cxANI0lYNB5y1DljpOF0IhzBDPOZnDOqYYbeGKECbPzWnXludPphw5c2YBq5zlwXphIbO4VDCZ0gnPfUO1TwZoYwAs2ExPCedAu9DAjfQUjzITQb3jNj0KG2Sgt6BHaQUdYzWz+XmBktOHwanXjaSTcwwziBcuMOtwBmqPrTOxFQR/DRKKPqyur0aiW6cULYsx6tBm0jXpR/AUWR6HRq9WVW6MRhIq5jLyjbaCTDCijyYJNpCajdyobP/eTw0iexBAKkJ3gA5KcQb2zBXsIBckn+xVv8jkZSaEFHE+jFEleAEfayRU0MouNoBmB/L50Ai/HSLIHxcrpCvnhSQAuakKp2C/YbCylJjXRVy/z3+Kv/RrNcCo+WUzlVEhzKffnTQnxeN9fWF88fiNCUdSTsaufaChKWInHeysygfpIqagoakW+vV20J8uyl6TyNKEZWV4oRSPyCkWpgOLSbkCObT8o2r6tlG58HQquf6O0v50tB7JM7F4EORd2dx/K0w/KHsVkLPaoYrwgP/y7krr3SSMA4zj+OBgmjYkxcdIJQyQRKgg2viX9Hddi9UBb29LrKR7CVVEEEXWojUkXNyfTNDE14W9gbHJNuhjDettN3ZvbOvdOqCD3Jp/9l+/wJE+9PkYGjx/fqkys3S2rMozM/o2106rfMUINo6hVqz+eu/hd1c4xTg0TAfy5kV+4UG6+IthHTU9woWmxuKNbTfuCSfovBCxq7EtHqvYL4Sm6F8GVxsSXHMQ07TOi1DKtZxjWaaIyi4CXWjxPccUw8WVbMYY5wxC1mzEyXMJWkllpRloi+Kkoq69sxBTlElF6aAxYUbjXNlhlDZilDnM4U5SlN5biRsRHnbx3mbeWjEh4mEyiuJDl5XcWVmX5GvNkFgLWZM5qwsop4/AWfLhU1cR7k1VVvcYCWRkOI6Xy5gmnphCYIkvzuNYzHzosq2oNk2RtSs8khfUOfHIDgR6ysYBaMpl4uEgk2U/oJTs9AaTSwma7dT69geAE2ZpEjUsn2ieJNHeKfrI3EcAGJ2ZaNgVuC8EBctCLc57P5u5led6IOBkIYkuQMrmmjChs4VkfOerHqSBkPzZlhe06RslZ3zMjk2sscqKwY0RcjKK+LWbzd7KiHhkncs/siFJ+V5eXxD34B8nVuJEpGJNmxN2gH3vSvp7J70tF+D1Ej8qUJD1TkErAND2GZwTFg/LubvmgiBG3SOvdlsqFQrkEzJCL1rstlnVFROixZoDDSuXQFHESwVGlcuQcMb/b42NgjLowh5MTDFE3vNB5qStRIErdCQEh6pLPR92anSUb/wAIhldAaDMpGgAAAABJRU5ErkJggg==", k0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
window.nezasa = { iso8601: $l };
delete B.Icon.Default.prototype._getIconUrl;
B.Icon.Default.mergeOptions({
  iconUrl: P0,
  iconRetinaUrl: M0,
  shadowUrl: k0
});
B.PM.setOptIn(!0);
const F0 = B.GridLayer.prototype._getTiledPixelBounds;
B.GridLayer.include({
  _getTiledPixelBounds: function(e) {
    let t = F0.call(this, e);
    const i = this.options.edgeBufferTiles;
    if (i > 0) {
      const n = B.GridLayer.prototype.getTileSize.call(this).multiplyBy(i);
      t = new B.Bounds(t.min.subtract(n), t.max.add(n));
    }
    return t;
  }
});
const D0 = B.Map.prototype._createRenderer;
B.Map.include({
  _createRenderer: function(e) {
    return D0.call(this, Object.assign(a.get(this.options, "rendererOptions", {}), e));
  }
});
const A0 = {
  emits: [
    "map-ready",
    "layer-added",
    "layer-removed",
    "layer-shown",
    "layer-hidden",
    "layer-enabled",
    "layer-disabled",
    "pane-added",
    "pane-removed",
    "pane-shown",
    "pane-hidden"
  ],
  data() {
    return {
      layers: {},
      orphanLayers: []
    };
  },
  methods: {
    refreshMap() {
      this.map && this.map.invalidateSize();
    },
    setupMap(e, t = {}) {
      const i = a.defaults(t, a.get(this, "activityOptions.engine.viewer", {}), {
        minZoom: 3,
        maxZoom: 21,
        center: [47, 3],
        zoom: 6,
        maxBounds: [[-90, -180], [90, 180]],
        maxBoundsViscosity: 0.25,
        scale: !0,
        geolocate: !0,
        rotateControl: !1
        // Rotate plugin show this even if rotation is disabled
      });
      this.map = B.map(e, Object.assign({ zoomControl: !1 }, i));
      const n = a.get(i, "backgroundColor");
      n && (this.map._container.style.backgroundColor = n), this.map.pm === void 0 && (this.map.options.pmIgnore = !1, B.PM.reInitLayer(this.map), this.map.pm.setLang(Dt())), B.DomEvent.on(this.map._container, Ln.join(" "), this.onTouchEvent, this), kt(this.map, Zt.Map, this, i);
      const r = a.get(i, "scale", !0);
      r && this.setupScaleControl(r);
      const s = a.get(i, "geolocate", !0);
      s && this.setupGeolocateControl(s);
      const o = this.map.createPane("kdk-hidden-features");
      o.style.display = "none", this.onMapReady();
    },
    convertTouches(e) {
      const t = [];
      if (e && e.length)
        for (let i = 0; i < e.length; i++) {
          const n = typeof e.item == "function" ? e.item(i) : e[i], r = {
            containerPoint: this.map.mouseEventToContainerPoint(n)
          };
          r.containerPoint && (r.layerPoint = this.map.containerPointToLayerPoint(r.containerPoint), r.latlng = this.map.layerPointToLatLng(r.layerPoint)), t.push(r);
        }
      return t;
    },
    onTouchEvent(e) {
      if (e.pointerType === "mouse") return;
      const n = {
        pointerdown: "touchstart",
        pointermove: "touchmove",
        pointerup: "touchend",
        pointercancel: "touchcancel"
      }[e.type] || e.type;
      let r = this.map._findEventTargets(e, n);
      if (!r.length) return;
      const s = this.convertTouches(e.touches), o = this.convertTouches(e.changedTouches), l = this.convertTouches(e.targetTouches);
      for (let c = 0; c < r.length; c++) {
        const u = r[c], d = {
          originalEvent: e,
          touches: s,
          changedTouches: o,
          targetTouches: l
        }, f = a.isEmpty(s) ? a.isEmpty(o) ? [] : o : s, m = u.getLatLng && (!u._radius || u._radius <= 10);
        if (d.containerPoint = m ? this.map.latLngToContainerPoint(u.getLatLng()) : a.get(f, "[0].containerPoint"), d.containerPoint && (d.layerPoint = this.map.containerPointToLayerPoint(d.containerPoint), d.latlng = m ? u.getLatLng() : this.map.layerPointToLatLng(d.layerPoint)), u.fire(n, d, !0), d.originalEvent._stopped) return;
      }
    },
    onMapReady() {
      this.$emit("map-ready", "leaflet"), this.$engineEvents.emit("map-ready", "leaflet");
    },
    setupScaleControl(e) {
      typeof e == "object" ? this.scaleControl = new B.control.graphicScale(e) : this.scaleControl = new B.control.scale(), this.scaleControl.addTo(this.map);
    },
    setupGeolocateControl() {
      this.locateControl = new B.control.locate({
        // eslint-disable-line
        locateOptions: {
          maxZoom: 16,
          watch: !1,
          setView: !1,
          timeout: 3e4,
          enableHighAccuracy: !0
        },
        strings: {
          title: this.$t("geolocation.TITLE"),
          metersUnit: this.$t("geolocation.METERS"),
          feetUnit: this.$t("geolocation.FEET"),
          popup: this.$t("geolocation.POPUP"),
          outsideMapBoundsMsg: this.$t("geolocation.OUTSIDE_MAP_BOUNDS")
        }
      }), this.locateControl.addTo(this.map), this.locateControl._container.style.display = "none";
    },
    processLeafletLayerOptions(e) {
      const t = a.cloneDeep(e), i = t.leaflet;
      return this.leafletObjectOptions.forEach((n) => {
        typeof a.get(i, n) == "string" && a.set(i, n, a.get(B, a.get(i, n)));
      }), a.has(i, "minZoom") && !a.isNumber(i.minZoom) && a.unset(i, "minZoom"), a.has(i, "maxZoom") && !a.isNumber(i.maxZoom) && a.unset(i, "maxZoom"), i.attribution = t.attribution, t;
    },
    getLeafletPaneName(e) {
      return typeof e == "object" ? e.name || e.zIndex.toString() : e.toString();
    },
    createLeafletPane(e) {
      const t = this.getLeafletPaneName(e);
      let i = this.map.getPane(t);
      if (!i) {
        let n;
        typeof e == "object" ? n = e.zIndex || 400 : typeof e == "number" && (n = e);
        let r = e.container;
        this.map._rotate && !r && (r = "rotatePane"), r = this.map.getPane(r), i = this.map.createPane(t, r), a.set(i, "style.zIndex", n || 400);
      }
      return this.leafletPanes[t] = i, this.onPaneAdded(t, i), i;
    },
    onPaneAdded(e, t) {
      this.$emit("pane-added", e, t), this.$engineEvents.emit("pane-added", e, t);
    },
    getLeafletPaneByName(e) {
      const t = e.toString();
      return this.leafletPanes[t];
    },
    removeLeafletPane(e) {
      const t = e.toString(), i = this.getLeafletPaneByName(t);
      i && (delete this.leafletPanes[t], this.onPaneRemoved(t, i));
    },
    onPaneRemoved(e, t) {
      this.$emit("pane-removed", e, t), this.$engineEvents.emit("pane-removed", e, t);
    },
    isPaneVisible(e) {
      const t = this.getLeafletPaneByName(e);
      return t && t.style.display === "block";
    },
    showPane(e) {
      const t = this.getLeafletPaneByName(e);
      !t || t.style.display === "block" || (t.style.display = "block", this.onPaneShown(e, t));
    },
    onPaneShown(e, t) {
      this.$emit("pane-shown", e, t), this.$engineEvents.emit("pane-shown", e, t);
    },
    hidePane(e) {
      const t = this.getLeafletPaneByName(e);
      !t || t.style.display === "none" || (t.style.display = "none", this.onPaneHidden(e, t));
    },
    onPaneHidden(e, t) {
      this.$emit("pane-hidden", e, t), this.$engineEvents.emit("pane-hidden", e, t);
    },
    updateLeafletPanesVisibility() {
      const e = Math.floor(this.map.getZoom());
      a.forOwn(this.leafletPanes, (t, i) => {
        const n = !!a.get(t, "minZoom"), r = !!a.get(t, "maxZoom");
        if (!(!n && !r)) {
          if (t.style || (t.style = {}), n && e < a.get(t, "minZoom")) {
            this.hidePane(i);
            return;
          }
          if (r && e > a.get(t, "maxZoom")) {
            this.hidePane(i);
            return;
          }
          this.showPane(i);
        }
      });
    },
    createLeafletLayer(e) {
      const t = e.name, i = e.leaflet || e, n = { name: t }, r = !!a.get(i, "minZoom"), s = !!a.get(i, "maxZoom"), o = !!a.get(i, "zIndex");
      r && (n.minZoom = a.get(i, "minZoom")), s && (n.maxZoom = a.get(i, "maxZoom")), o && (n.zIndex = a.get(i, "zIndex")), o && (this.createLeafletPane(n), a.has(i, "pane") || a.set(i, "pane", n.name));
      const l = a.get(i, "panes", []);
      l && l.forEach((f) => {
        const m = this.createLeafletPane(f);
        Object.assign(m, f);
      }), this.updateLeafletPanesVisibility();
      let c = a.get(i, "options", []);
      typeof c == "object" && (c = [c]);
      let u, d = i.type;
      if (i.source) {
        const f = i.source;
        delete i.source, u = a.get(B, d)(f, a.omit(i, ["options"]), ...c);
      } else
        u = a.get(B, d)(a.omit(i, ["options"]), ...c);
      return u;
    },
    registerLeafletConstructor(e) {
      this.leafletFactory.push(e);
    },
    async createLayer(e) {
      const t = this.processLeafletLayerOptions(e);
      let i;
      for (let n = 0; n < this.leafletFactory.length; n++) {
        const r = this.leafletFactory[n];
        if (i = await r(t), i) break;
      }
      return i || this.createLeafletLayer(t);
    },
    createLeafletTimedWmsLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tileLayer.wms" && t.type !== "TileLayer.wmsHeader") return;
      let i = this.createLeafletLayer(e);
      const n = a.get(t, "timeDimension");
      if (n) {
        a.set(n, "period", "P1D");
        const r = a.get(n, "times"), s = typeof r == "string" ? r.split("/") : [], o = typeof r == "string" ? r.split(",") : [];
        let l = [];
        a.isEmpty(o) ? s.length === 2 ? a.set(n, "times", `${r}/P1D`) : s.length === 3 && a.set(n, "period", s[2]) : (a.unset(n, "period"), l = a.sortBy(o.map((u) => he.utc(u)), (u) => u.valueOf()));
        const c = he.duration(a.get(n, "period"));
        i = this.createLeafletLayer({
          type: "timeDimension.layer.wms",
          source: i,
          timeDimension: B.timeDimension(n),
          currentTime: be.getCurrentTime().toDate().getTime()
        }), i.setCurrentTime = (u) => {
          i._timeDimension.setCurrentTime(u.toDate().getTime());
        }, i._createLayerForTime = (u) => {
          u = he.utc(u);
          const d = a.omit(i._baseLayer.options, ["timeDimension", "isVisible", "type"]);
          if (c.years() > 0)
            d.time = u.format("YYYY").toISOString();
          else if (c.months() > 0)
            d.time = u.format("YYYY-MM");
          else if (c.days() > 0)
            d.time = u.format("YYYY-MM-DD");
          else if (a.isEmpty(l))
            d.time = u.toISOString();
          else {
            const { index: m, difference: g } = jr(u, l, !0);
            m >= 0 ? d.time = o[m] : d.time = u.toISOString();
          }
          let f = a.get(t, "options", []);
          return typeof f == "object" && (f = [f]), new i._baseLayer.constructor(i._baseLayer.getURL(), d, ...f);
        };
      }
      return i;
    },
    hasLayer(e) {
      return a.has(this.layers, e);
    },
    isLayerVisible(e) {
      const t = this.getLeafletLayerByName(e);
      return t && this.map.hasLayer(t);
    },
    isLayerDisabled(e) {
      const t = a.get(e, "leaflet.minZoom"), i = a.get(e, "leaflet.maxZoom");
      let n = !1;
      return t && this.map.getZoom() < t && (n = !0), i && this.map.getZoom() > i && (n = !0), n;
    },
    updateLayerDisabled(e) {
      const t = e.isDisabled, i = this.isLayerDisabled(e);
      t !== i && (e.isDisabled = i, t ? this.onLayerEnabled(e) : this.onLayerDisabled(e));
    },
    onLayerEnabled(e) {
      this.$emit("layer-enabled", e), this.$engineEvents.emit("layer-enabled", e);
    },
    onLayerDisabled(e) {
      this.$emit("layer-disabled", e), this.$engineEvents.emit("layer-disabled", e);
    },
    getLayerByName(e) {
      return this.layers[e];
    },
    getOrphanLayerByName(e) {
      return this.orphanLayers.find((t) => t?.name === e);
    },
    getLeafletLayerByName(e) {
      return this.leafletLayers[e];
    },
    getLayerById(e) {
      const t = this.getLayers({ _id: e });
      return a.get(t, "[0]");
    },
    getLayers(e = {}) {
      return a.values(this.layers).filter(Te(e));
    },
    hasLayers(e = {}) {
      return a.values(this.layers).filter(Te(e)).length > 0;
    },
    async showLayer(e) {
      const t = this.getLayerByName(e);
      if (!t || this.isLayerVisible(e)) return;
      let i = this.getLeafletLayerByName(e);
      if (!i)
        try {
          i = await this.createLayer(t);
        } catch (n) {
          I.error(n);
          return;
        }
      this.leafletLayers[e] = i, this.map.addLayer(i), t.isVisible = !0, typeof i.setCurrentTime == "function" && i.setCurrentTime(be.getCurrentTime()), this.onLayerShown(t, i);
    },
    onLayerShown(e, t) {
      this.$emit("layer-shown", e, t), this.$engineEvents.emit("layer-shown", e, t);
    },
    hideLayer(e) {
      if (!this.isLayerVisible(e)) return;
      const t = this.getLayerByName(e);
      if (!t) return;
      t.isVisible = !1;
      const i = this.leafletLayers[e];
      delete this.leafletLayers[e], this.map.removeLayer(i);
      const n = a.get(t, "leaflet.panes");
      n && n.forEach((r) => this.removeLeafletPane(r.name || r.zIndex)), this.onLayerHidden(t, i);
    },
    onLayerHidden(e, t) {
      this.$emit("layer-hidden", e, t), this.$engineEvents.emit("layer-hidden", e, t);
    },
    async addLayer(e) {
      return e && !this.hasLayer(e.name) && (e.isVisible = !1, e.isDisabled = this.isLayerDisabled(e), this.layers[e.name] = e, this.onLayerAdded(e), a.get(e, "leaflet.isVisible", !1) && await this.showLayer(e.name)), e;
    },
    onLayerAdded(e) {
      this.$emit("layer-added", e), this.$engineEvents.emit("layer-added", e);
    },
    async addGeoJsonLayer(e, t, i = !0) {
      Pd(e, t) && (await this.addLayer(e), await this.updateLayer(e.name, t), i && (t.bbox ? this.zoomToBBox(t.bbox) : this.zoomToLayer(e.name)));
    },
    renameLayer(e, t) {
      const i = this.getLayerByName(e), n = this.getLeafletLayerByName(e);
      i && (n && (this.leafletLayers[t] = n, delete this.leafletLayers[e]), this.layers[t] = i, delete this.layers[e]);
    },
    reorganizeLayers() {
      for (let e = this.layerCategories.length - 1; e >= 0; e--) {
        const t = this.layerCategories[e];
        if (t?.layers)
          for (let i = t.layers.length - 1; i >= 0; i--) {
            const n = t.layers[i];
            this.bringLayerToFront(n);
          }
      }
      for (let e = this.orphanLayers.length - 1; e >= 0; e--) {
        const t = this.orphanLayers[e];
        this.bringLayerToFront(t.name);
      }
    },
    removeLayer(e) {
      const t = this.getLayerByName(e);
      t && (this.hideLayer(e), delete this.layers[t.name], this.onLayerRemoved(t));
    },
    onLayerRemoved(e) {
      this.$emit("layer-removed", e), this.$engineEvents.emit("layer-removed", e);
    },
    clearLayers() {
      Object.keys(this.layers).forEach((e) => this.removeLayer(e));
    },
    toGeoJson(e) {
      if (!this.isLayerVisible(e)) {
        const i = this.geojsonCache[e];
        if (i) return i;
      }
      const t = this.getLeafletLayerByName(e);
      if (!(!t || typeof t.toGeoJSON != "function"))
        return t.toGeoJSON();
    },
    zoomToLayer(e, t) {
      const i = this.getLayerByName(e);
      if (!i) return;
      if (this.isLayerDisabled(i)) {
        const r = a.get(i, "leaflet.minZoom");
        if (r) {
          const s = this.getCenter();
          this.center(s.longitude, s.latitude, r);
          return;
        }
      }
      const n = a.get(i, "bbox");
      if (n)
        this.zoomToBBox(n);
      else {
        const r = this.getLeafletLayerByName(e);
        if (r)
          if (typeof r.getBounds == "function") {
            const s = r.getBounds();
            s.isValid() && this.map.fitBounds(s, t);
          } else {
            const s = a.get(i, "leaflet.bounds", this.map.options.maxBounds);
            this.zoomToBounds(s);
          }
      }
    },
    zoomToBounds(e) {
      this.map.fitBounds(e);
    },
    zoomToBBox(e) {
      this.zoomToBounds([[e[1], e[0]], [e[3], e[2]]]);
    },
    bringLayerToFront(e) {
      let t = this.getLeafletLayerByName(e);
      if (!t) return;
      const i = a.get(t, "options.panes");
      if (i) {
        i.forEach((n) => {
          const r = this.getLeafletPaneByName(this.getLeafletPaneName(n));
          r && B.DomUtil.toFront(r);
        });
        return;
      }
      if (t instanceof B.MarkerClusterGroup) {
        const n = t;
        t = t.getLayers().find((r) => r._container === n);
      }
      t && typeof t.bringToFront == "function" && t.bringToFront();
    },
    bringLayerToBack(e) {
      let t = this.getLeafletLayerByName(e);
      if (!t) return;
      const i = a.get(t, "options.panes");
      if (i) {
        i.forEach((n) => {
          const r = this.getLeafletPaneByName(this.getLeafletPaneName(n));
          r && B.DomUtil.toBack(r);
        });
        return;
      }
      if (t instanceof B.MarkerClusterGroup) {
        const n = t;
        t = t.getLayers().find((r) => r._container === n);
      }
      t && typeof t.bringToBack == "function" && t.bringToBack();
    },
    animateCenter(e) {
      this.centerAnimation.startTime || (this.centerAnimation.startTime = e);
      const {
        id: t,
        duration: i,
        startTime: n,
        fps: r,
        animate: { center: s, zoom: o, bearing: l },
        startLongitude: c,
        endLatitude: u,
        startLatitude: d,
        startZoom: f,
        startBearing: m,
        endLongitude: g,
        endZoom: v,
        endBearing: x
      } = this.centerAnimation, S = e - n;
      if (r && this.centerAnimation.lastTime) {
        const C = e - this.centerAnimation.lastTime, P = 1e3 / r;
        if (C < P) {
          this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
          return;
        }
      }
      const A = Math.abs(S / (1e3 * i));
      let p, y, w;
      if (A <= 1) {
        const C = this.getCenter();
        if (s) {
          const O = s.easing.function, $ = s.easing.parameters || [];
          p = cn[O](A, ...$);
        }
        if (o) {
          const O = o.easing.function, $ = o.easing.parameters || [];
          y = cn[O](A, ...$);
        }
        if (l) {
          const O = l.easing.function, $ = l.easing.parameters || [];
          w = cn[O](A, ...$);
        }
        const P = this.centerAnimation.offset, M = s && P && p * P.x || 0, z = s && P && p * P.y || 0;
        let D = C.longitude, T = C.latitude;
        if (s)
          if (s.rhumb) {
            const O = Nl(this.centerAnimation.rhumbStart, p * this.centerAnimation.rhumbDistance, this.centerAnimation.rhumbBearing);
            D = O.geometry.coordinates[0], T = O.geometry.coordinates[1];
          } else
            D = c + p * (g - c), T = d + p * (u - d);
        const F = o ? f + y * (v - f) : null;
        let k;
        if (!a.isNil(m)) {
          const O = (x - m + 540) % 360 - 180;
          k = l ? (m + w * O + 360) % 360 : null;
        }
        this.center(D, T, F, k, { offset: { x: Math.round(M), y: Math.round(z) }, bearingTolerance: this.centerAnimation.bearingTolerance }), this.centerAnimation.lastTime = e, this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
      } else
        this.centerAnimation.id = null;
    },
    center(e, t, i, n, r = {}) {
      const s = B.point(a.get(r, "offset.x", 0), a.get(r, "offset.y", 0));
      if (a.isNil(i) && (i = this.map.getZoom()), a.isNil(n) && (n = this.map.getBearing()), n < 0 && (n += 360), a.get(r, "duration", 0)) {
        a.defaultsDeep(r, {
          animate: {
            center: { easing: { function: "linear" }, rhumb: !1 },
            zoom: { easing: { function: "linear" } },
            bearing: { easing: { function: "linear" } }
          }
        }), a.has(this.centerAnimation, "id") && cancelAnimationFrame(a.get(this.centerAnimation, "id"));
        const l = this.getCenter(r), c = ar([l.longitude, l.latitude]), u = ar([e, t]);
        this.centerAnimation = {
          id: requestAnimationFrame(this.animateCenter),
          ...r,
          startLongitude: l.longitude,
          startLatitude: l.latitude,
          startZoom: l.zoom,
          endLongitude: e,
          endLatitude: t,
          rhumbStart: c,
          rhumbEnd: u,
          rhumbBearing: zl(c, u),
          rhumbDistance: Il(c, u),
          endZoom: i
        }, typeof this.map.getBearing == "function" && Object.assign(this.centerAnimation, {
          startBearing: this.map.getBearing(),
          endBearing: n
        });
      } else
        typeof this.map.setBearing == "function" && this.setBearing(n, r), this.map.setView(new B.LatLng(t, e), i, { animate: !1, duration: 0 }), this.map.panBy(s, { animate: !1, duration: 0 });
    },
    getCenter() {
      const e = this.map.getCenter(), t = this.map.getZoom();
      return {
        longitude: e.lng,
        latitude: e.lat,
        zoomLevel: t
      };
    },
    setBearing(e, t = {}) {
      if (typeof this.map.setBearing != "function") {
        I.warn("[KDK] Map not configured to handle bearing, ignoring");
        return;
      }
      const i = B.point(a.get(t, "offset.x", 0), a.get(t, "offset.y", 0)), n = a.get(t, "bearingTolerance", 0.1);
      Math.abs(this.map.getBearing() - e) >= n && this.map.setBearing(e, i);
    },
    getBearing() {
      return typeof this.map.getBearing != "function" ? 0 : this.map.getBearing();
    },
    setCompassBearingTrackingEnabled(e) {
      e ? this.map.compassBearing.enabled() || this.map.compassBearing.enable() : this.map.compassBearing.enabled() && this.map.compassBearing.disable();
    },
    setTouchRotateEnabled(e) {
      e ? this.map.touchRotate.enabled() || this.map.touchRotate.enable() : this.map.touchRotate.enabled() && this.map.touchRotate.disable();
    },
    getBounds() {
      this.viewBounds = this.map.getBounds();
      const e = this.viewBounds.getSouth(), t = this.viewBounds.getWest(), i = this.viewBounds.getNorth(), n = this.viewBounds.getEast();
      return [[e, t], [i, n]];
    },
    showUserLocation() {
      if (Ct.hasLocation()) {
        const e = Ct.getLongitude(), t = Ct.getLatitude(), i = Ct.getAccuracy();
        i ? this.zoomToBounds(new B.LatLng(t, e).toBounds(i * 2)) : this.center(e, t);
      }
      this.locateControl && this.locateControl.start();
    },
    hideUserLocation() {
      this.locateControl && this.locateControl.stop();
    },
    isUserLocationVisible() {
      return this.locateControl && this.locateControl._active;
    },
    isOrphanLayer(e) {
      return this.orphanLayers.some((t) => t.name === e.name);
    },
    setCursor(e) {
      B.DomUtil.addClass(this.map._container, e);
    },
    isCursor(e) {
      return B.DomUtil.hasClass(this.map._container, e);
    },
    unsetCursor(e) {
      B.DomUtil.removeClass(this.map._container, e);
    },
    onCurrentMapTimeChanged(e) {
      a.forEach(this.leafletLayers, (t) => {
        typeof t.setCurrentTime == "function" && t.setCurrentTime(e);
      });
    },
    onMapZoomChanged() {
      this.updateLeafletPanesVisibility(), a.values(this.layers).filter(Te({
        $or: [{ "leaflet.minZoom": { $exists: !0 } }, { "leaflet.maxZoom": { $exists: !0 } }]
      })).forEach(async (t) => {
        this.updateLayerDisabled(t);
      });
    }
  },
  async created() {
    this.leafletLayers = {}, this.leafletPanes = {}, this.leafletFactory = [], this.leafletObjectOptions = ["crs", "rendererFactory"], this.registerLeafletConstructor(this.createLeafletTimedWmsLayer), this.$engineEvents = new jl(), this.$engineEvents.on("zoomend", this.onMapZoomChanged), ne.on("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  beforeUnmount() {
    this.clearLayers(), B.DomEvent.off(this.map._container, Ln.join(" "), this.onTouchEvent, this), this.$engineEvents.off("zoomend", this.onMapZoomChanged), ne.off("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  unmounted() {
    this.map && (this.map.off(), this.map.remove());
  }
};
B.Polygon.extend({
  initialize: function(e, t) {
    B.setOptions(this, Object.assign({
      interactive: !1,
      fitBounds: !0,
      bounds: new B.LatLngBounds([-90, -360], [90, 360])
    }), t);
    const i = [
      this.options.bounds.getSouthWest(),
      this.options.bounds.getNorthWest(),
      this.options.bounds.getNorthEast(),
      this.options.bounds.getSouthEast()
    ], n = [];
    if (a.get(e, "type") === "Feature") {
      const s = a.get(e, "geometry.type"), o = a.get(e, "geometry.coordinates");
      s === "Polygon" && o ? this.addPolygon(o, n) : s === "MultiPolygon" && o && a.forEach(o, (l) => this.addPolygon(l, n)), e.bbox || (e.bbox = wi(e));
    } else
      I.warn("Invalid/Unsupported GeoJson object for MaskLayer");
    B.Polygon.prototype.initialize.call(this, [i, n], this.options);
  },
  addPolygon(e, t) {
    const i = [];
    a.forEach(e, (n) => {
      const r = [];
      for (let s = 0; s < n.length; s++)
        r.push(new B.LatLng(n[s][1], n[s][0]));
      i.push(r);
    }), t.push(i);
  }
});
const O0 = B.GridLayer.extend({
  initialize(e) {
    this.enableDebug = a.get(e, "enableDebug", !1), B.GridLayer.prototype.initialize.call(this, e), this.on("tileunload", (t) => {
      this.onTileUnload(t);
    }), this.userIsDragging = !1, this.userIsZooming = !1, this.pendingStationUpdates = [], this.pendingRequests = [], this.getFeatureKey = (t) => Et(t, this.layer), this.probeSource = e.probeSource, this.featureSource = e.featureSource, this.flyingTiles = /* @__PURE__ */ new Map(), this.modifiedTiles = /* @__PURE__ */ new Set(), this.allFeatures = /* @__PURE__ */ new Map();
  },
  setup(e, t) {
    this.activity = e, this.layer = t;
  },
  onAdd(e) {
    this.userIsDragging = !1, this.userIsZooming = !1, this.pendingStationUpdates = [], this.zoomStartLevel = this.zoomEndLevel = this._map.getZoom(), this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), B.GridLayer.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), B.GridLayer.prototype.onRemove.call(this, e);
  },
  getEvents() {
    const e = B.GridLayer.prototype.getEvents.call(this), t = e.movestart;
    e.movestart = (s) => {
      this.userIsDragging = !0, t && t.call(this, s);
    };
    const i = e.moveend;
    e.moveend = (s) => {
      this.userIsDragging = !1, i && i.call(this, s);
    };
    const n = e.zoomstart;
    e.zoomstart = (s) => {
      n && n.call(this, s), this.zoomStartLevel = this._map.getZoom(), this.userIsZooming = !0;
    };
    const r = e.zoomend;
    return e.zoomend = (s) => {
      if (r && r.call(this, s), this.zoomEndLevel = this._map.getZoom(), this.userIsZooming = !1, this.layer.probeService) {
        const o = a.get(this.options, "minFeatureZoom", this._map.getMinZoom()), l = a.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
        if (this.zoomStartLevel >= o && this.zoomEndLevel < o || this.zoomStartLevel <= l && this.zoomEndLevel > l) {
          let c = [];
          for (const u of this.allFeatures.values())
            c.push(a.cloneDeep(u.geojson));
          c = ut(c), this.activity.updateLayer(this.layer.name, c, { replace: !0 });
        } else if (this.pendingStationUpdates.length)
          for (const c of this.pendingStationUpdates) {
            const u = [];
            bi(c, (d) => {
              this.allFeatures.has(this.getFeatureKey(d)) && u.push(d);
            }), this.activity.updateLayer(this.layer.name, ut(u));
          }
        this.pendingStationUpdates.length = 0;
      }
    }, e;
  },
  createTile(e) {
    const t = Pt(e);
    let i = this.flyingTiles.get(t);
    return i === void 0 ? (i = {
      div: document.createElement("div"),
      coords: e,
      bbox: this._tileCoordsToBounds(e),
      featuresRequest: null,
      featuresChildren: [],
      features: [],
      measuresRequest: null,
      measuresChildren: [],
      unload: !1
    }, this.flyingTiles.set(t, i), this.enableDebug && (i.div.style.outline = "1px solid orange", i.div.innerHTML = "")) : (i.unload = !1, this.enableDebug && (i.div.innerHTML += "</br>createTile: found in flying tiles")), this.modifiedTiles.add(t), i.div;
  },
  onTileUnload(e) {
    const t = Pt(e.coords), i = this.flyingTiles.get(t);
    i && (i.unload = !0), this.modifiedTiles.add(t), this.enableDebug && i && (i.div.innerHTML += "</br>unload scheduled");
  },
  mergeRequests(e) {
    const t = [], i = e.sort((n, r) => n.coords.x === r.coords.x ? n.coords.y < r.coords.y ? -1 : n.coords.y !== r.coords.y ? 1 : 0 : n.coords.x < r.coords.x ? -1 : 1);
    if (i.length) {
      const n = i[0].coords.z, r = [];
      if (i.forEach((s) => {
        let o = !0;
        if (r.length) {
          const l = r[r.length - 1];
          s.coords.x === l.x && s.coords.y === l.maxy + 1 && (l.tiles.push(s), l.maxy = s.coords.y, o = !1);
        }
        o && r.push({
          x: s.coords.x,
          miny: s.coords.y,
          maxy: s.coords.y,
          tiles: [s]
        });
      }), r.forEach((s) => {
        let o = !0;
        if (t.length) {
          const l = t[t.length - 1];
          s.miny === l.miny && s.maxy === l.maxy && s.x === l.maxx + 1 && (l.tiles.push(...s.tiles), l.maxx = s.x, o = !1);
        }
        o && t.push({
          minx: s.x,
          maxx: s.x,
          miny: s.miny,
          maxy: s.maxy,
          tiles: [].concat(s.tiles)
        });
      }), t.forEach((s) => {
        const o = B.point(s.minx, s.miny), l = B.point(s.maxx, s.maxy);
        o.z = l.z = n;
        const c = this._tileCoordsToBounds(o);
        c.extend(this._tileCoordsToBounds(l)), s.query = {
          south: c.getSouth(),
          north: c.getNorth(),
          west: c.getWest(),
          east: c.getEast()
        };
      }), this.enableDebug) {
        let s = 0;
        t.forEach((o) => {
          s += o.tiles.length;
        }), s !== e.length && I.debug("TiledFeatureLayer: less requested tiles than expected !");
      }
    }
    return this.enableDebug && e.length && I.debug(`TiledFeatureLayer: ${e.length} requests reduced to ${t.length}`), t;
  },
  _update(e) {
    if (B.GridLayer.prototype._update.call(this), this.pendingRequests = this.pendingRequests.filter((u) => u.status.pending), this.userIsDragging) return;
    const t = [], i = [], n = [], r = a.get(this.options, "minFeatureZoom", this._map.getMinZoom()), s = a.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
    this.modifiedTiles.forEach((u) => {
      const d = this.flyingTiles.get(u);
      if (d !== void 0)
        if (d.unload)
          d.featuresRequest === null && d.measuresRequest === null && t.push(d);
        else {
          const f = this.layer.probeService && d.coords.z >= r && d.coords.z <= s;
          this.enableDebug && (d.div.innerHTML += "</br>features", f && (d.div.innerHTML += " + measures"));
          const m = ad(this.flyingTiles, d.coords);
          if (m === void 0)
            i.push(d), f && n.push(d), this.enableDebug && (d.div.innerHTML += "</br>need request(s)");
          else {
            const g = this.flyingTiles.get(Pt(m));
            g.featuresRequest === null ? (g.features.forEach((v) => {
              const x = this.allFeatures.get(v);
              d.bbox.intersects(x.bbox) && (x.refCount += 1, d.features.push(v));
            }), this.enableDebug && (d.div.style.outline = "1px solid green", d.div.innerHTML += `</br>found ${d.features.length} features in parent tile`)) : (g.featuresChildren.push(d), d.featuresRequest = g.featuresRequest, this.enableDebug && (d.div.innerHTML += "</br>pending parent features request")), f && (g.measuresRequest !== null ? (g.measuresChildren.push(d), d.measuresRequest = g.measuresRequest, this.enableDebug && (d.div.innerHTML += "</br>pending parent measures request")) : m.z < r && (n.push(d), this.enableDebug && (d.div.innerHTML += "</br>need measures request")));
          }
        }
    }), this.modifiedTiles.clear(), this.mergeRequests(i).forEach((u) => {
      const d = this.layer.probeService ? this.probeSource(u.query) : this.featureSource(u.query);
      u.tiles.forEach((f) => {
        f.featuresRequest = d, this.enableDebug && (f.div.innerHTML += "</br>features request issued");
      }), d.status = { cancelled: !1, pending: !0 }, this.pendingRequests.push(d), d.then((f) => {
        if (d.status.cancelled) return;
        const m = [u.tiles];
        u.tiles.forEach((x) => {
          x.featuresChildren.length && m.push(x.featuresChildren);
        });
        const g = m.flat(), v = [];
        if (f.features.forEach((x) => {
          const S = this.getFeatureKey(x);
          let A = this.allFeatures.get(S);
          const p = A === void 0;
          if (p) {
            const y = wi(x), w = B.latLng(y[1], y[0]), C = B.latLng(y[3], y[2]);
            A = { geojson: x, refCount: 0, bbox: B.latLngBounds(w, C) };
          }
          g.forEach((y) => {
            y.bbox.intersects(A.bbox) && (A.refCount += 1, y.features.push(S));
          }), A.refCount > 0 && p && (v.push(a.cloneDeep(x)), this.allFeatures.set(S, A));
        }), v.length) {
          const x = ut(v);
          this.activity.updateLayer(this.layer.name, x);
        }
        g.forEach((x) => {
          x.featuresRequest = null, x.featuresChildren = [], x.unload && this.modifiedTiles.add(Pt(x.coords)), this.enableDebug && (x.div.style.outline = "1px solid green", x.div.innerHTML += `</br>features request success: ${f.features.length} total, ${x.features.length} for tile`);
        }), this.enableDebug && I.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).catch((f) => {
        if (d.status.cancelled) return;
        const m = [u.tiles];
        u.tiles.forEach((v) => {
          v.featuresChildren.length && m.push(v.featuresChildren);
        }), m.flat().forEach((v) => {
          this.flyingTiles.delete(Pt(v.coords)), this.enableDebug && (v.div.style.outline = "1px solid red", v.div.innerHTML += `</br>features request failed: ${f}`);
        }), this.enableDebug && I.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).finally(() => {
        d.status.pending = !1;
      });
    }), this.mergeRequests(n).forEach((u) => {
      const d = this.featureSource(u.query), f = [];
      u.tiles.forEach((m) => {
        m.measuresRequest = d, m.featuresRequest && f.push(m.featuresRequest), this.enableDebug && (m.div.innerHTML += "</br>measures request issued");
      }), d.status = { cancelled: !1, pending: !0 }, this.pendingRequests.push(d), Promise.all(f).then(() => {
        if (d.status.cancelled) return;
        const m = [];
        u.tiles.forEach((g) => {
          g.features.forEach((v) => {
            const x = this.allFeatures.get(v);
            if (x) {
              const S = a.cloneDeep(x.geojson);
              S.measureRequestIssued = !0, m.push(S);
            }
          });
        }), m.length && this.updateStations(ut(m));
      }), d.then((m) => {
        if (d.status.cancelled) return;
        const g = [u.tiles];
        u.tiles.forEach((S) => {
          S.measuresChildren.length && g.push(S.measuresChildren);
        });
        const v = g.flat(), x = [];
        v.forEach((S) => {
          S.measuresRequest = null, S.measuresChildren = [], S.featuresRequest && x.push(S.featuresRequest), this.enableDebug && (S.div.innerHTML += `</br>measures request success: ${m.features.length} total`);
        }), Promise.all(x).then(() => {
          const S = [];
          bi(m, (A) => {
            const p = this.getFeatureKey(A);
            this.allFeatures.has(p) && S.push(A);
          }), S.length && this.updateStations(ut(S));
        });
      }).catch((m) => {
        if (d.status.cancelled) return;
        const g = [u.tiles];
        u.tiles.forEach((x) => {
          x.measuresChildren.length && g.push(x.measuresChildren);
        }), g.flat().forEach((x) => {
          this.enableDebug && (x.div.style.outline = "1px solid red", x.div.innerHTML += `</br>measures request failed: ${m}`);
        });
      }).finally(() => {
        d.status.pending = !1;
      });
    });
    const c = [];
    t.forEach((u) => {
      u.features.forEach((d) => {
        const f = this.allFeatures.get(d);
        f.refCount === 1 ? (c.push(f.geojson), this.allFeatures.delete(d)) : f.refCount -= 1;
      }), this.flyingTiles.delete(Pt(u.coords));
    }), c.length && this.activity.updateLayer(this.layer.name, ut(c), { remove: !0 }), this.enableDebug && (I.debug(`TiledFeatureLayer: flyingTiles is ${this.flyingTiles.size} long`), I.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`), this.flyingTiles.size === 0 && this.allFeatures.size !== 0 && (I.debug(`TileFeatureLayer: no more flyingTiles but ${this.allFeatures.size} remaining features !`), this.allFeatures.forEach((u) => {
      I.debug(`TileFeatureLayer: ${this.getFeatureKey(u.geojson)}: refCount ${u.refCount}`);
    })));
  },
  updateStations(e) {
    if (this.userIsZooming)
      this.pendingStationUpdates.push(e);
    else {
      const t = a.get(this.options, "minFeatureZoom", this._map.getMinZoom()), i = a.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
      this.zoomEndLevel >= t && this.zoomEndLevel <= i && this.activity.updateLayer(this.layer.name, e);
    }
  },
  redraw() {
    const e = Array.from(this.allFeatures.values(), (t) => t.geojson);
    this.activity.updateLayer(this.layer.name, ut(e), { remove: !0 }), this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), this.pendingStationUpdates.length = 0, this.pendingRequests.forEach((t) => {
      t.status.cancelled = !0;
    }), B.GridLayer.prototype.redraw.call(this);
  }
});
function B0(e, t = {}) {
  return fetch(e, { redirect: "follow", headers: t }).then((i) => i.text()).then((i) => lr.parseStringPromise(i, { tagNameProcessors: [lr.processors.stripPrefix] }));
}
function R0(e, t, i, n = {}, r = {}, { xml2json: s = !0 } = {}) {
  const o = Tn(e, Object.assign({
    SERVICE: "WFS",
    VERSION: t,
    REQUEST: "GetFeature",
    TYPENAMES: typeof i == "string" ? i : i.join(" ")
  }, n));
  return s ? B0(o, r) : fetch(o, { redirect: "follow", headers: r }).then((l) => l.json());
}
const $0 = {
  emits: [
    "layer-updated"
  ],
  methods: {
    processRealtimeGeoJsonLayerOptions(e) {
      const t = e.leaflet || e;
      t.type = "realtime", a.set(t, "getFeatureId", (n) => Et(n, e));
      const i = a.get(t, "container");
      if (typeof i == "string" && (t.container = this.createLeafletLayer({ type: i })), a.has(t, "updateFeature") || (t.updateFeature = Gu(t)), e.service)
        if (e = this.getLayerByName(e.name), a.set(t, "start", !1), t.tiled)
          t.removeMissing = !1, a.set(t, "source", async (n, r) => {
          }), t.probeSource = (n) => this.getProbeFeatures(a.merge({ baseQuery: n }, e)), t.featureSource = (n) => this.getFeatures(a.merge({ baseQuery: n }, e));
        else {
          t.removeMissing = !e.probeService;
          let n = !e.probeService;
          a.set(t, "source", async (r, s) => {
            if (!n)
              try {
                const o = await this.getProbeFeatures(e);
                Ne(o).forEach((c) => {
                  c.measureRequestIssued = !0;
                }), r(o), n = !0;
              } catch (o) {
                s(o);
              }
            try {
              const o = await this.getFeatures(e);
              r(o);
            } catch (o) {
              s(o);
            }
          });
        }
      else if (e.wfs)
        a.set(t, "start", !1), a.set(t, "source", async (n, r) => {
        }), t.tiled && (t.removeMissing = !1, t.featureSource = (n) => {
          const r = Object.assign({
            OUTPUTFORMAT: e.wfs.outputFormat,
            // request as geojson
            SRSNAME: "EPSG:4326",
            // result in 4326
            BBOX: `${n.south},${n.west},${n.north},${n.east},urn:ogc:def:crs:EPSG::4326`
            // request bbox
          }, e.wfs.searchParams);
          return R0(e.wfs.url, e.wfs.version, e.wfs.layer, r, e.wfs.headers, { xml2json: !1 });
        });
      else if (a.has(t, "sourceTemplate")) {
        const n = a.template(a.get(t, "sourceTemplate"));
        let r;
        a.set(t, "source", async (s, o) => {
          try {
            const l = n({ time: be.getCurrentTime() });
            (!r || r !== l) && (r = l, s(await Oi(l, e)));
          } catch (l) {
            o(l);
          }
        }), a.set(t, "start", !1);
      } else a.has(t, "source") || (a.set(t, "start", !1), a.set(t, "source", async (n, r) => {
      }));
    },
    async processGeoJsonLayerOptions(e) {
      const t = e.leaflet || e, i = a.get(t, "source");
      if (a.isNil(i))
        a.set(t, "source", { type: "FeatureCollection", features: [] });
      else if (typeof i == "string") {
        let n;
        e.service ? n = await this.getFeatures(e) : n = await Oi(i, e), a.set(t, "source", n);
      }
    },
    processClusterLayerOptions(e) {
      const t = e.leaflet || e, i = Object.assign({ type: "markerClusterGroup" }, t.cluster);
      t.pane && (i.clusterPane = t.pane), t.container = this.createLeafletLayer(i), kt(t.container, Zt.Cluster, this, e);
    },
    async createLeafletGeoJsonLayer(e) {
      const t = e.leaflet || e;
      if (t.type === "geoJson")
        try {
          const i = !!a.get(t, "minZoom"), n = !!a.get(t, "maxZoom"), r = !!a.get(t, "zIndex"), s = e.name, o = { name: s };
          i && (o.minZoom = a.get(t, "minZoom")), n && (o.maxZoom = a.get(t, "maxZoom")), r && (o.zIndex = a.get(t, "zIndex"));
          const l = a.get(t, "panes", []);
          a.find(l, { name: o.name }) || l.push(o), a.has(t, "pane") || (t.pane = o.name), a.has(t, "shadowPane") || (t.shadowPane = o.name);
          for (const v of ["point", "line", "polygon"])
            a.set(t, `style.${v}.pane`, o.name), a.set(t, `style.${v}.shadowPane`, o.name);
          r || (a.find(l, { name: `${s}-markers` }) || l.push(Object.assign({ name: `${s}-markers`, zIndex: 600 }, a.omit(o, ["name"]))), a.find(l, { name: `${s}-shadows` }) || l.push(Object.assign({ name: `${s}-shadows`, zIndex: 500 }, a.omit(o, ["name"]))), a.has(t, "shadowPane") || (t.shadowPane = `${s}-shadows`), a.set(t, "style.point.pane", `${s}-markers`), a.set(t, "style.point.shadowPane", `${s}-shadows`)), t.panes = l, !a.has(t, "cluster") && a.get(this, "activityOptions.engine.cluster") && (t.cluster ? Object.assign(t.cluster, a.get(this, "activityOptions.engine.cluster")) : t.cluster = Object.assign({}, a.get(this, "activityOptions.engine.cluster"))), t.cluster && this.processClusterLayerOptions(e), t.realtime ? this.processRealtimeGeoJsonLayerOptions(e) : await this.processGeoJsonLayerOptions(e);
          const c = a.get(t, "template");
          c && (t.template = c.map((v) => ({
            property: v,
            compiler: a.template(a.get(t, v))
          })));
          const u = a.get(t, "popup.template");
          u && (t.popup.compiler = a.template(u));
          const d = a.get(t, "tooltip.template");
          d && (t.tooltip.compiler = a.template(d)), a.get(e, "variables", []).forEach((v) => {
            a.has(v, "chromajs") && (v.colorScale = Fn(a.get(v, "chromajs")));
          }), t.style ? (t.layerPointStyle = a.get(t.style, "point"), t.layerLineStyle = a.get(t.style, "line"), t.layerPolygonStyle = a.get(t.style, "polygon")) : (t.layerPointStyle = An(t), t.layerLineStyle = On(t), t.layerPolygonStyle = Bn(t));
          const m = this.getGeoJsonOptions(e);
          Object.keys(m).forEach((v) => {
            (!a.has(t, v) || v === "style") && a.set(t, v, a.get(m, v));
          });
          let g = this.createLeafletLayer(e);
          if (t.realtime) {
            if (t.tiled) {
              const v = !!a.get(t, "minZoom"), x = !!a.get(t, "maxZoom"), S = [];
              v || S.push("minZoom"), x || S.push("maxZoom");
              const A = new O0(a.omit(t, S));
              A.setup(this, e), g.tiledLayer = A, g.on("add", () => A.addTo(this.map)), g.on("remove", () => A.removeFrom(this.map));
            }
            g.on("update", (v) => this.onLayerUpdated(e, g, v)), g.update();
          } else
            t.cluster && t.container && (t.container.addLayer(g), g = t.container);
          return t.timeDimension && (g = this.createLeafletLayer(Object.assign({ type: "timeDimension.layer.geoJson", source: g }, t.timeDimension))), g;
        } catch (i) {
          return I.error(i), null;
        }
    },
    getGeoJsonOptions(e = {}) {
      return {
        onEachFeature: (i, n) => {
          xr(n, Zt.Feature), typeof this.onLeafletFeature == "function" && this.onLeafletFeature(i, n, e), n.getPopup() && n.unbindPopup();
          const r = this.generateStyle("popup", i, n, e);
          if (r) {
            const o = n.getPopup() && n.isPopupOpen();
            n.bindPopup(r), kt(n.getPopup(), Zt.Popup, this, e), o && n.openPopup();
          }
          n.getTooltip() && n.unbindTooltip();
          const s = this.generateStyle("tooltip", i, n, e, this.map.getZoom());
          if (s) {
            const o = n.getTooltip() && n.isTooltipOpen();
            n.bindTooltip(s), kt(n.getTooltip(), Zt.Tooltip, this, e), o && n.openTooltip();
          }
          kt(n, Zt.Feature, this, e);
        },
        style: (i) => {
          const n = Xr(i);
          if (!n) {
            I.warn(`[KDK] cannot get a style type from the feature of geometry type ${i.geometry.type}`);
            return;
          }
          return this.generateStyle(n, i, e, a.get(this, `activityOptions.engine.style.${n}`), this.map.getZoom());
        },
        pointToLayer: (i, n) => {
          const r = this.generateStyle("point", i, e, a.get(this, "activityOptions.engine.style.point"), this.map.getZoom());
          if (!r) {
            I.warn("[KDK] cannot generate point style from a feature");
            return;
          }
          return Mo(n, r);
        }
      };
    },
    getUpdateAnimation(e, t, i, n) {
      const { duration: r, removeMissing: s, animate: o } = i, l = a.keys(o);
      l.forEach((u) => {
        a.defaultsDeep(o, {
          [u]: { easing: { function: "linear" }, bearing: !1 }
        });
      });
      const c = Ne(n);
      return c.forEach((u) => {
        const d = t.getLayer(t.options.getFeatureId(u)), f = d ? d.feature : null;
        if (f) {
          delete f.previousFeature, u.previousFeature = f;
          const m = u.previousFeature.geometry.coordinates[0], g = u.previousFeature.geometry.coordinates[1], v = u.geometry.coordinates[0], x = u.geometry.coordinates[1], S = ar([m, g]), A = ar([v, x]);
          Object.assign(u, {
            rhumbStart: S,
            rhumbEnd: A,
            rhumbBearing: zl(S, A),
            rhumbDistance: Il(S, A)
          });
        }
      }), (u) => {
        i.startTime || (i.startTime = u);
        const { id: d, startTime: f, fps: m } = i, g = u - f;
        if (m && i.lastTime) {
          const x = u - i.lastTime, S = 1e3 / m;
          if (x < S) {
            i.id = requestAnimationFrame(i.step);
            return;
          }
        }
        const v = Math.abs(g / (1e3 * r));
        if (v <= 1) {
          const x = [];
          c.forEach((S) => {
            if (!S.previousFeature) {
              x.push(S);
              return;
            }
            const A = S.geometry.coordinates[0], p = S.geometry.coordinates[1];
            let y = A, w = p;
            if (o.geometry) {
              const z = o.geometry.easing.function, D = o.geometry.easing.parameters || [], T = cn[z](v, ...D);
              if (o.geometry.rhumb) {
                const F = Nl(S.rhumbStart, T * S.rhumbDistance, S.rhumbBearing);
                y = F.geometry.coordinates[0], w = F.geometry.coordinates[1];
              } else {
                const F = S.previousFeature.geometry.coordinates[0], k = S.previousFeature.geometry.coordinates[1];
                y = F + T * (A - F), w = k + T * (p - k);
              }
            }
            const C = {}, P = S.previousFeature.properties || {}, M = S.properties || {};
            l.forEach((z) => {
              if (z === "geometry") return;
              const D = o[z], T = D.easing.function, F = D.easing.parameters || [], k = cn[T](v, ...F), O = P[z], $ = M[z];
              let X = O + k * ($ - O);
              if (D.bearing) {
                const te = ($ - O + 540) % 360 - 180;
                X = (O + k * te + 360) % 360;
              }
              C[z] = X;
            }), x.push({
              type: S.type,
              geometry: {
                type: S.geometry.type,
                coordinates: [y, w]
              },
              properties: Object.assign({}, M, C),
              style: S.style
            });
          }), t._onNewData(a.isNil(s) ? t.options.removeMissing : s, x), i.lastTime = u, i.id = requestAnimationFrame(i.step);
        } else
          delete i.id;
      };
    },
    updateLayer(e, t, i = {}) {
      let n = this.getLeafletLayerByName(e);
      if (!n) return;
      if (!a.get(n, "options.realtime")) {
        I.warn(`Impossible to update non-realtime layer ${e}`);
        return;
      }
      if (a.get(i, "replace", !1))
        this.updateLayer(e, t, { remove: !0 }), this.updateLayer(e, t, a.omit(i, ["replace"]));
      else {
        const s = typeof i == "boolean" ? i : i.remove, o = a.get(i, "removeMissing", n.options.removeMissing);
        let l;
        if (n instanceof B.MarkerClusterGroup && (l = n, n = l.getLayers().find((u) => u._container === l)), s) {
          if (typeof n.remove != "function") return;
          let u = Ne(t);
          u = u.filter((d) => n.getLayer(n.options.getFeatureId(d))), n.remove(u);
        } else if (t) {
          if (typeof n._onNewData == "function") {
            let u = a.get(i, "duration", 0);
            const d = Array.isArray(t) ? t : t.type === "FeatureCollection" ? t.features : [t];
            if (u && d.length === 0 && (u = 0), u && a.some(d, (f) => ch(f) !== "Point") && (I.warn(`Impossible to animate layer ${e} as it does not contain only point geometries`), u = 0), u) {
              a.defaultsDeep(i, {
                animate: {
                  geometry: { easing: { function: "linear" }, rhumb: !1 }
                }
              });
              const f = a.get(this.updateAnimations, `${e}.id`);
              a.isNil(f) || cancelAnimationFrame(f), i.step = this.getUpdateAnimation(e, n, i, t), i.id = requestAnimationFrame(i.step), a.set(this.updateAnimations, e, i);
            } else
              a.unset(this.updateAnimations, e), n._onNewData(o, t);
          }
        } else
          n.tiledLayer ? n.tiledLayer.redraw() : typeof n.update == "function" ? n.update() : typeof n._onNewData == "function" && n._onNewData(o, this.toGeoJson(e));
        const c = this.getLayerByName(e);
        if (Jt(c)) {
          const u = n.toGeoJSON(!1);
          this.geojsonCache[e] = u;
        }
      }
    },
    onLayerUpdated(e, t, i) {
      this.$emit("layer-updated", e, t, i), this.$engineEvents.emit("layer-updated", e, t, i);
    },
    onCurrentTimeChangedGeoJsonLayers(e) {
      a.values(this.layers).filter(Te(tr.TimeUpdate)).forEach(async (i) => {
        const n = this.getLeafletLayerByName(i.name);
        (!n.lastUpdateTime || !this.shouldSkipFeaturesUpdate(n.lastUpdateTime, i)) && (n.lastUpdateTime = be.getCurrentTime().clone(), n.tiledLayer ? n.tiledLayer.redraw() : n.update());
      });
    },
    onCurrentLevelChangedGeoJsonLayers(e) {
      let t = this.selectableLevelsLayer;
      t && a.get(t, `${this.engine}.type`) === "geoJson" && (t = this.getLeafletLayerByName(t.name), t.tiledLayer ? t.tiledLayer.redraw() : t.update());
    },
    onDefaultUnitChangedGeoJsonLayers(e) {
      a.forOwn(e.default, (t, i) => {
        const n = a.map(Me.getUnits(i), "name");
        let r = a.values(this.layers).filter(Te(tr.UnitUpdate));
        r = r.filter((s) => Hu(n, s)), r.forEach((s) => {
          s = this.getLeafletLayerByName(s.name), s.tiledLayer ? s.tiledLayer.redraw() : s.update();
        });
      });
    },
    onMapZoomChangedGeoJsonLayers() {
      a.values(this.layers).filter(Te(tr.TooltipUpdate)).forEach(async (t) => {
        const i = this.getLeafletLayerByName(t.name), n = a.get(t, "leaflet.tooltip.minZoom"), r = a.get(t, "leaflet.tooltip.maxZoom"), s = this.map.getZoom();
        let o = !0;
        r && s > r && (o = !1), n && s < n && (o = !1), i.showTooltips !== o && (i.showTooltips = o, this.updateLayer(t.name, this.toGeoJson(t.name)));
      });
    },
    onLayerShownGeoJsonLayers(e, t) {
      const i = this.geojsonCache[e.name];
      if (i)
        if (Jt(e)) {
          if (t instanceof B.MarkerClusterGroup) {
            const n = t;
            t = n.getLayers().find((r) => r._container === n);
          }
          t._onNewData(!1, i);
        } else
          delete this.geojsonCache[e.name];
    },
    onLayerRemovedGeoJsonLayers(e) {
      a.has(this.geojsonCache, e.name) && delete this.geojsonCache[e.name];
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGeoJsonLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers), ne.on("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.on("zoomend", this.onMapZoomChangedGeoJsonLayers), this.$engineEvents.on("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.on("layer-removed", this.onLayerRemovedGeoJsonLayers), this.updateAnimations = {}, this.geojsonCache = {};
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers), ne.off("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.off("zoomend", this.onMapZoomChangedGeoJsonLayers), this.$engineEvents.off("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.off("layer-removed", this.onLayerRemovedGeoJsonLayers), this.geojsonCache = {};
  }
}, I0 = {
  methods: {
    async importFiles(e) {
      const t = await yi.filter(e);
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        try {
          const r = await yi.read(n), s = zt.basename(n.name, zt.extname(n.name)), o = a.join(a.map(n.files, (l) => l.name), ",");
          await this.addGeoJsonLayer({ name: s, description: o }, r);
        } catch {
        }
      }
    }
  },
  mounted() {
    this.$engineEvents.on("map-ready", () => {
      const e = this.map.getContainer(), t = document.createElement("input");
      t.setAttribute("id", "dropFileInput"), t.type = "file", t.style.display = "none", t.addEventListener("change", async (i) => {
        I.debug("[KDK] processing dropped files: ", i.target.files), await this.importFiles(i.target.files);
      }), e.appendChild(t), this.map._container.addEventListener("dragenter", () => this.map.scrollWheelZoom.disable(), !1), this.map._container.addEventListener("dragleave", () => this.map.scrollWheelZoom.enable(), !1), this.map._container.addEventListener("dragover", (i) => {
        i.stopPropagation(), i.preventDefault();
      }, !1), this.map._container.addEventListener("drop", async (i) => {
        I.debug("[KDK] processing dropped files: ", i.dataTransfer.files), i.stopPropagation(), i.preventDefault(), await this.importFiles(i.dataTransfer.files), this.map.scrollWheelZoom.enable();
      }, !1);
    });
  }
};
function pf(e, t, i) {
  if (i === void 0 && (i = {}), i.final === !0)
    return z0(e, t);
  var n = pt(e), r = pt(t), s = gt(n[0]), o = gt(r[0]), l = gt(n[1]), c = gt(r[1]), u = Math.sin(o - s) * Math.cos(c), d = Math.cos(l) * Math.sin(c) - Math.sin(l) * Math.cos(c) * Math.cos(o - s);
  return br(Math.atan2(u, d));
}
function z0(e, t) {
  var i = pf(t, e);
  return i = (i + 180) % 360, i;
}
const vl = ["pm:drawstart", "pm:drawend", "pm:create"], bl = ["layerremove", "pm:update", "pm:dragend", "pm:rotateend", "pm:markerdragend"], rn = "editHelpersPane", N0 = {
  emits: [
    "edit-start",
    "edit-stop",
    "edit-point-moved"
  ],
  data() {
    return {
      editingLayer: !1,
      allowedLayerEditModes: [],
      layerEditMode: ""
    };
  },
  watch: {
    async $route(e, t) {
      if (this.editedFeature) {
        if (a.get(e, "params.featureId"))
          this.editedPopup = this.editedFeature.getPopup(), this.editedPopup && this.editedFeature.unbindPopup(this.editedPopup);
        else if (a.get(t, "params.featureId")) {
          this.editedPopup && this.editedFeature.bindPopup(this.editedPopup);
          const i = this.editedLayer._id ? a.get(this.editedLayer, "service", "features") : "features-edition", n = await G.getService(i).get(this.editedFeature.feature._id);
          this.editableLayer.removeLayer(this.editedFeature), this.editableLayer.addData(n), this.editedPopup = null, this.editedFeature = null;
        }
      }
    }
  },
  methods: {
    isLayerEdited(e) {
      return this.editedLayer && this.editedLayer.name === e.name;
    },
    getGeoJsonEditOptions(e, t) {
      let i = e;
      const n = e.leaflet || e, r = {};
      r.layerPointStyle = n.style ? a.get(n.style, "point") : An(n), r.layerLineStyle = n.style ? a.get(n.style, "line") : On(n), r.layerPolygonStyle = n.style ? a.get(n.style, "polygon") : Bn(n), (a.has(i, "leaflet.tooltip") || a.has(i, "leaflet.popup")) && (i = Object.assign({}, e), i.leaflet.tooltip && delete i.leaflet.tooltip, i.leaflet.popup && delete i.leaflet.popup);
      const { onEachFeature: s, style: o, pointToLayer: l } = this.getGeoJsonOptions(i);
      return {
        // Ensure it is on top of all others layers while editing
        pane: "popupPane",
        // Allow geoman edition
        pmIgnore: !1,
        onEachFeature: s,
        // Use default styling when editing as dynamic styling can conflict
        style: (c) => {
          if (c.geometry.type === "LineString" || c.geometry.type === "MultiLineString")
            return !a.isEmpty(t) && !t.includes("LineString") && !t.includes("MultiLineString") ? o(c) : Oo(c, r, a.get(this, "activityOptions.engine.style.edition.line"));
          if (c.geometry.type === "Polygon" || c.geometry.type === "MultiPolygon")
            return !a.isEmpty(t) && !t.includes("Polygon") && !t.includes("MultiPolygon") ? o(c) : Bo(c, r, a.get(this, "activityOptions.engine.style.edition.polygon"));
          logger.warn(`[KDK] the geometry of type of ${c.geometry.type} is not supported`);
        },
        pointToLayer: (c, u) => {
          if (!a.isEmpty(t) && !t.includes("Point") && !t.includes("MultiPoint")) return l(c, layer);
          const d = Ao(c, r, a.get(this, "activityOptions.engine.style.edition.point"));
          return d.options = { pmIgnore: !1 }, Mo(u, d);
        }
      };
    },
    setEditMode(e) {
      this.editableLayer && (this.map.pm.globalDrawModeEnabled() && this.map.pm.disableDraw(), this.map.pm.globalEditModeEnabled() && this.map.pm.disableGlobalEditMode(), this.map.pm.globalDragModeEnabled() && this.map.pm.disableGlobalDragMode(), this.map.pm.globalRemovalModeEnabled() && this.map.pm.disableGlobalRemovalMode(), this.map.pm.globalRotateModeEnabled() && this.map.pm.disableGlobalRotateMode(), this.map.pm.setGlobalOptions({
        layerGroup: this.map,
        // Ensure it is on top of all others layers while editing
        panes: {
          layerPane: rn,
          vertexPane: rn,
          markerPane: rn
        }
      }), this.allowedLayerEditModes.indexOf(e) !== -1 && (e === "edit-properties" || (e === "edit-geometry" ? this.map.pm.enableGlobalEditMode() : e === "drag" ? this.map.pm.enableGlobalDragMode() : e === "rotate" ? this.map.pm.enableGlobalRotateMode() : e === "remove" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableGlobalRemovalMode()) : e === "add-polygons" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Polygon", { continueDrawing: !0 })) : e === "add-rectangles" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Rectangle", { continueDrawing: !0 })) : e === "add-lines" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Line", { continueDrawing: !0 })) : e === "add-points" && (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Marker", { continueDrawing: !0 }))), this.layerEditMode = e));
    },
    async startEditLayer(e, {
      features: t = [],
      // Target features to be edited, otherwise the whole layer will be
      geometryTypes: i = [],
      // Target geometry types to be edited, otherwise the whole layer will be
      allowedEditModes: n = null,
      editMode: r = null,
      zIndex: s = -1,
      callback: o = null
      // Callback function to be called once edition is started/ended
    } = {}) {
      this.editedLayer && await this.stopEditLayer("accept");
      const l = this.getLeafletLayerByName(e.name);
      if (!l) return;
      this.allowedLayerEditModes = n || [
        "edit-properties",
        "edit-geometry",
        "drag",
        "rotate",
        "remove",
        "add-polygons",
        "add-rectangles",
        "add-lines",
        "add-points"
      ], this.editedLayer = e, this.editingLayer = !0, this.editingCallback = o, typeof this.setHighlightsEnabled == "function" && this.setHighlightsEnabled(e, !1), typeof this.setSelectionEnabled == "function" && this.setSelectionEnabled(!1), this.onEditStart(this.editedLayer);
      const c = l.toGeoJSON();
      let u = Ne(c);
      if (a.isEmpty(t) && a.isEmpty(i) ? l.clearLayers() : a.isEmpty(t) ? a.isEmpty(i) || (u = u.filter((f) => i.includes(a.get(f, "geometry.type"))), l.getLayers().forEach((f) => {
        const m = f.feature;
        i.includes(a.get(m, "geometry.type")) && l.removeLayer(f);
      })) : (u = u.filter((f) => t.includes(Et(f, e))), l.getLayers().forEach((f) => {
        const m = f.feature;
        t.includes(Et(m, f)) && l.removeLayer(f);
      })), this.editedLayer._id === void 0)
        for (const f of u)
          f._id = ti().toString(), await G.getService("features-edition").create(f);
      else
        this.editedLayerServiceEventListeners = Rn(this.editedLayer, {
          created: this.onEditedFeaturesCreated,
          updated: this.onEditedFeaturesUpdated,
          patched: this.onEditedFeaturesUpdated,
          removed: this.onEditedFeaturesRemoved
        });
      this.editableLayer = B.geoJson(u, this.getGeoJsonEditOptions(e, i)), this.map.addLayer(this.editableLayer), kt(this.map, vl, this), kt(this.editableLayer, bl, this), this.$engineEvents.on("click", this.onEditFeatureProperties), this.$engineEvents.on("mousemove", this.onMouseMoveWhileEditing), this.$engineEvents.on("zoomend", this.onMapZoomWhileEditing), this.$engineEvents.on("pm:drawstart", this.onDrawStart), this.$engineEvents.on("pm:drawend", this.onDrawEnd), this.$engineEvents.on("pm:create", this.onCreateFeatures), this.$engineEvents.on("pm:update", this.onEditFeatures), this.$engineEvents.on("pm:dragend", this.onEditFeatures), this.$engineEvents.on("pm:rotateend", this.onEditFeatures), this.$engineEvents.on("layerremove", this.onRemoveFeatures), this.$engineEvents.on("pm:markerdragend", this.onPointMoveEnd);
      let d = this.map.getPane(rn);
      d || (d = this.map.createPane(rn)), a.set(d, "style.zIndex", s !== -1 ? s : 700), r && this.setEditMode(r);
    },
    onEditStart(e) {
      this.$emit("edit-start", { layer: e }), this.$engineEvents.emit("edit-start", { layer: e }), this.editingCallback && this.editingCallback({ status: "edit-start", layer: e });
    },
    async stopEditLayer(e = "accept") {
      if (!this.editedLayer) return;
      const t = this.getLeafletLayerByName(this.editedLayer.name);
      if (t) {
        if (this.map.pm.globalDrawModeEnabled() && this.map.pm.disableDraw(), this.map.pm.globalEditModeEnabled() && this.map.pm.disableGlobalEditMode(), this.map.pm.globalDragModeEnabled() && this.map.pm.disableGlobalDragMode(), this.map.pm.globalRemovalModeEnabled() && this.map.pm.disableGlobalRemovalMode(), this.map.pm.globalRotateModeEnabled() && this.map.pm.disableGlobalRotateMode(), this.map.pm.setGlobalOptions({ layerGroup: this.map }), xr(this.map, vl), xr(this.editableLayer, bl), this.pendingOperations.length > 0) {
          const i = this.pendingOperations.flat();
          await Promise.all(i);
        }
        if (this.editedLayer._id === void 0) {
          const i = this.editableLayer.toGeoJSON(), n = Ne(i), r = G.getService("features-edition");
          await Promise.all(n.map((s) => r.remove(s._id)));
        } else
          Gi(this.editedLayer, this.editedLayerServiceEventListeners);
        this.map.removeLayer(this.editableLayer), t.addLayer(this.editableLayer), typeof this.setHighlightsEnabled == "function" && this.setHighlightsEnabled(this.editedLayer, !0), typeof this.setSelectionEnabled == "function" && this.setSelectionEnabled(!0), this.onEditStop(e, this.editedLayer), this.editedLayer = null, this.editingLayer = !1, this.editingCallback = null, this.$engineEvents.off("click", this.onEditFeatureProperties), this.$engineEvents.off("mousemove", this.onMouseMoveWhileEditing), this.$engineEvents.off("zoomend", this.onMapZoomWhileEditing), this.$engineEvents.off("pm:drawstart", this.onDrawStart), this.$engineEvents.off("pm:drawend", this.onDrawEnd), this.$engineEvents.off("pm:create", this.onCreateFeatures), this.$engineEvents.off("pm:update", this.onEditFeatures), this.$engineEvents.off("pm:dragend", this.onEditFeatures), this.$engineEvents.off("pm:rotateend", this.onEditFeatures), this.$engineEvents.off("layerremove", this.onRemoveFeatures), this.$engineEvents.off("pm:markerdragend", this.onPointMoveEnd);
      }
    },
    onEditStop(e, t) {
      this.$emit("edit-stop", { status: e, layer: t }), this.$engineEvents.emit("edit-stop", { status: e, layer: t }), this.editingCallback && this.editingCallback({ status: e, layer: t });
    },
    resetEditionTooltip() {
      this.hintTooltip && (this.hintTooltipInitialContent = this.hintTooltip.getContent());
    },
    updateEditionTooltip(e) {
      if (!this.hintTooltip) return;
      const { latlng: t } = e;
      if (a.isNil(t)) return;
      let i = this.hintTooltipInitialContent;
      const n = ["add-polygons", "add-rectangles", "add-lines", "add-points"], r = ["add-polygons", "add-lines"];
      if (n.includes(this.layerEditMode) && (i += `<br/>${es(t.lat, t.lng, j.get("locationFormat", "FFf"))}`), r.includes(this.layerEditMode) && this.workingLayer) {
        const s = st(this.workingLayer.toGeoJSON());
        if (s.length > 0) {
          const o = pf(s[s.length - 1], [t.lng, t.lat]);
          i += `<br/>${Me.format(o, "deg", Me.getDefaultUnit("angle"))}`;
        }
      }
      this.hintTooltip.setContent(i);
    },
    onDrawStart(e) {
      this.hintMarker = a.get(this.map.pm, `${e.source}.${e.shape}._hintMarker`), this.hintMarker && (this.hintTooltip = this.hintMarker.getTooltip(), this.hintTooltip && (e.workingLayer && (this.workingLayer = e.workingLayer, this.workingLayer.on("pm:vertexadded", this.onVertexAddedWhileEditing)), this.resetEditionTooltip()));
    },
    onDrawEnd(e) {
      this.hintTooltip && this.workingLayer && this.workingLayer.off("pm:vertexadded", this.onVertexAddedWhileEditing), this.hintMarker = null, this.hintTooltip = null;
    },
    onMouseMoveWhileEditing(e, t) {
      this.updateEditionTooltip(t);
    },
    onVertexAddedWhileEditing(e) {
      this.resetEditionTooltip();
    },
    async onEditFeatureProperties(e, t) {
      const i = t && t.target, n = a.get(i, "feature");
      this.layerEditMode !== "edit-properties" || !this.isLayerEdited(e) || !a.get(e, "schema.content") || !i || !n || (this.editedFeature = i, this.$router.push({
        name: "edit-map-layer-feature",
        query: this.$route.query,
        params: Object.assign(this.$route.params, {
          layerId: this.editedLayer._id,
          layerName: this.editedLayer.name,
          featureId: n._id,
          contextId: j.get("context")
        })
      }));
    },
    async onCreateFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "add-polygons" && this.layerEditMode !== "add-rectangles" && this.layerEditMode !== "add-lines" && this.layerEditMode !== "add-points" || !t) return;
      let i = t.toGeoJSON();
      if (this.createdFeature && this.createdFeature._id === i._id) return;
      const n = ti().toString();
      let r = a.get(this.editedLayer, "featureId");
      r = r && r !== "_id" ? "properties." + r : "_id", a.set(i, r, n), this.editedLayer._id ? i = await this.createFeatures(i, this.editedLayer) : (i._id = n, await G.getService("features-edition").create(i)), this.editableLayer.removeLayer(t), this.editableLayer.addData(i);
    },
    async onEditFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "edit-geometry" && this.layerEditMode !== "drag" && this.layerEditMode !== "rotate" || !t) return;
      const i = t.toGeoJSON();
      if (!(this.updatedFeature && this.updatedFeature._id === i._id))
        if (this.editedLayer._id)
          await this.editFeaturesGeometry(i, this.editedLayer);
        else {
          const n = Ne(i), r = G.getService("features-edition"), s = Promise.all(n.map((l) => r.patch(l._id, { geometry: l.geometry })));
          this.pendingOperations.push(s), await s;
          const o = this.pendingOperations.indexOf(s);
          this.pendingOperations.splice(o, 1);
        }
    },
    async onRemoveFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "remove" || !t || !e.target || e.target !== this.editableLayer) return;
      const i = t.toGeoJSON();
      if (!(this.removedFeature && this.removedFeature._id === i._id))
        if (this.editedLayer._id)
          await this.removeFeatures(i, this.editedLayer);
        else {
          const n = Ne(i), r = G.getService("features-edition");
          await Promise.all(n.map((s) => r.remove(s._id)));
        }
    },
    onMapZoomWhileEditing(e) {
      this.editableLayer && this.editableLayer.bringToFront();
    },
    onPointMoveEnd(e) {
      if (typeof e.layer.getLatLngs != "function") return;
      let t = e.layer.getLatLngs();
      for (let r = 0; r < e.indexPath.length; ++r)
        t = t[e.indexPath[r]];
      const i = this.editableLayer.pm._layers.findIndex((r) => r._leaflet_id === e.layer._leaflet_id), n = e.indexPath.slice(0, e.indexPath.length);
      n.splice(0, 0, i), this.onEditPointMoved(n, t, "user");
    },
    moveEditPoint(e, t, i, n) {
      if (!this.editingLayer) return;
      const r = B.latLng(t, i), s = e[0], o = e.slice(1, e.length), l = this.editableLayer.pm._layers[s], c = l.getLatLngs(), u = o.slice(0, o.length - 1), d = o[o.length - 1];
      let f = c;
      for (const g of u)
        f = f[g];
      f[d] = r, l.setLatLngs(c);
      let m = l.pm._markers;
      for (const g of o)
        m = m[g];
      m.setLatLng(r), this.onEditPointMoved(e, r, n || "app");
    },
    onEditPointMoved(e, t, i) {
      const n = {
        layer: this.editedLayer,
        pointPath: e,
        latitude: t.lat,
        longitude: t.lng,
        origin: i
      };
      this.$emit("edit-point-moved", n), this.$engineEvents.emit("edit-point-moved", n);
    },
    onEditedFeaturesCreated(e, t) {
      !mi(e) || !Yt(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.createdFeature = e, this.editableLayer.addData(e), this.createdFeature = null));
    },
    onEditedFeaturesUpdated(e, t) {
      !mi(e) || !Yt(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.updatedFeature = e, this.editableLayer.eachLayer((i) => {
        a.get(i, "feature._id") === e._id && (this.editableLayer.removeLayer(i), this.editableLayer.addData(e));
      }), this.updatedFeature = null));
    },
    onEditedFeaturesRemoved(e, t) {
      !mi(e) || !Yt(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.removedFeature = e, this.editableLayer.eachLayer((i) => {
        a.get(i, "feature._id") === e._id && this.editableLayer.removeLayer(i);
      }), this.removedFeature = null));
    }
  },
  created() {
    this.pendingOperations = [];
  }
}, q0 = {
  created() {
    this.registerStyle("point", Ao), this.registerStyle("line", Oo), this.registerStyle("polygon", Bo);
  }
}, j0 = {
  methods: {
    getDefaultTooltip(e, t, i, n) {
      const r = e.properties;
      let s;
      if (r) {
        const o = i.leaflet || i;
        if (a.has(o, "tooltip") && !a.get(o, "tooltip") || a.has(r, "tooltip") && !a.get(r, "tooltip")) return;
        const l = Object.assign(
          {},
          a.get(this, "activityOptions.engine.tooltip"),
          o.tooltip,
          r.tooltip
        ), c = a.get(o, "tooltip.minZoom"), u = a.get(o, "tooltip.maxZoom");
        if (u && n > u || c && n < c) return;
        let d = l.html;
        if (!d) {
          if (l.property)
            d = a.has(r, l.property) ? a.get(r, l.property) : a.get(e, l.property), d && typeof d.toString == "function" && (d = d.toString());
          else if (l.template) {
            const f = l.compiler;
            d = f({ properties: r, feature: e, $t: this.$t, Units: Me, Time: be, moment: he });
          }
        }
        d && (s = B.tooltip(l.options || { permanent: !1 }, t), s.setContent(d));
      }
      return s;
    }
  },
  created() {
    this.registerStyle("tooltip", this.getDefaultTooltip);
  }
}, U0 = {
  methods: {
    getDefaultPopup(e, t, i) {
      let n = e.properties, r;
      if (n) {
        const s = i.leaflet || i;
        if (a.has(s, "popup") && !a.get(s, "popup") || a.has(n, "popup") && !a.get(n, "popup")) return;
        const o = Object.assign(
          {},
          a.get(this, "activityOptions.engine.popup"),
          s.popup,
          n.popup
        );
        let l = o.html;
        if (!l)
          if (o.template) {
            const c = o.compiler;
            l = c({ properties: n, feature: e, $t: this.$t, Units: Me, Time: be, moment: he });
          } else o.pick ? n = a.pick(n, o.pick) : o.omit && (n = a.omit(n, o.omit));
        if (l || (l = Wu(n)), !l) return null;
        o.options ? r = B.popup(o.options, t) : r = B.popup({
          maxHeight: 400,
          maxWidth: 400,
          autoPan: !1
        }, t), r.setContent(l);
      }
      return r;
    }
  },
  created() {
    this.registerStyle("popup", this.getDefaultPopup);
  }
}, V0 = {
  methods: {
    async initializeMap(e) {
      this.map || (this.setupMap(e), await this.initialize(), this.map.on("moveend", this.storeView));
    },
    finalizeMap() {
      this.map.off("moveend", this.storeView);
    },
    storeView() {
      typeof this.storeContext == "function" && (a.get(this.centerAnimation, "id") || this.storeContext("view"));
    },
    onMapResized(e) {
      this.observe && (this.refreshMap(), this.mapContainer && (this.engineContainerWidth = this.mapContainer.getBoundingClientRect().width, this.engineContainerHeight = this.mapContainer.getBoundingClientRect().height));
    }
  },
  created() {
    this.engine = "leaflet", this.observe = !0;
  },
  beforeUnmount() {
    this.observe = !1, this.finalizeMap();
  }
};
var wl = {};
const yf = /* @__PURE__ */ new WeakMap(), Vs = /* @__PURE__ */ new WeakMap();
function Ce(e) {
  const t = yf.get(e);
  return console.assert(
    t != null,
    "'this' is expected an Event object, but got",
    e
  ), t;
}
function _l(e) {
  if (e.passiveListener != null) {
    typeof console < "u" && typeof console.error == "function" && console.error(
      "Unable to preventDefault inside passive event listener invocation.",
      e.passiveListener
    );
    return;
  }
  e.event.cancelable && (e.canceled = !0, typeof e.event.preventDefault == "function" && e.event.preventDefault());
}
function ji(e, t) {
  yf.set(this, {
    eventTarget: e,
    event: t,
    eventPhase: 2,
    currentTarget: e,
    canceled: !1,
    stopped: !1,
    immediateStopped: !1,
    passiveListener: null,
    timeStamp: t.timeStamp || Date.now()
  }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
  const i = Object.keys(t);
  for (let n = 0; n < i.length; ++n) {
    const r = i[n];
    r in this || Object.defineProperty(this, r, vf(r));
  }
}
ji.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return Ce(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return Ce(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return Ce(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const e = Ce(this).currentTarget;
    return e == null ? [] : [e];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return Ce(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const e = Ce(this);
    e.stopped = !0, typeof e.event.stopPropagation == "function" && e.event.stopPropagation();
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const e = Ce(this);
    e.stopped = !0, e.immediateStopped = !0, typeof e.event.stopImmediatePropagation == "function" && e.event.stopImmediatePropagation();
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return !!Ce(this).event.bubbles;
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return !!Ce(this).event.cancelable;
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    _l(Ce(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return Ce(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return !!Ce(this).event.composed;
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return Ce(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return Ce(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return Ce(this).stopped;
  },
  set cancelBubble(e) {
    if (!e)
      return;
    const t = Ce(this);
    t.stopped = !0, typeof t.event.cancelBubble == "boolean" && (t.event.cancelBubble = !0);
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !Ce(this).canceled;
  },
  set returnValue(e) {
    e || _l(Ce(this));
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
  }
};
Object.defineProperty(ji.prototype, "constructor", {
  value: ji,
  configurable: !0,
  writable: !0
});
typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(ji.prototype, window.Event.prototype), Vs.set(window.Event.prototype, ji));
function vf(e) {
  return {
    get() {
      return Ce(this).event[e];
    },
    set(t) {
      Ce(this).event[e] = t;
    },
    configurable: !0,
    enumerable: !0
  };
}
function K0(e) {
  return {
    value() {
      const t = Ce(this).event;
      return t[e].apply(t, arguments);
    },
    configurable: !0,
    enumerable: !0
  };
}
function G0(e, t) {
  const i = Object.keys(t);
  if (i.length === 0)
    return e;
  function n(r, s) {
    e.call(this, r, s);
  }
  n.prototype = Object.create(e.prototype, {
    constructor: { value: n, configurable: !0, writable: !0 }
  });
  for (let r = 0; r < i.length; ++r) {
    const s = i[r];
    if (!(s in e.prototype)) {
      const l = typeof Object.getOwnPropertyDescriptor(t, s).value == "function";
      Object.defineProperty(
        n.prototype,
        s,
        l ? K0(s) : vf(s)
      );
    }
  }
  return n;
}
function bf(e) {
  if (e == null || e === Object.prototype)
    return ji;
  let t = Vs.get(e);
  return t == null && (t = G0(bf(Object.getPrototypeOf(e)), e), Vs.set(e, t)), t;
}
function H0(e, t) {
  const i = bf(Object.getPrototypeOf(t));
  return new i(e, t);
}
function W0(e) {
  return Ce(e).immediateStopped;
}
function Z0(e, t) {
  Ce(e).eventPhase = t;
}
function Q0(e, t) {
  Ce(e).currentTarget = t;
}
function Ll(e, t) {
  Ce(e).passiveListener = t;
}
const wf = /* @__PURE__ */ new WeakMap(), xl = 1, Sl = 2, sr = 3;
function or(e) {
  return e !== null && typeof e == "object";
}
function fn(e) {
  const t = wf.get(e);
  if (t == null)
    throw new TypeError(
      "'this' is expected an EventTarget object, but got another value."
    );
  return t;
}
function J0(e) {
  return {
    get() {
      let i = fn(this).get(e);
      for (; i != null; ) {
        if (i.listenerType === sr)
          return i.listener;
        i = i.next;
      }
      return null;
    },
    set(t) {
      typeof t != "function" && !or(t) && (t = null);
      const i = fn(this);
      let n = null, r = i.get(e);
      for (; r != null; )
        r.listenerType === sr ? n !== null ? n.next = r.next : r.next !== null ? i.set(e, r.next) : i.delete(e) : n = r, r = r.next;
      if (t !== null) {
        const s = {
          listener: t,
          listenerType: sr,
          passive: !1,
          once: !1,
          next: null
        };
        n === null ? i.set(e, s) : n.next = s;
      }
    },
    configurable: !0,
    enumerable: !0
  };
}
function _f(e, t) {
  Object.defineProperty(
    e,
    `on${t}`,
    J0(t)
  );
}
function El(e) {
  function t() {
    Ut.call(this);
  }
  t.prototype = Object.create(Ut.prototype, {
    constructor: {
      value: t,
      configurable: !0,
      writable: !0
    }
  });
  for (let i = 0; i < e.length; ++i)
    _f(t.prototype, e[i]);
  return t;
}
function Ut() {
  if (this instanceof Ut) {
    wf.set(this, /* @__PURE__ */ new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0]))
    return El(arguments[0]);
  if (arguments.length > 0) {
    const e = new Array(arguments.length);
    for (let t = 0; t < arguments.length; ++t)
      e[t] = arguments[t];
    return El(e);
  }
  throw new TypeError("Cannot call a class as a function");
}
Ut.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(e, t, i) {
    if (t == null)
      return;
    if (typeof t != "function" && !or(t))
      throw new TypeError("'listener' should be a function or an object.");
    const n = fn(this), r = or(i), o = (r ? !!i.capture : !!i) ? xl : Sl, l = {
      listener: t,
      listenerType: o,
      passive: r && !!i.passive,
      once: r && !!i.once,
      next: null
    };
    let c = n.get(e);
    if (c === void 0) {
      n.set(e, l);
      return;
    }
    let u = null;
    for (; c != null; ) {
      if (c.listener === t && c.listenerType === o)
        return;
      u = c, c = c.next;
    }
    u.next = l;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(e, t, i) {
    if (t == null)
      return;
    const n = fn(this), s = (or(i) ? !!i.capture : !!i) ? xl : Sl;
    let o = null, l = n.get(e);
    for (; l != null; ) {
      if (l.listener === t && l.listenerType === s) {
        o !== null ? o.next = l.next : l.next !== null ? n.set(e, l.next) : n.delete(e);
        return;
      }
      o = l, l = l.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(e) {
    if (e == null || typeof e.type != "string")
      throw new TypeError('"event.type" should be a string.');
    const t = fn(this), i = e.type;
    let n = t.get(i);
    if (n == null)
      return !0;
    const r = H0(this, e);
    let s = null;
    for (; n != null; ) {
      if (n.once ? s !== null ? s.next = n.next : n.next !== null ? t.set(i, n.next) : t.delete(i) : s = n, Ll(
        r,
        n.passive ? n.listener : null
      ), typeof n.listener == "function")
        try {
          n.listener.call(this, r);
        } catch (o) {
          typeof console < "u" && typeof console.error == "function" && console.error(o);
        }
      else n.listenerType !== sr && typeof n.listener.handleEvent == "function" && n.listener.handleEvent(r);
      if (W0(r))
        break;
      n = n.next;
    }
    return Ll(r, null), Z0(r, 0), Q0(r, null), !r.defaultPrevented;
  }
};
Object.defineProperty(Ut.prototype, "constructor", {
  value: Ut,
  configurable: !0,
  writable: !0
});
typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(Ut.prototype, window.EventTarget.prototype);
class In extends Ut {
  /**
   * AbortSignal cannot be constructed directly.
   */
  constructor() {
    throw super(), new TypeError("AbortSignal cannot be constructed directly");
  }
  /**
   * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
   */
  get aborted() {
    const t = Fr.get(this);
    if (typeof t != "boolean")
      throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
    return t;
  }
}
_f(In.prototype, "abort");
function Y0() {
  const e = Object.create(In.prototype);
  return Ut.call(e), Fr.set(e, !1), e;
}
function X0(e) {
  Fr.get(e) === !1 && (Fr.set(e, !0), e.dispatchEvent({ type: "abort" }));
}
const Fr = /* @__PURE__ */ new WeakMap();
Object.defineProperties(In.prototype, {
  aborted: { enumerable: !0 }
});
typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(In.prototype, Symbol.toStringTag, {
  configurable: !0,
  value: "AbortSignal"
});
let Dr = class {
  /**
   * Initialize this controller.
   */
  constructor() {
    Lf.set(this, Y0());
  }
  /**
   * Returns the `AbortSignal` object associated with this object.
   */
  get signal() {
    return Cl(this);
  }
  /**
   * Abort and signal to any observers that the associated activity is to be aborted.
   */
  abort() {
    X0(Cl(this));
  }
};
const Lf = /* @__PURE__ */ new WeakMap();
function Cl(e) {
  const t = Lf.get(e);
  if (t == null)
    throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${e === null ? "null" : typeof e}`);
  return t;
}
Object.defineProperties(Dr.prototype, {
  signal: { enumerable: !0 },
  abort: { enumerable: !0 }
});
typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Dr.prototype, Symbol.toStringTag, {
  configurable: !0,
  value: "AbortController"
});
const ew = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortController: Dr,
  AbortSignal: In,
  default: Dr
}, Symbol.toStringTag, { value: "Module" })), tw = /* @__PURE__ */ pv(ew);
var Tl;
function iw() {
  if (Tl) return wl;
  Tl = 1;
  const e = tw, t = typeof self < "u" ? self : typeof window < "u" ? window : typeof Va < "u" ? Va : (
    /* otherwise */
    void 0
  );
  return t && (typeof t.AbortController > "u" && (t.AbortController = e.AbortController), typeof t.AbortSignal > "u" && (t.AbortSignal = e.AbortSignal)), wl;
}
iw();
Ee.settings.PREFER_ENV = Ee.ENV.WEBGL2;
Ee.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
(function() {
  const e = new Float32Array(1), t = new Int32Array(e.buffer);
  return function(n) {
    e[0] = n;
    const r = t[0];
    let s = r >> 16 & 32768, o = r >> 12 & 2047;
    const l = r >> 23 & 255;
    return l < 103 ? s : l > 142 ? (s |= 31744, s |= (l === 255 ? 0 : 1) && r & 8388607, s) : l < 113 ? (o |= 2048, s |= (o >> 114 - l) + (o >> 113 - l & 1), s) : (s |= l - 112 << 10 | o >> 1, s += o & 1, s);
  };
})();
const Ls = {
  latLonToWebMercator: `vec2 latLonToWebMercator(vec3 latLonZoom) {
  const float d = 3.14159265359 / 180.0;
  const float maxLat = 85.0511287798;     // max lat using Web Mercator, used by EPSG:3857 CRS
  const float R = 6378137.0;              // earth radius

  // project
  // float lat = max(min(maxLat, latLonZoom[0]), -maxLat);
  float lat = clamp(latLonZoom[0], -maxLat, maxLat);
  float sla = sin(lat * d);
  vec2 point = vec2(R * latLonZoom[1] * d, R * log((1.0 + sla) / (1.0 - sla)) / 2.0);

  // scale
  float scale = 256.0 * pow(2.0, latLonZoom[2]);

  // transform
  const float s = 0.5 / (3.14159265359 * R);
  const vec4 abcd = vec4(s, 0.5, -s, 0.5);

  return scale * ((point * abcd.xz) + abcd.yw);
}`,
  unpack2: `vec2 unpack2(vec2 v, vec4 offsetScale) {
  return offsetScale.xy + v * offsetScale.zw;
}`,
  rgbFromFloat: `vec4 rgbFromFloat(float v) {
  const uint mask = uint(0xFF);
  uint asuint = floatBitsToUint(v);
  return vec4(asuint & mask, (asuint >> 8) & mask, (asuint >> 16) & mask, (asuint >> 24) & mask) / vec4(255.0);
}`
};
Ee.TYPES.HALF_FLOAT_VERTEX = 5131;
function Pl(e) {
  let t = `#version 300 es
precision highp float;`, i = `#version 300 es
precision highp float;`;
  t += `

/// attributes, uniforms and varyings
`, i += `

/// uniforms and varyings
out vec4 outColor;
`;
  for (const n of e) {
    let r = "", s = "";
    for (const o of a.get(n, "vertex.attributes", [])) r += `in ${o};
`;
    for (const o of a.get(n, "vertex.uniforms", [])) r += `uniform ${o};
`;
    for (const o of a.get(n, "fragment.uniforms", [])) s += `uniform ${o};
`;
    for (const o of a.get(n, "varyings", []))
      r += `out ${o};
`, s += `in ${o};
`;
    r && (t += `// ${n.name} ------
${r}`), s && (i += `// ${n.name} ------
${s}`);
  }
  t += `
/// additional functions
`, i += `
/// additional functions
`;
  for (const n of e) {
    for (const r of a.get(n, "vertex.functions", [])) t += `// ${n.name} ------
${r}
`;
    for (const r of a.get(n, "fragment.functions", [])) i += `// ${n.name} ------
${r}
`;
  }
  t += `
/// vertex shader code
void main()
{
`, i += `
/// fragment shader code
void main()
{
`;
  for (const n of e) {
    const r = a.get(n, "vertex.code"), s = a.get(n, "fragment.code");
    r && (t += `// ${n.name} ------
${r}
`), s && (i += `// ${n.name} ------
${s}
`);
  }
  return t += "}", i += "}", [t, i];
}
function xf(e, t, i) {
  for (let r = 1; r < e.length; ++r)
    if (e[r - 1] > e[r])
      throw new Error("Threshold array is not correctly sorted, color map shader code will be buggy!");
  let n = `vec4 ColorMap(float value) {
`;
  for (let r = 0; r < t.length; ++r)
    n += `  const vec4 color${r} = vec4(${t[r].join(",")});
`;
  if (n += `
`, i) {
    n += `  if (value < float(${e[0]})) { return color0; }
`;
    for (let r = 1; r < e.length; ++r) {
      const s = e[r - 1], o = e[r], l = o - s;
      n += `  if (value <= float(${o})) { float t = (value - float(${s})) / float(${l}); return mix(color${r - 1}, color${r}, t); }
`;
    }
    n += `  return color${t.length - 1};
`;
  } else {
    for (let r = 1; r < e.length - 1; ++r) {
      const s = e[r];
      n += `  if (value < float(${s})) { return color${r - 1}; }
`;
    }
    n += `  return color${t.length - 1};
`;
  }
  return n += "}", n;
}
function nw(e, t, i = !1) {
  let n = [], r = t.slice();
  if (e.length === t.length)
    n = e.slice();
  else if (e.length < t.length) {
    const s = (e[e.length - 1] - e[0]) / (t.length - 1);
    for (let o = 0; o < t.length; ++o)
      n.push(e[0] + o * s);
  }
  return n[0] > n[n.length - 1] && (n = n.reverse(), i = !i), i && (r = r.reverse()), xf(n, r, !0);
}
function rw(e, t, i) {
  let n = e.slice(), r = t.slice();
  return n[0] > n[n.length - 1] && (n = n.reverse(), i = !i), i && (r = r.reverse()), xf(n, r, !1);
}
const xs = B.GridLayer.extend({
  initialize(e, t) {
    this.conf = {}, this.conf.chromajs = e.chromajs, this.conf.render = {
      cutOver: e.cutOver,
      cutUnder: e.cutUnder,
      pixelColorMapping: e.pixelColorMapping,
      showWireframe: e.showWireframe,
      enableCulling: a.get(e, "enableCulling", !0)
    }, this.conf.debug = {
      showTileInfos: e.showTileInfos,
      meshAsPoints: e.meshAsPoints,
      showShader: e.showShader
    }, this.conf.resolutionScale = a.get(e, "resolutionScale", [1, 1]), B.GridLayer.prototype.initialize.call(this, e), this.pixiRoot = new Ee.Container(), this.pixiLayer = B.pixiOverlay(
      (i) => this.renderPixiLayer(i),
      this.pixiRoot,
      { destroyInteractionManager: !0, shouldRedrawOnMove: function() {
        return !0;
      } }
    ), this.layerUniforms = new Ee.UniformGroup({ in_layerAlpha: e.opacity, in_zoomLevel: 1 }), this.pixiState = new Ee.State(), this.pixiState.culling = this.conf.render.enableCulling, this.pixiState.blendMode = Ee.BLEND_MODES.SCREEN, this.cutValueUniform = null, e.cutOver && (this.layerUniforms.uniforms.in_cutOver = 0, e.cutOver === "levels" ? this.cutValueUniform = "in_cutOver" : this.layerUniforms.uniforms.in_cutOver = e.cutOver), e.cutUnder && (this.layerUniforms.uniforms.in_cutUnder = 0, e.cutUnder === "levels" ? this.cutValueUniform = "in_cutUnder" : this.layerUniforms.uniforms.in_cutUnder = e.cutUnder), this.on("tileload", (i) => {
      this.onTileLoad(i);
    }), this.on("tileunload", (i) => {
      this.onTileUnload(i);
    }), this.gridSource = t, this.onDataChangedCallback = this.onDataChanged.bind(this), this.gridSource.on("data-changed", this.onDataChangedCallback);
  },
  onAdd(e) {
    e.addLayer(this.pixiLayer), this.layerUniforms.uniforms.in_zoomLevel = this.pixiLayer._initialZoom, this.zoomStartCallback = this.onZoomStart.bind(this), this.zoomEndCallback = this.onZoomEnd.bind(this), e.on("zoomstart", this.zoomStartCallback), e.on("zoomend", this.zoomEndCallback), B.GridLayer.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    e.off("zoomstart", this.zoomStartCallback), e.off("zoomend", this.zoomEndCallback), this.zoomStartCallback = null, this.zoomEndCallback = null, e.removeLayer(this.pixiLayer), B.GridLayer.prototype.onRemove.call(this, e);
  },
  createTile(e, t) {
    const i = document.createElement("div"), n = this._tileCoordsToBounds(e), r = [n.getSouth(), n.getWest(), n.getNorth(), n.getEast()], s = this.getTileSize(), o = [
      this.conf.resolutionScale[0] * ((r[2] - r[0]) / (s.y - 1)),
      this.conf.resolutionScale[1] * ((r[3] - r[1]) / (s.x - 1))
    ];
    return i.fetchController = new AbortController(), this.gridSource.fetch(i.fetchController.signal, r, o).then((l) => {
      if (i.fetchController = null, l)
        if (l.hasData()) {
          const { coords: c, minLat: u, minLon: d, deltaLat: f, deltaLon: m } = l.genCoordsBuffer(), g = l.genValuesBuffer(), v = l.genMeshIndexBuffer(), x = new Ee.Geometry().addAttribute("in_layerCoord", c, 2, !1, Ee.TYPES.HALF_FLOAT_VERTEX).addAttribute("in_layerValue", g, 1, !1, Ee.TYPES.FLOAT).addIndex(v), S = {
            in_layerBounds: Float32Array.from(r),
            in_layerOffsetScale: Float32Array.of(u, d, f, m),
            layerUniforms: this.layerUniforms
          };
          l.nodata !== void 0 && (S.in_nodata = l.nodata);
          const A = new Ee.Shader(this.program, S), p = this.conf.debug.meshAsPoints ? Ee.DRAW_MODES.POINTS : Ee.DRAW_MODES.TRIANGLE_STRIP;
          if (i.mesh = new Ee.Mesh(x, A, this.pixiState, p), this.conf.render.showWireframe) {
            const y = new Ee.Geometry().addAttribute("in_layerCoord", x.getBuffer("in_layerCoord"), 2, !1, Ee.TYPES.HALF_FLOAT_VERTEX).addIndex(l.genWireframeIndexBuffer()), w = new Ee.Shader(this.wireframeProgram, S);
            i.wireframe = new Ee.Mesh(y, w, this.pixiState, Ee.DRAW_MODES.LINE_STRIP);
          }
          this.conf.debug.showTileInfos && (i.innerHTML = `leaflet tile is ${s.y} x ${s.x} pixels</br>
                 covering ${r[0].toPrecision(6)},${r[1].toPrecision(6)} to ${r[2].toPrecision(6)},${r[3].toPrecision(6)}</br>
                 req res: ${o[0].toPrecision(4)} ${o[1].toPrecision(4)}</br>
                 mesh is made of ${g.length} points`, i.style.outline = "1px solid green");
        } else this.conf.debug.showTileInfos && (i.style.outline = "1px solid red", i.innerHTML = "no data here (grid maybe full of nodata)!");
      else this.conf.debug.showTileInfos && (i.style.outline = "1px solid red", i.innerHTML = "no data here (grid source returned null grid)!");
      t(null, i);
    }).catch((l) => {
      I.error(l), t(l, i);
    }), i;
  },
  onTileLoad(e) {
    const t = e.tile.mesh;
    if (t) {
      if (t.zoomLevel = e.coords.z, t.visible = t.zoomLevel === this._map.getZoom(), this.pixiRoot.addChild(t), this.conf.render.showWireframe) {
        const i = e.tile.wireframe;
        i.zoomLevel = t.zoomLevel, i.visible = t.visible, this.pixiRoot.addChild(i);
      }
      t.visible && this.pixiLayer.redraw();
    }
  },
  onTileUnload(e) {
    e.tile.fetchController && (e.tile.fetchController.abort(), e.tile.fetchController = null), e.tile.mesh && (this.pixiRoot.removeChild(e.tile.mesh), this.conf.render.showWireframe && (this.pixiRoot.removeChild(e.tile.wireframe), e.tile.wireframe.destroy(), e.tile.wireframe = null), e.tile.mesh.visible && this.pixiLayer.redraw(), e.tile.mesh.destroy(), e.tile.mesh = null);
  },
  onZoomStart(e) {
    const t = this._map.getZoom();
    for (const i of this.pixiRoot.children)
      i.zoomLevel === t && (i.visible = !1);
  },
  onZoomEnd(e) {
    const t = this._map.getZoom();
    for (const i of this.pixiRoot.children)
      i.zoomLevel === t && (i.visible = !0);
    this.pixiLayer.redraw();
  },
  onDataChanged() {
    const e = this.gridSource.getBBox();
    if (e) {
      const t = B.latLng(e[0], e[1]), i = B.latLng(e[2], e[3]);
      this.options.bounds = B.latLngBounds(t, i);
    }
    this.updateColorMap(), this.updateShader(), this.redraw(), this.colorMap && (this.fire("data"), this.hasData = !0);
  },
  updateColorMap() {
    const e = this.conf.chromajs;
    if (a.isNil(e)) return;
    this.colorMap = null, this.colorMapShaderCode = null;
    const t = e.classes;
    let i;
    t || (i = e.domain, i || (i = this.gridSource.getDataBounds()));
    const r = Xt.scale(e.colors).colors().map((s) => Xt(s).gl());
    this.colorMap = Fn(e), i ? this.colorMapShaderCode = nw(i, r) : t && (this.colorMapShaderCode = rw(t, r));
  },
  updateShader() {
    const e = [
      // feature projecting layer position
      {
        name: "layerCoord",
        varyings: ["vec2 frg_layerCoord"],
        vertex: {
          attributes: ["vec2 in_layerCoord"],
          uniforms: ["mat3 translationMatrix", "mat3 projectionMatrix", "float in_zoomLevel", "vec4 in_layerOffsetScale"],
          functions: [Ls.latLonToWebMercator, Ls.unpack2],
          code: `  frg_layerCoord = unpack2(in_layerCoord, in_layerOffsetScale);
  vec2 projected = latLonToWebMercator(vec3(frg_layerCoord, in_zoomLevel));
  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(projected, 1.0)).xy, 0.0, 1.0);
  ${this.conf.debug.meshAsPoints ? "gl_PointSize = 10.0;" : ""}`
        },
        fragment: {
          uniforms: ["vec4 in_layerBounds"],
          code: `  bvec4 outside = bvec4(lessThan(frg_layerCoord, in_layerBounds.xy), greaterThan(frg_layerCoord, in_layerBounds.zw));
  if (any(outside)) discard;`
        }
      },
      // feature defining layer's scalar value
      {
        name: "layerValue",
        varyings: ["float frg_layerValue"],
        vertex: {
          attributes: ["float in_layerValue"],
          code: "  frg_layerValue = in_layerValue;"
        }
      }
    ];
    this.conf.render.cutOver && e.push({
      name: "cutOver",
      fragment: {
        uniforms: ["float in_cutOver"],
        code: "  if (frg_layerValue > in_cutOver) discard;"
      }
    }), this.conf.render.cutUnder && e.push({
      name: "cutUnder",
      fragment: {
        uniforms: ["float in_cutUnder"],
        code: "  if (frg_layerValue < in_cutUnder) discard;"
      }
    }), this.gridSource.supportsNoData() && e.push({
      name: "nodata",
      varyings: ["float frg_validValue"],
      vertex: {
        uniforms: ["float in_nodata"],
        code: "  frg_validValue = (in_layerValue == in_nodata ? 0.0 : 1.0);"
      },
      fragment: {
        code: "  if (frg_validValue != 1.0) discard;"
      }
    }), this.colorMapShaderCode ? this.conf.render.pixelColorMapping ? e.push({
      name: "colormap",
      fragment: {
        functions: [this.colorMapShaderCode],
        code: "  vec4 color = ColorMap(frg_layerValue);"
      }
    }) : e.push({
      name: "colormap",
      varyings: ["vec4 frg_color"],
      vertex: {
        functions: [this.colorMapShaderCode],
        code: "  frg_color = ColorMap(frg_layerValue);"
      },
      fragment: {
        code: "  vec4 color = frg_color;"
      }
    }) : e.push({
      name: "colormap",
      varyings: ["vec4 frg_color"],
      vertex: {
        functions: [Ls.rgbFromFloat],
        code: "  frg_color = rgbFromFloat(frg_layerValue);"
      },
      fragment: {
        code: "  vec4 color = frg_color;"
      }
    }), e.push({
      name: "tail",
      fragment: {
        uniforms: ["float in_layerAlpha"],
        code: "  outColor = vec4(color.rgb * in_layerAlpha, in_layerAlpha);"
      }
    });
    const [t, i] = Pl(e);
    if (this.program = new Ee.Program(t, i), this.conf.render.showWireframe) {
      const [n, r] = Pl([e[0], {
        name: "tail",
        fragment: {
          uniforms: ["float in_layerAlpha"],
          code: "  outColor = vec4(0.0, 0.0, 0.0, in_layerAlpha);"
        }
      }]);
      this.wireframeProgram = new Ee.Program(n, r);
    }
    this.conf.debug.showShader && (console.log("Generated vertex shader:"), console.log(t), console.log("Generated fragment shader:"), console.log(i));
  },
  renderPixiLayer(e) {
    e.getRenderer().render(this.pixiRoot);
  },
  setLevel(e) {
    this.cutValueUniform ? (this.layerUniforms.uniforms[this.cutValueUniform] = e, this.pixiLayer.redraw()) : typeof this.gridSource.setLevel == "function" && (this._resetView(), this.gridSource.setLevel(e));
  },
  setTime(e) {
    typeof this.gridSource.setTime == "function" && (this._resetView(), this.gridSource.setTime(e));
  },
  setModel(e) {
    typeof this.gridSource.setModel == "function" && (this._resetView(), this.gridSource.setModel(e));
  },
  getBounds() {
    const e = this.options.bounds ? this.options.bounds : B.latLngBounds(B.latLng(-90, -180), B.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(e) : e;
  }
}), sw = {
  methods: {
    async createLeafletTiledMeshLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tiledMeshLayer") return;
      const i = a.get(e, "variables[0].chromajs", null);
      i && Object.assign(t, { chromajs: i });
      const [n, r] = $n(e), s = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : this.getWeacastApi(), o = s.hasConfig("gatewayJwt") ? await s.get("storage").getItem(s.getConfig("gatewayJwt")) : null, l = qi(n, { weacastApi: s, apiToken: o });
      return l.setup(r), l.updateCtx && (o && (l.updateCtx.jwtToken = o), l.updateCtx.meteoElements = a.get(e, "meteoElements")), new xs(t, l);
    },
    updateTiledMeshLayerZoomBounds(e, t) {
      const i = a.get(e, `leaflet.meteoModelMinZoom[${t.name}]`), n = a.get(e, `leaflet.meteoModelMaxZoom[${t.name}]`);
      i ? e.leaflet.minZoom = i : delete e.leaflet.minZoom, n ? e.leaflet.maxZoom = n : delete e.leaflet.maxZoom, this.updateLayerDisabled(e);
      const r = this.getLeafletLayerByName(e.name);
      r && (i ? r.options.minZoom = i : delete r.options.minZoom, n ? r.options.maxZoom = n : delete r.options.maxZoom);
    },
    onAddTiledMeshLayer(e) {
      !this.forecastModel || a.get(e, "leaflet.type") !== "tiledMeshLayer" || this.updateTiledMeshLayerZoomBounds(e, this.forecastModel);
    },
    onShowTiledMeshLayer(e, t) {
      t instanceof xs && (this.tiledMeshLayers.set(e._id, t), t.setModel(this.forecastModel), t.setTime(be.getCurrentTime()));
    },
    onHideTiledMeshLayer(e, t) {
      t instanceof xs && this.tiledMeshLayers.delete(e._id);
    },
    onSelectedLevelChangedTiledMeshLayer(e) {
      if (!this.selectableLevelsLayer) return;
      const t = this.tiledMeshLayers.get(this.selectableLevelsLayer._id);
      t && t.setLevel(e);
    },
    onForecastModelChangedTiledMeshLayer(e) {
      const t = a.filter(this.layers, (i) => a.get(i, "leaflet.type") === "tiledMeshLayer");
      for (const i of t) this.updateTiledMeshLayerZoomBounds(i, e);
      this.tiledMeshLayers.forEach((i) => {
        i.setModel(e);
      });
    },
    onCurrentTimeChangedTiledMeshLayer(e) {
      this.tiledMeshLayers.forEach((t) => {
        t.setTime(e);
      });
    }
  },
  created() {
    this.tiledMeshLayers = /* @__PURE__ */ new Map(), this.registerLeafletConstructor(this.createLeafletTiledMeshLayer), this.$engineEvents.on("layer-added", this.onAddTiledMeshLayer), this.$engineEvents.on("layer-shown", this.onShowTiledMeshLayer), this.$engineEvents.on("layer-hidden", this.onHideTiledMeshLayer), this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer), this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledMeshLayer), this.$engineEvents.off("layer-shown", this.onShowTiledMeshLayer), this.$engineEvents.off("layer-hidden", this.onHideTiledMeshLayer), this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer), this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer), ne.off("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  }
}, Ss = B.GridLayer.extend({
  initialize(e, t, i) {
    this.conf = {}, this.conf.enableDebug = a.get(e, "enabledDebug", !1), this.conf.resolutionScale = a.get(e, "resolutionScale", [1, 1]), this.conf.meteoModelOverride = a.get(e, "meteoModelOverride"), B.GridLayer.prototype.initialize.call(this, e), this.userIsDragging = !1, this.pendingFetchs = 0, this.loadedTiles = /* @__PURE__ */ new Set();
    const n = a.get(e, "chromajs");
    this.colorMap = Fn(n), this.uSource = t, this.vSource = i, this.onDataChangedCallback = this.onDataChanged.bind(this), this.uSource.on("data-changed", this.onDataChangedCallback), this.vSource.on("data-changed", this.onDataChangedCallback), this.numDataChanged = 0;
    const r = Object.assign({
      displayValues: !1,
      minVelocity: this.colorMap.domain()[0],
      maxVelocity: this.colorMap.domain()[1],
      velocityScale: 0.01,
      colorScale: this.colorMap.colors(),
      data: null
    }, e);
    this.velocityLayer = B.velocityLayer(r), this.velocityLayer.onDrawLayer = (s, o) => {
      if (this._map && this.velocityLayer._windy) {
        let l = !0;
        const c = this._map.getZoom();
        this.options.maxZoom && c > this.options.maxZoom && (l = !1), this.options.minZoom && c < this.options.minZoom && (l = !1), this.pendingFetchs === 0 && !this.userIsDragging && l ? this.velocityLayer._clearAndRestart() : this.velocityLayer._clearWind();
      }
    }, this.uFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 2
      },
      data: []
    }, this.vFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 3
      },
      data: []
    };
  },
  getEvents() {
    const e = B.GridLayer.prototype.getEvents.call(this), t = e.dragstart;
    e.dragstart = (n) => {
      this.userIsDragging = !0, t && t.call(this, n);
    };
    const i = e.dragend;
    return e.dragend = (n) => {
      this.userIsDragging = !1, i && i.call(this, n);
    }, e;
  },
  setTime(e) {
    const t = typeof this.uSource.setTime == "function", i = typeof this.vSource.setTime == "function";
    (t || i) && (this.pendingAdd || this._resetView(), t && this.uSource.setTime(e), i && this.vSource.setTime(e));
  },
  setLevel(e) {
    const t = typeof this.uSource.setLevel == "function", i = typeof this.vSource.setLevel == "function";
    (t || i) && (this.pendingAdd || this._resetView(), t && this.uSource.setLevel(e), i && this.vSource.setLevel(e));
  },
  setModel(e) {
    const t = {
      nx: e.size[0],
      ny: e.size[1],
      lo1: e.origin[0],
      la1: e.origin[1],
      dx: e.resolution[0],
      dy: e.resolution[1]
    };
    if (this.conf.meteoModelOverride) {
      const s = this.conf.meteoModelOverride[e.name];
      s && Object.assign(t, s);
    }
    Object.assign(this.uFlow.header, t), Object.assign(this.vFlow.header, t);
    const i = t.nx * t.ny;
    this.uFlow.data = new Array(i), this.vFlow.data = new Array(i);
    for (let s = 0; s < i; ++s) this.uFlow.data[s] = this.vFlow.data[s] = 0;
    const n = typeof this.uSource.setModel == "function", r = typeof this.vSource.setModel == "function";
    (n || r) && (this.pendingAdd || this._resetView(), n && this.uSource.setModel(e), r && this.vSource.setModel(e));
  },
  onDataChanged() {
    if (++this.numDataChanged, this.numDataChanged !== 2) return;
    this.numDataChanged = 0, this.loadedTiles.clear();
    const e = [], t = this.vSource.getBBox();
    t && (e.push(B.latLng(t[0], t[1])), e.push(B.latLng(t[2], t[3])));
    const i = this.uSource.getBBox();
    i && (e.push(B.latLng(i[0], i[1])), e.push(B.latLng(i[2], i[3]))), this.options.bounds = e.length ? B.latLngBounds(e) : null, this.pendingAdd ? this.onPendingAdd() : this.redraw(), this.fire("data"), this.hasData = !0;
  },
  onAdd(e) {
    this.pendingAdd = e;
  },
  onPendingAdd() {
    const e = this.pendingAdd;
    this.loadedTiles.clear(), B.GridLayer.prototype.onAdd.call(this, e), e.addLayer(this.velocityLayer), this.velocityLayer.setData([this.uFlow, this.vFlow]), this.velocityLayer._initWindy(this.velocityLayer), this._map.off("dragstart", this.velocityLayer._windy.stop), this._map.off("dragend", this.velocityLayer._clearAndRestart), this.pendingAdd = null;
  },
  onRemove(e) {
    this.pendingAdd ? this.pendingAdd = null : (e.removeLayer(this.velocityLayer), B.GridLayer.prototype.onRemove.call(this, e)), this.uSource.invalidate(), this.vSource.invalidate(), this.loadedTiles.clear();
  },
  updateWindArray(e, t, i, n) {
    const [r, s, o, l] = e.getBestFit(i), c = e.getLat(r), u = e.getLon(s), d = Math.round((u - t.header.lo1) / t.header.dy), f = Math.round((t.header.la1 - c) / t.header.dx);
    for (let m = s; m <= l; ++m)
      for (let g = r; g <= o; ++g) {
        const v = e.getValue(g, m);
        let x = d + (m - s), S = f - (g - r);
        x < 0 && (x += t.header.nx), S < 0 && (S += t.header.ny);
        const A = x + S * t.header.nx;
        t.data[A] = v;
      }
  },
  createTile(e) {
    const t = document.createElement("div"), i = od(this.loadedTiles, e);
    if (this.conf.enableDebug && (t.style.outline = "1px solid blue", t.innerHTML = `${e.x} ${e.y} ${e.z} :`), i)
      this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += " skipped");
    else {
      this.conf.enableDebug && (t.innerHTML += " requested");
      const n = this._tileCoordsToBounds(e), r = [n.getSouth(), n.getWest(), n.getNorth(), n.getEast()], s = this.getTileSize(), o = [
        this.conf.resolutionScale[0] * ((r[2] - r[0]) / (s.y - 1)),
        this.conf.resolutionScale[1] * ((r[3] - r[1]) / (s.x - 1))
      ], l = this.uSource.fetch(null, r, o), c = this.vSource.fetch(null, r, o);
      ++this.pendingFetchs;
      const u = () => {
        --this.pendingFetchs, this.pendingFetchs === 0 && !this.userIsDragging && (this.velocityLayer._clearAndRestart(), this.conf.enableDebug && (t.innerHTML += ", triggered wind restart"));
      };
      Promise.all([l, c]).then((d) => {
        const f = d[0], m = d[1];
        f && m ? f.sourceKey === this.uSource.sourceKey && m.sourceKey === this.vSource.sourceKey ? (this.updateWindArray(f, this.uFlow, r), this.updateWindArray(m, this.vFlow, r), this.loadedTiles.add(Pt(e)), this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += ", added to loadedTiles")) : this.conf.enableDebug && (t.style.outline = "1px solid red", t.innerHTML += ", discarded (out of date)") : this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += ", empty"), u();
      }).catch((d) => {
        throw this.conf.enableDebug && (t.style.outline = "1px solid red", t.innerHTML += `, failed (${d})`), u(), d;
      });
    }
    return t;
  },
  redraw() {
    this.loadedTiles.clear(), this.velocityLayer._clearWind(), this.uFlow.data.fill(0), this.vFlow.data.fill(0), B.GridLayer.prototype.redraw.call(this);
  },
  getBounds() {
    const e = this.options.bounds ? this.options.bounds : B.latLngBounds(B.latLng(-90, -180), B.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(e) : e;
  }
}), ow = {
  methods: {
    async createLeafletTiledWindLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tiledWindLayer") return;
      const i = a.get(e, "variables[0].chromajs", null);
      i && Object.assign(t, { chromajs: i });
      const [n, r] = $n(e), s = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : this.getWeacastApi(), o = qi(n, { weacastApi: s }), l = qi(n, { weacastApi: s });
      if (o.setup(r), l.setup(r), o.updateCtx) {
        const c = s.hasConfig("gatewayJwt") ? await s.get("storage").getItem(s.getConfig("gatewayJwt")) : null;
        c && (o.updateCtx.jwtToken = c, l.updateCtx.jwtToken = c), o.updateCtx.windComponent = a.get(e, "meteoElements[0]"), l.updateCtx.windComponent = a.get(e, "meteoElements[1]");
      }
      return new Ss(t, o, l);
    },
    updateTiledWindLayerZoomBounds(e, t) {
      const i = a.get(e, `leaflet.meteoModelMinZoom[${t.name}]`), n = a.get(e, `leaflet.meteoModelMaxZoom[${t.name}]`);
      i ? e.leaflet.minZoom = i : delete e.leaflet.minZoom, n ? e.leaflet.maxZoom = n : delete e.leaflet.maxZoom, this.updateLayerDisabled(e);
      const r = this.getLeafletLayerByName(e.name);
      r && (i ? r.options.minZoom = i : delete r.options.minZoom, n ? r.options.maxZoom = n : delete r.options.maxZoom);
    },
    onAddTiledWindLayer(e) {
      !this.forecastModel || a.get(e, "leaflet.type") !== "tiledWindLayer" || this.updateTiledWindLayerZoomBounds(e, this.forecastModel);
    },
    onShowTiledWindLayer(e, t) {
      t instanceof Ss && (this.tiledWindLayers.set(e._id, t), t.setModel(this.forecastModel), t.setTime(be.getCurrentTime()));
    },
    onHideTiledWindLayer(e, t) {
      t instanceof Ss && this.tiledWindLayers.delete(e._id);
    },
    onForecastModelChangedTiledWindLayer(e) {
      const t = a.filter(this.layers, (i) => a.get(i, "leaflet.type") === "tiledWindLayer");
      for (const i of t) this.updateTiledWindLayerZoomBounds(i, e);
      this.tiledWindLayers.forEach((i) => {
        i.setModel(e);
      });
    },
    onCurrentTimeChangedTiledWindLayer(e) {
      this.tiledWindLayers.forEach((t) => {
        t.setTime(e);
      });
    },
    onSelectedLevelChangedTiledWindLayer(e) {
      if (!this.selectableLevelsLayer) return;
      const t = this.tiledWindLayers.get(this.selectableLevelsLayer._id);
      t && t.setLevel(e);
    }
  },
  created() {
    this.tiledWindLayers = /* @__PURE__ */ new Map(), this.registerLeafletConstructor(this.createLeafletTiledWindLayer), this.$engineEvents.on("layer-added", this.onAddTiledWindLayer), this.$engineEvents.on("layer-shown", this.onShowTiledWindLayer), this.$engineEvents.on("layer-hidden", this.onHideTiledWindLayer), this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer), this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledWindLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledWindLayer), this.$engineEvents.off("layer-shown", this.onShowTiledWindLayer), this.$engineEvents.off("layer-hidden", this.onHideTiledWindLayer), this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer), this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledWindLayer), ne.off("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  }
}, aw = {
  methods: {
    async createLeafletHeatmapLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "heatmap") return;
      const i = this.createLeafletLayer(e), n = a.get(t, "url"), r = a.get(t, "urlTemplate");
      r && (i.sourceCompiler = a.template(r));
      const s = a.get(t, "valueTemplate");
      if (s && (i.valueCompiler = a.template(s)), e.service) {
        i.lastUpdateTime = be.getCurrentTime().clone();
        const o = await this.getFeatures(e);
        this.updateLeafletHeatmap(i, o);
      } else if (a.isNil(n)) {
        if (!a.isNil(r)) {
          const o = i.sourceCompiler({ time: be.getCurrentTime() });
          i.lastFetchedSource = o;
          const l = await Oi(o, e);
          this.updateLeafletHeatmap(i, l);
        }
      } else {
        const o = await Oi(n, e);
        this.updateLeafletHeatmap(i, o);
      }
      return i;
    },
    updateLeafletHeatmap(e, t) {
      const i = a.get(e, "cfg.valueField", "value"), n = a.get(e, "cfg.min"), r = a.get(e, "cfg.max"), s = e.valueCompiler ? t.features.map((o) => a.toNumber(e.valueCompiler({ properties: o.properties, feature: o }))) : t.features.map((o) => a.toNumber(a.get(o, `properties.${i}`, 1)));
      e.setData({
        min: n || (i ? a.min(s) : 0),
        max: r || (i ? a.max(s) : 1),
        data: t.features.map((o, l) => {
          const c = hi(o);
          return {
            lng: a.get(c, "geometry.coordinates[0]"),
            lat: a.get(c, "geometry.coordinates[1]"),
            [i]: s[l]
          };
        })
      });
    },
    updateHeatmap(e, t) {
      const i = this.getLeafletLayerByName(e);
      i && this.updateLeafletHeatmap(i, t);
    },
    onCurrentTimeChangedHeatmapLayers(e) {
      a.values(this.layers).filter(Te({
        "leaflet.type": "heatmap",
        $or: [
          // Supported by template URL or time-based features
          { "leaflet.urlTemplate": { $exists: !0 } },
          { service: { $exists: !0 } }
        ],
        isVisible: !0
      })).forEach(async (i) => {
        const n = this.getLeafletLayerByName(i.name);
        if (i.service) {
          if (!n.lastUpdateTime || !this.shouldSkipFeaturesUpdate(n.lastUpdateTime, i)) {
            n.lastUpdateTime = be.getCurrentTime().clone();
            const r = await this.getFeatures(i);
            this.updateLeafletHeatmap(n, r);
          }
        } else if (n.sourceCompiler) {
          const r = n.sourceCompiler({ time: be.getCurrentTime() });
          if (!n.lastFetchedSource || n.lastFetchedSource !== r) {
            n.lastFetchedSource = r;
            const s = await Oi(r, i);
            this.updateLeafletHeatmap(n, s);
          }
        }
      });
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletHeatmapLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  }
};
B.heatmap = function(e) {
  return new mh(e);
};
const lw = {
  methods: {
    async createLeafletMapillaryLayer(e) {
      if ((e.leaflet || e).type !== "mapillary") return;
      const i = await this.createLeafletLayer(a.merge(e, {
        leaflet: {
          type: "vectorGrid.protobuf",
          source: "https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=" + this.mapillaryToken,
          interactive: !0,
          minZoom: 13,
          maxNativeZoom: 14,
          vectorTileLayerStyles: {
            sequence: function(n, r) {
              return {
                weight: r > 13 ? 1 : 2,
                color: "#44BB44",
                opacity: r > 13 ? 0.5 : 1
              };
            },
            image: []
          }
        }
      }));
      return kt(i, Zt.Feature, this, e), i;
    }
  },
  created() {
    if (this.mapillaryToken = j.get("capabilities.api.mapillary.token"), !this.mapillaryToken) {
      I.warn("You must provide a client token to use Mapillary");
      return;
    }
    this.registerLeafletConstructor(this.createLeafletMapillaryLayer);
  }
}, cw = B.TileLayer.extend({
  initialize(e) {
    this.product = e.product || "rain";
    const t = this.makeUrl(e.time), i = Object.assign({ tms: !0 }, e);
    B.TileLayer.prototype.initialize.call(this, t, i);
    const n = e.chromajs;
    n && (this.colorMap = Fn(n), this.colorMap && this.on("tileload", (r) => {
      this.hasData || (this.fire("data"), this.hasData = !0);
    }));
  },
  makeUrl(e) {
    const t = e || he(), i = he.duration(30, "minutes"), n = he(Math.trunc(t / i) * i).utc(), r = "https://sharaku.eorc.jaxa.jp/cgi-bin/trmm/GSMaP_NOW/tilemap/", s = `year=${n.year()}&month=${n.month() + 1}&day=${n.date()}&hour=${n.hour()}&min=${n.minute()}&z={z}&x={x}&y={y}`;
    return this.product === "rain12" || this.product === "rain24" || this.product === "rain72" ? r + `tile_total.py?prod=${this.product}&` + s : this.product === "ir" ? r + `gsmapnow_tile_ir.py?prod=${this.product}&` + s : r + "tile_rain.py?prod=rain&" + s;
  },
  setCurrentTime(e) {
    const t = this.makeUrl(e);
    this.setUrl(t, !1);
  }
}), uw = {
  methods: {
    async createLeafletGSMaPLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "gsmapLayer") return;
      const i = a.get(e, "variables[0].chromajs", null);
      return i && Object.assign(t, { chromajs: i }), t.time = be.getCurrentTime(), new cw(t);
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGSMaPLayer);
  }
}, Sf = {
  initialize() {
    this.ctx || (this.ctx = {});
  },
  get() {
    return this.ctx;
  },
  merge(e) {
    this.ctx = Object.assign({}, this.ctx, e);
  }
};
Sf.initialize();
function dw(e, t) {
  const i = { node: e.target, display: e.target.style.display };
  i.node.style.display = "none";
  const n = document.elementFromPoint(e.clientX, e.clientY);
  if (n && n !== t) {
    const r = new MouseEvent(e.type, e);
    (!n.dispatchEvent(r) || r._stopped) && B.DomEvent.stop(e);
  }
  i.node.style.display = i.display;
}
B.KanvasLayer = (B.Layer ? B.Layer : B.Class).extend({
  // -- initialized is called on prototype
  initialize: function(e) {
    if (this._map = null, this._mapPaneOffset = null, this._canvas = null, this._frame = null, this._delegate = null, B.setOptions(this, e), this.clickableFeatures = [], this.mousePosition = null, this.highlighting = !1, this.autoRedraw = !1, e.tooltip) {
      if (this._tooltip = B.tooltip({}), this._tooltipContent = "", e.tooltip.html)
        this._getTooltipContent = (t) => e.tooltip.html;
      else if (e.tooltip.property)
        this._getTooltipContent = (t) => `${a.get(t, e.tooltip.property)}`;
      else if (e.tooltip.template) {
        const t = a.template(e.tooltip.template);
        this._getTooltipContent = (i) => t({ feature: i, properties: i.properties });
      }
    }
  },
  delegate: function(e) {
    this._delegate = e;
  },
  setAutoRedraw: function(e) {
    this.autoRedraw = e, e && this._frame === null && this.needRedraw();
  },
  needRedraw: function() {
    this._frame !== null || this._canvas === null || (this._frame = B.Util.requestAnimFrame(this.drawLayer, this));
  },
  redrawNow: function() {
    const e = this._frame, t = this.autoRedraw;
    this.autoRedraw = !1, this.drawLayer(), this._frame = e, this.autoRedraw = t;
  },
  latLonToCanvas: function(e) {
    let t = this._map.latLngToLayerPoint(B.latLng(e.lat, e.lon));
    return this._map._rotate && (t = t.add(this._map._getRotatePanePos()).rotateFrom(this._map._bearing, this._map._getRotatePanePos())), t.add(this._mapPaneOffset);
  },
  clearClickableFeatures: function() {
    this.clickableFeatures.length = 0;
  },
  addClickableFeature: function(e, t, { clickableStrokeWidth: i = 0, highlightPath: n = void 0, highlightAsStroke: r = !1, highlightStyle: s = {} }) {
    this.clickableFeatures.push({
      feature: e,
      click: { path: t, strokeWidth: i }
    }), n && (this.clickableFeatures[this.clickableFeatures.length - 1].highlight = {
      path: n,
      asStroke: r,
      style: s
    });
  },
  hasClickableFeaturesAt: function(e) {
    if (!e || this.clickableFeatures.length === 0) return !1;
    const t = this.latLonToCanvas({ lat: e.lat, lon: e.lng }), i = this._canvas.getContext("2d");
    let n = !1;
    for (const r of this.clickableFeatures)
      if (i.save(), r.click.strokeWidth ? (i.lineWidth = r.click.strokeWidth, n = i.isPointInStroke(r.click.path, t.x, t.y)) : n = i.isPointInPath(r.click.path, t.x, t.y), i.restore(), n) return !0;
    return !1;
  },
  getClickableFeaturesAt: function(e) {
    if (!e || this.clickableFeatures.length === 0) return [];
    const t = this.latLonToCanvas({ lat: e.lat, lon: e.lng }), i = [], n = this._canvas.getContext("2d");
    return this.clickableFeatures.forEach((r, s) => {
      n.save(), r.click.strokeWidth ? (n.lineWidth = r.click.strokeWidth, n.isPointInStroke(r.click.path, t.x, t.y) && i.push(s)) : n.isPointInPath(r.click.path, t.x, t.y) && i.push(s), n.restore();
    }), i;
  },
  // -------------------------------------------------------------
  _onLayerDidResize: function(e) {
    this._canvas.width = e.newSize.x, this._canvas.height = e.newSize.y;
  },
  // -------------------------------------------------------------
  _onLayerDidMove: function() {
    if (this._mapPaneOffset = this._map._getMapPanePos(), this._map._rotate) {
      const e = this._mapPaneOffset.add(this._map._getRotatePanePos());
      this._canvas.style[B.DomUtil.TRANSFORM] = // TODO: zoomAnimation is currently always off on the layer beacause of rotate plugin
      // this._map.options.zoomAnimation ?
      "translate(-50%, -50%) rotate(" + -this._map._bearing + "rad) translate(50%, 50%) translate3d(" + -e.x + "px," + -e.y + "px, 0)";
    } else
      B.DomUtil.setPosition(this._canvas, B.point(0, 0).subtract(this._mapPaneOffset));
    this.redrawNow();
  },
  // -------------------------------------------------------------
  _onLayerClick: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    const t = this.getClickableFeaturesAt(e.latlng);
    if (t.length)
      this.fire("click", Object.assign({}, e, { feature: this.clickableFeatures[t[0]].feature }));
    else if (this.options.clickThroughEnabled) {
      const i = this.options.pane ? this._map._panes[this.options.pane] : this._map._panes.overlayPane;
      dw(e.originalEvent, i);
    }
  },
  // -------------------------------------------------------------
  _onLayerContextMenu: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    const t = this.getClickableFeaturesAt(e.latlng);
    t.length !== 0 && this.fire("contextmenu", Object.assign({}, e, { feature: this.clickableFeatures[t[0]].feature }));
  },
  // -------------------------------------------------------------
  _onMouseMove: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    this.mousePosition = e.latlng;
    let t = !1;
    if (this._tooltip) {
      const i = this.getClickableFeaturesAt(e.latlng);
      if (i.length === 0 && this._map.hasLayer(this._tooltip))
        this._map.closeTooltip(this._tooltip), this._tooltipContent = "";
      else if (i.length) {
        const n = this._getTooltipContent(this.clickableFeatures[i[0]].feature);
        n !== this._tooltipContent && (this._tooltip.setLatLng(e.latlng), this._tooltip.setContent(n), this._tooltipContent = n), this._map.hasLayer(this._tooltip) || this._map.openTooltip(this._tooltip), t = !0;
      }
    } else
      t = this.hasClickableFeaturesAt(e.latlng);
    if (!t && !this.highlighting) {
      this._canvas.style.cursor = "";
      return;
    } else
      this._canvas.style.cursor = "pointer", this.needRedraw();
  },
  // -------------------------------------------------------------
  _onLayerDidRotate: function(e) {
    this._onLayerDidMove();
  },
  // -------------------------------------------------------------
  getEvents: function() {
    const e = {
      resize: this._onLayerDidResize,
      moveend: this._onLayerDidMove,
      zoom: this._onLayerDidMove,
      rotate: this._onLayerDidRotate
    };
    return this._map.options.zoomAnimation && B.Browser.any3d && (e.zoomanim = this._animateZoom), this.options.pointerEventsEnabled && (e.click = this._onLayerClick, e.contextmenu = this._onLayerContextMenu, e.mousemove = this._onMouseMove), e;
  },
  // -------------------------------------------------------------
  onAdd: function(e) {
    this._map = e, this._canvas = B.DomUtil.create("canvas", "leaflet-layer"), this.options.pointerEventsEnabled || (this._canvas.style.pointerEvents = "none");
    const t = this._map.getSize();
    this._canvas.width = t.x, this._canvas.height = t.y, this._mapPaneOffset = e._getMapPanePos(), B.DomUtil.setPosition(this._canvas, B.point(0, 0).subtract(this._mapPaneOffset)), B.DomUtil.addClass(this._canvas, "leaflet-zoom-hide"), (this.options.pane ? e._panes[this.options.pane] : e._panes.overlayPane).appendChild(this._canvas), e.on(this.getEvents(), this);
    const n = this._delegate || this;
    n.onLayerDidMount && n.onLayerDidMount(), this.needRedraw();
  },
  // -------------------------------------------------------------
  onRemove: function(e) {
    const t = this._delegate || this;
    t.onLayerWillUnmount && t.onLayerWillUnmount(), this._frame !== null && B.Util.cancelAnimFrame(this._frame), (this.options.pane ? e._panes[this.options.pane] : e._panes.overlayPane).removeChild(this._canvas), e.off(this.getEvents(), this), this._canvas = null, this._frame = null;
  },
  // ---------- --------------------------------------------------
  addTo: function(e) {
    return e.addLayer(this), this;
  },
  // --------------------------------------------------------------------------------
  LatLonToMercator: function(e) {
    return {
      x: e.lng * 6378137 * Math.PI / 180,
      y: Math.log(Math.tan((90 + e.lat) * Math.PI / 360)) * 6378137
    };
  },
  // ------------------------------------------------------------------------------
  drawLayer: function() {
    const e = this._map.getSize(), t = this._map.getBounds(), i = this._map.getZoom(), n = this.LatLonToMercator(this._map.getCenter()), r = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize())), s = this._delegate || this;
    s.onDrawLayer && s.onDrawLayer({
      layer: this,
      canvas: this._canvas,
      bounds: t,
      size: e,
      zoom: i,
      center: n,
      corner: r
    });
    const o = this.getClickableFeaturesAt(this.mousePosition);
    if (this.highlighting = o.length > 0, this.highlighting) {
      const l = this._canvas.getContext("2d");
      for (const c of o) {
        const u = this.clickableFeatures[c];
        l.save(), l.globalAlpha = 0.5;
        for (const d in u.highlight.style) l[d] = u.highlight.style[d];
        u.highlight.asStroke ? l.stroke(u.highlight.path) : l.fill(u.highlight.path), l.restore();
      }
    }
    this._frame = null, this.autoRedraw && this.needRedraw();
  },
  // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7
  // ------------------------------------------------------------------------------
  _setTransform: function(e, t, i) {
    const n = t || new B.Point(0, 0);
    e.style[B.DomUtil.TRANSFORM] = (B.Browser.ie3d ? "translate(" + n.x + "px," + n.y + "px)" : "translate3d(" + n.x + "px," + n.y + "px,0)") + (i ? " scale(" + i + ")" : "");
  },
  // ------------------------------------------------------------------------------
  _animateZoom: function(e) {
    const t = this._map.getZoomScale(e.zoom), i = B.Layer ? this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min : this._map._getCenterOffset(e.center)._multiplyBy(-t).subtract(this._map._getMapPanePos());
    B.DomUtil.setTransform(this._canvas, i, t);
  }
});
B.kanvasLayer = function(e) {
  return new B.KanvasLayer(e);
};
const fw = {
  methods: {
    createLeafletCanvasLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "kanvasLayer") return;
      const i = this.createLeafletLayer(e);
      return this.setCanvasLayerDrawCode(i, t.draw), t.userData && this.setCanvasLayerUserData(i, t.userData), t.autoRedraw && this.setCanvasLayerAutoRedraw(i, t.autoRedraw), kt(i, ["click", "contextmenu"], this, e), i;
    },
    setCanvasLayerDrawCode(e, t, i = !1) {
      const n = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      if (!n) return;
      const r = (s, o) => {
        for (const l in s.listenedLayers) {
          if (s.listenedLayers[l] === o) continue;
          const u = this.getLeafletLayerByName(l);
          u && (o ? u.on("update", s.needRedraw, s) : u.off("update", s.needRedraw, s), s.listenedLayers[l] = o);
        }
      };
      r(n, !1), n.listenedLayers = {}, n.drawCalls = [], n.userData === void 0 && (n.userData = {}), n.compatContext === void 0 && (n.compatContext = {}), n.clearClickableFeatures();
      for (const s of t) {
        const o = Function(`
// define visible variables
const ctx = this;
with(this.proxy) { ${s.code} }
`);
        if (s.feature) {
          const [l, c] = s.feature.split("?");
          n.drawCalls.push((u) => {
            const d = this.getLeafletLayerByName(l);
            if (!d) return;
            const f = d._features ? d._features[c] : void 0;
            f && (u.feature = f, o.call(u));
          }), a.has(n.listenedLayers, l) || (n.listenedLayers[l] = !1);
        } else s.layer && (n.drawCalls.push((l) => {
          const c = this.getLeafletLayerByName(s.layer);
          if (c)
            for (const u of Object.values(c._features))
              l.feature = u, o.call(l);
        }), a.has(n.listenedLayers, s.layer) || (n.listenedLayers[s.layer] = !1));
      }
      n.onDrawLayer || (n.onDrawLayer = (s) => {
        r(n, !0);
        const o = s.canvas.getContext("2d"), l = Object.assign(
          // current state context
          {
            canvas: o,
            now: Date.now(),
            zoom: s.zoom,
            latLonToCanvas: n.latLonToCanvas.bind(n),
            clearClickableFeatures: n.clearClickableFeatures.bind(n),
            addClickableFeature: n.addClickableFeature.bind(n),
            userData: n.userData
          },
          n.compatContext,
          // global context
          this.canvasLayerDrawContext
        );
        o.save(), o.clearRect(0, 0, s.canvas.width, s.canvas.height);
        for (const c of n.drawCalls) c(l);
        o.restore();
      }), n.setAutoRedraw(i), n.needRedraw();
    },
    setCanvasLayerUserData(e, t) {
      const i = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      i && (i.userData = Object.assign(i.userData, t), i.needRedraw());
    },
    setCanvasLayerAutoRedraw(e, t) {
      const i = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      i && i.setAutoRedraw(t);
    },
    /* Compatibility methods */
    updateCanvasLayerDrawCode(e, t, i = !1) {
      this.setCanvasLayerDrawCode(e, t, i);
    },
    setCanvasLayerContext(e, t) {
      const i = this.getLeafletLayerByName(e);
      i && (i.compatContext = t, i.needRedraw());
    }
  },
  created() {
    this.canvasLayerDrawProxy = new Proxy(window, {
      get: (e, t, i) => {
      }
    }), this.canvasLayerDrawContext = Object.assign({
      proxy: this.canvasLayerDrawProxy,
      // Math constants
      Math,
      // a few handy helpers for draw code
      vec2: (e, t) => ({ x: e.x - t.x, y: e.y - t.y }),
      len2: (e) => Math.sqrt(e.x * e.x + e.y * e.y),
      scale2: (e, t) => ({ x: e.x * t, y: e.y * t }),
      norm2: (e) => {
        const t = Math.sqrt(e.x * e.x + e.y * e.y);
        return { x: e.x / t, y: e.y / t };
      }
    }, Sf.get()), this.registerLeafletConstructor(this.createLeafletCanvasLayer);
  },
  beforeUnmount() {
  }
}, hw = {
  methods: {
    async createLeafletPMTilesLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "pmtiles") return;
      const i = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : G, n = i.hasConfig("apiJwt") ? await i.get("storage").getItem(i.getConfig("apiJwt")) : null, r = i.hasConfig("gatewayJwt") ? await i.get("storage").getItem(i.getConfig("gatewayJwt")) : null, s = a.get(t, "urlTemplate");
      s && (t.url = a.template(s)({ apiJwt: n, gatewayJwt: r }));
      const o = a.get(t, "styleTemplate");
      o && (t.style = a.template(o)({ apiJwt: n, gatewayJwt: r }));
      const l = a.get(t, "template");
      l && (t.template = l.map((d) => ({
        property: d,
        compiler: a.template(a.get(t, d))
      })));
      let c = {}, u = a.get(t, "style");
      if (typeof u == "string") {
        const d = await fetch(u);
        if (d.status !== 200)
          throw new Error(`Impossible to fetch style ${u}: ` + d.status);
        u = await d.json();
        const f = u.layers.find((m) => m.type === "background");
        f && (t.backgroundColor = f.paint["fill-color"]), c = gh(u, {});
      } else if (a.get(t, "template", []).forEach((d) => {
        const f = (m, g) => {
          const v = Object.assign({ properties: g.props, feature: g, chroma: Xt, moment: he, Units: Me, Time: be, level: this.selectedLevel }, ro.get());
          return d.property.endsWith("filter") ? d.compiler(v) === "true" : d.compiler(v);
        };
        a.set(t, d.property, f);
      }), u) {
        const d = a.map(
          u,
          (g) => Object.assign(a.omit(g, ["symbolizer"]), {
            symbolizer: new Bl[g.symbolizer.type](g.symbolizer)
          })
        ), f = (g) => typeof g.symbolizer.place == "function", m = (g) => !f(g);
        c.paint_rules = c.paintRules = a.filter(d, m), c.label_rules = c.labelRules = a.filter(d, f);
      }
      return this.createLeafletLayer({
        ...t,
        ...c
        //debug: true,
        //levelDiff: 2
      });
    },
    onCurrentTimeChangedPMTilesLayers(e) {
      a.values(this.layers).filter(Te({
        "leaflet.type": "pmtiles",
        // Skip invisible layers
        isVisible: !0
      })).forEach(async (i) => {
        this.getLeafletLayerByName(i.name).redraw();
      });
    },
    onCurrentLevelChangedPMTilesLayers(e) {
      let t = this.selectableLevelsLayer;
      t && a.get(t, `${this.engine}.type`) === "pmtiles" && (t = this.getLeafletLayerByName(t.name), t.redraw());
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletPMTilesLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers), this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers), this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  }
};
B.pmtiles = function(e) {
  return Bl.leafletLayer(e);
};
const mw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: V0,
  baseMap: A0,
  canvasLayers: fw,
  editLayers: N0,
  fileLayers: I0,
  geojsonLayers: $0,
  gsmapLayers: uw,
  heatmapLayers: aw,
  mapillaryLayers: lw,
  pmtilesLayers: hw,
  popup: U0,
  style: q0,
  tiledMeshLayers: sw,
  tiledWindLayers: ow,
  tooltip: j0
}, Symbol.toStringTag, { value: "Module" })), gw = Object.assign({}, S0, { map: mw }), F_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Geolocation: Ct,
  Navigator: ff,
  Planets: Uo,
  composables: g0,
  dap: Kb,
  default: gf,
  errors: Rb,
  grid: qb,
  hooks: Xv,
  mixins: gw,
  permissions: Ib,
  setupApi: mf,
  utils: pb
}, Symbol.toStringTag, { value: "Module" })), D_ = { core: xu, map: gf };
export {
  D_ as default,
  M_ as kdkCore,
  F_ as kdkMap
};
