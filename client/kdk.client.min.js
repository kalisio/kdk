import Dh from "ajv";
import Ah from "ajv-formats";
import Oh from "ajv-keywords";
import o from "lodash";
import { FeathersError as _c } from "@feathersjs/errors";
import Fi from "@turf/bbox";
import z from "loglevel";
import me from "config";
import { getFingerprint as Bh, getFingerprintData as Rh } from "@thumbmarkjs/thumbmarkjs";
import $h, { LocalForage as Ih } from "@kalisio/feathers-localforage";
import { getClientService as zh } from "@kalisio/feathers-s3/client.js";
import { reactive as Nt, toRef as _o, ref as ue, createApp as Nh, computed as W, markRaw as ns, defineComponent as jh, getCurrentInstance as Ve, h as K, onBeforeUnmount as Ue, Transition as Dn, withDirectives as Vh, TransitionGroup as Uh, onDeactivated as Lo, nextTick as Et, watch as Le, onMounted as Qt, onUnmounted as qh, Teleport as Gh, inject as Lc, onBeforeUpdate as Kh, onActivated as Hh, toRaw as jt, defineAsyncComponent as Wh, shallowReactive as Zh, shallowRef as xc, readonly as Ei, watchEffect as Sc, onBeforeMount as qn, unref as Wi } from "vue";
import { createI18n as Jh } from "vue-i18n";
import _t from "moment-timezone/builds/moment-timezone-with-data-10-year-range.js";
import * as Ri from "mathjs";
import Pe from "sift";
import Ts from "sanitize-html";
import fe from "moment";
import qt from "path-browserify";
import { useRouter as xo, useRoute as So } from "vue-router";
import Cc from "debug";
import Qh from "papaparse";
import Xs from "formatcoords";
import { image as Yh } from "@pdfme/schemas";
import { generate as Xh } from "@pdfme/generator";
import rs from "@mapbox/sphericalmercator";
import { PMTiles as Ec, zxyToTileId as em, findTile as tm } from "pmtiles";
import * as Tc from "protomaps-leaflet";
import { sourcesToViews as Pc } from "protomaps-leaflet";
import Pt from "chroma-js";
import B from "leaflet";
import kc from "iso8601-js-period";
import { kml as Mc, gpx as im } from "@tmcw/togeojson";
import * as zt from "cesium";
import { Color as pi, exportKml as Fc, buildModuleUrl as Dc, Math as Ee, Cartographic as Ma, Entity as nm, EntityCollection as rm, BoundingSphere as Ps, Ellipsoid as vr, PinBuilder as sm, VerticalOrigin as om, Cartesian3 as mn, DebugModelMatrixPrimitive as ks, HeadingPitchRoll as Ln, HeadingPitchRange as am, Transforms as qi, Matrix4 as tr, Matrix3 as ir, DebugCameraPrimitive as lm, Rectangle as Fa, Cesium3DTileset as xn, ImageryLayer as nr, ScreenSpaceEventType as rr, ScreenSpaceEventHandler as cm, Ion as Da, Viewer as um, viewerCesiumInspectorMixin as dm, GeoJsonDataSource as gn, ConstantProperty as ei, ColorMaterialProperty as Ms, viewerDragDropMixin as fm, Fullscreen as sr, Resource as hm } from "cesium";
import mm from "jwt-decode";
import Sn from "@feathersjs/client";
import { io as gm } from "socket.io-client";
import { rx as pm } from "feathers-reactive";
import { createAliasResolver as ym, AbilityBuilder as vm, Ability as bm } from "@casl/ability";
import { toMongoQuery as wm } from "@casl/mongoose";
import _m from "email-validator";
import Aa from "ajv-i18n";
import "leaflet-realtime";
import "leaflet.markercluster/dist/MarkerCluster.css";
import "leaflet.markercluster/dist/MarkerCluster.Default.css";
import "leaflet.markercluster";
import { lineOffset as Lm, point as kr, rhumbDistance as Ac, rhumbBearing as Oc, rhumbDestination as Bc, getType as xm } from "@turf/turf";
import * as Te from "pixi.js";
import "leaflet-pixi-overlay";
import eo from "jsdap/src/parser.js";
import Sm from "jsdap/src/xdr.js";
import * as Rc from "geotiff";
import Mr from "xml2js";
import { memory as Cm } from "@feathersjs/memory";
import ti from "shpjs";
import "leaflet/dist/leaflet.css";
import "leaflet-fullscreen";
import "leaflet-fullscreen/dist/leaflet.fullscreen.css";
import "@kalisio/leaflet.donutcluster/src/Leaflet.DonutCluster.css";
import "@kalisio/leaflet.donutcluster";
import "leaflet.geodesic";
import "@kalisio/leaflet-graphicscale";
import "@kalisio/leaflet-graphicscale/dist/Leaflet.GraphicScale.min.css";
import "leaflet.locatecontrol";
import "leaflet.locatecontrol/dist/L.Control.Locate.css";
import "leaflet-wms-header";
import "leaflet-timedimension/dist/leaflet.timedimension.control.css";
import "@geoman-io/leaflet-geoman-free";
import "@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css";
import "leaflet-velocity";
import Em from "leaflet-heatmap";
import { mapbox_style as Tm } from "@kalisio/leaflet-pmtiles";
import "cesium/Source/Widgets/widgets.css";
const or = {};
function Ot(e, t) {
  o.has(or, e) || o.set(or, e, Nt(t || {}));
  const i = o.get(or, e);
  function n() {
    o.forOwn(i, function(u, d) {
      o.unset(i, d);
    });
  }
  function r(u, d) {
    o.set(i, u, d);
  }
  function s(u, d) {
    return u ? o.get(i, u, d) : i;
  }
  function a(u) {
    o.unset(i, u);
  }
  function l(u) {
    return o.has(i, u);
  }
  function c(u) {
    o.forOwn(i, function(d, f) {
      u(d, f);
    });
  }
  return {
    Store: or,
    store: i,
    clear: n,
    set: r,
    get: s,
    unset: a,
    has: l,
    forOwn: c
  };
}
class Co {
  constructor() {
    this.__stack = {};
  }
  on(t, i, n) {
    return (this.__stack[t] || (this.__stack[t] = [])).push({
      fn: i,
      ctx: n
    }), this;
  }
  once(t, i, n) {
    const r = () => {
      this.off(t, r), i.apply(n, arguments);
    };
    return r.__callback = i, this.on(t, r, n);
  }
  emit(t) {
    const i = this.__stack[t];
    if (i !== void 0) {
      const n = [].slice.call(arguments, 1);
      i.forEach((r) => {
        r.fn.apply(r.ctx, n);
      });
    }
    return this;
  }
  off(t, i) {
    const n = this.__stack[t];
    if (n === void 0)
      return this;
    if (i === void 0)
      return delete this.__stack[t], this;
    const r = n.filter(
      (s) => s.fn !== i && s.fn.__callback !== i
    );
    return r.length !== 0 ? this.__stack[t] = r : delete this.__stack[t], this;
  }
}
const ne = new Co(), { store: Oa, set: Pm, get: ar, unset: km, has: Mm } = Ot("store"), V = Object.assign(Oa, {
  get: ar,
  has: Mm,
  // Override write methods to send events
  set(e, t) {
    const i = ar(e);
    Pm(e, t);
    const n = o.kebabCase(`${e}-changed`);
    ne.emit(n, t, i), ne.emit("store-changed", e, t, i);
  },
  patch(e, t) {
    const i = ar(e);
    i && (Object.assign(i, t), this.set(e, i));
  },
  unset(e) {
    km(e);
    const t = o.kebabCase(`${e}-changed`);
    ne.emit(t, void 0);
  },
  getRef(e) {
    const t = e.lastIndexOf("."), i = e.substring(t + 1), n = t < 0 ? Oa : ar(e.replace(`.${i}`, ""));
    return _o(n, i);
  }
}), Fm = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function ss({ r: e, g: t, b: i, a: n }) {
  const r = n !== void 0;
  if (e = Math.round(e), t = Math.round(t), i = Math.round(i), e > 255 || t > 255 || i > 255 || r && n > 100)
    throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
  return n = r ? (Math.round(255 * n / 100) | 256).toString(16).slice(1) : "", "#" + (i | t << 8 | e << 16 | 1 << 24).toString(16).slice(1) + n;
}
function $c(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  e = e.replace(/^#/, ""), e.length === 3 ? e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] : e.length === 4 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]);
  const t = parseInt(e, 16);
  return e.length > 6 ? { r: t >> 24 & 255, g: t >> 16 & 255, b: t >> 8 & 255, a: Math.round((t & 255) / 2.55) } : { r: t >> 16, g: t >> 8 & 255, b: t & 255 };
}
function Dm({ h: e, s: t, v: i, a: n }) {
  let r, s, a;
  t = t / 100, i = i / 100, e = e / 360;
  const l = Math.floor(e * 6), c = e * 6 - l, u = i * (1 - t), d = i * (1 - c * t), f = i * (1 - (1 - c) * t);
  switch (l % 6) {
    case 0:
      r = i, s = f, a = u;
      break;
    case 1:
      r = d, s = i, a = u;
      break;
    case 2:
      r = u, s = i, a = f;
      break;
    case 3:
      r = u, s = d, a = i;
      break;
    case 4:
      r = f, s = u, a = i;
      break;
    case 5:
      r = i, s = u, a = d;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(s * 255),
    b: Math.round(a * 255),
    a: n
  };
}
function Am({ r: e, g: t, b: i, a: n }) {
  const r = Math.max(e, t, i), s = Math.min(e, t, i), a = r - s, l = r === 0 ? 0 : a / r, c = r / 255;
  let u;
  switch (r) {
    case s:
      u = 0;
      break;
    case e:
      u = t - i + a * (t < i ? 6 : 0), u /= 6 * a;
      break;
    case t:
      u = i - e + a * 2, u /= 6 * a;
      break;
    case i:
      u = e - t + a * 4, u /= 6 * a;
      break;
  }
  return {
    h: Math.round(u * 360),
    s: Math.round(l * 100),
    v: Math.round(c * 100),
    a: n
  };
}
function oi(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  const t = e.replace(/ /g, ""), i = Fm.exec(t);
  if (i === null)
    return $c(t);
  const n = {
    r: Math.min(255, parseInt(i[2], 10)),
    g: Math.min(255, parseInt(i[3], 10)),
    b: Math.min(255, parseInt(i[4], 10))
  };
  if (i[1]) {
    const r = parseFloat(i[5]);
    n.a = Math.min(1, isNaN(r) === !0 ? 1 : r) * 100;
  }
  return n;
}
function Om(e, t) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  if (typeof t != "number")
    throw new TypeError("Expected a numeric percent");
  const i = oi(e), n = t < 0 ? 0 : 255, r = Math.abs(t) / 100, s = i.r, a = i.g, l = i.b;
  return "#" + (16777216 + (Math.round((n - s) * r) + s) * 65536 + (Math.round((n - a) * r) + a) * 256 + (Math.round((n - l) * r) + l)).toString(16).slice(1);
}
function Bm(e) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  const t = typeof e == "string" ? oi(e) : e, i = t.r / 255, n = t.g / 255, r = t.b / 255, s = i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4), a = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4), l = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
  return 0.2126 * s + 0.7152 * a + 0.0722 * l;
}
function Rm(e) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  const t = typeof e == "string" ? oi(e) : e;
  return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
}
function $m(e, t) {
  if (typeof e != "string" && (!e || e.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as fgColor");
  if (typeof t != "string" && (!t || t.r === void 0))
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as bgColor");
  const i = typeof e == "string" ? oi(e) : e, n = i.r / 255, r = i.g / 255, s = i.b / 255, a = i.a !== void 0 ? i.a / 100 : 1, l = typeof t == "string" ? oi(t) : t, c = l.r / 255, u = l.g / 255, d = l.b / 255, f = l.a !== void 0 ? l.a / 100 : 1, h = a + f * (1 - a), g = Math.round((n * a + c * f * (1 - a)) / h * 255), v = Math.round((r * a + u * f * (1 - a)) / h * 255), x = Math.round((s * a + d * f * (1 - a)) / h * 255), w = { r: g, g: v, b: x, a: Math.round(h * 100) };
  return typeof e == "string" ? ss(w) : w;
}
function Im(e, t) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  if (t === void 0 || t < -1 || t > 1)
    throw new TypeError("Expected offset to be between -1 and 1");
  const { r: i, g: n, b: r, a: s } = oi(e), a = s !== void 0 ? s / 100 : 0;
  return ss({
    r: i,
    g: n,
    b: r,
    a: Math.round(Math.min(1, Math.max(0, a + t)) * 100)
  });
}
function zm(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as color");
  const t = document.createElement("div");
  t.className = `text-${e} invisible fixed no-pointer-events`, document.body.appendChild(t);
  const i = getComputedStyle(t).getPropertyValue("color");
  return t.remove(), ss(oi(i));
}
const Ft = {
  rgbToHex: ss,
  hexToRgb: $c,
  hsvToRgb: Dm,
  rgbToHsv: Am,
  textToRgb: oi,
  lighten: Om,
  luminosity: Bm,
  brightness: Rm,
  blend: $m,
  changeAlpha: Im,
  getPaletteColor: zm
};
function Eo(e, t = document.body) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as propName");
  if (!(t instanceof Element))
    throw new TypeError("Expected a DOM element");
  return getComputedStyle(t).getPropertyValue(`--q-${e}`).trim() || null;
}
function xt(e, t, i = document.body) {
  if (typeof e != "string")
    throw new TypeError("Expected a string as propName");
  if (typeof t != "string")
    throw new TypeError("Expected a string as value");
  if (!(i instanceof Element))
    throw new TypeError("Expected a DOM element");
  i.style.setProperty(`--q-${e}`, t);
}
const Fs = ["primary", "secondary", "accent", "dark", "info", "positive", "negative", "warning"], Nm = {
  primary: "#bf360c",
  secondary: "#bf360",
  accent: "#bf360c",
  dark: "#bf360c",
  info: "#bf360c",
  positive: "#7bb946",
  negative: "#c74a4a",
  warning: "#d09931"
}, Ic = {
  initialize() {
    this.default || (this.default = {}, Fs.forEach((e) => {
      this.default[e] = Eo(e) || Nm[e];
    }));
  },
  apply(e) {
    typeof e == "string" ? (xt("primary", e), xt("secondary", Ft.lighten(e, 75)), xt("accent", Ft.lighten(e, 25)), xt("dark", Ft.lighten(e, -25)), xt("info", Ft.lighten(e, 25)), xt("positive", this.default.positive), xt("negative", this.default.negative), xt("warning", this.default.warning)) : Fs.forEach((t) => {
      xt(t, o.get(e, t, this.default[t]));
    });
  },
  restore() {
    Fs.forEach((e) => {
      xt(e, this.default[e]);
    });
  }
};
class zc extends Error {
}
const jm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KError: zc
}, Symbol.toStringTag, { value: "Module" })), Vm = ym({
  update: ["patch"],
  read: ["get", "find"],
  remove: ["delete"],
  all: ["read", "create", "update", "remove"]
}), ut = {
  member: 0,
  manager: 1,
  owner: 2
}, os = [
  "member",
  "manager",
  "owner"
];
let An = [];
const Nc = "type", To = Symbol.for(Nc);
function Um(e, t, i, n) {
  const r = ut[t.permissions];
  r >= ut.member && n("read", i, { _id: t._id }), r >= ut.manager && (n("update", i, { _id: t._id }), n(["create", "remove"], "authorisations", { resource: t._id })), r >= ut.owner && n("remove", i, { _id: t._id });
}
function qm(e, t, i) {
  t("service", "users"), t("create", "users"), t("service", "account"), t(["create", "verifyEmail"], "account"), t("service", "import-export"), t("create", "import-export"), t("service", "push"), t("create", "push"), t("service", "tags"), t("create", "tags"), e && e._id && (t("read", "users"), t(["update", "remove"], "users", { _id: e._id }), t("service", "authorisations"), t("service", "storage"), t("create", "storage", { id: "avatars/" + e._id.toString() }), t("create", "storage", { id: "avatars/" + e._id.toString() + ".thumbnail" }), t(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + e._id.toString() }), t(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + e._id.toString() + ".thumbnail" }), t("remove", "storage", { _id: "avatars/" + e._id.toString() }), t("remove", "storage", { _id: "avatars/" + e._id.toString() + ".thumbnail" }), t("read", "storage", { _id: { $regex: "^avatars/*" } }));
}
async function as(e, ...t) {
  const { build: i, can: n, cannot: r } = new vm(bm);
  return await Promise.all(An.map(async (s) => {
    await s(e, n, r, ...t);
  })), i({
    detectSubjectType: (s) => !s || typeof s == "string" ? s : s[To],
    resolveAction: Vm
  });
}
as.registerHook = function(e) {
  An.includes(e) || An.push(e);
};
as.unregisterHook = function(e) {
  An = An.filter((t) => t !== e);
};
function jc(e, t) {
  if (!e) return !1;
  const i = typeof t == "string" ? t : t.getPath(), n = o.replace(i, /^.*\//, "*/");
  return e.can("service", i) || e.can("service", `*/${i}`) || e.can("service", n);
}
function Vc(e, t, i, n, r) {
  if (!e) return !1;
  const s = Object.assign({}, r);
  return s[To] = i, n && (s.context = typeof n == "object" ? n._id.toString() : n.toString()), e.can(t, s);
}
function Fr(e) {
  return o.forOwn(e, (t, i) => {
    i === "context" ? delete e.context : Array.isArray(t) ? (t.forEach((n) => Fr(n)), o.isEmpty(t) && delete e[i]) : typeof t == "object" && (Fr(t), o.isEmpty(t) && delete e[i]);
  }), e;
}
function Gm(e, t, i) {
  if (!e) return null;
  const n = wm(e, i, t);
  return n ? Fr(o.cloneDeep(n)) : null;
}
function Uc(e, t, i) {
  const n = { [e]: { $elemMatch: { _id: t } } };
  return i && o.set(n[e], "$elemMatch.permissions", typeof i == "string" ? i : os[i]), n;
}
function Km(e, t, i, n) {
  const r = Uc(t, i, n);
  return e.find({ query: r });
}
function Hm(e, t, i, n) {
  const r = Uc(t, i, n);
  return r.$limit = 0, e.find({ query: r });
}
function Wm(e, t) {
  return ut[e] >= ut[t];
}
function Zm(e, t) {
  return ut[e] < ut[t];
}
function Jm(e) {
  const t = [];
  return o.forEach(ut, (i) => {
    ut[e] < i && t.push(os[i]);
  }), t;
}
function Qm(e) {
  const t = [];
  return o.forEach(ut, (i) => {
    ut[e] >= i && t.push(os[i]);
  }), t;
}
const Ym = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RESOURCE_TYPE: Nc,
  RESOURCE_TYPE_KEY: To,
  RoleNames: os,
  Roles: ut,
  countSubjectsForResource: Hm,
  defineAbilities: as,
  defineResourceRules: Um,
  defineUserAbilities: qm,
  findSubjectsForResource: Km,
  getJuniorRoles: Qm,
  getQueryForAbilities: Gm,
  getSeniorRoles: Jm,
  hasResourceAbilities: Vc,
  hasServiceAbilities: jc,
  isJuniorRole: Zm,
  isSeniorRole: Wm,
  removeContext: Fr
}, Symbol.toStringTag, { value: "Module" })), Xm = {
  allErrors: !0,
  strict: !1,
  $data: !0,
  keywords: ["field"]
}, Po = {
  initialize(e) {
    this.ajv = new Dh(e || Xm), Oh(this.ajv), Ah(this.ajv);
  },
  register(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    if (!e.$id) throw new Error("the schema must have an `$id` property");
    return this.ajv.getSchema(e.$id) || this.ajv.compile(e);
  },
  addKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.addKeyword(e);
  },
  getKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    return this.ajv.getKeyword(e);
  },
  removeKeyword(e) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.removeKeyword(e);
  }
}, Ba = Cc("kdk:core:offline");
async function qc(e, t) {
  let { baseQuery: i, baseQueries: n, offlineService: r, dataPath: s = "data" } = t, a = [];
  n || (n = [i]);
  for (let l = 0; l < n.length; l++) {
    const c = Object.assign({ $skip: 0 }, n[l]);
    Ba(`[KDK] making service snapshot with query ${JSON.stringify(c)}`), r && o.get(t, "clear", !0) && await r.remove(null, { query: o.omit(n[l], ["$limit"]) });
    let u = await e.find({ query: c }), d = o.get(u, s) || u;
    if (r && await r.create(d, { addId: !1, snapshot: !0 }), a = a.concat(d), !o.get(u, s)) return a;
    const { total: f, limit: h } = u;
    for (; c.$skip + d.length < f; )
      c.$skip += h, Ba(`[KDK] getting service ${e.name} next page with query ${JSON.stringify(c)}`), u = await e.find({ query: c }), d = o.get(u, s), r ? await r.create(d, { addId: !1, snapshot: !0 }) : a = a.concat(d);
  }
  return a;
}
function Gc(e, t, i) {
  const n = e.includes("?") ? "&" : "?";
  return `${e}${n}${t}=${Array.isArray(i) ? JSON.stringify(i) : i}`;
}
function Gn(e, t) {
  let i = e;
  return o.forOwn(t, function(n, r) {
    i = Gc(i, r, n);
  }), i;
}
function Kc(e, t) {
  return encodeURI(Kc());
}
function eg(e, t = {}) {
  const i = ["a,á,à,ä,â,ã", "e,é,ë,è,ê", "i,í,ï,ì,î", "o,ó,ö,ò,õ,ô", "u,ü,ú,ù,û", "c,ç"];
  let n = "";
  for (const r of e) {
    const s = i.find((a) => t.reverse ? a.includes(r) : a[0] === r);
    s ? n += `[${s}]` : n += r;
  }
  return n;
}
const Ce = {
  initialize() {
    const e = { name: "offline_cache", storeName: "cache_entries" };
    this.storage = Ih.createInstance(e), z.debug("[KDK] LocalForage initialized with configuration:", e);
  },
  getStorage() {
    return this.storage;
  },
  async getItem(e) {
    return await this.storage.getItem(e);
  },
  async setItem(e, t) {
    await this.storage.setItem(e, t);
  },
  async removeItem(e) {
    return await this.storage.removeItem(e);
  },
  async createCache(e) {
    return await caches.open(e);
  },
  async getCache(e) {
    return await caches.open(e);
  },
  async removeCache(e) {
    await caches.delete(e);
  },
  async has(e) {
    return !o.isNil(this.getCount(e));
  },
  async getCount(e) {
    return await this.storage.getItem(e);
  },
  async setCount(e, t) {
    await this.storage.setItem(e, t);
  },
  async set(e, t, i, n = {}) {
    const r = await this.getCount(t);
    if (!o.isNil(r))
      await this.setCount(t, r + 1);
    else {
      const s = await this.getCache(e);
      let a = await fetch(i, n);
      a.status === 206 && (a = new Response(a.body, { status: 200, headers: a.headers })), await s.put(t, a), await this.storage.setItem(t, 1);
    }
  },
  async unset(e, t) {
    const i = await this.getCache(e), n = await this.getCount(t);
    o.isNil(n) || (n <= 1 ? (i.delete(t), await this.storage.removeItem(t)) : await this.setCount(t, n - 1));
  }
};
function tg(e) {
  o.get(e, `params.skip-${e.type}-event`) || ne.emit(e.type + "-hook", e);
}
function ig(e) {
  let t = `[KDK] ${e.type}: ${e.path} - Method: ${e.method}`;
  e.type === "error" && (t += `: ${e.error.message}`), z.debug(t), e.error && z.error(e.error), e.data && z.trace(e.data), e.params && z.trace(e.params), e.result && z.trace(e.result);
}
let Ds, lr = 0;
const Ge = new Array(256);
for (let e = 0; e < 256; e++)
  Ge[e] = (e + 256).toString(16).substring(1);
const ng = (() => {
  const e = typeof crypto < "u" ? crypto : typeof window < "u" ? window.crypto || window.msCrypto : void 0;
  if (e !== void 0) {
    if (e.randomBytes !== void 0)
      return e.randomBytes;
    if (e.getRandomValues !== void 0)
      return (t) => {
        const i = new Uint8Array(t);
        return e.getRandomValues(i), i;
      };
  }
  return (t) => {
    const i = [];
    for (let n = t; n > 0; n--)
      i.push(Math.floor(Math.random() * 256));
    return i;
  };
})(), Ra = 4096;
function Gt() {
  (Ds === void 0 || lr + 16 > Ra) && (lr = 0, Ds = ng(Ra));
  const e = Array.prototype.slice.call(Ds, lr, lr += 16);
  return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, Ge[e[0]] + Ge[e[1]] + Ge[e[2]] + Ge[e[3]] + "-" + Ge[e[4]] + Ge[e[5]] + "-" + Ge[e[6]] + Ge[e[7]] + "-" + Ge[e[8]] + Ge[e[9]] + "-" + Ge[e[10]] + Ge[e[11]] + Ge[e[12]] + Ge[e[13]] + Ge[e[14]] + Ge[e[15]];
}
function ko(e) {
  const t = e.params;
  o.unset(t, "query.$locale"), o.unset(t, "query.$collation"), o.unset(t, "query.populate"), o.has(t, "query.upsert") && (o.set(t, "upsert", o.get(t, "query.upsert")), o.unset(t, "query.upsert"));
}
function Mo(e) {
  if (e.params.snapshot) return;
  (Array.isArray(e.data) ? e.data : [e.data]).filter((n) => !n._id).forEach((n) => {
    n._id = Gt().toString();
  });
}
function Fo(e) {
  e.data && (e.data = o.cloneDeep(e.data));
}
async function rg(e) {
  const t = e.app.getService("account");
  try {
    await t.create({
      action: "checkUnique",
      value: { email: e.data.email }
    }, {
      // As we manage error we make this call transparent from the client perspective
      // This will avoid displaying an error message twice
      "skip-before-event": !0,
      "skip-after-event": !0,
      "skip-error-event": !0
    });
  } catch (i) {
    throw i.code === 400 && (i.data.translation = { key: "EMAIL_ALREADY_TAKEN" }), i;
  }
  return e;
}
const sg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkUnique: rg,
  emit: tg,
  ensureSerializable: Fo,
  generateId: Mo,
  log: ig,
  removeServerSideParameters: ko
}, Symbol.toStringTag, { value: "Module" }));
Sn.authentication.AuthenticationClient.prototype.handleSocket = () => {
};
async function Do(e) {
  o.get(me, "logs.level") ? z.setLevel(o.get(me, "logs.level"), !1) : z.setLevel("info");
  const t = Sn();
  t.isDisconnected = !navigator.onLine, addEventListener("online", () => {
    t.isDisconnected = !1, ne.emit("navigator-reconnected", t);
  }), addEventListener("offline", () => {
    t.isDisconnected = !0, ne.emit("navigator-disconnected", t);
  }), t.useLocalFirst = e.useLocalFirst, t.setLocalFirstEnabled = function(s) {
    t.useLocalFirst = s;
  };
  let i = [];
  function n(s) {
    const a = Object.keys(s).filter((c) => c.charCodeAt(0) === 36);
    let l = o.omit(s, ...a);
    o.forOwn(l, (c, u) => {
      typeof c == "object" && o.has(c, "$search") && (l[u] = { $regex: new RegExp(o.get(c, "$search"), "i") });
    });
    for (const c of i)
      l = c(l);
    return Pe(l);
  }
  t.registerMatcher = function(s) {
    i.includes(s) || i.push(s);
  }, t.unregisterMatcher = function(s) {
    i = i.filter((a) => a !== s);
  }, t.matcher = n, t.getServicePath = function(s, a, l = !0) {
    let c = s;
    return o.isEmpty(a) || (typeof a == "string" ? a !== "global" && (c = a + "/" + s) : a._id && (c = a._id + "/" + s)), l && (c = e.apiPath + "/" + c), c.startsWith("/") && (c = c.substr(1)), c;
  }, t.getServiceInstance = function(s, a, l = {}) {
    let c;
    if (o.isEmpty(a)) {
      const u = V.get("context"), d = t.getServicePath(s, u), f = t.services[d], h = t.getServicePath(s), g = t.services[h];
      c = f || g, !c && l.create && (c = t.service(h));
    } else {
      const u = t.getServicePath(s, a);
      c = l.create ? t.service(u) : t.services[u];
    }
    return c;
  }, t.getOnlineService = function(s, a, l = {}) {
    return t.getServiceInstance(s, a, Object.assign({ create: !0 }, l));
  }, t.getOfflineService = function(s, a, l = {}) {
    return t.getServiceInstance(`${s}-offline`, a, Object.assign({ create: !1 }, l));
  }, t.getService = function(s, a, l = {}) {
    let c;
    if ((t.isDisconnected || t.useLocalFirst) && (c = t.getOfflineService(s, a, l), !c && !t.useLocalFirst && z.warn("[KDK] Cannot retrieve offline service " + s + " for context " + (typeof a == "object" ? a._id : a))), !c && (c = t.getOnlineService(s, a, l), !c))
      throw new Error("Cannot retrieve service " + s + " for context " + (typeof a == "object" ? a._id : a));
    return c;
  }, t.createService = function(s, a = {}) {
    const l = t.getServicePath(s, a.context);
    let c = a.service;
    return typeof c == "function" && (c = c(s, t, a)), c || (c = t.transporter.service(l)), t.use(l, c, a), c = t.service(l), a.hooks && c.hooks(a.hooks), a.context && (c.context = a.context), c.path = l, c;
  }, t.createOfflineService = async function(s, a = {}) {
    const l = `${s}-offline`;
    let c = t.getOfflineService(s);
    if (!c) {
      const u = o.omit(a, ["hooks", "snapshot", "clear", "baseQuery", "baseQueries", "dataPath"]), d = await Ce.getItem("services") || {};
      o.set(d, s, u), await Ce.setItem("services", d), c = t.createService(l, {
        service: $h({
          id: "_id",
          name: "offline_services",
          storeName: s,
          multi: !0,
          storage: ["IndexedDB"],
          // FIXME: this should not be hard-coded as it depends on the service
          // For now we set it at the max value but if a component
          // does not explicitly set the limit it will get a lot of data
          paginate: { default: 5e3, max: 5e3 }
        }),
        // Set required default hooks
        hooks: o.defaultsDeep(o.get(a, "hooks"), {
          before: {
            all: [Fo, ko],
            create: [Mo]
          }
        }),
        ...u
      });
    }
    if (o.get(a, "snapshot", !0)) {
      const u = t.getOnlineService(s);
      await qc(u, Object.assign({ offlineService: c }, a));
    }
    return c;
  }, t.removeService = function(s, a) {
    const l = t.getServicePath(s, a);
    t.unuse(l);
  }, t.getConfig = function(s) {
    return s ? o.get(e, s) : e;
  }, t.setConfig = function(s, a) {
    o.set(e, s, a);
  }, t.hasConfig = function(s, a) {
    return o.has(e, s, a);
  }, t.can = function() {
    let s, a, l;
    const c = arguments[arguments.length - 1], u = o.has(c, "abilities"), d = u ? arguments.length - 1 : arguments.length, f = arguments[0];
    s = arguments[1], d === 4 ? (a = arguments[2], l = arguments[3]) : typeof arguments[2] == "string" ? a = arguments[2] : l = arguments[2], o.has(s, "abilities") && (s = void 0), o.has(a, "abilities") && (a = void 0), o.has(l, "abilities") && (l = void 0);
    const h = u ? o.get(c, "abilities") : V.get("user.abilities");
    if (z.debug("[KDK] Check for abilities ", f, s, a, l, h), !h)
      return z.debug("[KDK] Access denied without abilities"), !1;
    let g;
    if (s) {
      const v = t.getServicePath(s, a, !1);
      if (g = jc(h, v), g) {
        if (f === "service")
          return !0;
      } else return z.debug("[KDK] Access to service path " + v + " denied"), !1;
      g = Vc(h, f, s, a, l);
    } else
      g = h.can(f);
    return g ? z.debug("[KDK] Access to resource granted") : z.debug("[KDK] Access to resource denied"), g;
  };
  const r = t.getConfig("domain");
  if (e.transport === "http" ? (t.transporter = Sn.rest(r).fetch(window.fetch.bind(window)), t.configure(t.transporter)) : (t.socket = gm(r, {
    transports: ["websocket"],
    path: (e.apiPath || "/") + "ws"
  }), t.transporter = Sn.socketio(t.socket, { timeout: e.apiTimeout || 1e4 }), t.configure(t.transporter), t.socket.on("rate-limit", (s) => ne.emit("error", s)), t.socket.io.on("reconnect", async () => {
    t.isDisconnected = !1, t.socket.sendBuffer = [], await t.reAuthenticate(!0), ne.emit("websocket-reconnected", t), z.info("[KDK] Socket has been reconnected");
  }), t.socket.io.on("reconnect_error", () => {
    t.isDisconnected = !0, ne.emit("websocket-disconnected", t), z.error(new Error("[KDK] Socket has been disconnected"));
  })), t.configure(Sn.authentication({
    storage: window.localStorage,
    storageKey: e.apiJwt || "feathers-jwt",
    path: e.apiPath + "/authentication"
  })), t.configure(pm({
    idField: "_id",
    matcher: n
    // Our custom matcher to handle fuzzy search
  })), t.renewJwtOnExpiration = function(s) {
    const { accessToken: a } = s, l = mm(a);
    if (!l.exp) return;
    const c = fe(), d = fe.unix(l.exp).diff(c) - 2e3;
    setTimeout(() => {
      t.reAuthenticate(!0);
    }, d);
  }, o.get(e, "renewJwt", !0) && t.on("login", t.renewJwtOnExpiration), t.configure = async function(s) {
    return await s.call(this, this), this;
  }, t.getConfig("domain") || t.setConfig("domain", window.location.origin), !t.isDisconnected)
    try {
      const s = new URL(t.getConfig("domain") + e.apiPath + "/capabilities");
      s.searchParams.set("random", Math.random().toFixed(18).substring(2, 18)), await window.fetch(s.toString(), { method: "HEAD" });
    } catch (s) {
      t.isDisconnected = !0, ne.emit("navigator-disconnected", t), z.warn(`[KDK] Cannot request target domain ${t.getConfig("domain")}, setting state to offline`, s);
    }
  return t;
}
let q;
async function og(e) {
  return q = await Do(me), e && e.call(q, me), q;
}
const ct = {
  serviceName: null,
  service: null,
  initialize() {
    this.serviceName = o.get(me, "context.service"), o.isEmpty(this.serviceName) || (V.set("context", null), z.debug(`[KDK] Context configured with service '${this.serviceName}'`));
  },
  get() {
    return V.get("context");
  },
  getId() {
    return o.get(this.get(), "_id");
  },
  getRef() {
    return V.getRef("context");
  },
  getService() {
    if (o.isEmpty(this.serviceName)) throw new Error("[KDK] Context service undefined !");
    if (this.service) return this.service;
    if (this.service = q.getService(this.serviceName), o.isNil(this.service)) throw new Error("[KDK] Context service not found !");
    return this.service;
  },
  set(e) {
    V.set("context", e);
  }
};
function nn(e, t, i, n) {
  return Object.defineProperty(e, t, {
    get: i,
    set: n,
    enumerable: !0
  }), e;
}
const ai = ue(
  !1
);
let ls;
function ag(e, t) {
  const i = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(vivaldi)[\/]([\w.]+)/.exec(e) || /(chrome|crios)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(firefox|fxios)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(e) || [];
  return {
    browser: i[5] || i[3] || i[1] || "",
    version: i[2] || i[4] || "0",
    versionNumber: i[4] || i[2] || "0",
    platform: t[0] || ""
  };
}
function lg(e) {
  return /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(silk)/.exec(e) || /(android)/.exec(e) || /(win)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || /(playbook)/.exec(e) || /(bb)/.exec(e) || /(blackberry)/.exec(e) || [];
}
const Hc = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function cg(e) {
  ls = { is: { ...e } }, delete e.mac, delete e.desktop;
  const t = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(e, {
    mobile: !0,
    ios: !0,
    platform: t,
    [t]: !0
  });
}
function ug(e) {
  const t = e.toLowerCase(), i = lg(t), n = ag(t, i), r = {};
  n.browser && (r[n.browser] = !0, r.version = n.version, r.versionNumber = parseInt(n.versionNumber, 10)), n.platform && (r[n.platform] = !0);
  const s = r.android || r.ios || r.bb || r.blackberry || r.ipad || r.iphone || r.ipod || r.kindle || r.playbook || r.silk || r["windows phone"];
  return s === !0 || t.indexOf("mobile") > -1 ? (r.mobile = !0, r.edga || r.edgios ? (r.edge = !0, n.browser = "edge") : r.crios ? (r.chrome = !0, n.browser = "chrome") : r.fxios && (r.firefox = !0, n.browser = "firefox")) : r.desktop = !0, (r.ipod || r.ipad || r.iphone) && (r.ios = !0), r["windows phone"] && (r.winphone = !0, delete r["windows phone"]), (r.chrome || r.opr || r.safari || r.vivaldi || r.mobile === !0 && r.ios !== !0 && s !== !0) && (r.webkit = !0), r.edg && (n.browser = "edgechromium", r.edgeChromium = !0), (r.safari && r.blackberry || r.bb) && (n.browser = "blackberry", r.blackberry = !0), r.safari && r.playbook && (n.browser = "playbook", r.playbook = !0), r.opr && (n.browser = "opera", r.opera = !0), r.safari && r.android && (n.browser = "android", r.android = !0), r.safari && r.kindle && (n.browser = "kindle", r.kindle = !0), r.safari && r.silk && (n.browser = "silk", r.silk = !0), r.vivaldi && (n.browser = "vivaldi", r.vivaldi = !0), r.name = n.browser, r.platform = n.platform, t.indexOf("electron") > -1 ? r.electron = !0 : document.location.href.indexOf("-extension://") > -1 ? r.bex = !0 : (window.Capacitor !== void 0 ? (r.capacitor = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "capacitor") : (window._cordovaNative !== void 0 || window.cordova !== void 0) && (r.cordova = !0, r.nativeMobile = !0, r.nativeMobileWrapper = "cordova"), Hc === !0 && r.mac === !0 && (r.desktop === !0 && r.safari === !0 || r.nativeMobile === !0 && r.android !== !0 && r.ios !== !0 && r.ipad !== !0) && cg(r)), r;
}
const $a = navigator.userAgent || navigator.vendor || window.opera, dg = {
  has: {
    touch: !1,
    webStorage: !1
  },
  within: { iframe: !1 }
}, Fe = {
  userAgent: $a,
  is: ug($a),
  has: {
    touch: Hc
  },
  within: {
    iframe: window.self !== window.top
  }
}, Ti = {
  install(e) {
    const { $q: t } = e;
    ai.value === !0 ? (e.onSSRHydrated.push(() => {
      Object.assign(t.platform, Fe), ai.value = !1, ls = void 0;
    }), t.platform = Nt(this)) : t.platform = this;
  }
};
{
  let e;
  nn(Fe.has, "webStorage", () => {
    if (e !== void 0)
      return e;
    try {
      if (window.localStorage)
        return e = !0, !0;
    } catch {
    }
    return e = !1, !1;
  }), Fe.is.ios === !0 && window.navigator.vendor.toLowerCase().indexOf("apple"), ai.value === !0 ? Object.assign(Ti, Fe, ls, dg) : Object.assign(Ti, Fe);
}
const Vt = {
  async initialize() {
    o.merge(this, o.omit(Ti, ["install", "__installed"])), this.fingerprint = await Bh(), this.fingerprintData = await Rh(), this.is.pwa = o.get(me, "buildMode", "spa") === "pwa", z.debug("[KDK] Platform initialized with:", this);
  },
  getData(e) {
    const t = {
      userAgent: this.userAgent,
      application: {
        mode: this.is.pwa ? "PWA" : "SPA",
        iframe: this.within.iframe,
        permissions: o.get(this.fingerprintData, "permissions")
      },
      browser: Object.assign(
        {},
        o.get(this.fingerprintData, "system.browser"),
        { locale: o.get(this.fingerprintData, "locales") },
        { webgl: o.get(this.fingerprintData, "hardware.videocard") }
      ),
      system: {
        os: o.get(this.fingerprintData, "system.platform"),
        desktop: this.is.desktop || !1,
        mobile: this.is.mobile || !1,
        touch: this.is.touch || !1
      }
    };
    return o.isEmpty(e) ? t : o.get(t, e);
  }
}, Dr = {
  async initialize() {
    if ((q.isDisconnected || q.useLocalFirst) && (this.content = await Ce.getItem("capabilities")), !this.content) {
      const e = await window.fetch(q.getConfig("domain") + o.get(me, "apiPath") + "/capabilities");
      this.content = await e.json(), await Ce.setItem("capabilities", this.content);
    }
    z.debug("[KDK] Capabilities initialized with content:", this.content), this.content && (o.forOwn(o.pick(this.content, ["gateway"]), (e, t) => {
      q.setConfig(t, e);
    }), V.set("capabilities.api", this.content), V.set("capabilities.client", o.pick(me, ["version", "buildNumber"])));
  },
  get(e, t) {
    if (!this.content) z.error(new Error("[KDK] Capabilities must be initialized first"));
    else return o.get(this.content, e, t);
  }
}, nt = {
  initialize() {
    this.prefix = o.get(me, "appSlug", o.kebabCase(o.get(me, "appName", "kdk"))), z.debug(`[KDK] LocalStorage initialized with prefix: '${this.prefix}'`);
  },
  localKey(e) {
    const t = `${this.prefix}-`;
    return o.startsWith(t) ? e : `${t}${e}`;
  },
  set(e, t) {
    const i = JSON.stringify(t);
    window.localStorage.setItem(this.localKey(e), i);
  },
  has(e) {
    const t = window.localStorage.getItem(this.localKey(e));
    return !o.isNil(t);
  },
  get(e, t) {
    const i = window.localStorage.getItem(this.localKey(e));
    return o.isNil(i) ? (z.debug(`[KDK] Cannot find local storage value with key '${e}'. Returning default value '${t}'`), t) : JSON.parse(i);
  },
  clear(e) {
    window.localStorage.removeItem(this.localKey(e));
  }
}, Wc = {
  initialize() {
    this.channelName = o.get(me, "appSlug", o.kebabCase(o.get(me, "appName", "kdk"))), this.channel = new BroadcastChannel(this.channelName), z.debug(`[KDK] Broadcaster initialized with channel '${this.channelName}'`);
  },
  getChannelName() {
    return this.channelName;
  },
  getChannel() {
    return this.channel;
  },
  post(e) {
    this.channel.postMessage(e);
  }
}, rn = (e, t) => {
  const i = Nt(e);
  for (const n in e)
    nn(
      t,
      n,
      () => i[n],
      (r) => {
        i[n] = r;
      }
    );
  return t;
}, pt = {
  hasPassive: !1,
  passiveCapture: !0,
  notPassiveCapture: !0
};
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(pt, {
        hasPassive: !0,
        passive: { passive: !0 },
        notPassive: { passive: !1 },
        passiveCapture: { passive: !0, capture: !0 },
        notPassiveCapture: { passive: !1, capture: !0 }
      });
    }
  });
  window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e);
} catch {
}
function Zi() {
}
function fg(e) {
  return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), {
    top: e.clientY,
    left: e.clientX
  };
}
function hg(e) {
  if (e.path)
    return e.path;
  if (e.composedPath)
    return e.composedPath();
  const t = [];
  let i = e.target;
  for (; i; ) {
    if (t.push(i), i.tagName === "HTML")
      return t.push(document), t.push(window), t;
    i = i.parentElement;
  }
}
function Ar(e) {
  e.stopPropagation();
}
function Vi(e) {
  e.cancelable !== !1 && e.preventDefault();
}
function yt(e) {
  e.cancelable !== !1 && e.preventDefault(), e.stopPropagation();
}
function mg(e, t, i) {
  const n = `__q_${t}_evt`;
  e[n] = e[n] !== void 0 ? e[n].concat(i) : i, i.forEach((r) => {
    r[0].addEventListener(r[1], e[r[2]], pt[r[3]]);
  });
}
function gg(e, t) {
  const i = `__q_${t}_evt`;
  e[i] !== void 0 && (e[i].forEach((n) => {
    n[0].removeEventListener(n[1], e[n[2]], pt[n[3]]);
  }), e[i] = void 0);
}
function Zc(e, t = 250, i) {
  let n = null;
  function r() {
    const s = arguments, a = () => {
      n = null, e.apply(this, s);
    };
    n !== null && clearTimeout(n), n = setTimeout(a, t);
  }
  return r.cancel = () => {
    n !== null && clearTimeout(n);
  }, r;
}
const As = ["sm", "md", "lg", "xl"], { passive: Ia } = pt, bt = rn({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0
  },
  gt: {
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1
  },
  xs: !0,
  sm: !1,
  md: !1,
  lg: !1,
  xl: !1
}, {
  setSizes: Zi,
  setDebounce: Zi,
  install({ $q: e, onSSRHydrated: t }) {
    if (e.screen = this, this.__installed === !0) {
      e.config.screen !== void 0 && (e.config.screen.bodyClasses === !1 ? document.body.classList.remove(`screen--${this.name}`) : this.__update(!0));
      return;
    }
    const { visualViewport: i } = window, n = i || window, r = document.scrollingElement || document.documentElement, s = i === void 0 || Fe.is.mobile === !0 ? () => [
      Math.max(window.innerWidth, r.clientWidth),
      Math.max(window.innerHeight, r.clientHeight)
    ] : () => [
      i.width * i.scale + window.innerWidth - r.clientWidth,
      i.height * i.scale + window.innerHeight - r.clientHeight
    ], a = e.config.screen !== void 0 && e.config.screen.bodyClasses === !0;
    this.__update = (f) => {
      const [h, g] = s();
      if (g !== this.height && (this.height = g), h !== this.width)
        this.width = h;
      else if (f !== !0)
        return;
      let v = this.sizes;
      this.gt.xs = h >= v.sm, this.gt.sm = h >= v.md, this.gt.md = h >= v.lg, this.gt.lg = h >= v.xl, this.lt.sm = h < v.sm, this.lt.md = h < v.md, this.lt.lg = h < v.lg, this.lt.xl = h < v.xl, this.xs = this.lt.sm, this.sm = this.gt.xs === !0 && this.lt.md === !0, this.md = this.gt.sm === !0 && this.lt.lg === !0, this.lg = this.gt.md === !0 && this.lt.xl === !0, this.xl = this.gt.lg, v = this.xs === !0 && "xs" || this.sm === !0 && "sm" || this.md === !0 && "md" || this.lg === !0 && "lg" || "xl", v !== this.name && (a === !0 && (document.body.classList.remove(`screen--${this.name}`), document.body.classList.add(`screen--${v}`)), this.name = v);
    };
    let l, c = {}, u = 16;
    this.setSizes = (f) => {
      As.forEach((h) => {
        f[h] !== void 0 && (c[h] = f[h]);
      });
    }, this.setDebounce = (f) => {
      u = f;
    };
    const d = () => {
      const f = getComputedStyle(document.body);
      f.getPropertyValue("--q-size-sm") && As.forEach((h) => {
        this.sizes[h] = parseInt(f.getPropertyValue(`--q-size-${h}`), 10);
      }), this.setSizes = (h) => {
        As.forEach((g) => {
          h[g] && (this.sizes[g] = h[g]);
        }), this.__update(!0);
      }, this.setDebounce = (h) => {
        l !== void 0 && n.removeEventListener("resize", l, Ia), l = h > 0 ? Zc(this.__update, h) : this.__update, n.addEventListener("resize", l, Ia);
      }, this.setDebounce(u), Object.keys(c).length !== 0 ? (this.setSizes(c), c = void 0) : this.__update(), a === !0 && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    ai.value === !0 ? t.push(d) : d();
  }
}), He = rn({
  isActive: !1,
  mode: !1
}, {
  __media: void 0,
  set(e) {
    He.mode = e, e === "auto" ? (He.__media === void 0 && (He.__media = window.matchMedia("(prefers-color-scheme: dark)"), He.__updateMedia = () => {
      He.set("auto");
    }, He.__media.addListener(He.__updateMedia)), e = He.__media.matches) : He.__media !== void 0 && (He.__media.removeListener(He.__updateMedia), He.__media = void 0), He.isActive = e === !0, document.body.classList.remove(`body--${e === !0 ? "light" : "dark"}`), document.body.classList.add(`body--${e === !0 ? "dark" : "light"}`);
  },
  toggle() {
    He.set(He.isActive === !1);
  },
  install({ $q: e, onSSRHydrated: t, ssrContext: i }) {
    const { dark: n } = e.config;
    if (e.dark = this, this.__installed === !0 && n === void 0)
      return;
    this.isActive = n === !0;
    const r = n !== void 0 ? n : !1;
    if (ai.value === !0) {
      const s = (l) => {
        this.__fromSSR = l;
      }, a = this.set;
      this.set = s, s(r), t.push(() => {
        this.set = a, this.set(this.__fromSSR);
      });
    } else
      this.set(r);
  }
}), Jc = () => !0;
function pg(e) {
  return typeof e == "string" && e !== "" && e !== "/" && e !== "#/";
}
function yg(e) {
  return e.startsWith("#") === !0 && (e = e.substring(1)), e.startsWith("/") === !1 && (e = "/" + e), e.endsWith("/") === !0 && (e = e.substring(0, e.length - 1)), "#" + e;
}
function vg(e) {
  if (e.backButtonExit === !1)
    return () => !1;
  if (e.backButtonExit === "*")
    return Jc;
  const t = ["#/"];
  return Array.isArray(e.backButtonExit) === !0 && t.push(
    ...e.backButtonExit.filter(pg).map(yg)
  ), () => t.includes(window.location.hash);
}
const to = {
  __history: [],
  add: Zi,
  remove: Zi,
  install({ $q: e }) {
    if (this.__installed === !0)
      return;
    const { cordova: t, capacitor: i } = Fe.is;
    if (t !== !0 && i !== !0)
      return;
    const n = e.config[t === !0 ? "cordova" : "capacitor"];
    if (n !== void 0 && n.backButton === !1 || // if we're on Capacitor mode
    i === !0 && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0))
      return;
    this.add = (a) => {
      a.condition === void 0 && (a.condition = Jc), this.__history.push(a);
    }, this.remove = (a) => {
      const l = this.__history.indexOf(a);
      l >= 0 && this.__history.splice(l, 1);
    };
    const r = vg(
      Object.assign(
        { backButtonExit: !0 },
        n
      )
    ), s = () => {
      if (this.__history.length) {
        const a = this.__history[this.__history.length - 1];
        a.condition() === !0 && (this.__history.pop(), a.handler());
      } else r() === !0 ? navigator.app.exitApp() : window.history.back();
    };
    t === !0 ? document.addEventListener("deviceready", () => {
      document.addEventListener("backbutton", s, !1);
    }) : window.Capacitor.Plugins.App.addListener("backButton", s);
  }
}, za = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (e) => e ? `Expand "${e}"` : "Expand",
    collapse: (e) => e ? `Collapse "${e}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: !1,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (e) => e === 1 ? "1 record selected." : (e === 0 ? "No" : e) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (e, t, i) => e + "-" + t + " of " + i,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function Na() {
  const e = Array.isArray(navigator.languages) === !0 && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof e == "string")
    return e.split(/[-_]/).map((t, i) => i === 0 ? t.toLowerCase() : i > 1 || t.length < 4 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1).toLowerCase()).join("-");
}
const St = rn({
  __langPack: {}
}, {
  getLocale: Na,
  set(e = za, t) {
    const i = {
      ...e,
      rtl: e.rtl === !0,
      getLocale: Na
    };
    {
      if (i.set = St.set, St.__langConfig === void 0 || St.__langConfig.noHtmlAttrs !== !0) {
        const n = document.documentElement;
        n.setAttribute("dir", i.rtl === !0 ? "rtl" : "ltr"), n.setAttribute("lang", i.isoName);
      }
      Object.assign(St.__langPack, i), St.props = i, St.isoName = i.isoName, St.nativeName = i.nativeName;
    }
  },
  install({ $q: e, lang: t, ssrContext: i }) {
    e.lang = St.__langPack, St.__langConfig = e.config.lang, this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || za);
  }
});
let Qc = !1;
function bg(e) {
  Qc = e.isComposing === !0;
}
function Yc(e) {
  return Qc === !0 || e !== Object(e) || e.isComposing === !0 || e.qKeyEvent === !0;
}
function On(e, t) {
  return Yc(e) === !0 ? !1 : [].concat(t).includes(e.keyCode);
}
function Xc(e) {
  if (e.ios === !0) return "ios";
  if (e.android === !0) return "android";
}
function wg({ is: e, has: t, within: i }, n) {
  const r = [
    e.desktop === !0 ? "desktop" : "mobile",
    `${t.touch === !1 ? "no-" : ""}touch`
  ];
  if (e.mobile === !0) {
    const s = Xc(e);
    s !== void 0 && r.push("platform-" + s);
  }
  if (e.nativeMobile === !0) {
    const s = e.nativeMobileWrapper;
    r.push(s), r.push("native-mobile"), e.ios === !0 && (n[s] === void 0 || n[s].iosStatusBarPadding !== !1) && r.push("q-ios-padding");
  } else e.electron === !0 ? r.push("electron") : e.bex === !0 && r.push("bex");
  return i.iframe === !0 && r.push("within-iframe"), r;
}
function _g() {
  const { is: e } = Fe, t = document.body.className, i = new Set(t.replace(/ {2}/g, " ").split(" "));
  if (ls !== void 0)
    i.delete("desktop"), i.add("platform-ios"), i.add("mobile");
  else if (e.nativeMobile !== !0 && e.electron !== !0 && e.bex !== !0) {
    if (e.desktop === !0)
      i.delete("mobile"), i.delete("platform-ios"), i.delete("platform-android"), i.add("desktop");
    else if (e.mobile === !0) {
      i.delete("desktop"), i.add("mobile");
      const r = Xc(e);
      r !== void 0 ? (i.add(`platform-${r}`), i.delete(`platform-${r === "ios" ? "android" : "ios"}`)) : (i.delete("platform-ios"), i.delete("platform-android"));
    }
  }
  Fe.has.touch === !0 && (i.delete("no-touch"), i.add("touch")), Fe.within.iframe === !0 && i.add("within-iframe");
  const n = Array.from(i).join(" ");
  t !== n && (document.body.className = n);
}
function Lg(e) {
  for (const t in e)
    xt(t, e[t]);
}
const xg = {
  install(e) {
    if (this.__installed !== !0) {
      if (ai.value === !0)
        _g();
      else {
        const { $q: t } = e;
        t.config.brand !== void 0 && Lg(t.config.brand);
        const i = wg(Fe, t.config);
        document.body.classList.add.apply(document.body.classList, i);
      }
      Fe.is.ios === !0 && document.body.addEventListener("touchstart", Zi), window.addEventListener("keydown", bg, !0);
    }
  }
}, Sg = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
}, Or = rn({
  iconMapFn: null,
  __icons: {}
}, {
  set(e, t) {
    const i = { ...e, rtl: e.rtl === !0 };
    i.set = Or.set, Object.assign(Or.__icons, i);
  },
  install({ $q: e, iconSet: t, ssrContext: i }) {
    e.config.iconMapFn !== void 0 && (this.iconMapFn = e.config.iconMapFn), e.iconSet = this.__icons, nn(e, "iconMapFn", () => this.iconMapFn, (n) => {
      this.iconMapFn = n;
    }), this.__installed === !0 ? t !== void 0 && this.set(t) : this.set(t || Sg);
  }
}), eu = "_q_", Cg = "_q_fo_", Br = {};
let tu = !1;
function Eg() {
  tu = !0;
}
function vt(e) {
  return e !== null && typeof e == "object" && Array.isArray(e) !== !0;
}
function Tg(e) {
  return typeof e == "number" && isFinite(e);
}
const ja = [
  Ti,
  xg,
  He,
  bt,
  to,
  St,
  Or
];
function Ao(e, t) {
  const i = Nh(e);
  i.config.globalProperties = t.config.globalProperties;
  const { reload: n, ...r } = t._context;
  return Object.assign(i._context, r), i;
}
function Va(e, t) {
  t.forEach((i) => {
    i.install(e), i.__installed = !0;
  });
}
function Pg(e, t, i) {
  e.config.globalProperties.$q = i.$q, e.provide(eu, i.$q), Va(i, ja), t.components !== void 0 && Object.values(t.components).forEach((n) => {
    vt(n) === !0 && n.name !== void 0 && e.component(n.name, n);
  }), t.directives !== void 0 && Object.values(t.directives).forEach((n) => {
    vt(n) === !0 && n.name !== void 0 && e.directive(n.name, n);
  }), t.plugins !== void 0 && Va(
    i,
    Object.values(t.plugins).filter(
      (n) => typeof n.install == "function" && ja.includes(n) === !1
    )
  ), ai.value === !0 && (i.$q.onSSRHydrated = () => {
    i.onSSRHydrated.forEach((n) => {
      n();
    }), i.$q.onSSRHydrated = () => {
    };
  });
}
const kg = function(e, t = {}) {
  const i = { version: "2.12.0" };
  tu === !1 ? (t.config !== void 0 && Object.assign(Br, t.config), i.config = { ...Br }, Eg()) : i.config = t.config || {}, Pg(e, t, {
    parentApp: e,
    $q: i,
    lang: t.lang,
    iconSet: t.iconSet,
    onSSRHydrated: []
  });
}, Mg = {
  version: "2.12.0",
  install: kg,
  lang: St,
  iconSet: Or
};
function iu() {
  return navigator.language || o.get(navigator, "languages.0") || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;
}
function Bt(e = !0) {
  const t = o.get(me, "locale.default", iu());
  if (!e) return t;
  const i = o.split(t, "-");
  return o.head(i);
}
function nu(e = !0) {
  const t = o.get(me, "locale.fallbackLocale", "en-GB");
  if (!e) return t;
  const i = o.split(t, "-");
  return o.head(i);
}
async function Fg(e, t, i) {
  const n = {};
  n[t] = {}, n[i] = {};
  for (let r = 0; r < e.length; r++) {
    try {
      const s = await import(`@i18n/${e[r]}_${t}.json`);
      o.merge(n[t], s.default);
    } catch {
      z.warn(`[KDK] unable to load translation file ${e[r]}_${t}.json`);
    }
    try {
      const s = await import(`@i18n/${e[r]}_${i}.json`);
      o.merge(n[i], s.default);
    } catch {
      z.error(`[KDK] unable to load translation file ${e[r]}_${i}.json`);
    }
  }
  return n;
}
const Y = {
  async initialize(e, t) {
    const i = nu(), n = Bt();
    this.i18n = Jh({
      locale: n,
      fallbackLocale: i,
      messages: await Fg(t, n, i),
      silentFallbackWarn: !0
    }), e.use(this.i18n);
    try {
      const r = await import(`quasar/lang/${Bt(!1)}.js`);
      r && Mg.lang.set(r.default);
    } catch (r) {
      z.error(r);
    }
  },
  registerTranslation(e) {
    if (!this.i18n) {
      z.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return;
    }
    const t = this.i18n.global.locale;
    let i = e[t];
    i && this.i18n.global.mergeLocaleMessage(t, i);
    const n = this.i18n.global.fallbackLocale;
    i = e[n], i && this.i18n.global.mergeLocaleMessage(n, i);
  },
  t(e, t) {
    return this.i18n ? this.i18n.global.t(e, t) : (z.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e);
  },
  tc(e, t) {
    if (!this.i18n)
      return z.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e;
    if (this.i18n.global.te(e)) return this.i18n.global.tc(e, t);
    if (this.i18n.global.te(e, this.i18n.global.fallbackLocale)) return this.i18n.global.tc(e, t, this.i18n.global.fallbackLocale);
  },
  tie(e, t) {
    return this.i18n ? o.isEmpty(e) ? e : this.i18n.global.te(e) ? this.i18n.global.t(e, t) : this.i18n.global.te(e, this.i18n.global.fallbackLocale) ? this.i18n.global.t(e, this.i18n.global.fallbackLocale, t) : e : (z.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e);
  },
  localize(e) {
    if (!this.i18n)
      return z.error("[KDK] i18n instance is not existing. Did you initialize it ?"), e;
    const t = e.lastIndexOf("."), i = t > 0 ? e.substring(0, t) : e, n = t > 0 ? e.substring(t, e.length) : "";
    return [
      `${i}_${this.i18n.global.locale}${n}`,
      `${i}_${this.i18n.global.fallbackLocale}${n}`,
      e
    ];
  }
}, io = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
}, Kn = {
  size: String
};
function Hn(e, t = io) {
  return W(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null);
}
const Je = (e) => ns(jh(e)), Dg = (e) => ns(e);
function Tt(e, t) {
  return e !== void 0 && e() || t;
}
function yi(e, t) {
  return e !== void 0 ? t.concat(e()) : t;
}
function Ag(e, t) {
  return e === void 0 ? t : t !== void 0 ? t.concat(e()) : e();
}
const Ua = "0 0 24 24", qa = (e) => e, Os = (e) => `ionicons ${e}`, ru = {
  "mdi-": (e) => `mdi ${e}`,
  "icon-": qa,
  // fontawesome equiv
  "bt-": (e) => `bt ${e}`,
  "eva-": (e) => `eva ${e}`,
  "ion-md": Os,
  "ion-ios": Os,
  "ion-logo": Os,
  "iconfont ": qa,
  "ti-": (e) => `themify-icon ${e}`,
  "bi-": (e) => `bootstrap-icons ${e}`
}, su = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
}, ou = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
}, Og = new RegExp("^(" + Object.keys(ru).join("|") + ")"), Bg = new RegExp("^(" + Object.keys(su).join("|") + ")"), Ga = new RegExp("^(" + Object.keys(ou).join("|") + ")"), Rg = /^[Mm]\s?[-+]?\.?\d/, $g = /^img:/, Ig = /^svguse:/, zg = /^ion-/, Ng = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /, Kt = Je({
  name: "QIcon",
  props: {
    ...Kn,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: i } } = Ve(), n = Hn(e), r = W(
      () => "q-icon" + (e.left === !0 ? " on-left" : "") + (e.right === !0 ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")
    ), s = W(() => {
      let a, l = e.name;
      if (l === "none" || !l)
        return { none: !0 };
      if (i.iconMapFn !== null) {
        const d = i.iconMapFn(l);
        if (d !== void 0)
          if (d.icon !== void 0) {
            if (l = d.icon, l === "none" || !l)
              return { none: !0 };
          } else
            return {
              cls: d.cls,
              content: d.content !== void 0 ? d.content : " "
            };
      }
      if (Rg.test(l) === !0) {
        const [d, f = Ua] = l.split("|");
        return {
          svg: !0,
          viewBox: f,
          nodes: d.split("&&").map((h) => {
            const [g, v, x] = h.split("@@");
            return K("path", { style: v, d: g, transform: x });
          })
        };
      }
      if ($g.test(l) === !0)
        return {
          img: !0,
          src: l.substring(4)
        };
      if (Ig.test(l) === !0) {
        const [d, f = Ua] = l.split("|");
        return {
          svguse: !0,
          src: d.substring(7),
          viewBox: f
        };
      }
      let c = " ";
      const u = l.match(Og);
      if (u !== null)
        a = ru[u[1]](l);
      else if (Ng.test(l) === !0)
        a = l;
      else if (zg.test(l) === !0)
        a = `ionicons ion-${i.platform.is.ios === !0 ? "ios" : "md"}${l.substring(3)}`;
      else if (Ga.test(l) === !0) {
        a = "notranslate material-symbols";
        const d = l.match(Ga);
        d !== null && (l = l.substring(6), a += ou[d[1]]), c = l;
      } else {
        a = "notranslate material-icons";
        const d = l.match(Bg);
        d !== null && (l = l.substring(2), a += su[d[1]]), c = l;
      }
      return {
        cls: a,
        content: c
      };
    });
    return () => {
      const a = {
        class: r.value,
        style: n.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      return s.value.none === !0 ? K(e.tag, a, Tt(t.default)) : s.value.img === !0 ? K("span", a, yi(t.default, [
        K("img", { src: s.value.src })
      ])) : s.value.svg === !0 ? K("span", a, yi(t.default, [
        K("svg", {
          viewBox: s.value.viewBox || "0 0 24 24"
        }, s.value.nodes)
      ])) : s.value.svguse === !0 ? K("span", a, yi(t.default, [
        K("svg", {
          viewBox: s.value.viewBox
        }, [
          K("use", { "xlink:href": s.value.src })
        ])
      ])) : (s.value.cls !== void 0 && (a.class += " " + s.value.cls), K(e.tag, a, yi(t.default, [
        s.value.content
      ])));
    };
  }
}), jg = Je({
  name: "QAvatar",
  props: {
    ...Kn,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(e, { slots: t }) {
    const i = Hn(e), n = W(
      () => "q-avatar" + (e.color ? ` bg-${e.color}` : "") + (e.textColor ? ` text-${e.textColor} q-chip--colored` : "") + (e.square === !0 ? " q-avatar--square" : e.rounded === !0 ? " rounded-borders" : "")
    ), r = W(() => e.fontSize ? { fontSize: e.fontSize } : null);
    return () => {
      const s = e.icon !== void 0 ? [K(Kt, { name: e.icon })] : void 0;
      return K("div", {
        class: n.value,
        style: i.value
      }, [
        K("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: r.value
        }, Ag(t.default, s))
      ]);
    };
  }
}), Vg = {
  size: {
    type: [Number, String],
    default: "1em"
  },
  color: String
};
function Ug(e) {
  return {
    cSize: W(() => e.size in io ? `${io[e.size]}px` : e.size),
    classes: W(
      () => "q-spinner" + (e.color ? ` text-${e.color}` : "")
    )
  };
}
const Ji = Je({
  name: "QSpinner",
  props: {
    ...Vg,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(e) {
    const { cSize: t, classes: i } = Ug(e);
    return () => K("svg", {
      class: i.value + " q-spinner-mat",
      width: t.value,
      height: t.value,
      viewBox: "25 25 50 50"
    }, [
      K("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": e.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function qg(e, t) {
  const i = e.style;
  for (const n in t)
    i[n] = t[n];
}
function Gg(e, t) {
  if (e == null || e.contains(t) === !0)
    return !0;
  for (let i = e.nextElementSibling; i !== null; i = i.nextElementSibling)
    if (i.contains(t))
      return !0;
  return !1;
}
function Kg(e, t = 250) {
  let i = !1, n;
  return function() {
    return i === !1 && (i = !0, setTimeout(() => {
      i = !1;
    }, t), n = e.apply(this, arguments)), n;
  };
}
function Ka(e, t, i, n) {
  i.modifiers.stop === !0 && Ar(e);
  const r = i.modifiers.color;
  let s = i.modifiers.center;
  s = s === !0 || n === !0;
  const a = document.createElement("span"), l = document.createElement("span"), c = fg(e), { left: u, top: d, width: f, height: h } = t.getBoundingClientRect(), g = Math.sqrt(f * f + h * h), v = g / 2, x = `${(f - g) / 2}px`, w = s ? x : `${c.left - u - v}px`, M = `${(h - g) / 2}px`, p = s ? M : `${c.top - d - v}px`;
  l.className = "q-ripple__inner", qg(l, {
    height: `${g}px`,
    width: `${g}px`,
    transform: `translate3d(${w},${p},0) scale3d(.2,.2,1)`,
    opacity: 0
  }), a.className = `q-ripple${r ? " text-" + r : ""}`, a.setAttribute("dir", "ltr"), a.appendChild(l), t.appendChild(a);
  const y = () => {
    a.remove(), clearTimeout(S);
  };
  i.abort.push(y);
  let S = setTimeout(() => {
    l.classList.add("q-ripple__inner--enter"), l.style.transform = `translate3d(${x},${M},0) scale3d(1,1,1)`, l.style.opacity = 0.2, S = setTimeout(() => {
      l.classList.remove("q-ripple__inner--enter"), l.classList.add("q-ripple__inner--leave"), l.style.opacity = 0, S = setTimeout(() => {
        a.remove(), i.abort.splice(i.abort.indexOf(y), 1);
      }, 275);
    }, 250);
  }, 50);
}
function Ha(e, { modifiers: t, value: i, arg: n }) {
  const r = Object.assign({}, e.cfg.ripple, t, i);
  e.modifiers = {
    early: r.early === !0,
    stop: r.stop === !0,
    center: r.center === !0,
    color: r.color || n,
    keyCodes: [].concat(r.keyCodes || 13)
  };
}
const Hg = Dg(
  {
    name: "ripple",
    beforeMount(e, t) {
      const i = t.instance.$.appContext.config.globalProperties.$q.config || {};
      if (i.ripple === !1)
        return;
      const n = {
        cfg: i,
        enabled: t.value !== !1,
        modifiers: {},
        abort: [],
        start(r) {
          n.enabled === !0 && r.qSkipRipple !== !0 && r.type === (n.modifiers.early === !0 ? "pointerdown" : "click") && Ka(r, e, n, r.qKeyEvent === !0);
        },
        keystart: Kg((r) => {
          n.enabled === !0 && r.qSkipRipple !== !0 && On(r, n.modifiers.keyCodes) === !0 && r.type === `key${n.modifiers.early === !0 ? "down" : "up"}` && Ka(r, e, n, !0);
        }, 300)
      };
      Ha(n, t), e.__qripple = n, mg(n, "main", [
        [e, "pointerdown", "start", "passive"],
        [e, "click", "start", "passive"],
        [e, "keydown", "keystart", "passive"],
        [e, "keyup", "keystart", "passive"]
      ]);
    },
    updated(e, t) {
      if (t.oldValue !== t.value) {
        const i = e.__qripple;
        i !== void 0 && (i.enabled = t.value !== !1, i.enabled === !0 && Object(t.value) === t.value && Ha(i, t));
      }
    },
    beforeUnmount(e) {
      const t = e.__qripple;
      t !== void 0 && (t.abort.forEach((i) => {
        i();
      }), gg(t, "main"), delete e._qripple);
    }
  }
), au = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
}, Wg = Object.keys(au), lu = {
  align: {
    type: String,
    validator: (e) => Wg.includes(e)
  }
};
function cu(e) {
  return W(() => {
    const t = e.align === void 0 ? e.vertical === !0 ? "stretch" : "left" : e.align;
    return `${e.vertical === !0 ? "items" : "justify"}-${au[t]}`;
  });
}
function uu(e) {
  return e.appContext.config.globalProperties.$router !== void 0;
}
function du(e) {
  return e.isUnmounted === !0 || e.isDeactivated === !0;
}
function Wa(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
function Za(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function Zg(e, t) {
  for (const i in t) {
    const n = t[i], r = e[i];
    if (typeof n == "string") {
      if (n !== r)
        return !1;
    } else if (Array.isArray(r) === !1 || r.length !== n.length || n.some((s, a) => s !== r[a]))
      return !1;
  }
  return !0;
}
function Ja(e, t) {
  return Array.isArray(t) === !0 ? e.length === t.length && e.every((i, n) => i === t[n]) : e.length === 1 && e[0] === t;
}
function Jg(e, t) {
  return Array.isArray(e) === !0 ? Ja(e, t) : Array.isArray(t) === !0 ? Ja(t, e) : e === t;
}
function Qg(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const i in e)
    if (Jg(e[i], t[i]) === !1)
      return !1;
  return !0;
}
const Yg = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  },
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
function Xg({ fallbackTag: e, useDisableForRouterLinkProps: t = !0 } = {}) {
  const i = Ve(), { props: n, proxy: r, emit: s } = i, a = uu(i), l = W(() => n.disable !== !0 && n.href !== void 0), c = t === !0 ? W(
    () => a === !0 && n.disable !== !0 && l.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ) : W(
    () => a === !0 && l.value !== !0 && n.to !== void 0 && n.to !== null && n.to !== ""
  ), u = W(() => c.value === !0 ? p(n.to) : null), d = W(() => u.value !== null), f = W(() => l.value === !0 || d.value === !0), h = W(() => n.type === "a" || f.value === !0 ? "a" : n.tag || e || "div"), g = W(() => l.value === !0 ? {
    href: n.href,
    target: n.target
  } : d.value === !0 ? {
    href: u.value.href,
    target: n.target
  } : {}), v = W(() => {
    if (d.value === !1)
      return -1;
    const { matched: C } = u.value, { length: T } = C, k = C[T - 1];
    if (k === void 0)
      return -1;
    const I = r.$route.matched;
    if (I.length === 0)
      return -1;
    const A = I.findIndex(
      Za.bind(null, k)
    );
    if (A > -1)
      return A;
    const P = Wa(C[T - 2]);
    return (
      // we are dealing with nested routes
      T > 1 && Wa(k) === P && I[I.length - 1].path !== P ? I.findIndex(
        Za.bind(null, C[T - 2])
      ) : A
    );
  }), x = W(
    () => d.value === !0 && v.value !== -1 && Zg(r.$route.params, u.value.params)
  ), w = W(
    () => x.value === !0 && v.value === r.$route.matched.length - 1 && Qg(r.$route.params, u.value.params)
  ), M = W(() => d.value === !0 ? w.value === !0 ? ` ${n.exactActiveClass} ${n.activeClass}` : n.exact === !0 ? "" : x.value === !0 ? ` ${n.activeClass}` : "" : "");
  function p(C) {
    try {
      return r.$router.resolve(C);
    } catch {
    }
    return null;
  }
  function y(C, { returnRouterError: T, to: k = n.to, replace: I = n.replace } = {}) {
    if (n.disable === !0)
      return C.preventDefault(), Promise.resolve(!1);
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      C.metaKey || C.altKey || C.ctrlKey || C.shiftKey || C.button !== void 0 && C.button !== 0 || n.target === "_blank"
    )
      return Promise.resolve(!1);
    C.preventDefault();
    const A = r.$router[I === !0 ? "replace" : "push"](k);
    return T === !0 ? A : A.then(() => {
    }).catch(() => {
    });
  }
  function S(C) {
    if (d.value === !0) {
      const T = (k) => y(C, k);
      s("click", C, T), C.defaultPrevented !== !0 && T();
    } else
      s("click", C);
  }
  return {
    hasRouterLink: d,
    hasHrefLink: l,
    hasLink: f,
    linkTag: h,
    resolvedLink: u,
    linkIsActive: x,
    linkIsExactActive: w,
    linkClass: M,
    linkAttrs: g,
    getLink: p,
    navigateToRouterLink: y,
    navigateOnClick: S
  };
}
const Qa = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
}, ep = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
}, tp = ["button", "submit", "reset"], ip = /[^\s]\/[^\s]/, np = ["flat", "outline", "push", "unelevated"], rp = (e, t) => e.flat === !0 ? "flat" : e.outline === !0 ? "outline" : e.push === !0 ? "push" : e.unelevated === !0 ? "unelevated" : t, sp = {
  ...Kn,
  ...Yg,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...np.reduce(
    (e, t) => (e[t] = Boolean) && e,
    {}
  ),
  square: Boolean,
  round: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  align: {
    ...lu.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
function op(e) {
  const t = Hn(e, ep), i = cu(e), { hasRouterLink: n, hasLink: r, linkTag: s, linkAttrs: a, navigateOnClick: l } = Xg({
    fallbackTag: "button"
  }), c = W(() => {
    const w = e.fab === !1 && e.fabMini === !1 ? t.value : {};
    return e.padding !== void 0 ? Object.assign({}, w, {
      padding: e.padding.split(/\s+/).map((M) => M in Qa ? Qa[M] + "px" : M).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : w;
  }), u = W(
    () => e.rounded === !0 || e.fab === !0 || e.fabMini === !0
  ), d = W(
    () => e.disable !== !0 && e.loading !== !0
  ), f = W(() => d.value === !0 ? e.tabindex || 0 : -1), h = W(() => rp(e, "standard")), g = W(() => {
    const w = { tabindex: f.value };
    return r.value === !0 ? Object.assign(w, a.value) : tp.includes(e.type) === !0 && (w.type = e.type), s.value === "a" ? (e.disable === !0 ? w["aria-disabled"] = "true" : w.href === void 0 && (w.role = "button"), n.value !== !0 && ip.test(e.type) === !0 && (w.type = e.type)) : e.disable === !0 && (w.disabled = "", w["aria-disabled"] = "true"), e.loading === !0 && e.percentage !== void 0 && Object.assign(w, {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": e.percentage
    }), w;
  }), v = W(() => {
    let w;
    e.color !== void 0 ? e.flat === !0 || e.outline === !0 ? w = `text-${e.textColor || e.color}` : w = `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (w = `text-${e.textColor}`);
    const M = e.round === !0 ? "round" : `rectangle${u.value === !0 ? " q-btn--rounded" : e.square === !0 ? " q-btn--square" : ""}`;
    return `q-btn--${h.value} q-btn--${M}` + (w !== void 0 ? " " + w : "") + (d.value === !0 ? " q-btn--actionable q-focusable q-hoverable" : e.disable === !0 ? " disabled" : "") + (e.fab === !0 ? " q-btn--fab" : e.fabMini === !0 ? " q-btn--fab-mini" : "") + (e.noCaps === !0 ? " q-btn--no-uppercase" : "") + (e.dense === !0 ? " q-btn--dense" : "") + (e.stretch === !0 ? " no-border-radius self-stretch" : "") + (e.glossy === !0 ? " glossy" : "") + (e.square ? " q-btn--square" : "");
  }), x = W(
    () => i.value + (e.stack === !0 ? " column" : " row") + (e.noWrap === !0 ? " no-wrap text-no-wrap" : "") + (e.loading === !0 ? " q-btn__content--hidden" : "")
  );
  return {
    classes: v,
    style: c,
    innerClasses: x,
    attributes: g,
    hasLink: r,
    linkTag: s,
    navigateOnClick: l,
    isActionable: d
  };
}
const { passiveCapture: mt } = pt;
let $i = null, Ii = null, zi = null;
const no = Je({
  name: "QBtn",
  props: {
    ...sp,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(e, { slots: t, emit: i }) {
    const { proxy: n } = Ve(), {
      classes: r,
      style: s,
      innerClasses: a,
      attributes: l,
      hasLink: c,
      linkTag: u,
      navigateOnClick: d,
      isActionable: f
    } = op(e), h = ue(null), g = ue(null);
    let v = null, x, w = null;
    const M = W(
      () => e.label !== void 0 && e.label !== null && e.label !== ""
    ), p = W(() => e.disable === !0 || e.ripple === !1 ? !1 : {
      keyCodes: c.value === !0 ? [13, 32] : [13],
      ...e.ripple === !0 ? {} : e.ripple
    }), y = W(() => ({ center: e.round })), S = W(() => {
      const $ = Math.max(0, Math.min(100, e.percentage));
      return $ > 0 ? { transition: "transform 0.6s", transform: `translateX(${$ - 100}%)` } : {};
    }), C = W(() => {
      if (e.loading === !0)
        return {
          onMousedown: O,
          onTouchstart: O,
          onClick: O,
          onKeydown: O,
          onKeyup: O
        };
      if (f.value === !0) {
        const $ = {
          onClick: k,
          onKeydown: I,
          onMousedown: P
        };
        if (n.$q.platform.has.touch === !0) {
          const X = e.onTouchstart !== void 0 ? "" : "Passive";
          $[`onTouchstart${X}`] = A;
        }
        return $;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: yt
      };
    }), T = W(() => ({
      ref: h,
      class: "q-btn q-btn-item non-selectable no-outline " + r.value,
      style: s.value,
      ...l.value,
      ...C.value
    }));
    function k($) {
      if (h.value !== null) {
        if ($ !== void 0) {
          if ($.defaultPrevented === !0)
            return;
          const X = document.activeElement;
          if (e.type === "submit" && X !== document.body && h.value.contains(X) === !1 && X.contains(h.value) === !1) {
            h.value.focus();
            const te = () => {
              document.removeEventListener("keydown", yt, !0), document.removeEventListener("keyup", te, mt), h.value !== null && h.value.removeEventListener("blur", te, mt);
            };
            document.addEventListener("keydown", yt, !0), document.addEventListener("keyup", te, mt), h.value.addEventListener("blur", te, mt);
          }
        }
        d($);
      }
    }
    function I($) {
      h.value !== null && (i("keydown", $), On($, [13, 32]) === !0 && Ii !== h.value && (Ii !== null && F(), $.defaultPrevented !== !0 && (h.value.focus(), Ii = h.value, h.value.classList.add("q-btn--active"), document.addEventListener("keyup", D, !0), h.value.addEventListener("blur", D, mt)), yt($)));
    }
    function A($) {
      h.value !== null && (i("touchstart", $), $.defaultPrevented !== !0 && ($i !== h.value && ($i !== null && F(), $i = h.value, v = $.target, v.addEventListener("touchcancel", D, mt), v.addEventListener("touchend", D, mt)), x = !0, w !== null && clearTimeout(w), w = setTimeout(() => {
        w = null, x = !1;
      }, 200)));
    }
    function P($) {
      h.value !== null && ($.qSkipRipple = x === !0, i("mousedown", $), $.defaultPrevented !== !0 && zi !== h.value && (zi !== null && F(), zi = h.value, h.value.classList.add("q-btn--active"), document.addEventListener("mouseup", D, mt)));
    }
    function D($) {
      if (h.value !== null && !($ !== void 0 && $.type === "blur" && document.activeElement === h.value)) {
        if ($ !== void 0 && $.type === "keyup") {
          if (Ii === h.value && On($, [13, 32]) === !0) {
            const X = new MouseEvent("click", $);
            X.qKeyEvent = !0, $.defaultPrevented === !0 && Vi(X), $.cancelBubble === !0 && Ar(X), h.value.dispatchEvent(X), yt($), $.qKeyEvent = !0;
          }
          i("keyup", $);
        }
        F();
      }
    }
    function F($) {
      const X = g.value;
      $ !== !0 && ($i === h.value || zi === h.value) && X !== null && X !== document.activeElement && (X.setAttribute("tabindex", -1), X.focus()), $i === h.value && (v !== null && (v.removeEventListener("touchcancel", D, mt), v.removeEventListener("touchend", D, mt)), $i = v = null), zi === h.value && (document.removeEventListener("mouseup", D, mt), zi = null), Ii === h.value && (document.removeEventListener("keyup", D, !0), h.value !== null && h.value.removeEventListener("blur", D, mt), Ii = null), h.value !== null && h.value.classList.remove("q-btn--active");
    }
    function O($) {
      yt($), $.qSkipRipple = !0;
    }
    return Ue(() => {
      F(!0);
    }), Object.assign(n, { click: k }), () => {
      let $ = [];
      e.icon !== void 0 && $.push(
        K(Kt, {
          name: e.icon,
          left: e.stack === !1 && M.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      ), M.value === !0 && $.push(
        K("span", { class: "block" }, [e.label])
      ), $ = yi(t.default, $), e.iconRight !== void 0 && e.round === !1 && $.push(
        K(Kt, {
          name: e.iconRight,
          right: e.stack === !1 && M.value === !0,
          role: "img",
          "aria-hidden": "true"
        })
      );
      const X = [
        K("span", {
          class: "q-focus-helper",
          ref: g
        })
      ];
      return e.loading === !0 && e.percentage !== void 0 && X.push(
        K("span", {
          class: "q-btn__progress absolute-full overflow-hidden" + (e.darkPercentage === !0 ? " q-btn__progress--dark" : "")
        }, [
          K("span", {
            class: "q-btn__progress-indicator fit block",
            style: S.value
          })
        ])
      ), X.push(
        K("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + a.value
        }, $)
      ), e.loading !== null && X.push(
        K(Dn, {
          name: "q-transition--fade"
        }, () => e.loading === !0 ? [
          K("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, t.loading !== void 0 ? t.loading() : [K(Ji)])
        ] : null)
      ), Vh(
        K(
          u.value,
          T.value,
          X
        ),
        [[
          Hg,
          p.value,
          void 0,
          y.value
        ]]
      );
    };
  }
}), Gi = [], Tn = [];
let ap = 1, ii = document.body;
function cs(e, t) {
  const i = document.createElement("div");
  if (i.id = t !== void 0 ? `q-portal--${t}--${ap++}` : e, Br.globalNodes !== void 0) {
    const n = Br.globalNodes.class;
    n !== void 0 && (i.className = n);
  }
  return ii.appendChild(i), Gi.push(i), Tn.push(t), i;
}
function Oo(e) {
  const t = Gi.indexOf(e);
  Gi.splice(t, 1), Tn.splice(t, 1), e.remove();
}
function lp(e) {
  if (e === ii)
    return;
  if (ii = e, ii === document.body || Tn.reduce((i, n) => n === "dialog" ? i + 1 : i, 0) < 2) {
    Gi.forEach((i) => {
      i.contains(ii) === !1 && ii.appendChild(i);
    });
    return;
  }
  const t = Tn.lastIndexOf("dialog");
  for (let i = 0; i < Gi.length; i++) {
    const n = Gi[i];
    (i === t || Tn[i] !== "dialog") && n.contains(ii) === !1 && ii.appendChild(n);
  }
}
let cp = 0;
const br = {}, wr = {}, Ct = {}, fu = {}, up = /^\s*$/, hu = [], Bo = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "top",
  "bottom",
  "left",
  "right",
  "center"
], dp = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
], Ui = {
  positive: {
    icon: (e) => e.iconSet.type.positive,
    color: "positive"
  },
  negative: {
    icon: (e) => e.iconSet.type.negative,
    color: "negative"
  },
  warning: {
    icon: (e) => e.iconSet.type.warning,
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: (e) => e.iconSet.type.info,
    color: "info"
  },
  ongoing: {
    group: !1,
    timeout: 0,
    spinner: !0,
    color: "grey-8"
  }
};
function mu(e, t, i) {
  if (!e)
    return pn("parameter required");
  let n;
  const r = { textColor: "white" };
  if (e.ignoreDefaults !== !0 && Object.assign(r, br), vt(e) === !1 && (r.type && Object.assign(r, Ui[r.type]), e = { message: e }), Object.assign(r, Ui[e.type || r.type], e), typeof r.icon == "function" && (r.icon = r.icon(t)), r.spinner ? (r.spinner === !0 && (r.spinner = Ji), r.spinner = ns(r.spinner)) : r.spinner = !1, r.meta = {
    hasMedia: !!(r.spinner !== !1 || r.icon || r.avatar),
    hasText: Ya(r.message) || Ya(r.caption)
  }, r.position) {
    if (Bo.includes(r.position) === !1)
      return pn("wrong position", e);
  } else
    r.position = "bottom";
  if (r.timeout === void 0)
    r.timeout = 5e3;
  else {
    const c = parseInt(r.timeout, 10);
    if (isNaN(c) || c < 0)
      return pn("wrong timeout", e);
    r.timeout = c;
  }
  r.timeout === 0 ? r.progress = !1 : r.progress === !0 && (r.meta.progressClass = "q-notification__progress" + (r.progressClass ? ` ${r.progressClass}` : ""), r.meta.progressStyle = {
    animationDuration: `${r.timeout + 1e3}ms`
  });
  const s = (Array.isArray(e.actions) === !0 ? e.actions : []).concat(
    e.ignoreDefaults !== !0 && Array.isArray(br.actions) === !0 ? br.actions : []
  ).concat(
    Ui[e.type] !== void 0 && Array.isArray(Ui[e.type].actions) === !0 ? Ui[e.type].actions : []
  ), { closeBtn: a } = r;
  if (a && s.push({
    label: typeof a == "string" ? a : t.lang.label.close
  }), r.actions = s.map(({ handler: c, noDismiss: u, ...d }) => ({
    flat: !0,
    ...d,
    onClick: typeof c == "function" ? () => {
      c(), u !== !0 && l();
    } : () => {
      l();
    }
  })), r.multiLine === void 0 && (r.multiLine = r.actions.length > 1), Object.assign(r.meta, {
    class: `q-notification row items-stretch q-notification--${r.multiLine === !0 ? "multi-line" : "standard"}` + (r.color !== void 0 ? ` bg-${r.color}` : "") + (r.textColor !== void 0 ? ` text-${r.textColor}` : "") + (r.classes !== void 0 ? ` ${r.classes}` : ""),
    wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (r.multiLine === !0 ? "column no-wrap justify-center" : "row items-center"),
    contentClass: "q-notification__content row items-center" + (r.multiLine === !0 ? "" : " col"),
    leftClass: r.meta.hasText === !0 ? "additional" : "single",
    attrs: {
      role: "alert",
      ...r.attrs
    }
  }), r.group === !1 ? (r.group = void 0, r.meta.group = void 0) : ((r.group === void 0 || r.group === !0) && (r.group = [
    r.message,
    r.caption,
    r.multiline
  ].concat(
    r.actions.map((c) => `${c.label}*${c.icon}`)
  ).join("|")), r.meta.group = r.group + "|" + r.position), r.actions.length === 0 ? r.actions = void 0 : r.meta.actionsClass = "q-notification__actions row items-center " + (r.multiLine === !0 ? "justify-end" : "col-auto") + (r.meta.hasMedia === !0 ? " q-notification__actions--with-media" : ""), i !== void 0) {
    i.notif.meta.timer && (clearTimeout(i.notif.meta.timer), i.notif.meta.timer = void 0), r.meta.uid = i.notif.meta.uid;
    const c = Ct[r.position].value.indexOf(i.notif);
    Ct[r.position].value[c] = r;
  } else {
    const c = wr[r.meta.group];
    if (c === void 0) {
      if (r.meta.uid = cp++, r.meta.badge = 1, ["left", "right", "center"].indexOf(r.position) !== -1)
        Ct[r.position].value.splice(
          Math.floor(Ct[r.position].value.length / 2),
          0,
          r
        );
      else {
        const u = r.position.indexOf("top") > -1 ? "unshift" : "push";
        Ct[r.position].value[u](r);
      }
      r.group !== void 0 && (wr[r.meta.group] = r);
    } else {
      if (c.meta.timer && (clearTimeout(c.meta.timer), c.meta.timer = void 0), r.badgePosition !== void 0) {
        if (dp.includes(r.badgePosition) === !1)
          return pn("wrong badgePosition", e);
      } else
        r.badgePosition = `top-${r.position.indexOf("left") > -1 ? "right" : "left"}`;
      r.meta.uid = c.meta.uid, r.meta.badge = c.meta.badge + 1, r.meta.badgeClass = `q-notification__badge q-notification__badge--${r.badgePosition}` + (r.badgeColor !== void 0 ? ` bg-${r.badgeColor}` : "") + (r.badgeTextColor !== void 0 ? ` text-${r.badgeTextColor}` : "") + (r.badgeClass ? ` ${r.badgeClass}` : "");
      const u = Ct[r.position].value.indexOf(c);
      Ct[r.position].value[u] = wr[r.meta.group] = r;
    }
  }
  const l = () => {
    fp(r), n = void 0;
  };
  if (r.timeout > 0 && (r.meta.timer = setTimeout(() => {
    r.meta.timer = void 0, l();
  }, r.timeout + /* show duration */
  1e3)), r.group !== void 0)
    return (c) => {
      c !== void 0 ? pn("trying to update a grouped one which is forbidden", e) : l();
    };
  if (n = {
    dismiss: l,
    config: e,
    notif: r
  }, i !== void 0) {
    Object.assign(i, n);
    return;
  }
  return (c) => {
    if (n !== void 0)
      if (c === void 0)
        n.dismiss();
      else {
        const u = Object.assign({}, n.config, c, {
          group: !1,
          position: r.position
        });
        mu(u, t, n);
      }
  };
}
function fp(e) {
  e.meta.timer && (clearTimeout(e.meta.timer), e.meta.timer = void 0);
  const t = Ct[e.position].value.indexOf(e);
  if (t !== -1) {
    e.group !== void 0 && delete wr[e.meta.group];
    const i = hu["" + e.meta.uid];
    if (i) {
      const { width: n, height: r } = getComputedStyle(i);
      i.style.left = `${i.offsetLeft}px`, i.style.width = n, i.style.height = r;
    }
    Ct[e.position].value.splice(t, 1), typeof e.onDismiss == "function" && e.onDismiss();
  }
}
function Ya(e) {
  return e != null && up.test(e) !== !0;
}
function pn(e, t) {
  return console.error(`Notify: ${e}`, t), !1;
}
function hp() {
  return Je({
    name: "QNotifications",
    // hide App from Vue devtools
    devtools: { hide: !0 },
    setup() {
      return () => K("div", { class: "q-notifications" }, Bo.map((e) => K(Uh, {
        key: e,
        class: fu[e],
        tag: "div",
        name: `q-notification--${e}`
      }, () => Ct[e].value.map((t) => {
        const i = t.meta, n = [];
        if (i.hasMedia === !0 && (t.spinner !== !1 ? n.push(
          K(t.spinner, {
            class: "q-notification__spinner q-notification__spinner--" + i.leftClass,
            color: t.spinnerColor,
            size: t.spinnerSize
          })
        ) : t.icon ? n.push(
          K(Kt, {
            class: "q-notification__icon q-notification__icon--" + i.leftClass,
            name: t.icon,
            color: t.iconColor,
            size: t.iconSize,
            role: "img"
          })
        ) : t.avatar && n.push(
          K(jg, {
            class: "q-notification__avatar q-notification__avatar--" + i.leftClass
          }, () => K("img", { src: t.avatar, "aria-hidden": "true" }))
        )), i.hasText === !0) {
          let s;
          const a = { class: "q-notification__message col" };
          if (t.html === !0)
            a.innerHTML = t.caption ? `<div>${t.message}</div><div class="q-notification__caption">${t.caption}</div>` : t.message;
          else {
            const l = [t.message];
            s = t.caption ? [
              K("div", l),
              K("div", { class: "q-notification__caption" }, [t.caption])
            ] : l;
          }
          n.push(
            K("div", a, s)
          );
        }
        const r = [
          K("div", { class: i.contentClass }, n)
        ];
        return t.progress === !0 && r.push(
          K("div", {
            key: `${i.uid}|p|${i.badge}`,
            class: i.progressClass,
            style: i.progressStyle
          })
        ), t.actions !== void 0 && r.push(
          K("div", {
            class: i.actionsClass
          }, t.actions.map((s) => K(no, s)))
        ), i.badge > 1 && r.push(
          K("div", {
            key: `${i.uid}|${i.badge}`,
            class: t.meta.badgeClass,
            style: t.badgeStyle
          }, [i.badge])
        ), K("div", {
          ref: (s) => {
            hu["" + i.uid] = s;
          },
          key: i.uid,
          class: i.class,
          ...i.attrs
        }, [
          K("div", { class: i.wrapperClass }, r)
        ]);
      }))));
    }
  });
}
const Xe = {
  setDefaults(e) {
    vt(e) === !0 && Object.assign(br, e);
  },
  registerType(e, t) {
    vt(t) === !0 && (Ui[e] = t);
  },
  install({ $q: e, parentApp: t }) {
    if (e.notify = this.create = (i) => mu(i, e), e.notify.setDefaults = this.setDefaults, e.notify.registerType = this.registerType, e.config.notify !== void 0 && this.setDefaults(e.config.notify), this.__installed !== !0) {
      Bo.forEach((n) => {
        Ct[n] = ue([]);
        const r = ["left", "center", "right"].includes(n) === !0 ? "center" : n.indexOf("top") > -1 ? "top" : "bottom", s = n.indexOf("left") > -1 ? "start" : n.indexOf("right") > -1 ? "end" : "center", a = ["left", "right"].includes(n) ? `items-${n === "left" ? "start" : "end"} justify-center` : n === "center" ? "flex-center" : `items-${s}`;
        fu[n] = `q-notifications__list q-notifications__list--${r} fixed column no-wrap ${a}`;
      });
      const i = cs("q-notify");
      Ao(hp(), t).mount(i);
    }
  }
}, gu = {
  initialize() {
    this.useProxy = o.get(me, "storage.useProxy", !1);
  },
  createService(e) {
    let t = q.getServiceInstance("storage", e, { create: !1 });
    return t || (t = zh(q, {
      servicePath: q.getServicePath("storage", e),
      transport: q.transporter,
      fetch: window.fetch.bind(window),
      useProxy: this.useProxy
    }), t = q.createService("storage", {
      service: t,
      context: e,
      methods: ["create", "get", "find", "remove", "createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"]
    })), t;
  },
  getService(e) {
    return q.getServiceInstance("storage", e);
  },
  async upload(e, t) {
    const { file: i, key: n, blob: r, context: s } = e, a = this.getService(s), l = Xe.create({
      type: "ongoing",
      message: Y.t("storage.UPLOADING_FILE", { file: i }),
      timeout: 0
    });
    try {
      const c = await a.upload(n, r, { expiresIn: 60 }, t);
      return l(), ne.emit("file-uploaded", { name: i, key: n, type: r.type, context: s }), c;
    } catch (c) {
      throw l(), z.error(`[KDK] Cannot upload ${i} with key '${n}'`, c), c;
    }
  },
  async download(e, t) {
    const { file: i, key: n, context: r, asDataUrl: s } = e, a = this.getService(r), l = Xe.create({
      type: "ongoing",
      message: Y.t("storage.DOWNLOADING_FILE", { file: i }),
      color: "info",
      timeout: 0
    });
    try {
      const c = await a.download(n, { expiresIn: 60 }, t);
      return ne.emit("file-downloaded", { name: i, key: n, type: c.type, context: r }), l(), new Promise((u, d) => {
        if (s) {
          const f = new FileReader();
          f.onload = (h) => {
            delete c.buffer, c.uri = h.target.result, u(c);
          }, f.readAsDataURL(new Blob([c.buffer], { type: c.type }));
        } else
          u(c);
      });
    } catch (c) {
      throw l(), z.error(`[KDK] Cannot download '${i}' with key '${n}'`, c), c;
    }
  },
  async export(e) {
    const { file: t, key: i, context: n } = e, s = await this.getService(n).create({
      id: i,
      command: "GetObject",
      expiresIn: 60,
      ResponseContentDisposition: `attachment; filename="${t}"`
    });
    if (s.SignedUrl) {
      let a = document.getElementById("export-hidden-frame");
      a || (a = document.createElement("iframe"), a.id = "export-hidden-frame", a.style.display = "none", document.body.appendChild(a)), a.src = s.SignedUrl;
    } else
      z.error(`[KDK] Cannot export ${t} with key '${i}'`);
  },
  async remove(e) {
    const { file: t, key: i, context: n } = e, r = this.getService(n);
    try {
      await r.remove(i), ne.emit("file-removed", { name: t, key: i, context: n });
    } catch (s) {
      throw z.error(`[KDK] Cannot remove ${t} with key '${i}'`, s), s;
    }
  },
  async getObjectUrl(e) {
    const { key: t, context: i } = e, n = this.getService(i);
    let r = q.getConfig("domain") + me.apiPath;
    n.context && (r += `/${i}`), r += `/storage-objects/${t}`;
    const s = o.get(e, "query", {}), a = await q.get("storage").getItem(me.apiJwt);
    return s.jwt = a, r += `?${new URLSearchParams(s)}`, r;
  },
  async getPresignedUrl(e) {
    const { key: t, context: i } = e, n = this.getService(i), { SignedUrl: r } = await n.create({ id: t, command: "GetObject", ...o.omit(e, ["key", "context"]) });
    return r;
  }
}, { store: mp, set: gp, get: Xa, unset: pp, has: yp } = Ot("template-context"), us = Object.assign(mp, {
  get: Xa,
  has: yp,
  unset: pp,
  // Override write methods to send events
  set(e, t) {
    const i = Xa(e);
    gp(e, t), ne.emit("template-context-changed", e, t, i);
  }
}), pe = {
  initialize() {
    this.timer = null, _t.locale(Bt());
    const e = _t.utc(), t = e.clone().subtract(1, "months").startOf("day"), i = e.clone().endOf("day"), n = _t.tz.guess() || "";
    V.set("time", o.defaultsDeep(me.time || {}, {
      range: {
        start: t,
        end: i,
        field: "createdAt",
        query: { createdAt: { $gte: t.toISOString(), $lte: i.toISOString() } }
      },
      format: {
        time: {
          short: "H[h]",
          long: "HH:mm"
        },
        date: {
          short: "DD/MM",
          long: "dddd D"
        },
        year: {
          short: "YY",
          long: "YYYY"
        },
        timezone: n
      },
      currentTime: e,
      realtime: !1,
      step: 60,
      // 1H
      interval: 60
      // 1m
    }));
  },
  convertToMoment(e) {
    return _t.isMoment(e) ? _t.utc(e.valueOf()) : typeof e == "string" && !e.endsWith("Z") ? _t(e).utc() : _t.utc(e);
  },
  get() {
    return V.get("time");
  },
  getRange() {
    return this.get().range;
  },
  patchRange(e) {
    if (this.getRange().start.isSame(e.start) && this.getRange().end.isSame(e.end)) return;
    const t = { [this.getRange().field]: { $gte: e.start.toISOString(), $lte: e.end.toISOString() } };
    V.patch("time.range", Object.assign({ query: t }, e));
  },
  patchField(e) {
    if (this.getRange().field === e) return;
    const t = { [e]: { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() } };
    V.patch("time.range", { field: e, query: t });
  },
  getRangeQuery() {
    return V.get("time.range.query");
  },
  // Build sort query
  updateTimeRangeQuery() {
    const e = {};
    e[this.getRange().field] = { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() }, this.getRange().query = e;
  },
  getFormat() {
    return this.get().format;
  },
  getFormatTimezone() {
    return this.getFormat().timezone;
  },
  convertToLocal(e) {
    let t = this.convertToMoment(e);
    return this.getFormatTimezone() && (t = _t.tz(t.toISOString(), this.getFormatTimezone())), t;
  },
  format(e, t, i = { year: "numeric", month: "numeric", day: "numeric", hour: "2-digit", minute: "2-digit" }) {
    const n = this.convertToLocal(e);
    return t === "iso" ? n.toISOString() : t === "locale" ? n.toDate().toLocaleString(Bt(), i) : n.format(o.get(this.getFormat(), t));
  },
  getCurrentTime() {
    return this.get().currentTime;
  },
  setCurrentTime(e) {
    this.isRealtime() && this.stopRealtime();
    const t = this.convertToMoment(e);
    this.getCurrentTime().isSame(t) || V.patch("time.currentTime", t);
  },
  setNow() {
    this.setCurrentTime(_t.utc());
  },
  isRealtime() {
    return this.get().realtime;
  },
  startRealtime() {
    if (this.isRealtime()) {
      z.warn("[KDK] Realtime mode is already active");
      return;
    }
    V.patch("time", { realtime: !0 }), V.patch("time.currentTime", _t.utc()), this.timer = setInterval(() => {
      V.patch("time.currentTime", _t.utc());
    }, 1e3 * this.get().interval);
  },
  stopRealtime() {
    if (!this.isRealtime()) {
      z.warn("[KDK] Realtime mode is alrady inactive");
      return;
    }
    V.patch("time", { realtime: !1 }), clearInterval(this.timer), this.timer = null;
  },
  getCurrentFormattedTime() {
    const e = this.getCurrentTime();
    return {
      time: {
        short: this.format(e, "time.short"),
        long: this.format(e, "time.long")
      },
      date: {
        short: this.format(e, "date.short"),
        long: this.format(e, "date.long")
      },
      year: {
        short: this.format(e, "year.short"),
        long: this.format(e, "year.long")
      },
      iso: this.format(e, "iso")
    };
  },
  getStep() {
    return this.get().step;
  },
  setStep(e) {
    this.getStep() !== e && V.patch("time", { step: e });
  },
  // Round hours to expected interval, e.g. using 6 hourly interval 00 || 06 || 12 || 18
  roundHours(e, t) {
    return Math.floor(e / t) * t;
  }
}, vp = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  mi: {
    symbol: "units.MILE_SYMBOL",
    label: "units.MILE_LABEL"
  },
  NM: {
    symbol: "units.NAUTICAL_MILE_SYMBOL",
    label: "units.NAUTICAL_MILE_LABEL",
    definition: "1852 m"
  }
}, bp = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  ft: {
    symbol: "units.FEET_SYMBOL",
    label: "units.FEET_LABEL"
  }
}, wp = {
  "m^2": {
    symbol: "units.SQUARED_METER_SYMBOL",
    label: "units.SQUARED_METER_LABEL"
  },
  "km^2": {
    symbol: "units.SQUARED_KILOMETER_SYMBOL",
    label: "units.SQUARED_KILOMETER_LABEL"
  },
  acre: {
    symbol: "units.ACRE_SYMBOL",
    label: "units.ACRE_LABEL"
  },
  hectare: {
    symbol: "units.HECTARE_SYMBOL",
    label: "units.HECTARE_LABEL"
  }
}, _p = {
  "m/s": {
    symbol: "units.METER_PER_SECOND_SYMBOL",
    label: "units.METER_PER_SECOND_LABEL"
  },
  "km/h": {
    symbol: "units.KILOMETER_PER_HOUR_SYMBOL",
    label: "units.KILOMETER_PER_HOUR_LABEL"
  },
  "mi/h": {
    symbol: "units.MILES_PER_HOUR_SYMBOL",
    label: "units.MILES_PER_HOUR_LABEL"
  },
  kt: {
    symbol: "units.KNOT_SYMBOL",
    label: "units.KNOT_LABEL",
    definition: "0.514444 m/s",
    override: !0
    // because kt can be kilo ton :(
  }
}, Lp = {
  degC: {
    symbol: "units.CELSIUS_SYMBOL",
    label: "units.CELSIUS_LABEL"
  },
  degF: {
    symbol: "units.FAHRENHEIT_SYMBOL",
    label: "units.FAHRENHEIT_LABEL"
  },
  K: {
    symbol: "units.KELVIN_SYMBOL",
    label: "units.KELVIN_LABEL"
  }
}, xp = {
  deg: {
    symbol: "units.DEGREE_SYMBOL",
    label: "units.DEGREE_LABEL"
  },
  rad: {
    symbol: "units.RADIAN_SYMBOL",
    label: "units.RADIAN_LABEL"
  }
}, Sp = {
  ppm: {
    symbol: "units.PPM_SYMBOL",
    label: "units.PPM_LABEL"
  }
}, Cp = {
  "ug/m^3": {
    symbol: "units.MICROGRAM_PER_M3_SYMBOL",
    label: "units.MICROGRAM_PER_M3_LABEL"
  }
}, Ep = {
  "m^3/s": {
    symbol: "units.CUBIC_METER_PER_SECOND_SYMBOL",
    label: "units.CUBIC_METER_PER_SECOND_LABEL"
  }
}, Tp = {
  bq: {
    symbol: "units.BEQUEREL_SYMBOL",
    label: "units.BEQUEREL_LABEL",
    baseName: "radioactivity"
  }
}, Pp = {
  "bq/m^2": {
    symbol: "units.BEQUEREL_PER_M2_SYMBOL",
    label: "units.BEQUEREL_PER_M2_LABEL"
  },
  "bq/m^3": {
    symbol: "units.BEQUEREL_PER_M3_SYMBOL",
    label: "units.BEQUEREL_PER_M3_LABEL"
  }
}, kp = {
  sv: {
    symbol: "units.SIEVERT_SYMBOL",
    label: "units.SIEVERT_LABEL",
    baseName: "equivalentDose",
    aliases: ["sievert"]
  },
  msv: {
    symbol: "units.MILLISIEVERT_SYMBOL",
    label: "units.MILLISIEVERT_LABEL",
    definition: "0.001 sv"
  },
  usv: {
    symbol: "units.MICROSIEVERT_SYMBOL",
    label: "units.MICROSIEVERT_LABEL",
    definition: "0.000001 sv"
  },
  nsv: {
    symbol: "units.NANOSIEVERT_SYMBOL",
    label: "units.NANOSIEVERT_LABEL",
    definition: "0.000000001 sv"
  }
}, Mp = {
  svs: {
    symbol: "units.SIEVERT_PER_SECOND_SYMBOL",
    label: "units.SIEVERT_PER_SECOND_LABEL",
    baseName: "equivalentDoseRate"
  },
  msvs: {
    symbol: "units.MILLISIEVERT_PER_SECOND_SYMBOL",
    label: "units.MILLISIEVERT_PER_SECOND_LABEL",
    definition: "0.001 svs"
  },
  usvs: {
    symbol: "units.MICROSIEVERT_PER_SECOND_SYMBOL",
    label: "units.MICROSIEVERT_PER_SECOND_LABEL",
    definition: "0.000001 svs"
  },
  nsvs: {
    symbol: "units.NANOSIEVERT_PER_SECOND_SYMBOL",
    label: "units.NANOSIEVERT_PER_SECOND_LABEL",
    definition: "0.000000001 svs"
  },
  svh: {
    symbol: "units.SIEVERT_PER_HOUR_SYMBOL",
    label: "units.SIEVERT_PER_HOUR_LABEL",
    definition: "0.000277778 svs"
  },
  msvh: {
    symbol: "units.MILLISIEVERT_PER_HOUR_SYMBOL",
    label: "units.MILLISIEVERT_PER_HOUR_LABEL",
    definition: "0.000000277778 svs"
  },
  usvh: {
    symbol: "units.MICROSIEVERT_PER_HOUR_SYMBOL",
    label: "units.MICROSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000277778 svs"
  },
  nsvh: {
    symbol: "units.NANOSIEVERT_PER_HOUR_SYMBOL",
    label: "units.NANOSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000000277778 svs"
  }
}, Fp = {
  length: vp,
  altitude: bp,
  area: wp,
  velocity: _p,
  temperature: Lp,
  angle: xp,
  fraction: Sp,
  density: Cp,
  volumeVelocity: Ep,
  radioactivity: Tp,
  radioactivityDensity: Pp,
  equivalentDose: kp,
  equivalentDoseRate: Mp
}, be = {
  initialize() {
    V.set("units", o.defaultsDeep(
      me.units || {},
      Fp,
      {
        default: {
          length: "m",
          altitude: "m",
          area: "m^2",
          velocity: "m/s",
          temperature: "degC",
          angle: "deg",
          radioactivity: "bq",
          equivalentDose: "usv",
          equivalentDoseRate: "usvh",
          notation: "auto",
          precision: 3
        }
      }
    )), this.getQuantities().forEach((e) => {
      this.createUnits(e);
    });
  },
  createUnits(e) {
    o.sortBy(this.getUnits(e), [(i) => i.baseName ? 0 : 1]).forEach((i) => {
      Ri.Unit.isValuelessUnit(i.name) && !i.override || (i.definition || i.baseName) && Ri.createUnit(i.name, o.omit(i, ["label", "override"]), { override: o.get(i, "override", !1) });
    });
  },
  get() {
    return V.get("units");
  },
  getDefaultNotation() {
    return V.get("units.default.notation", "auto");
  },
  getDefaultPrecision() {
    return V.get("units.default.precision", 3);
  },
  getQuantities() {
    return o.keys(o.omit(this.get(), ["default"]));
  },
  setUnits(e, t) {
    V.set(`units.${e}`, t), this.createUnits(e);
  },
  getUnits(e) {
    if (e) {
      const t = V.get(`units.${e}`, {});
      return o.values(o.mapValues(t, (i, n) => Object.assign({ name: n, quantity: e }, i)));
    } else {
      let t = [];
      return this.getQuantities().forEach((i) => {
        t = t.concat(this.getUnits(i));
      }), t;
    }
  },
  // Get unit definition by name
  getUnit(e) {
    let t;
    return o.forOwn(this.get(), (i, n) => {
      !t && o.has(i, e) && (t = Object.assign({ name: e, quantity: n }, o.get(i, e)));
    }), t || (t = { name: e, symbol: e, label: e }), t;
  },
  // Get unit symbol by unit name/definition
  getUnitSymbol(e) {
    const t = typeof e == "object" ? e : this.getUnit(e);
    return t && t.symbol ? Y.tie(t.symbol) : e;
  },
  // Get default unit definition (if any) for a given quantity/unit name/definition
  getDefaultUnit(e) {
    if (!e) return null;
    typeof e == "object" && (e = e.name);
    let t = V.get(`units.default.${e}`);
    if (t)
      t = this.getUnit(t);
    else {
      const i = this.getUnit(e);
      i && (t = this.getDefaultUnit(i.quantity));
    }
    return t;
  },
  // Set default unit name for a quantity
  setDefaultUnit(e, t) {
    V.set(`units.default.${e}`, t);
  },
  // Get symbol of default unit (if any) for a given quantity/unit name/definition
  getDefaultUnitSymbol(e) {
    return this.getUnitSymbol(this.getDefaultUnit(e));
  },
  // Get target unit definition for a source unit name/definition, will be default unit (if any) or source unit
  getTargetUnit(e) {
    return this.getDefaultUnit(e) || (typeof e == "object" ? e : this.getUnit(e));
  },
  // Get target unit symbol for a source unit name/definition, will be default unit symbol (if any) or source unit symbol
  getTargetUnitSymbol(e) {
    return this.getUnitSymbol(this.getTargetUnit(e));
  },
  // Convert between units by names/definitions
  // If target unit is not specified will use default unit (if any) for source unit
  convert(e, t, i) {
    if (o.isNil(e) || !o.isFinite(e) || e === Number.MIN_VALUE || e === Number.MAX_VALUE) return e;
    const n = typeof t == "string" ? this.getUnit(t) : t;
    let r = typeof i == "string" ? this.getUnit(i) : i;
    if (!r && n && (r = this.getDefaultUnit(n)), !n || !r || r.name === n.name) return e;
    const s = n.name.replace("^", ""), a = r.name.replace("^", "");
    if (!Ri.Unit.isValuelessUnit(s) || !Ri.Unit.isValuelessUnit(a)) return e;
    let l = Ri.unit(e, s);
    return l = l.toNumber(a), l = a === "deg" && l < 0 ? l + 360 : l, l;
  },
  // Format display of source value in target unit, converting from source unit
  // If target unit is not specified will use default unit (if any) for source unit
  // options are mathjs format options
  format(e, t, i, n) {
    if (o.isNil(e)) {
      z.warn("[KDK] cannot format a nil value");
      return;
    }
    i || (i = this.getDefaultUnit(t));
    const r = i ? this.convert(e, t, i) : e;
    n = Object.assign({
      symbol: !0,
      notation: this.getDefaultNotation(),
      precision: this.getDefaultPrecision(),
      lowerExp: -this.getDefaultPrecision(),
      upperExp: this.getDefaultPrecision()
    }, n);
    let s = Ri.format(r, n);
    return n.symbol && (s += ` ${i ? this.getUnitSymbol(i) : this.getUnitSymbol(t)}`), s;
  }
}, Dp = ["handler", "visible", "hidden", "disabled", "on.listener"], Ap = ["content", "visible", "hidden", "route"];
function el(e, t) {
  const i = t.split(".");
  let n = e;
  for (const r of i) {
    if (!n || !(r in n))
      return !1;
    n = n[r];
  }
  return !0;
}
function Ki(e, t) {
  if (typeof e != "object") return e;
  const i = Array.isArray(e), n = o.keys(e);
  let r = e;
  return i ? r.forEach((s) => {
    s.content && (s.content = Ki(s.content, t));
  }) : (r.content ? r.content = Ki(r.content, t) : n.forEach((s) => {
    const a = r[s];
    r[s] = Ki(a, t);
  }), r = [r]), r = r.filter(Pe(t)), i ? r : r[0];
}
function Wn(e, t, i = []) {
  const n = o.flatMapDeep(e);
  return o.forEach(n, (r) => {
    Dp.forEach((s) => pu(r, s, t)), Rr(r, t, i), r.content && Wn(r.content, t, i);
  }), e;
}
function Rr(e, t, i = []) {
  if (Array.isArray(e))
    for (let n = 0; n < e.length; n++)
      e[n] = Rr(e[n], t);
  else typeof e == "object" && o.forOwn(e, (n, r) => {
    !Ap.includes(r) && !i.includes(r) && (typeof n == "string" ? e[r] = Ro(n, t) : e[r] = Rr(n, t));
  });
  return e;
}
function pu(e, t, i) {
  const n = o.get(e, t);
  if (Array.isArray(n)) {
    const r = n.map((s) => _r(i, s.name || s, s.params));
    o.set(e, t, (...s) => r.reduce((a, l) => a && l(...s), !0));
  } else n && typeof n == "object" ? n.name ? n.name.startsWith(":") || o.set(e, t, _r(i, n.name, n.params)) : z.debug(`[KDK] invalid handler binding for ${n}: you must provide the name to the function to be called`) : typeof n == "string" && !n.startsWith(":") && o.set(e, t, _r(i, n));
  return o.get(e, t);
}
function _r(e, t, i) {
  const n = t.startsWith("!");
  return n && (t = t.substring(1)), (...r) => {
    let s;
    const a = o.get(e, t);
    return typeof a == "function" ? s = a(...i ? $r(i, e, r) : r) : s = a, n ? !s : s;
  };
}
function $r(e, t, i) {
  return o.isNil(e) ? e : Array.isArray(e) ? e.map((n) => $r(n, t, i)) : typeof e == "object" ? o.mapValues(e, (n, r) => $r(n, t, i)) : Ro(e, t, i);
}
function Ro(e, t, i) {
  if (typeof e == "string" && e.startsWith(":")) {
    if (e.startsWith(":store.")) {
      const n = e.replace(":store.", "");
      if (V.has(n)) return V.get(n);
    } else if (e.startsWith(":storeRef.")) {
      const n = e.replace(":storeRef.", "");
      if (el(V, n)) return V.getRef(n);
    } else {
      const n = e.substring(1), r = o.toNumber(n);
      if (o.isFinite(r)) return i[r];
      if (el(t, n)) return o.get(t, n);
    }
    return;
  }
  return e;
}
const Cn = {
  drawer: 3e3,
  // see Quasar css variables
  panes: 1e3,
  fab: 1e3,
  stickies: 980,
  focus: 1010
}, ze = "layout", lt = { content: void 0, filter: {}, mode: void 0, visible: !1 }, cr = { opener: !1, size: [0, 0], zIndex: Cn.panes }, yu = { menu: !0, pin: !0, unpin: !0, maximize: !0, restore: !0, close: !0, resize: !0 }, ur = { state: void 0, position: void 0, size: void 0, current: void 0, controls: yu, controlsMenuBreakpoint: "xs", zIndex: 980 }, tl = {
  minSize: [300, 200],
  floating: { position: [0, 0], size: [300, 200] },
  pinned: { xs: [100, 30], sm: [90, 30], md: [80, 30], lg: [70, 30], xl: [60, 30] }
}, il = {
  minSize: [200, 300],
  floating: { position: [0, 0], size: [200, 300] },
  pinned: { xs: [50, 90], sm: [40, 80], md: [30, 75], lg: [25, 75], xl: [20, 75] }
}, nl = {
  view: "lHh LpR lFf",
  padding: !0,
  mode: void 0,
  header: { ...lt, size: [void 0, 0] },
  footer: { ...lt, size: [void 0, 0] },
  page: { ...lt, size: [0, 0] },
  stickies: { ...lt, zIndex: Cn.stickies },
  fab: { ...lt, icon: "las la-ellipsis-v", position: "bottom-right", offset: [16, 16], zIndex: Cn.fab },
  panes: {
    left: { ...lt, ...cr, sizes: 300, zIndex: Cn.drawer },
    top: { ...lt, ...cr, sizes: void 0 },
    right: { ...lt, ...cr, sizes: { xs: [85, 75], sm: [360, 75], md: [440, 80], lg: [500, 80], xl: [500, 85] } },
    bottom: { ...lt, ...cr, sizes: void 0 }
  },
  windows: {
    left: { ...lt, ...ur, sizePolicy: il },
    top: { ...lt, ...ur, sizePolicy: tl },
    right: { ...lt, ...ur, sizePolicy: il },
    bottom: { ...lt, ...ur, sizePolicy: tl }
  },
  focus: {
    element: null,
    zIndex: Cn.focus
  }
}, ee = {
  placements: ["top", "right", "bottom", "left"],
  paths: {
    layout: ze,
    view: ze + ".view",
    padding: ze + ".padding",
    mode: ze + ".mode",
    header: ze + ".header",
    footer: ze + ".footer",
    page: ze + ".page",
    stickies: ze + ".stickies",
    fab: ze + ".fab",
    panes: {
      left: ze + ".panes.left",
      top: ze + ".panes.top",
      right: ze + ".panes.right",
      bottom: ze + ".panes.bottom"
    },
    windows: {
      left: ze + ".windows.left",
      top: ze + ".windows.top",
      right: ze + ".windows.right",
      bottom: ze + ".windows.bottom"
    },
    focus: ze + ".focus"
  },
  defaults: nl,
  initialize() {
    V.set(this.paths.view, this.getElementDefaults("view")), V.set(this.paths.padding, this.getElementDefaults("padding")), V.set(this.paths.header, this.getElementDefaults("header")), V.set(this.paths.footer, this.getElementDefaults("footer")), V.set(this.paths.page, this.getElementDefaults("page")), V.set(this.paths.stickies, this.getElementDefaults("stickies")), V.set(this.paths.fab, this.getElementDefaults("fab")), this.placements.forEach((e) => {
      V.set(o.get(this.paths.panes, e), this.getElementDefaults(`panes.${e}`)), V.set(o.get(this.paths.windows, e), this.getElementDefaults(`windows.${e}`));
    }), V.set(this.paths.focus, this.getElementDefaults("focus")), z.debug("[KDK] Layout initialized with configuration:", this.get());
  },
  get() {
    return V.get(this.paths.layout);
  },
  set(e) {
    o.has(e, "view") && this.setView(e.view), o.has(e, "padding") && this.setPadding(e.padding), o.has(e, "header") && this.setHeader(e.header), o.has(e, "footer") && this.setFooter(e.footer), o.has(e, "page") && this.setPage(e.page), o.has(e, "stickies") && this.setStickies(e.stickies), o.has(e, "fab") && this.setFab(e.fab), this.placements.forEach((t) => {
      o.has(e, `panes.${t}`) && this.setPane(t, o.get(e, `panes.${t}`)), o.has(e, `windows.${t}`) && this.setWindow(t, o.get(e, `windows.${t}`));
    }), o.has(e, "mode") && this.setMode(e.mode), o.has(e, "focus") && this.setFocus(e.focus);
  },
  setView(e) {
    if (o.isNil(e)) {
      z.warn("[KDK] Undefined 'view' argument");
      return;
    }
    V.patch(this.paths.layout, { view: e });
  },
  clearView() {
    V.patch(this.paths.layout, { view: this.getElementDefaults("view") });
  },
  getPadding() {
    return this.get().padding;
  },
  setPadding(e) {
    if (o.isNil(e)) {
      z.warn("[KDK] Undefined 'padding' argument");
      return;
    }
    V.patch(this.paths.layout, { padding: e });
  },
  clearPadding() {
    V.patch(this.paths.layout, { padding: this.getElementDefaults("padding") });
  },
  getMode() {
    return this.get().mode;
  },
  setMode(e) {
    this.getMode() !== e && (this.setHeaderMode(e), this.setFooterMode(e), this.setPageMode(e), this.setFabMode(e), this.setStickiesMode(e), this.placements.forEach((t) => {
      this.setPaneMode(t, e), this.setWindowMode(t, e);
    }), V.patch(this.paths.layout, { mode: e }));
  },
  clearMode() {
    V.patch(this.paths.layout, { mode: void 0 });
  },
  getElement(e) {
    return V.get(this.getElementPath(e));
  },
  getElementPath(e) {
    return o.get(this.paths, e);
  },
  getElementDefaults(e) {
    const t = this.getElementPath(e), i = o.get(nl, e), n = o.get(me, t);
    return n ? o.defaultsDeep(o.cloneDeep(n), i) : o.cloneDeep(i);
  },
  setElement(e, t, i, n = []) {
    const r = o.defaultsDeep(o.cloneDeep(t), this.getElementDefaults(e)), { content: s, mode: a } = r;
    !o.isEmpty(s) && i && (r.content = Wn(s, i, n)), Array.isArray(s) ? r.components = s.filter(Pe(r.filter)) : r.components = o.get(s, a, []).filter(Pe(r.filter)), V.patch(this.getElementPath(e), r);
  },
  setElementMode(e, t) {
    const i = this.getElement(e);
    if (i.mode === t) return;
    let n;
    Array.isArray(i.content) ? n = i.content.filter(Pe(i.filter)) : n = o.get(i.content, t, []).filter(Pe(i.filter)), V.patch(this.getElementPath(e), { mode: t, components: n });
  },
  setElementFilter(e, t) {
    const i = this.getElement(e);
    if (o.isEqual(i.filter, t)) return;
    let n;
    Array.isArray(i.content) ? n = i.content.filter(Pe(i.filter)) : n = o.get(i.content, i.mode, []).filter(Pe(i.filter)), V.patch(this.getElementPath(e), { filter: t, components: n });
  },
  setElementVisible(e, t) {
    this.getElement(e).visible !== t && V.patch(this.getElementPath(e), { visible: t });
  },
  setElementSize(e, t) {
    if (!Array.isArray(t) && t.length !== 2) {
      z.warn(`[KDK] Invalid size ${t}`);
      return;
    }
    const i = this.getElement(e);
    o.isEqual(i.size, t) || V.patch(this.getElementPath(e), { size: t });
  },
  clearElement(e) {
    this.setElement(e, this.getElementDefaults(e));
  },
  getHeader() {
    return this.getElement("header");
  },
  setHeader(e, t) {
    this.setElement("header", e, t);
  },
  setHeaderMode(e) {
    this.setElementMode("header", e);
  },
  setHeaderFilter(e) {
    this.setElementFilter("header", e);
  },
  setHeaderVisible(e) {
    this.setElementVisible("header", e);
  },
  setHeaderSize(e) {
    this.setElementSize("header", e);
  },
  clearHeader() {
    this.clearElement("header");
  },
  getFooter() {
    return this.getElement("footer");
  },
  setFooter(e, t) {
    this.setElement("footer", e, t);
  },
  setFooterMode(e) {
    this.setElementMode("footer", e);
  },
  setFooterFilter(e) {
    this.setElementFilter("footer", e);
  },
  setFooterVisible(e) {
    this.setElementVisible("footer", e);
  },
  setFooterSize(e) {
    this.setElementSize("footer", e);
  },
  clearFooter() {
    this.clearElement("footer");
  },
  getPage() {
    return this.getElement("page");
  },
  setPage(e, t) {
    this.setElement("page", e, t);
  },
  setPageMode(e) {
    this.setElementMode("page", e);
  },
  setPageFilter(e) {
    this.setElementFilter("page", e);
  },
  setPageVisible(e) {
    this.setElementVisible("page", e);
  },
  clearPage() {
    this.clearElement("page");
  },
  getStickies() {
    return this.getElement("stickies");
  },
  setStickies(e, t) {
    this.setElement("stickies", e, t);
  },
  setStickiesMode(e) {
    this.setElementMode("stickies", e);
  },
  setStickiesFilter(e) {
    this.setElementFilter("stickies", e);
  },
  setStickiesVisible(e) {
    this.setElementVisible("stickies", e);
  },
  clearStickies() {
    this.clearElement("stickies");
  },
  findSticky(e) {
    return o.find(this.getStickies().components, { id: e });
  },
  showSticky(e) {
    const t = this.findSticky(e);
    if (!t) {
      z.error(`[KDK] Cannot find sticky with id '${e}'`);
      return;
    }
    o.set(t, "visible", !0);
  },
  hideSticky(e) {
    const t = this.findSticky(e);
    if (!t) {
      z.error(`[KDK] Cannot find sticky with id '${e}'`);
      return;
    }
    o.set(t, "visible", !1);
  },
  getFab() {
    return this.getElement("fab");
  },
  setFab(e, t) {
    this.setElement("fab", e, t);
  },
  setFabMode(e) {
    this.setElementMode("fab", e);
  },
  setFabFilter(e) {
    this.setElementFilter("fab", e);
  },
  setFabVisible(e) {
    this.setElementVisible("fab", e);
  },
  setFabIcon(e) {
    this.getElement("fab").icon !== e && V.patch(this.getElementPath("fab"), { icon: e });
  },
  setFabPosition(e) {
    if (!["top-left", "top-right", "bottom-left", "bottom-right"].includes(e)) {
      z.warn(`[KDK] Invalid position ${e}`);
      return;
    }
    this.getElement("fab").position !== e && V.patch(this.getElementPath("fab"), { position: e });
  },
  setFabOffset(e) {
    if (!Array.isArray(e) && e.length !== 2) {
      z.warn(`[KDK] Invalid offset ${e}`);
      return;
    }
    this.getElement("fab").offset !== e && V.patch(this.getElementPath("fab"), { offset: e });
  },
  clearFab() {
    this.clearElement("fab");
  },
  getPane(e) {
    return this.getElement(`panes.${e}`);
  },
  setPane(e, t, i) {
    this.setElement(`panes.${e}`, t, i);
  },
  setPaneMode(e, t) {
    this.setElementMode(`panes.${e}`, t);
  },
  setPaneFilter(e, t) {
    this.setElementFilter(`panes.${e}`, t);
  },
  setPaneVisible(e, t) {
    this.setElementVisible(`panes.${e}`, t);
  },
  setPaneOpener(e, t) {
    this.getElement(`panes.${e}`).opener !== t && V.patch(this.getElementPath(`panes.${e}`), { opener: t });
  },
  setPaneSizes(e, t) {
    const i = this.getElement(`panes.${e}`);
    o.isEqual(i.sizes, t) || V.patch(this.getElementPath(`panes.${e}`), { sizes: t });
  },
  clearPane(e) {
    this.clearElement(`panes.${e}`);
  },
  getWindow(e) {
    return this.getElement(`windows.${e}`);
  },
  setWindow(e, t, i) {
    this.setElement(`windows.${e}`, t, i, ["header", "fab"]);
  },
  setWindowMode(e, t) {
    this.setElementMode(`windows.${e}`, t);
  },
  setWindowFilter(e, t) {
    this.setElementFilter(`windows.${e}`, t);
  },
  setWindowVisible(e, t) {
    this.setElementVisible(`windows.${e}`, t);
  },
  setWindowControls(e, t) {
    for (const n of o.keys(yu))
      if (!o.has(t, n)) {
        z.warn(`[KDK] Invalid window control key ${n}`);
        return;
      }
    const i = this.getElement(`windows.${e}`);
    o.isEqual(i.controls, t) || V.patch(this.getElementPath(`windows.${e}`), { controls: t });
  },
  setWindowState(e, t) {
    if (!["pinned", "floating", "maximized"].includes(t)) {
      z.warn(`[KDK] Invalid window state ${t}`);
      return;
    }
    this.getElement(`windows.${e}`).state !== t && V.patch(this.getElementPath(`windows.${e}`), { state: t });
  },
  setWindowPosition(e, t) {
    if (!Array.isArray(t) && t.length !== 2) {
      z.warn(`[KDK] Invalid position ${t}`);
      return;
    }
    const i = this.getElement(`windows.${e}`);
    o.isEqual(i.position, t) || V.patch(this.getElementPath(`windows.${e}`), { position: t });
  },
  setWindowSize(e, t) {
    this.setElementSize(`windows.${e}`, t);
  },
  setWindowSizePolicy(e, t) {
    if (!t.minSize || !t.floating || !t.pinned) {
      z.warn(`[KDK] Invalid window sizePolicy ${t}`);
      return;
    }
    const i = this.getElement(`windows.${e}`);
    o.isEqual(i.sizePolicy, t) || V.patch(this.getElementPath(`windows.${e}`), { sizePolicy: t });
  },
  setWindowCurrent(e, t) {
    const i = this.getElement(`windows.${e}`);
    if (i.current === t) return;
    o.find(i.components, { id: t }) || (t = o.get(i.components, "[0].id")), V.patch(this.getElementPath(`windows.${e}`), { current: t });
  },
  clearWindow(e) {
    this.clearElement(`windows.${e}`);
  },
  findWindow(e) {
    for (const t of this.placements) {
      const i = this.getWindow(t);
      if (o.find(i.components, { id: e }))
        return { placement: t, window: i };
    }
    return z.debug(`[KDK] Unable to find the widget ${e}`), { placement: void 0, window: void 0 };
  },
  openWidget(e, t = !0) {
    const { placement: i, window: n } = this.findWindow(e);
    i && (n.current !== "current" && this.setWindowCurrent(i, e), n.visible || this.setWindowVisible(i, !0), t && ee.setFocus(`windows.${i}`));
  },
  closeWidget(e) {
    const { placement: t, window: i } = this.findWindow(e);
    t && i.visible && this.setWindowVisible(t, !1);
  },
  setFocus(e) {
    const t = this.getElement("focus");
    if (t.element) {
      if (t.element === e) return;
      V.patch(this.getElementPath(t.element.path), { zIndex: t.element.zIndex });
    }
    const i = this.getElement(e);
    V.patch(this.getElementPath("focus"), { element: { path: e, zIndex: i.zIndex } }), V.patch(this.getElementPath(e), { zIndex: t.zIndex });
  },
  clearFocus() {
    this.clearElement("focus");
  }
}, vu = {
  initialize() {
    V.set("filter", { fields: "name", pattern: "", items: [], query: {} }), ne.on("filter-changed", () => this.updateFilterQuery());
  },
  get() {
    return V.get("filter");
  },
  getItems() {
    return V.get("filter.items");
  },
  getFields() {
    const e = V.get("filter.fields");
    return typeof e == "string" ? [e] : e;
  },
  getPattern() {
    return V.get("filter.pattern");
  },
  getQuery() {
    return V.get("filter.query");
  },
  clear() {
    V.patch("filter", { fields: "name", pattern: "", items: [], query: {} });
  },
  // Build query from filter pattern and/or items
  updateFilterQuery() {
    const e = {}, t = this.getPattern(), i = this.getFields(), n = this.getItems();
    t !== "" && (e.$or = o.map(i, (r) => ({ [r]: { $search: t } }))), n.forEach((r) => {
      const s = { [r.field]: r[r.field] };
      r.baseQuery && Object.assign(s, r.baseQuery), Object.assign(e, { [r.service]: { $elemMatch: s } });
    }), o.isEqual(e, this.getQuery()) || V.patch("filter", { query: e });
  }
}, bu = {
  initialize() {
    V.set("sorter", { field: "name", order: "1", query: {} }), ne.on("sorter-changed", () => this.updateSorterQuery());
  },
  get() {
    return V.get("sorter");
  },
  getField() {
    return this.get().field;
  },
  getOrder() {
    return this.get().order;
  },
  getQuery() {
    return V.get("sorter.query");
  },
  // Build sort query
  updateSorterQuery() {
    const e = { $sort: { [this.getField()]: this.getOrder() } };
    o.isEqual(e, this.getQuery()) || V.patch("sorter", { query: e });
  }
}, wu = {
  initialize() {
    this.options = o.defaultsDeep(o.get(me, "document"), {
      viewers: {
        htm: "document/KHtml",
        html: "document/KHtml",
        "text/html": "document/KHtml",
        txt: "document/KHtml",
        "text/plain": "document/KHtml",
        csv: "document/KCsv",
        "text/csv": "document/KCsv",
        md: "document/KMarkdown",
        "text/markdown": "document/KMarkdown",
        pdf: "document/KPdf",
        "application/pdf": "document/KPdf",
        jpg: "document/KImage",
        jpeg: "document/KImage",
        "image/jpeg": "document/KImage",
        png: "document/KImage",
        "image/png": "document/KImage",
        apng: "document/KImage",
        "image/apng": "document/KImage",
        gif: "document/KImage",
        "image/gif": "document/KImage",
        svg: "document/KImage",
        "image/svg+xml": "document/KImage",
        webp: "document/KImage",
        "image/webp": "document/KImage",
        mp4: "document/KVideo",
        "video/mp4": "document/KVideo",
        mkv: "document/KVideo",
        "video/x-matroska": "document/KVideo",
        mov: "document/KVideo",
        "video/quicktime": "document/KVideo",
        webm: "document/KVideo",
        "video/webm": "document/KVideo"
      },
      browser: {
        scrollableViewers: ["document/KHtml", "document/KMarkdown", "document/KCsv"]
      },
      htmlSanitizer: {
        allowedTags: Ts.defaults.allowedTags.concat(["img", "strike"]),
        allowedAttributes: o.assign(Ts.defaults.allowedAttributes, { div: ["style"] })
      },
      mdConverter: {}
    }), z.debug("[KDK] Document initialized with options:", this.options);
  },
  register(e, t) {
    o.isArray(e) || (e = [e]), o.forEach(e, (i) => {
      o.set(this.options, `viewers.${i}`, t);
    });
  },
  getViewer(e) {
    return o.get(this.options, `viewers.${e}`);
  },
  hasViewer(e) {
    return !o.isNil(this.getViewer(e));
  },
  sanitizeHtml(e) {
    return o.isNil(e) ? null : Ts(e, this.options.htmlSanitizer);
  },
  async fetchUrl(e, t) {
    if (o.isEmpty(e)) return null;
    let i;
    t ? i = Y.localize(e) : i = [e];
    let n;
    for (const r of i)
      try {
        if (n = await fetch(r), n.ok) return n;
      } catch {
      }
    return null;
  }
};
function Op(e, t, i) {
  let n;
  function r() {
    n !== void 0 && (to.remove(n), n = void 0);
  }
  return Ue(() => {
    e.value === !0 && r();
  }), {
    removeFromHistory: r,
    addToHistory() {
      n = {
        condition: () => i.value === !0,
        handler: t
      }, to.add(n);
    }
  };
}
function Bp() {
  let e = null;
  const t = Ve();
  function i() {
    e !== null && (clearTimeout(e), e = null);
  }
  return Lo(i), Ue(i), {
    removeTimeout: i,
    registerTimeout(n, r) {
      i(), du(t) === !1 && (e = setTimeout(n, r));
    }
  };
}
function Rp() {
  let e;
  const t = Ve();
  function i() {
    e = void 0;
  }
  return Lo(i), Ue(i), {
    removeTick: i,
    registerTick(n) {
      e = n, Et(() => {
        e === n && (du(t) === !1 && e(), e = void 0);
      });
    }
  };
}
const $p = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
}, Ip = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function zp({
  showing: e,
  canShow: t,
  // optional
  hideOnRouteChange: i,
  // optional
  handleShow: n,
  // optional
  handleHide: r,
  // optional
  processOnMount: s
  // optional
}) {
  const a = Ve(), { props: l, emit: c, proxy: u } = a;
  let d;
  function f(p) {
    e.value === !0 ? v(p) : h(p);
  }
  function h(p) {
    if (l.disable === !0 || p !== void 0 && p.qAnchorHandled === !0 || t !== void 0 && t(p) !== !0)
      return;
    const y = l["onUpdate:modelValue"] !== void 0;
    y === !0 && (c("update:modelValue", !0), d = p, Et(() => {
      d === p && (d = void 0);
    })), (l.modelValue === null || y === !1) && g(p);
  }
  function g(p) {
    e.value !== !0 && (e.value = !0, c("beforeShow", p), n !== void 0 ? n(p) : c("show", p));
  }
  function v(p) {
    if (l.disable === !0)
      return;
    const y = l["onUpdate:modelValue"] !== void 0;
    y === !0 && (c("update:modelValue", !1), d = p, Et(() => {
      d === p && (d = void 0);
    })), (l.modelValue === null || y === !1) && x(p);
  }
  function x(p) {
    e.value !== !1 && (e.value = !1, c("beforeHide", p), r !== void 0 ? r(p) : c("hide", p));
  }
  function w(p) {
    l.disable === !0 && p === !0 ? l["onUpdate:modelValue"] !== void 0 && c("update:modelValue", !1) : p === !0 !== e.value && (p === !0 ? g : x)(d);
  }
  Le(() => l.modelValue, w), i !== void 0 && uu(a) === !0 && Le(() => u.$route.fullPath, () => {
    i.value === !0 && e.value === !0 && v();
  }), Qt(() => {
    w(l.modelValue);
  });
  const M = { show: h, hide: v, toggle: f };
  return Object.assign(u, M), M;
}
const Np = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function jp(e, t = () => {
}, i = () => {
}) {
  return {
    transitionProps: W(() => {
      const n = `q-transition--${e.transitionShow || t()}`, r = `q-transition--${e.transitionHide || i()}`;
      return {
        appear: !0,
        enterFromClass: `${n}-enter-from`,
        enterActiveClass: `${n}-enter-active`,
        enterToClass: `${n}-enter-to`,
        leaveFromClass: `${r}-leave-from`,
        leaveActiveClass: `${r}-leave-active`,
        leaveToClass: `${r}-leave-to`
      };
    }),
    transitionStyle: W(() => `--q-transition-duration: ${e.transitionDuration}ms`)
  };
}
let vi = [], Bn = [];
function _u(e) {
  Bn = Bn.filter((t) => t !== e);
}
function Vp(e) {
  _u(e), Bn.push(e);
}
function rl(e) {
  _u(e), Bn.length === 0 && vi.length !== 0 && (vi[vi.length - 1](), vi = []);
}
function $o(e) {
  Bn.length === 0 ? e() : vi.push(e);
}
function Up(e) {
  vi = vi.filter((t) => t !== e);
}
const Bs = [];
function qp(e) {
  for (e = e.parent; e != null; ) {
    if (e.type.name === "QGlobalDialog")
      return !0;
    if (e.type.name === "QDialog" || e.type.name === "QMenu")
      return !1;
    e = e.parent;
  }
  return !1;
}
function Gp(e, t, i, n) {
  const r = ue(!1), s = ue(!1);
  let a = null;
  const l = {}, c = qp(e);
  function u(f) {
    if (f === !0) {
      rl(l), s.value = !0;
      return;
    }
    s.value = !1, r.value === !1 && (c === !1 && a === null && (a = cs(!1, n)), r.value = !0, Bs.push(e.proxy), Vp(l));
  }
  function d(f) {
    if (s.value = !1, f !== !0)
      return;
    rl(l), r.value = !1;
    const h = Bs.indexOf(e.proxy);
    h !== -1 && Bs.splice(h, 1), a !== null && (Oo(a), a = null);
  }
  return qh(() => {
    d(!0);
  }), e.proxy.__qPortal = !0, nn(e.proxy, "contentEl", () => t.value), {
    showPortal: u,
    hidePortal: d,
    portalIsActive: r,
    portalIsAccessible: s,
    renderPortal: () => c === !0 ? i() : r.value === !0 ? [K(Gh, { to: a }, i())] : void 0
  };
}
function Kp(e) {
  return e === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : e.scrollTop;
}
function Hp(e) {
  return e === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : e.scrollLeft;
}
function Wp(e, t = !0) {
  return !e || e.nodeType !== Node.ELEMENT_NODE ? !1 : t ? e.scrollHeight > e.clientHeight && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-y"])) : e.scrollWidth > e.clientWidth && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-x"]));
}
let yn = 0, Rs, $s, En, Is = !1, sl, ol, al, hi = null;
function Zp(e) {
  Jp(e) && yt(e);
}
function Jp(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop"))
    return !0;
  const t = hg(e), i = e.shiftKey && !e.deltaX, n = !i && Math.abs(e.deltaX) <= Math.abs(e.deltaY), r = i || n ? e.deltaY : e.deltaX;
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    if (Wp(a, n))
      return n ? r < 0 && a.scrollTop === 0 ? !0 : r > 0 && a.scrollTop + a.clientHeight === a.scrollHeight : r < 0 && a.scrollLeft === 0 ? !0 : r > 0 && a.scrollLeft + a.clientWidth === a.scrollWidth;
  }
  return !0;
}
function ll(e) {
  e.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop);
}
function dr(e) {
  Is !== !0 && (Is = !0, requestAnimationFrame(() => {
    Is = !1;
    const { height: t } = e.target, { clientHeight: i, scrollTop: n } = document.scrollingElement;
    (En === void 0 || t !== window.innerHeight) && (En = i - t, document.scrollingElement.scrollTop = n), n > En && (document.scrollingElement.scrollTop -= Math.ceil((n - En) / 8));
  }));
}
function cl(e) {
  const t = document.body, i = window.visualViewport !== void 0;
  if (e === "add") {
    const { overflowY: n, overflowX: r } = window.getComputedStyle(t);
    Rs = Hp(window), $s = Kp(window), sl = t.style.left, ol = t.style.top, al = window.location.href, t.style.left = `-${Rs}px`, t.style.top = `-${$s}px`, r !== "hidden" && (r === "scroll" || t.scrollWidth > window.innerWidth) && t.classList.add("q-body--force-scrollbar-x"), n !== "hidden" && (n === "scroll" || t.scrollHeight > window.innerHeight) && t.classList.add("q-body--force-scrollbar-y"), t.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = !0, Fe.is.ios === !0 && (i === !0 ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", dr, pt.passiveCapture), window.visualViewport.addEventListener("scroll", dr, pt.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", ll, pt.passiveCapture));
  }
  Fe.is.desktop === !0 && Fe.is.mac === !0 && window[`${e}EventListener`]("wheel", Zp, pt.notPassive), e === "remove" && (Fe.is.ios === !0 && (i === !0 ? (window.visualViewport.removeEventListener("resize", dr, pt.passiveCapture), window.visualViewport.removeEventListener("scroll", dr, pt.passiveCapture)) : window.removeEventListener("scroll", ll, pt.passiveCapture)), t.classList.remove("q-body--prevent-scroll"), t.classList.remove("q-body--force-scrollbar-x"), t.classList.remove("q-body--force-scrollbar-y"), document.qScrollPrevented = !1, t.style.left = sl, t.style.top = ol, window.location.href === al && window.scrollTo(Rs, $s), En = void 0);
}
function ro(e) {
  let t = "add";
  if (e === !0) {
    if (yn++, hi !== null) {
      clearTimeout(hi), hi = null;
      return;
    }
    if (yn > 1)
      return;
  } else {
    if (yn === 0 || (yn--, yn > 0))
      return;
    if (t = "remove", Fe.is.ios === !0 && Fe.is.nativeMobile === !0) {
      hi !== null && clearTimeout(hi), hi = setTimeout(() => {
        cl(t), hi = null;
      }, 100);
      return;
    }
  }
  cl(t);
}
function Qp() {
  let e;
  return {
    preventBodyScroll(t) {
      t !== e && (e !== void 0 || t === !0) && (e = t, ro(t));
    }
  };
}
const _i = [];
let Qi;
function Yp(e) {
  Qi = e.keyCode === 27;
}
function Xp() {
  Qi === !0 && (Qi = !1);
}
function ey(e) {
  Qi === !0 && (Qi = !1, On(e, 27) === !0 && _i[_i.length - 1](e));
}
function Lu(e) {
  window[e]("keydown", Yp), window[e]("blur", Xp), window[e]("keyup", ey), Qi = !1;
}
function ty(e) {
  Fe.is.desktop === !0 && (_i.push(e), _i.length === 1 && Lu("addEventListener"));
}
function ul(e) {
  const t = _i.indexOf(e);
  t > -1 && (_i.splice(t, 1), _i.length === 0 && Lu("removeEventListener"));
}
const Li = [];
function xu(e) {
  Li[Li.length - 1](e);
}
function iy(e) {
  Fe.is.desktop === !0 && (Li.push(e), Li.length === 1 && document.body.addEventListener("focusin", xu));
}
function dl(e) {
  const t = Li.indexOf(e);
  t > -1 && (Li.splice(t, 1), Li.length === 0 && document.body.removeEventListener("focusin", xu));
}
let fr = 0;
const ny = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
}, fl = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
}, ry = Je({
  name: "QDialog",
  inheritAttrs: !1,
  props: {
    ...$p,
    ...Np,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: "standard",
      validator: (e) => e === "standard" || ["top", "bottom", "left", "right"].includes(e)
    }
  },
  emits: [
    ...Ip,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(e, { slots: t, emit: i, attrs: n }) {
    const r = Ve(), s = ue(null), a = ue(!1), l = ue(!1);
    let c = null, u = null, d, f;
    const h = W(
      () => e.persistent !== !0 && e.noRouteDismiss !== !0 && e.seamless !== !0
    ), { preventBodyScroll: g } = Qp(), { registerTimeout: v } = Bp(), { registerTick: x, removeTick: w } = Rp(), { transitionProps: M, transitionStyle: p } = jp(
      e,
      () => fl[e.position][0],
      () => fl[e.position][1]
    ), { showPortal: y, hidePortal: S, portalIsAccessible: C, renderPortal: T } = Gp(
      r,
      s,
      _e,
      "dialog"
    ), { hide: k } = zp({
      showing: a,
      hideOnRouteChange: h,
      handleShow: $,
      handleHide: X,
      processOnMount: !0
    }), { addToHistory: I, removeFromHistory: A } = Op(a, k, h), P = W(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${e.maximized === !0 ? "maximized" : "minimized"} q-dialog__inner--${e.position} ${ny[e.position]}` + (l.value === !0 ? " q-dialog__inner--animating" : "") + (e.fullWidth === !0 ? " q-dialog__inner--fullwidth" : "") + (e.fullHeight === !0 ? " q-dialog__inner--fullheight" : "") + (e.square === !0 ? " q-dialog__inner--square" : "")
    ), D = W(() => a.value === !0 && e.seamless !== !0), F = W(() => e.autoClose === !0 ? { onClick: de } : {}), O = W(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${D.value === !0 ? "modal" : "seamless"}`,
      n.class
    ]);
    Le(() => e.maximized, (j) => {
      a.value === !0 && ce(j);
    }), Le(D, (j) => {
      g(j), j === !0 ? (iy(Q), ty(oe)) : (dl(Q), ul(oe));
    });
    function $(j) {
      I(), u = e.noRefocus === !1 && document.activeElement !== null ? document.activeElement : null, ce(e.maximized), y(), l.value = !0, e.noFocus !== !0 ? (document.activeElement !== null && document.activeElement.blur(), x(te)) : w(), v(() => {
        if (r.proxy.$q.platform.is.ios === !0) {
          if (e.seamless !== !0 && document.activeElement) {
            const { top: ie, bottom: le } = document.activeElement.getBoundingClientRect(), { innerHeight: ye } = window, ge = window.visualViewport !== void 0 ? window.visualViewport.height : ye;
            ie > 0 && le > ge / 2 && (document.scrollingElement.scrollTop = Math.min(
              document.scrollingElement.scrollHeight - ge,
              le >= ye ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + le - ge / 2)
            )), document.activeElement.scrollIntoView();
          }
          f = !0, s.value.click(), f = !1;
        }
        y(!0), l.value = !1, i("show", j);
      }, e.transitionDuration);
    }
    function X(j) {
      w(), A(), he(!0), l.value = !0, S(), u !== null && (((j && j.type.indexOf("key") === 0 ? u.closest('[tabindex]:not([tabindex^="-"])') : void 0) || u).focus(), u = null), v(() => {
        S(!0), l.value = !1, i("hide", j);
      }, e.transitionDuration);
    }
    function te(j) {
      $o(() => {
        let ie = s.value;
        ie === null || ie.contains(document.activeElement) === !0 || (ie = (j !== "" ? ie.querySelector(j) : null) || ie.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || ie.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || ie.querySelector("[autofocus], [data-autofocus]") || ie, ie.focus({ preventScroll: !0 }));
      });
    }
    function H(j) {
      j && typeof j.focus == "function" ? j.focus({ preventScroll: !0 }) : te(), i("shake");
      const ie = s.value;
      ie !== null && (ie.classList.remove("q-animate--scale"), ie.classList.add("q-animate--scale"), c !== null && clearTimeout(c), c = setTimeout(() => {
        c = null, s.value !== null && (ie.classList.remove("q-animate--scale"), te());
      }, 170));
    }
    function oe() {
      e.seamless !== !0 && (e.persistent === !0 || e.noEscDismiss === !0 ? e.maximized !== !0 && e.noShake !== !0 && H() : (i("escapeKey"), k()));
    }
    function he(j) {
      c !== null && (clearTimeout(c), c = null), (j === !0 || a.value === !0) && (ce(!1), e.seamless !== !0 && (g(!1), dl(Q), ul(oe))), j !== !0 && (u = null);
    }
    function ce(j) {
      j === !0 ? d !== !0 && (fr < 1 && document.body.classList.add("q-body--dialog"), fr++, d = !0) : d === !0 && (fr < 2 && document.body.classList.remove("q-body--dialog"), fr--, d = !1);
    }
    function de(j) {
      f !== !0 && (k(j), i("click", j));
    }
    function R(j) {
      e.persistent !== !0 && e.noBackdropDismiss !== !0 ? k(j) : e.noShake !== !0 && H();
    }
    function Q(j) {
      e.allowFocusOutside !== !0 && C.value === !0 && Gg(s.value, j.target) !== !0 && te('[tabindex]:not([tabindex="-1"])');
    }
    Object.assign(r.proxy, {
      // expose public methods
      focus: te,
      shake: H,
      // private but needed by QSelect
      __updateRefocusTarget(j) {
        u = j || null;
      }
    }), Ue(he);
    function _e() {
      return K("div", {
        role: "dialog",
        "aria-modal": D.value === !0 ? "true" : "false",
        ...n,
        class: O.value
      }, [
        K(Dn, {
          name: "q-transition--fade",
          appear: !0
        }, () => D.value === !0 ? K("div", {
          class: "q-dialog__backdrop fixed-full",
          style: p.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: R
        }) : null),
        K(
          Dn,
          M.value,
          () => a.value === !0 ? K("div", {
            ref: s,
            class: P.value,
            style: p.value,
            tabindex: -1,
            ...F.value
          }, Tt(t.default)) : null
        )
      ]);
    }
    return T;
  }
}), Di = {
  dark: {
    type: Boolean,
    default: null
  }
};
function Ai(e, t) {
  return W(() => e.dark === null ? t.dark.isActive : e.dark);
}
const sy = Je({
  name: "QCard",
  props: {
    ...Di,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(e, { slots: t }) {
    const { proxy: { $q: i } } = Ve(), n = Ai(e, i), r = W(
      () => "q-card" + (n.value === !0 ? " q-card--dark q-dark" : "") + (e.bordered === !0 ? " q-card--bordered" : "") + (e.square === !0 ? " q-card--square no-border-radius" : "") + (e.flat === !0 ? " q-card--flat no-shadow" : "")
    );
    return () => K(e.tag, { class: r.value }, Tt(t.default));
  }
}), vn = Je({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(e, { slots: t }) {
    const i = W(
      () => `q-card__section q-card__section--${e.horizontal === !0 ? "horiz row no-wrap" : "vert"}`
    );
    return () => K(e.tag, { class: i.value }, Tt(t.default));
  }
}), oy = Je({
  name: "QCardActions",
  props: {
    ...lu,
    vertical: Boolean
  },
  setup(e, { slots: t }) {
    const i = cu(e), n = W(
      () => `q-card__actions ${i.value} q-card__actions--${e.vertical === !0 ? "vert column" : "horiz row"}`
    );
    return () => K("div", { class: n.value }, Tt(t.default));
  }
}), ay = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
}, zs = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
}, hl = Je({
  name: "QSeparator",
  props: {
    ...Di,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(e) {
    const t = Ve(), i = Ai(e, t.proxy.$q), n = W(() => e.vertical === !0 ? "vertical" : "horizontal"), r = W(() => ` q-separator--${n.value}`), s = W(() => e.inset !== !1 ? `${r.value}-${ay[e.inset]}` : ""), a = W(
      () => `q-separator${r.value}${s.value}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (i.value === !0 ? " q-separator--dark" : "")
    ), l = W(() => {
      const c = {};
      if (e.size !== void 0 && (c[e.vertical === !0 ? "width" : "height"] = e.size), e.spaced !== !1) {
        const u = e.spaced === !0 ? `${zs.md}px` : e.spaced in zs ? `${zs[e.spaced]}px` : e.spaced, d = e.vertical === !0 ? ["Left", "Right"] : ["Top", "Bottom"];
        c[`margin${d[0]}`] = c[`margin${d[1]}`] = u;
      }
      return c;
    });
    return () => K("hr", {
      class: a.value,
      style: l.value,
      "aria-orientation": n.value
    });
  }
});
function ly({ validate: e, resetValidation: t, requiresQForm: i }) {
  const n = Lc(Cg, !1);
  if (n !== !1) {
    const { props: r, proxy: s } = Ve();
    Object.assign(s, { validate: e, resetValidation: t }), Le(() => r.disable, (a) => {
      a === !0 ? (typeof t == "function" && t(), n.unbindComponent(s)) : n.bindComponent(s);
    }), Qt(() => {
      r.disable !== !0 && n.bindComponent(s);
    }), Ue(() => {
      r.disable !== !0 && n.unbindComponent(s);
    });
  } else i === !0 && console.error("Parent QForm not found on useFormChild()!");
}
const ml = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, gl = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, pl = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, hr = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, mr = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/, Ns = {
  date: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e),
  time: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(e),
  fulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(e),
  timeOrFulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(e),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (e) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e),
  hexColor: (e) => ml.test(e),
  hexaColor: (e) => gl.test(e),
  hexOrHexaColor: (e) => pl.test(e),
  rgbColor: (e) => hr.test(e),
  rgbaColor: (e) => mr.test(e),
  rgbOrRgbaColor: (e) => hr.test(e) || mr.test(e),
  hexOrRgbColor: (e) => ml.test(e) || hr.test(e),
  hexaOrRgbaColor: (e) => gl.test(e) || mr.test(e),
  anyColor: (e) => pl.test(e) || hr.test(e) || mr.test(e)
}, cy = [!0, !1, "ondemand"], uy = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    validator: (e) => cy.includes(e)
  }
};
function dy(e, t) {
  const { props: i, proxy: n } = Ve(), r = ue(!1), s = ue(null), a = ue(null);
  ly({ validate: v, resetValidation: g });
  let l = 0, c;
  const u = W(
    () => i.rules !== void 0 && i.rules !== null && i.rules.length !== 0
  ), d = W(
    () => i.disable !== !0 && u.value === !0
  ), f = W(
    () => i.error === !0 || r.value === !0
  ), h = W(() => typeof i.errorMessage == "string" && i.errorMessage.length !== 0 ? i.errorMessage : s.value);
  Le(() => i.modelValue, () => {
    x();
  }), Le(() => i.reactiveRules, (M) => {
    M === !0 ? c === void 0 && (c = Le(() => i.rules, () => {
      x(!0);
    })) : c !== void 0 && (c(), c = void 0);
  }, { immediate: !0 }), Le(e, (M) => {
    M === !0 ? a.value === null && (a.value = !1) : a.value === !1 && (a.value = !0, d.value === !0 && i.lazyRules !== "ondemand" && t.value === !1 && w());
  });
  function g() {
    l++, t.value = !1, a.value = null, r.value = !1, s.value = null, w.cancel();
  }
  function v(M = i.modelValue) {
    if (d.value !== !0)
      return !0;
    const p = ++l, y = t.value !== !0 ? () => {
      a.value = !0;
    } : () => {
    }, S = (T, k) => {
      T === !0 && y(), r.value = T, s.value = k || null, t.value = !1;
    }, C = [];
    for (let T = 0; T < i.rules.length; T++) {
      const k = i.rules[T];
      let I;
      if (typeof k == "function" ? I = k(M, Ns) : typeof k == "string" && Ns[k] !== void 0 && (I = Ns[k](M)), I === !1 || typeof I == "string")
        return S(!0, I), !1;
      I !== !0 && I !== void 0 && C.push(I);
    }
    return C.length === 0 ? (S(!1), !0) : (t.value = !0, Promise.all(C).then(
      (T) => {
        if (T === void 0 || Array.isArray(T) === !1 || T.length === 0)
          return p === l && S(!1), !0;
        const k = T.find((I) => I === !1 || typeof I == "string");
        return p === l && S(k !== void 0, k), k === void 0;
      },
      (T) => (p === l && (console.error(T), S(!0)), !1)
    ));
  }
  function x(M) {
    d.value === !0 && i.lazyRules !== "ondemand" && (a.value === !0 || i.lazyRules !== !0 && M !== !0) && w();
  }
  const w = Zc(v, 0);
  return Ue(() => {
    c !== void 0 && c(), w.cancel();
  }), Object.assign(n, { resetValidation: g, validate: v }), nn(n, "hasError", () => f.value), {
    isDirtyModel: a,
    hasRules: u,
    hasError: f,
    errorMessage: h,
    validate: v,
    resetValidation: g
  };
}
const yl = /^on[A-Z]/;
function fy(e, t) {
  const i = {
    listeners: ue({}),
    attributes: ue({})
  };
  function n() {
    const r = {}, s = {};
    for (const a in e)
      a !== "class" && a !== "style" && yl.test(a) === !1 && (r[a] = e[a]);
    for (const a in t.props)
      yl.test(a) === !0 && (s[a] = t.props[a]);
    i.attributes.value = r, i.listeners.value = s;
  }
  return Kh(n), n(), i;
}
function so(e) {
  return e === void 0 ? `f_${Gt()}` : e;
}
function oo(e) {
  return e != null && ("" + e).length !== 0;
}
const hy = {
  ...Di,
  ...uy,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String,
  maxlength: [Number, String]
}, my = ["update:modelValue", "clear", "focus", "blur", "popupShow", "popupHide"];
function gy() {
  const { props: e, attrs: t, proxy: i, vnode: n } = Ve();
  return {
    isDark: Ai(e, i.$q),
    editable: W(
      () => e.disable !== !0 && e.readonly !== !0
    ),
    innerLoading: ue(!1),
    focused: ue(!1),
    hasPopupOpen: !1,
    splitAttrs: fy(t, n),
    targetUid: ue(so(e.for)),
    rootRef: ue(null),
    targetRef: ue(null),
    controlRef: ue(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function py(e) {
  const { props: t, emit: i, slots: n, attrs: r, proxy: s } = Ve(), { $q: a } = s;
  let l = null;
  e.hasValue === void 0 && (e.hasValue = W(() => oo(t.modelValue))), e.emitValue === void 0 && (e.emitValue = (H) => {
    i("update:modelValue", H);
  }), e.controlEvents === void 0 && (e.controlEvents = {
    onFocusin: A,
    onFocusout: P
  }), Object.assign(e, {
    clearValue: D,
    onControlFocusin: A,
    onControlFocusout: P,
    focus: k
  }), e.computedCounter === void 0 && (e.computedCounter = W(() => {
    if (t.counter !== !1) {
      const H = typeof t.modelValue == "string" || typeof t.modelValue == "number" ? ("" + t.modelValue).length : Array.isArray(t.modelValue) === !0 ? t.modelValue.length : 0, oe = t.maxlength !== void 0 ? t.maxlength : t.maxValues;
      return H + (oe !== void 0 ? " / " + oe : "");
    }
  }));
  const {
    isDirtyModel: c,
    hasRules: u,
    hasError: d,
    errorMessage: f,
    resetValidation: h
  } = dy(e.focused, e.innerLoading), g = e.floatingLabel !== void 0 ? W(() => t.stackLabel === !0 || e.focused.value === !0 || e.floatingLabel.value === !0) : W(() => t.stackLabel === !0 || e.focused.value === !0 || e.hasValue.value === !0), v = W(
    () => t.bottomSlots === !0 || t.hint !== void 0 || u.value === !0 || t.counter === !0 || t.error !== null
  ), x = W(() => t.filled === !0 ? "filled" : t.outlined === !0 ? "outlined" : t.borderless === !0 ? "borderless" : t.standout ? "standout" : "standard"), w = W(
    () => `q-field row no-wrap items-start q-field--${x.value}` + (e.fieldClass !== void 0 ? ` ${e.fieldClass.value}` : "") + (t.rounded === !0 ? " q-field--rounded" : "") + (t.square === !0 ? " q-field--square" : "") + (g.value === !0 ? " q-field--float" : "") + (p.value === !0 ? " q-field--labeled" : "") + (t.dense === !0 ? " q-field--dense" : "") + (t.itemAligned === !0 ? " q-field--item-aligned q-item-type" : "") + (e.isDark.value === !0 ? " q-field--dark" : "") + (e.getControl === void 0 ? " q-field--auto-height" : "") + (e.focused.value === !0 ? " q-field--focused" : "") + (d.value === !0 ? " q-field--error" : "") + (d.value === !0 || e.focused.value === !0 ? " q-field--highlighted" : "") + (t.hideBottomSpace !== !0 && v.value === !0 ? " q-field--with-bottom" : "") + (t.disable === !0 ? " q-field--disabled" : t.readonly === !0 ? " q-field--readonly" : "")
  ), M = W(
    () => "q-field__control relative-position row no-wrap" + (t.bgColor !== void 0 ? ` bg-${t.bgColor}` : "") + (d.value === !0 ? " text-negative" : typeof t.standout == "string" && t.standout.length !== 0 && e.focused.value === !0 ? ` ${t.standout}` : t.color !== void 0 ? ` text-${t.color}` : "")
  ), p = W(
    () => t.labelSlot === !0 || t.label !== void 0
  ), y = W(
    () => "q-field__label no-pointer-events absolute ellipsis" + (t.labelColor !== void 0 && d.value !== !0 ? ` text-${t.labelColor}` : "")
  ), S = W(() => ({
    id: e.targetUid.value,
    editable: e.editable.value,
    focused: e.focused.value,
    floatingLabel: g.value,
    modelValue: t.modelValue,
    emitValue: e.emitValue
  })), C = W(() => {
    const H = {
      for: e.targetUid.value
    };
    return t.disable === !0 ? H["aria-disabled"] = "true" : t.readonly === !0 && (H["aria-readonly"] = "true"), H;
  });
  Le(() => t.for, (H) => {
    e.targetUid.value = so(H);
  });
  function T() {
    const H = document.activeElement;
    let oe = e.targetRef !== void 0 && e.targetRef.value;
    oe && (H === null || H.id !== e.targetUid.value) && (oe.hasAttribute("tabindex") === !0 || (oe = oe.querySelector("[tabindex]")), oe && oe !== H && oe.focus({ preventScroll: !0 }));
  }
  function k() {
    $o(T);
  }
  function I() {
    Up(T);
    const H = document.activeElement;
    H !== null && e.rootRef.value.contains(H) && H.blur();
  }
  function A(H) {
    l !== null && (clearTimeout(l), l = null), e.editable.value === !0 && e.focused.value === !1 && (e.focused.value = !0, i("focus", H));
  }
  function P(H, oe) {
    l !== null && clearTimeout(l), l = setTimeout(() => {
      l = null, !(document.hasFocus() === !0 && (e.hasPopupOpen === !0 || e.controlRef === void 0 || e.controlRef.value === null || e.controlRef.value.contains(document.activeElement) !== !1)) && (e.focused.value === !0 && (e.focused.value = !1, i("blur", H)), oe !== void 0 && oe());
    });
  }
  function D(H) {
    yt(H), a.platform.is.mobile !== !0 ? (e.targetRef !== void 0 && e.targetRef.value || e.rootRef.value).focus() : e.rootRef.value.contains(document.activeElement) === !0 && document.activeElement.blur(), t.type === "file" && (e.inputRef.value.value = null), i("update:modelValue", null), i("clear", t.modelValue), Et(() => {
      h(), a.platform.is.mobile !== !0 && (c.value = !1);
    });
  }
  function F() {
    const H = [];
    return n.prepend !== void 0 && H.push(
      K("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: Vi
      }, n.prepend())
    ), H.push(
      K("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, O())
    ), d.value === !0 && t.noErrorIcon === !1 && H.push(
      X("error", [
        K(Kt, { name: a.iconSet.field.error, color: "negative" })
      ])
    ), t.loading === !0 || e.innerLoading.value === !0 ? H.push(
      X(
        "inner-loading-append",
        n.loading !== void 0 ? n.loading() : [K(Ji, { color: t.color })]
      )
    ) : t.clearable === !0 && e.hasValue.value === !0 && e.editable.value === !0 && H.push(
      X("inner-clearable-append", [
        K(Kt, {
          class: "q-field__focusable-action",
          tag: "button",
          name: t.clearIcon || a.iconSet.field.clear,
          tabindex: 0,
          type: "button",
          "aria-hidden": null,
          role: null,
          onClick: D
        })
      ])
    ), n.append !== void 0 && H.push(
      K("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: Vi
      }, n.append())
    ), e.getInnerAppend !== void 0 && H.push(
      X("inner-append", e.getInnerAppend())
    ), e.getControlChild !== void 0 && H.push(
      e.getControlChild()
    ), H;
  }
  function O() {
    const H = [];
    return t.prefix !== void 0 && t.prefix !== null && H.push(
      K("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, t.prefix)
    ), e.getShadowControl !== void 0 && e.hasShadow.value === !0 && H.push(
      e.getShadowControl()
    ), e.getControl !== void 0 ? H.push(e.getControl()) : n.rawControl !== void 0 ? H.push(n.rawControl()) : n.control !== void 0 && H.push(
      K("div", {
        ref: e.targetRef,
        class: "q-field__native row",
        tabindex: -1,
        ...e.splitAttrs.attributes.value,
        "data-autofocus": t.autofocus === !0 || void 0
      }, n.control(S.value))
    ), p.value === !0 && H.push(
      K("div", {
        class: y.value
      }, Tt(n.label, t.label))
    ), t.suffix !== void 0 && t.suffix !== null && H.push(
      K("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, t.suffix)
    ), H.concat(Tt(n.default));
  }
  function $() {
    let H, oe;
    d.value === !0 ? f.value !== null ? (H = [K("div", { role: "alert" }, f.value)], oe = `q--slot-error-${f.value}`) : (H = Tt(n.error), oe = "q--slot-error") : (t.hideHint !== !0 || e.focused.value === !0) && (t.hint !== void 0 ? (H = [K("div", t.hint)], oe = `q--slot-hint-${t.hint}`) : (H = Tt(n.hint), oe = "q--slot-hint"));
    const he = t.counter === !0 || n.counter !== void 0;
    if (t.hideBottomSpace === !0 && he === !1 && H === void 0)
      return;
    const ce = K("div", {
      key: oe,
      class: "q-field__messages col"
    }, H);
    return K("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (t.hideBottomSpace !== !0 ? "animated" : "stale"),
      onClick: Vi
    }, [
      t.hideBottomSpace === !0 ? ce : K(Dn, { name: "q-transition--field-message" }, () => ce),
      he === !0 ? K("div", {
        class: "q-field__counter"
      }, n.counter !== void 0 ? n.counter() : e.computedCounter.value) : null
    ]);
  }
  function X(H, oe) {
    return oe === null ? null : K("div", {
      key: H,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, oe);
  }
  let te = !1;
  return Lo(() => {
    te = !0;
  }), Hh(() => {
    te === !0 && t.autofocus === !0 && s.focus();
  }), Qt(() => {
    ai.value === !0 && t.for === void 0 && (e.targetUid.value = so()), t.autofocus === !0 && s.focus();
  }), Ue(() => {
    l !== null && clearTimeout(l);
  }), Object.assign(s, { focus: k, blur: I }), function() {
    const oe = e.getControl === void 0 && n.control === void 0 ? {
      ...e.splitAttrs.attributes.value,
      "data-autofocus": t.autofocus === !0 || void 0,
      ...C.value
    } : C.value;
    return K("label", {
      ref: e.rootRef,
      class: [
        w.value,
        r.class
      ],
      style: r.style,
      ...oe
    }, [
      n.before !== void 0 ? K("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: Vi
      }, n.before()) : null,
      K("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        K("div", {
          ref: e.controlRef,
          class: M.value,
          tabindex: -1,
          ...e.controlEvents
        }, F()),
        v.value === !0 ? $() : null
      ]),
      n.after !== void 0 ? K("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: Vi
      }, n.after()) : null
    ]);
  };
}
const vl = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
}, Ir = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleLowerCase() }
}, Su = Object.keys(Ir);
Su.forEach((e) => {
  Ir[e].regex = new RegExp(Ir[e].pattern);
});
const yy = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + Su.join("") + "])|(.)", "g"), bl = /[.*+?^${}()|[\]\\]/g, Oe = "", vy = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function by(e, t, i, n) {
  let r, s, a, l, c, u;
  const d = ue(null), f = ue(g());
  function h() {
    return e.autogrow === !0 || ["textarea", "text", "search", "url", "tel", "password"].includes(e.type);
  }
  Le(() => e.type + e.autogrow, x), Le(() => e.mask, (A) => {
    if (A !== void 0)
      w(f.value, !0);
    else {
      const P = k(f.value);
      x(), e.modelValue !== P && t("update:modelValue", P);
    }
  }), Le(() => e.fillMask + e.reverseFillMask, () => {
    d.value === !0 && w(f.value, !0);
  }), Le(() => e.unmaskedValue, () => {
    d.value === !0 && w(f.value);
  });
  function g() {
    if (x(), d.value === !0) {
      const A = C(k(e.modelValue));
      return e.fillMask !== !1 ? I(A) : A;
    }
    return e.modelValue;
  }
  function v(A) {
    if (A < r.length)
      return r.slice(-A);
    let P = "", D = r;
    const F = D.indexOf(Oe);
    if (F > -1) {
      for (let O = A - D.length; O > 0; O--)
        P += Oe;
      D = D.slice(0, F) + P + D.slice(F);
    }
    return D;
  }
  function x() {
    if (d.value = e.mask !== void 0 && e.mask.length !== 0 && h(), d.value === !1) {
      l = void 0, r = "", s = "";
      return;
    }
    const A = vl[e.mask] === void 0 ? e.mask : vl[e.mask], P = typeof e.fillMask == "string" && e.fillMask.length !== 0 ? e.fillMask.slice(0, 1) : "_", D = P.replace(bl, "\\$&"), F = [], O = [], $ = [];
    let X = e.reverseFillMask === !0, te = "", H = "";
    A.replace(yy, (de, R, Q, _e, j) => {
      if (_e !== void 0) {
        const ie = Ir[_e];
        $.push(ie), H = ie.negate, X === !0 && (O.push("(?:" + H + "+)?(" + ie.pattern + "+)?(?:" + H + "+)?(" + ie.pattern + "+)?"), X = !1), O.push("(?:" + H + "+)?(" + ie.pattern + ")?");
      } else if (Q !== void 0)
        te = "\\" + (Q === "\\" ? "" : Q), $.push(Q), F.push("([^" + te + "]+)?" + te + "?");
      else {
        const ie = R !== void 0 ? R : j;
        te = ie === "\\" ? "\\\\\\\\" : ie.replace(bl, "\\\\$&"), $.push(ie), F.push("([^" + te + "]+)?" + te + "?");
      }
    });
    const oe = new RegExp(
      "^" + F.join("") + "(" + (te === "" ? "." : "[^" + te + "]") + "+)?" + (te === "" ? "" : "[" + te + "]*") + "$"
    ), he = O.length - 1, ce = O.map((de, R) => R === 0 && e.reverseFillMask === !0 ? new RegExp("^" + D + "*" + de) : R === he ? new RegExp(
      "^" + de + "(" + (H === "" ? "." : H) + "+)?" + (e.reverseFillMask === !0 ? "$" : D + "*")
    ) : new RegExp("^" + de));
    a = $, l = (de) => {
      const R = oe.exec(e.reverseFillMask === !0 ? de : de.slice(0, $.length + 1));
      R !== null && (de = R.slice(1).join(""));
      const Q = [], _e = ce.length;
      for (let j = 0, ie = de; j < _e; j++) {
        const le = ce[j].exec(ie);
        if (le === null)
          break;
        ie = ie.slice(le.shift().length), Q.push(...le);
      }
      return Q.length !== 0 ? Q.join("") : de;
    }, r = $.map((de) => typeof de == "string" ? de : Oe).join(""), s = r.split(Oe).join(P);
  }
  function w(A, P, D) {
    const F = n.value, O = F.selectionEnd, $ = F.value.length - O, X = k(A);
    P === !0 && x();
    const te = C(X), H = e.fillMask !== !1 ? I(te) : te, oe = f.value !== H;
    F.value !== H && (F.value = H), oe === !0 && (f.value = H), document.activeElement === F && Et(() => {
      if (H === s) {
        const ce = e.reverseFillMask === !0 ? s.length : 0;
        F.setSelectionRange(ce, ce, "forward");
        return;
      }
      if (D === "insertFromPaste" && e.reverseFillMask !== !0) {
        const ce = F.selectionEnd;
        let de = O - 1;
        for (let R = c; R <= de && R < ce; R++)
          r[R] !== Oe && de++;
        p.right(F, de);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(D) > -1) {
        const ce = e.reverseFillMask === !0 ? O === 0 ? H.length > te.length ? 1 : 0 : Math.max(0, H.length - (H === s ? 0 : Math.min(te.length, $) + 1)) + 1 : O;
        F.setSelectionRange(ce, ce, "forward");
        return;
      }
      if (e.reverseFillMask === !0)
        if (oe === !0) {
          const ce = Math.max(0, H.length - (H === s ? 0 : Math.min(te.length, $ + 1)));
          ce === 1 && O === 1 ? F.setSelectionRange(ce, ce, "forward") : p.rightReverse(F, ce);
        } else {
          const ce = H.length - $;
          F.setSelectionRange(ce, ce, "backward");
        }
      else if (oe === !0) {
        const ce = Math.max(0, r.indexOf(Oe), Math.min(te.length, O) - 1);
        p.right(F, ce);
      } else {
        const ce = O - 1;
        p.right(F, ce);
      }
    });
    const he = e.unmaskedValue === !0 ? k(H) : H;
    String(e.modelValue) !== he && i(he, !0);
  }
  function M(A, P, D) {
    const F = C(k(A.value));
    P = Math.max(0, r.indexOf(Oe), Math.min(F.length, P)), c = P, A.setSelectionRange(P, D, "forward");
  }
  const p = {
    left(A, P) {
      const D = r.slice(P - 1).indexOf(Oe) === -1;
      let F = Math.max(0, P - 1);
      for (; F >= 0; F--)
        if (r[F] === Oe) {
          P = F, D === !0 && P++;
          break;
        }
      if (F < 0 && r[P] !== void 0 && r[P] !== Oe)
        return p.right(A, 0);
      P >= 0 && A.setSelectionRange(P, P, "backward");
    },
    right(A, P) {
      const D = A.value.length;
      let F = Math.min(D, P + 1);
      for (; F <= D; F++)
        if (r[F] === Oe) {
          P = F;
          break;
        } else r[F - 1] === Oe && (P = F);
      if (F > D && r[P - 1] !== void 0 && r[P - 1] !== Oe)
        return p.left(A, D);
      A.setSelectionRange(P, P, "forward");
    },
    leftReverse(A, P) {
      const D = v(A.value.length);
      let F = Math.max(0, P - 1);
      for (; F >= 0; F--)
        if (D[F - 1] === Oe) {
          P = F;
          break;
        } else if (D[F] === Oe && (P = F, F === 0))
          break;
      if (F < 0 && D[P] !== void 0 && D[P] !== Oe)
        return p.rightReverse(A, 0);
      P >= 0 && A.setSelectionRange(P, P, "backward");
    },
    rightReverse(A, P) {
      const D = A.value.length, F = v(D), O = F.slice(0, P + 1).indexOf(Oe) === -1;
      let $ = Math.min(D, P + 1);
      for (; $ <= D; $++)
        if (F[$ - 1] === Oe) {
          P = $, P > 0 && O === !0 && P--;
          break;
        }
      if ($ > D && F[P - 1] !== void 0 && F[P - 1] !== Oe)
        return p.leftReverse(A, D);
      A.setSelectionRange(P, P, "forward");
    }
  };
  function y(A) {
    t("click", A), u = void 0;
  }
  function S(A) {
    if (t("keydown", A), Yc(A) === !0)
      return;
    const P = n.value, D = P.selectionStart, F = P.selectionEnd;
    if (A.shiftKey || (u = void 0), A.keyCode === 37 || A.keyCode === 39) {
      A.shiftKey && u === void 0 && (u = P.selectionDirection === "forward" ? D : F);
      const O = p[(A.keyCode === 39 ? "right" : "left") + (e.reverseFillMask === !0 ? "Reverse" : "")];
      if (A.preventDefault(), O(P, u === D ? F : D), A.shiftKey) {
        const $ = P.selectionStart;
        P.setSelectionRange(Math.min(u, $), Math.max(u, $), "forward");
      }
    } else A.keyCode === 8 && e.reverseFillMask !== !0 && D === F ? (p.left(P, D), P.setSelectionRange(P.selectionStart, F, "backward")) : A.keyCode === 46 && e.reverseFillMask === !0 && D === F && (p.rightReverse(P, F), P.setSelectionRange(D, P.selectionEnd, "forward"));
  }
  function C(A) {
    if (A == null || A === "")
      return "";
    if (e.reverseFillMask === !0)
      return T(A);
    const P = a;
    let D = 0, F = "";
    for (let O = 0; O < P.length; O++) {
      const $ = A[D], X = P[O];
      if (typeof X == "string")
        F += X, $ === X && D++;
      else if ($ !== void 0 && X.regex.test($))
        F += X.transform !== void 0 ? X.transform($) : $, D++;
      else
        return F;
    }
    return F;
  }
  function T(A) {
    const P = a, D = r.indexOf(Oe);
    let F = A.length - 1, O = "";
    for (let $ = P.length - 1; $ >= 0 && F > -1; $--) {
      const X = P[$];
      let te = A[F];
      if (typeof X == "string")
        O = X + O, te === X && F--;
      else if (te !== void 0 && X.regex.test(te))
        do
          O = (X.transform !== void 0 ? X.transform(te) : te) + O, F--, te = A[F];
        while (D === $ && te !== void 0 && X.regex.test(te));
      else
        return O;
    }
    return O;
  }
  function k(A) {
    return typeof A != "string" || l === void 0 ? typeof A == "number" ? l("" + A) : A : l(A);
  }
  function I(A) {
    return s.length - A.length <= 0 ? A : e.reverseFillMask === !0 && A.length !== 0 ? s.slice(0, -A.length) + A : A + s.slice(A.length);
  }
  return {
    innerValue: f,
    hasMask: d,
    moveCursorForPaste: M,
    updateMaskValue: w,
    onMaskedKeydown: S,
    onMaskedClick: y
  };
}
const Io = {
  name: String
};
function Cu(e = {}) {
  return (t, i, n) => {
    t[i](
      K("input", {
        class: "hidden" + (n || ""),
        ...e.value
      })
    );
  };
}
function wy(e) {
  return W(() => e.name || e.for);
}
function _y(e, t) {
  function i() {
    const n = e.modelValue;
    try {
      const r = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      return Object(n) === n && ("length" in n ? Array.from(n) : [n]).forEach((s) => {
        r.items.add(s);
      }), {
        files: r.files
      };
    } catch {
      return {
        files: void 0
      };
    }
  }
  return W(() => {
    if (e.type === "file")
      return i();
  });
}
const Ly = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/, xy = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u, Sy = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/, Cy = /[a-z0-9_ -]$/i;
function Ey(e) {
  return function(i) {
    if (i.type === "compositionend" || i.type === "change") {
      if (i.target.qComposing !== !0)
        return;
      i.target.qComposing = !1, e(i);
    } else i.type === "compositionupdate" && i.target.qComposing !== !0 && typeof i.data == "string" && (Fe.is.firefox === !0 ? Cy.test(i.data) === !1 : Ly.test(i.data) === !0 || xy.test(i.data) === !0 || Sy.test(i.data) === !0) === !0 && (i.target.qComposing = !0);
  };
}
const Ty = Je({
  name: "QInput",
  inheritAttrs: !1,
  props: {
    ...hy,
    ...vy,
    ...Io,
    modelValue: { required: !1 },
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...my,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(e, { emit: t, attrs: i }) {
    const { proxy: n } = Ve(), { $q: r } = n, s = {};
    let a = NaN, l, c, u = null, d;
    const f = ue(null), h = wy(e), {
      innerValue: g,
      hasMask: v,
      moveCursorForPaste: x,
      updateMaskValue: w,
      onMaskedKeydown: M,
      onMaskedClick: p
    } = by(e, t, te, f), y = _y(e), S = W(() => oo(g.value)), C = Ey($), T = gy(), k = W(
      () => e.type === "textarea" || e.autogrow === !0
    ), I = W(
      () => k.value === !0 || ["text", "search", "url", "tel", "password"].includes(e.type)
    ), A = W(() => {
      const R = {
        ...T.splitAttrs.listeners.value,
        onInput: $,
        onPaste: O,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange: oe,
        onBlur: he,
        onFocus: Ar
      };
      return R.onCompositionstart = R.onCompositionupdate = R.onCompositionend = C, v.value === !0 && (R.onKeydown = M, R.onClick = p), e.autogrow === !0 && (R.onAnimationend = X), R;
    }), P = W(() => {
      const R = {
        tabindex: 0,
        "data-autofocus": e.autofocus === !0 || void 0,
        rows: e.type === "textarea" ? 6 : void 0,
        "aria-label": e.label,
        name: h.value,
        ...T.splitAttrs.attributes.value,
        id: T.targetUid.value,
        maxlength: e.maxlength,
        disabled: e.disable === !0,
        readonly: e.readonly === !0
      };
      return k.value === !1 && (R.type = e.type), e.autogrow === !0 && (R.rows = 1), R;
    });
    Le(() => e.type, () => {
      f.value && (f.value.value = e.modelValue);
    }), Le(() => e.modelValue, (R) => {
      if (v.value === !0) {
        if (c === !0 && (c = !1, String(R) === a))
          return;
        w(R);
      } else g.value !== R && (g.value = R, e.type === "number" && s.hasOwnProperty("value") === !0 && (l === !0 ? l = !1 : delete s.value));
      e.autogrow === !0 && Et(H);
    }), Le(() => e.autogrow, (R) => {
      R === !0 ? Et(H) : f.value !== null && i.rows > 0 && (f.value.style.height = "auto");
    }), Le(() => e.dense, () => {
      e.autogrow === !0 && Et(H);
    });
    function D() {
      $o(() => {
        const R = document.activeElement;
        f.value !== null && f.value !== R && (R === null || R.id !== T.targetUid.value) && f.value.focus({ preventScroll: !0 });
      });
    }
    function F() {
      f.value !== null && f.value.select();
    }
    function O(R) {
      if (v.value === !0 && e.reverseFillMask !== !0) {
        const Q = R.target;
        x(Q, Q.selectionStart, Q.selectionEnd);
      }
      t("paste", R);
    }
    function $(R) {
      if (!R || !R.target)
        return;
      if (e.type === "file") {
        t("update:modelValue", R.target.files);
        return;
      }
      const Q = R.target.value;
      if (R.target.qComposing === !0) {
        s.value = Q;
        return;
      }
      if (v.value === !0)
        w(Q, !1, R.inputType);
      else if (te(Q), I.value === !0 && R.target === document.activeElement) {
        const { selectionStart: _e, selectionEnd: j } = R.target;
        _e !== void 0 && j !== void 0 && Et(() => {
          R.target === document.activeElement && Q.indexOf(R.target.value) === 0 && R.target.setSelectionRange(_e, j);
        });
      }
      e.autogrow === !0 && H();
    }
    function X(R) {
      t("animationend", R), H();
    }
    function te(R, Q) {
      d = () => {
        u = null, e.type !== "number" && s.hasOwnProperty("value") === !0 && delete s.value, e.modelValue !== R && a !== R && (a = R, Q === !0 && (c = !0), t("update:modelValue", R), Et(() => {
          a === R && (a = NaN);
        })), d = void 0;
      }, e.type === "number" && (l = !0, s.value = R), e.debounce !== void 0 ? (u !== null && clearTimeout(u), s.value = R, u = setTimeout(d, e.debounce)) : d();
    }
    function H() {
      requestAnimationFrame(() => {
        const R = f.value;
        if (R !== null) {
          const Q = R.parentNode.style, { scrollTop: _e } = R, { overflowY: j, maxHeight: ie } = r.platform.is.firefox === !0 ? {} : window.getComputedStyle(R), le = j !== void 0 && j !== "scroll";
          le === !0 && (R.style.overflowY = "hidden"), Q.marginBottom = R.scrollHeight - 1 + "px", R.style.height = "1px", R.style.height = R.scrollHeight + "px", le === !0 && (R.style.overflowY = parseInt(ie, 10) < R.scrollHeight ? "auto" : "hidden"), Q.marginBottom = "", R.scrollTop = _e;
        }
      });
    }
    function oe(R) {
      C(R), u !== null && (clearTimeout(u), u = null), d !== void 0 && d(), t("change", R.target.value);
    }
    function he(R) {
      R !== void 0 && Ar(R), u !== null && (clearTimeout(u), u = null), d !== void 0 && d(), l = !1, c = !1, delete s.value, e.type !== "file" && setTimeout(() => {
        f.value !== null && (f.value.value = g.value !== void 0 ? g.value : "");
      });
    }
    function ce() {
      return s.hasOwnProperty("value") === !0 ? s.value : g.value !== void 0 ? g.value : "";
    }
    Ue(() => {
      he();
    }), Qt(() => {
      e.autogrow === !0 && H();
    }), Object.assign(T, {
      innerValue: g,
      fieldClass: W(
        () => `q-${k.value === !0 ? "textarea" : "input"}` + (e.autogrow === !0 ? " q-textarea--autogrow" : "")
      ),
      hasShadow: W(
        () => e.type !== "file" && typeof e.shadowText == "string" && e.shadowText.length !== 0
      ),
      inputRef: f,
      emitValue: te,
      hasValue: S,
      floatingLabel: W(
        () => S.value === !0 && (e.type !== "number" || isNaN(g.value) === !1) || oo(e.displayValue)
      ),
      getControl: () => K(k.value === !0 ? "textarea" : "input", {
        ref: f,
        class: [
          "q-field__native q-placeholder",
          e.inputClass
        ],
        style: e.inputStyle,
        ...P.value,
        ...A.value,
        ...e.type !== "file" ? { value: ce() } : y.value
      }),
      getShadowControl: () => K("div", {
        class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (k.value === !0 ? "" : " text-no-wrap")
      }, [
        K("span", { class: "invisible" }, ce()),
        K("span", e.shadowText)
      ])
    });
    const de = py(T);
    return Object.assign(n, {
      focus: D,
      select: F,
      getNativeElement: () => f.value
      // deprecated
    }), nn(n, "nativeEl", () => f.value), de;
  }
});
function Eu(e, t) {
  const i = ue(null), n = W(() => e.disable === !0 ? null : K("span", {
    ref: i,
    class: "no-outline",
    tabindex: -1
  }));
  function r(s) {
    const a = t.value;
    s !== void 0 && s.type.indexOf("key") === 0 ? a !== null && document.activeElement !== a && a.contains(document.activeElement) === !0 && a.focus() : i.value !== null && (s === void 0 || a !== null && a.contains(s.target) === !0) && i.value.focus();
  }
  return {
    refocusTargetEl: n,
    refocusTarget: r
  };
}
const Tu = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}, Py = K("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  K("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  K("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]), ky = Je({
  name: "QRadio",
  props: {
    ...Di,
    ...Kn,
    ...Io,
    modelValue: { required: !0 },
    val: { required: !0 },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(e, { slots: t, emit: i }) {
    const { proxy: n } = Ve(), r = Ai(e, n.$q), s = Hn(e, Tu), a = ue(null), { refocusTargetEl: l, refocusTarget: c } = Eu(e, a), u = W(() => jt(e.modelValue) === jt(e.val)), d = W(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (e.disable === !0 ? " disabled" : "") + (r.value === !0 ? " q-radio--dark" : "") + (e.dense === !0 ? " q-radio--dense" : "") + (e.leftLabel === !0 ? " reverse" : "")
    ), f = W(() => {
      const y = e.color !== void 0 && (e.keepColor === !0 || u.value === !0) ? ` text-${e.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${u.value === !0 ? "truthy" : "falsy"}${y}`;
    }), h = W(
      () => (u.value === !0 ? e.checkedIcon : e.uncheckedIcon) || null
    ), g = W(() => e.disable === !0 ? -1 : e.tabindex || 0), v = W(() => {
      const y = { type: "radio" };
      return e.name !== void 0 && Object.assign(y, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": u.value === !0,
        "^checked": u.value === !0 ? "checked" : void 0,
        name: e.name,
        value: e.val
      }), y;
    }), x = Cu(v);
    function w(y) {
      y !== void 0 && (yt(y), c(y)), e.disable !== !0 && u.value !== !0 && i("update:modelValue", e.val, y);
    }
    function M(y) {
      (y.keyCode === 13 || y.keyCode === 32) && yt(y);
    }
    function p(y) {
      (y.keyCode === 13 || y.keyCode === 32) && w(y);
    }
    return Object.assign(n, { set: w }), () => {
      const y = h.value !== null ? [
        K("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          K(Kt, {
            class: "q-radio__icon",
            name: h.value
          })
        ])
      ] : [Py];
      e.disable !== !0 && x(
        y,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const S = [
        K("div", {
          class: f.value,
          style: s.value,
          "aria-hidden": "true"
        }, y)
      ];
      l.value !== null && S.push(l.value);
      const C = e.label !== void 0 ? yi(t.default, [e.label]) : Tt(t.default);
      return C !== void 0 && S.push(
        K("div", {
          class: "q-radio__label q-anchor--skip"
        }, C)
      ), K("div", {
        ref: a,
        class: d.value,
        tabindex: g.value,
        role: "radio",
        "aria-label": e.label,
        "aria-checked": u.value === !0 ? "true" : "false",
        "aria-disabled": e.disable === !0 ? "true" : void 0,
        onClick: w,
        onKeydown: M,
        onKeyup: p
      }, S);
    };
  }
}), Pu = {
  ...Di,
  ...Kn,
  ...Io,
  modelValue: {
    required: !0,
    default: null
  },
  val: {},
  trueValue: { default: !0 },
  falseValue: { default: !1 },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (e) => e === "tf" || e === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
}, ku = ["update:modelValue"];
function Mu(e, t) {
  const { props: i, slots: n, emit: r, proxy: s } = Ve(), { $q: a } = s, l = Ai(i, a), c = ue(null), { refocusTargetEl: u, refocusTarget: d } = Eu(i, c), f = Hn(i, Tu), h = W(
    () => i.val !== void 0 && Array.isArray(i.modelValue)
  ), g = W(() => {
    const F = jt(i.val);
    return h.value === !0 ? i.modelValue.findIndex((O) => jt(O) === F) : -1;
  }), v = W(() => h.value === !0 ? g.value > -1 : jt(i.modelValue) === jt(i.trueValue)), x = W(() => h.value === !0 ? g.value === -1 : jt(i.modelValue) === jt(i.falseValue)), w = W(
    () => v.value === !1 && x.value === !1
  ), M = W(() => i.disable === !0 ? -1 : i.tabindex || 0), p = W(
    () => `q-${e} cursor-pointer no-outline row inline no-wrap items-center` + (i.disable === !0 ? " disabled" : "") + (l.value === !0 ? ` q-${e}--dark` : "") + (i.dense === !0 ? ` q-${e}--dense` : "") + (i.leftLabel === !0 ? " reverse" : "")
  ), y = W(() => {
    const F = v.value === !0 ? "truthy" : x.value === !0 ? "falsy" : "indet", O = i.color !== void 0 && (i.keepColor === !0 || (e === "toggle" ? v.value === !0 : x.value !== !0)) ? ` text-${i.color}` : "";
    return `q-${e}__inner relative-position non-selectable q-${e}__inner--${F}${O}`;
  }), S = W(() => {
    const F = { type: "checkbox" };
    return i.name !== void 0 && Object.assign(F, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": v.value,
      "^checked": v.value === !0 ? "checked" : void 0,
      name: i.name,
      value: h.value === !0 ? i.val : i.trueValue
    }), F;
  }), C = Cu(S), T = W(() => {
    const F = {
      tabindex: M.value,
      role: e === "toggle" ? "switch" : "checkbox",
      "aria-label": i.label,
      "aria-checked": w.value === !0 ? "mixed" : v.value === !0 ? "true" : "false"
    };
    return i.disable === !0 && (F["aria-disabled"] = "true"), F;
  });
  function k(F) {
    F !== void 0 && (yt(F), d(F)), i.disable !== !0 && r("update:modelValue", I(), F);
  }
  function I() {
    if (h.value === !0) {
      if (v.value === !0) {
        const F = i.modelValue.slice();
        return F.splice(g.value, 1), F;
      }
      return i.modelValue.concat([i.val]);
    }
    if (v.value === !0) {
      if (i.toggleOrder !== "ft" || i.toggleIndeterminate === !1)
        return i.falseValue;
    } else if (x.value === !0) {
      if (i.toggleOrder === "ft" || i.toggleIndeterminate === !1)
        return i.trueValue;
    } else
      return i.toggleOrder !== "ft" ? i.trueValue : i.falseValue;
    return i.indeterminateValue;
  }
  function A(F) {
    (F.keyCode === 13 || F.keyCode === 32) && yt(F);
  }
  function P(F) {
    (F.keyCode === 13 || F.keyCode === 32) && k(F);
  }
  const D = t(v, w);
  return Object.assign(s, { toggle: k }), () => {
    const F = D();
    i.disable !== !0 && C(
      F,
      "unshift",
      ` q-${e}__native absolute q-ma-none q-pa-none`
    );
    const O = [
      K("div", {
        class: y.value,
        style: f.value,
        "aria-hidden": "true"
      }, F)
    ];
    u.value !== null && O.push(u.value);
    const $ = i.label !== void 0 ? yi(n.default, [i.label]) : Tt(n.default);
    return $ !== void 0 && O.push(
      K("div", {
        class: `q-${e}__label q-anchor--skip`
      }, $)
    ), K("div", {
      ref: c,
      class: p.value,
      ...T.value,
      onClick: k,
      onKeydown: A,
      onKeyup: P
    }, O);
  };
}
const My = K("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  K("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    K("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    K("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]), Fy = Je({
  name: "QCheckbox",
  props: Pu,
  emits: ku,
  setup(e) {
    function t(i, n) {
      const r = W(
        () => (i.value === !0 ? e.checkedIcon : n.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || null
      );
      return () => r.value !== null ? [
        K("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          K(Kt, {
            class: "q-checkbox__icon",
            name: r.value
          })
        ])
      ] : [My];
    }
    return Mu("checkbox", t);
  }
}), Dy = Je({
  name: "QToggle",
  props: {
    ...Pu,
    icon: String,
    iconColor: String
  },
  emits: ku,
  setup(e) {
    function t(i, n) {
      const r = W(
        () => (i.value === !0 ? e.checkedIcon : n.value === !0 ? e.indeterminateIcon : e.uncheckedIcon) || e.icon
      ), s = W(() => i.value === !0 ? e.iconColor : null);
      return () => [
        K("div", { class: "q-toggle__track" }),
        K(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          r.value !== void 0 ? [
            K(Kt, {
              name: r.value,
              color: s.value
            })
          ] : void 0
        )
      ];
    }
    return Mu("toggle", t);
  }
}), Fu = {
  radio: ky,
  checkbox: Fy,
  toggle: Dy
}, Ay = Object.keys(Fu), Oy = Je({
  name: "QOptionGroup",
  props: {
    ...Di,
    modelValue: {
      required: !0
    },
    options: {
      type: Array,
      validator: (e) => e.every((t) => "value" in t && "label" in t)
    },
    name: String,
    type: {
      default: "radio",
      validator: (e) => Ay.includes(e)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t, slots: i }) {
    const { proxy: { $q: n } } = Ve(), r = Array.isArray(e.modelValue);
    e.type === "radio" ? r === !0 && console.error("q-option-group: model should not be array") : r === !1 && console.error("q-option-group: model should be array in your case");
    const s = Ai(e, n), a = W(() => Fu[e.type]), l = W(
      () => "q-option-group q-gutter-x-sm" + (e.inline === !0 ? " q-option-group--inline" : "")
    ), c = W(() => {
      const d = { role: "group" };
      return e.type === "radio" && (d.role = "radiogroup", e.disable === !0 && (d["aria-disabled"] = "true")), d;
    });
    function u(d) {
      t("update:modelValue", d);
    }
    return () => K("div", {
      class: l.value,
      ...c.value
    }, e.options.map((d, f) => {
      const h = i["label-" + f] !== void 0 ? () => i["label-" + f](d) : i.label !== void 0 ? () => i.label(d) : void 0;
      return K("div", [
        K(a.value, {
          modelValue: e.modelValue,
          val: d.value,
          name: d.name === void 0 ? e.name : d.name,
          disable: e.disable || d.disable,
          label: h === void 0 ? d.label : null,
          leftLabel: d.leftLabel === void 0 ? e.leftLabel : d.leftLabel,
          color: d.color === void 0 ? e.color : d.color,
          checkedIcon: d.checkedIcon,
          uncheckedIcon: d.uncheckedIcon,
          dark: d.dark || s.value,
          size: d.size === void 0 ? e.size : d.size,
          dense: e.dense,
          keepColor: d.keepColor === void 0 ? e.keepColor : d.keepColor,
          "onUpdate:modelValue": u
        }, h)
      ]);
    }));
  }
}), By = Je({
  name: "DialogPlugin",
  props: {
    ...Di,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: !0
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (e) => ["ok", "cancel", "none"].includes(e)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(e, { emit: t }) {
    const { proxy: i } = Ve(), { $q: n } = i, r = Ai(e, n), s = ue(null), a = ue(
      e.prompt !== void 0 ? e.prompt.model : e.options !== void 0 ? e.options.model : void 0
    ), l = W(
      () => "q-dialog-plugin" + (r.value === !0 ? " q-dialog-plugin--dark q-dark" : "") + (e.progress !== !1 ? " q-dialog-plugin--progress" : "")
    ), c = W(
      () => e.color || (r.value === !0 ? "amber" : "primary")
    ), u = W(() => e.progress === !1 ? null : vt(e.progress) === !0 ? {
      component: e.progress.spinner || Ji,
      props: { color: e.progress.color || c.value }
    } : {
      component: Ji,
      props: { color: c.value }
    }), d = W(
      () => e.prompt !== void 0 || e.options !== void 0
    ), f = W(() => {
      if (d.value !== !0)
        return {};
      const { model: $, isValid: X, items: te, ...H } = e.prompt !== void 0 ? e.prompt : e.options;
      return H;
    }), h = W(() => vt(e.ok) === !0 || e.ok === !0 ? n.lang.label.ok : e.ok), g = W(() => vt(e.cancel) === !0 || e.cancel === !0 ? n.lang.label.cancel : e.cancel), v = W(() => e.prompt !== void 0 ? e.prompt.isValid !== void 0 && e.prompt.isValid(a.value) !== !0 : e.options !== void 0 ? e.options.isValid !== void 0 && e.options.isValid(a.value) !== !0 : !1), x = W(() => ({
      color: c.value,
      label: h.value,
      ripple: !1,
      disable: v.value,
      ...vt(e.ok) === !0 ? e.ok : { flat: !0 },
      "data-autofocus": e.focus === "ok" && d.value !== !0 || void 0,
      onClick: y
    })), w = W(() => ({
      color: c.value,
      label: g.value,
      ripple: !1,
      ...vt(e.cancel) === !0 ? e.cancel : { flat: !0 },
      "data-autofocus": e.focus === "cancel" && d.value !== !0 || void 0,
      onClick: S
    }));
    Le(() => e.prompt && e.prompt.model, T), Le(() => e.options && e.options.model, T);
    function M() {
      s.value.show();
    }
    function p() {
      s.value.hide();
    }
    function y() {
      t("ok", jt(a.value)), p();
    }
    function S() {
      p();
    }
    function C() {
      t("hide");
    }
    function T($) {
      a.value = $;
    }
    function k($) {
      v.value !== !0 && e.prompt.type !== "textarea" && On($, 13) === !0 && y();
    }
    function I($, X) {
      return e.html === !0 ? K(vn, {
        class: $,
        innerHTML: X
      }) : K(vn, { class: $ }, () => X);
    }
    function A() {
      return [
        K(Ty, {
          color: c.value,
          dense: !0,
          autofocus: !0,
          dark: r.value,
          ...f.value,
          modelValue: a.value,
          "onUpdate:modelValue": T,
          onKeyup: k
        })
      ];
    }
    function P() {
      return [
        K(Oy, {
          color: c.value,
          options: e.options.items,
          dark: r.value,
          ...f.value,
          modelValue: a.value,
          "onUpdate:modelValue": T
        })
      ];
    }
    function D() {
      const $ = [];
      return e.cancel && $.push(
        K(no, w.value)
      ), e.ok && $.push(
        K(no, x.value)
      ), K(oy, {
        class: e.stackButtons === !0 ? "items-end" : "",
        vertical: e.stackButtons,
        align: "right"
      }, () => $);
    }
    function F() {
      const $ = [];
      return e.title && $.push(
        I("q-dialog__title", e.title)
      ), e.progress !== !1 && $.push(
        K(
          vn,
          { class: "q-dialog__progress" },
          () => K(u.value.component, u.value.props)
        )
      ), e.message && $.push(
        I("q-dialog__message", e.message)
      ), e.prompt !== void 0 ? $.push(
        K(
          vn,
          { class: "scroll q-dialog-plugin__form" },
          A
        )
      ) : e.options !== void 0 && $.push(
        K(hl, { dark: r.value }),
        K(
          vn,
          { class: "scroll q-dialog-plugin__form" },
          P
        ),
        K(hl, { dark: r.value })
      ), (e.ok || e.cancel) && $.push(D()), $;
    }
    function O() {
      return [
        K(sy, {
          class: [
            l.value,
            e.cardClass
          ],
          style: e.cardStyle,
          dark: r.value
        }, F)
      ];
    }
    return Object.assign(i, { show: M, hide: p }), () => K(ry, {
      ref: s,
      onHide: C
    }, O);
  }
});
function Du(e, t) {
  for (const i in t)
    i !== "spinner" && Object(t[i]) === t[i] ? (e[i] = Object(e[i]) !== e[i] ? {} : { ...e[i] }, Du(e[i], t[i])) : e[i] = t[i];
}
function Ry(e, t, i) {
  return (n) => {
    let r, s;
    const a = n.component !== void 0;
    if (a === !0) {
      const { component: p, componentProps: y } = n;
      r = typeof p == "string" ? i.component(p) : p, s = y || {};
    } else {
      const { class: p, style: y, ...S } = n;
      r = e, s = S, p !== void 0 && (S.cardClass = p), y !== void 0 && (S.cardStyle = y);
    }
    let l, c = !1;
    const u = ue(null), d = cs(!1, "dialog"), f = (p) => {
      if (u.value !== null && u.value[p] !== void 0) {
        u.value[p]();
        return;
      }
      const y = l.$.subTree;
      if (y && y.component) {
        if (y.component.proxy && y.component.proxy[p]) {
          y.component.proxy[p]();
          return;
        }
        if (y.component.subTree && y.component.subTree.component && y.component.subTree.component.proxy && y.component.subTree.component.proxy[p]) {
          y.component.subTree.component.proxy[p]();
          return;
        }
      }
      console.error("[Quasar] Incorrectly defined Dialog component");
    }, h = [], g = [], v = {
      onOk(p) {
        return h.push(p), v;
      },
      onCancel(p) {
        return g.push(p), v;
      },
      onDismiss(p) {
        return h.push(p), g.push(p), v;
      },
      hide() {
        return f("hide"), v;
      },
      update(p) {
        if (l !== null) {
          if (a === !0)
            Object.assign(s, p);
          else {
            const { class: y, style: S, ...C } = p;
            y !== void 0 && (C.cardClass = y), S !== void 0 && (C.cardStyle = S), Du(s, C);
          }
          l.$forceUpdate();
        }
        return v;
      }
    }, x = (p) => {
      c = !0, h.forEach((y) => {
        y(p);
      });
    }, w = () => {
      M.unmount(d), Oo(d), M = null, l = null, c !== !0 && g.forEach((p) => {
        p();
      });
    };
    let M = Ao({
      name: "QGlobalDialog",
      setup: () => () => K(r, {
        ...s,
        ref: u,
        onOk: x,
        onHide: w,
        onVnodeMounted(...p) {
          typeof s.onVnodeMounted == "function" && s.onVnodeMounted(...p), Et(() => f("show"));
        }
      })
    }, i);
    return l = M.mount(d), v;
  };
}
const Oi = {
  install({ $q: e, parentApp: t }) {
    e.dialog = Ry(By, !0, t), this.__installed !== !0 && (this.create = e.dialog);
  }
}, js = {
  initialize(e) {
    this.maxConcurrentRequests = e, this.pendingRequests = [], this.runningRequests = [], this.exportService = q.getService("import-export"), this.exportService.on("export-created", (t) => this.onRequestCreated(t)), this.exportService.on("export-completed", (t) => this.onRequestCompleted(t)), z.debug(`[KDK] Initialized 'Exporter' with '${e}' maxConcurrentRequests`);
  },
  push(e) {
    return this.pendingRequests.push(e), this.triggerRequest();
  },
  triggerRequest() {
    if (this.runningRequests.length >= this.maxConcurrentRequests) return !1;
    if (this.pendingRequests.length === 0) return !0;
    const e = this.pendingRequests.shift();
    try {
      let t = e.filename;
      if (!t) {
        const s = fe().toISOString().replace(/:/g, "-");
        t = `${o.get(e, "basename", e.service)}_${s}.${e.format}`;
      }
      let i = q.getServicePath(e.service);
      i.startsWith("/") && (i = i.substring(1));
      const n = o.get(e, "transform." + e.format), r = Object.assign(
        o.omit(e, ["title", "service", "context", "formats"]),
        { method: "export", filename: t, servicePath: i, transform: n }
      );
      z.debug(`[KDK] request export with options ${JSON.stringify(r, null, 2)}`), this.exportService.create(r);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return !0;
  },
  onRequestCreated(e) {
    z.debug(`[KDK] export request ${e.uuid} created`);
    const t = {
      uuid: e.uuid,
      notification: Xe.create({
        icon: "las la-hourglass-half",
        message: Y.t("exporter.EXPORTING"),
        color: "primary",
        timeout: 0,
        spinner: !0
      })
    };
    this.runningRequests.push(t);
  },
  onRequestCompleted(e) {
    z.debug(`[KDK] export request ${e.uuid} completed`);
    const t = o.head(o.remove(this.runningRequests, { uuid: e.uuid }));
    if (!t) {
      z.warn(`[KDK] export request ${e.uuid} not found`);
      return;
    }
    if (t.notification(), e.SignedUrl) {
      let i = document.getElementById("export-hidden-frame");
      i || (i = document.createElement("iframe"), i.id = "export-hidden-frame", i.style.display = "none", document.body.appendChild(i)), i.src = e.SignedUrl, Xe.create({
        type: "positive",
        message: Y.t("exporter.SUCCEEDED", { filename: e.filename }),
        html: !0
      });
    } else e.chunks === 0 ? Xe.create({
      type: "warning",
      message: Y.t("exporter.NO_DATA")
    }) : Xe.create({
      type: "negative",
      message: Y.t("exporter.ERRORED")
    });
    this.triggerRequest();
  }
}, Au = {
  initialize(e) {
    js.initialize(o.get(e, "maxConcurrentRequests", 3));
  },
  export(e) {
    if (!e.service) {
      z.error("[KDK] invalid options: missing 'service' property");
      return;
    }
    const t = o.cloneDeep(e);
    if (e.formats.length > 1) {
      const i = {
        title: Y.t(e.title ? e.title : "exporter.TITLE"),
        message: Y.t("exporter.MESSAGE"),
        options: {
          type: "radio",
          model: e.formats[0].label,
          items: e.formats.map((n) => ({ label: n.label, value: n.label }))
        },
        cancel: {
          id: "cancel-button",
          label: Y.t("CANCEL"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "export-button",
          label: Y.t("exporter.EXPORT"),
          color: "primary"
        },
        persistent: !0
      };
      Oi.create(i).onOk((n) => {
        const r = o.find(e.formats, { label: n });
        js.push(Object.assign(t, r)) || Xe.create({
          type: "negative",
          message: Y.t("exporter.EXPORTS_LIMIT_REACHED")
        });
      });
    } else
      js.push(Object.assign(t, e.formats[0])) || Xe.create({
        type: "negative",
        message: Y.t("exporter.EXPORTS_LIMIT_REACHED")
      });
  }
};
let Ni, Vs, wl = 0, mi = null, Ne = {}, bi = {};
const Ou = {
  group: "__default_quasar_group__",
  delay: 0,
  message: !1,
  html: !1,
  spinnerSize: 80,
  spinnerColor: "",
  messageColor: "",
  backgroundColor: "",
  boxClass: "",
  spinner: Ji,
  customClass: ""
}, Bu = { ...Ou };
function $y(e) {
  if (e && e.group !== void 0 && bi[e.group] !== void 0)
    return Object.assign(bi[e.group], e);
  const t = vt(e) === !0 && e.ignoreDefaults === !0 ? { ...Ou, ...e } : { ...Bu, ...e };
  return bi[t.group] = t, t;
}
const Re = rn({
  isActive: !1
}, {
  show(e) {
    Ne = $y(e);
    const { group: t } = Ne;
    return Re.isActive = !0, Ni !== void 0 ? (Ne.uid = wl, Vs.$forceUpdate()) : (Ne.uid = ++wl, mi !== null && clearTimeout(mi), mi = setTimeout(() => {
      mi = null;
      const i = cs("q-loading");
      Ni = Ao({
        name: "QLoading",
        setup() {
          Qt(() => {
            ro(!0);
          });
          function n() {
            Re.isActive !== !0 && Ni !== void 0 && (ro(!1), Ni.unmount(i), Oo(i), Ni = void 0, Vs = void 0);
          }
          function r() {
            if (Re.isActive !== !0)
              return null;
            const s = [
              K(Ne.spinner, {
                class: "q-loading__spinner",
                color: Ne.spinnerColor,
                size: Ne.spinnerSize
              })
            ];
            return Ne.message && s.push(
              K("div", {
                class: "q-loading__message" + (Ne.messageColor ? ` text-${Ne.messageColor}` : ""),
                [Ne.html === !0 ? "innerHTML" : "textContent"]: Ne.message
              })
            ), K("div", {
              class: "q-loading fullscreen flex flex-center z-max " + Ne.customClass.trim(),
              key: Ne.uid
            }, [
              K("div", {
                class: "q-loading__backdrop" + (Ne.backgroundColor ? ` bg-${Ne.backgroundColor}` : "")
              }),
              K("div", {
                class: "q-loading__box column items-center " + Ne.boxClass
              }, s)
            ]);
          }
          return () => K(Dn, {
            name: "q-transition--fade",
            appear: !0,
            onAfterLeave: n
          }, r);
        }
      }, Re.__parentApp), Vs = Ni.mount(i);
    }, Ne.delay)), (i) => {
      if (i === void 0 || Object(i) !== i) {
        Re.hide(t);
        return;
      }
      Re.show({ ...i, group: t });
    };
  },
  hide(e) {
    if (Re.isActive === !0) {
      if (e === void 0)
        bi = {};
      else {
        if (bi[e] === void 0)
          return;
        {
          delete bi[e];
          const t = Object.keys(bi);
          if (t.length !== 0) {
            const i = t[t.length - 1];
            Re.show({ group: i });
            return;
          }
        }
      }
      mi !== null && (clearTimeout(mi), mi = null), Re.isActive = !1;
    }
  },
  setDefaults(e) {
    vt(e) === !0 && Object.assign(Bu, e);
  },
  install({ $q: e, parentApp: t }) {
    e.loading = this, Re.__parentApp = t, e.config.loading !== void 0 && this.setDefaults(e.config.loading);
  }
}), Pi = {
  readers: {},
  register(e, t) {
    o.isArray(e) || (e = [e]), o.forEach(e, (i) => {
      this.readers[i] = t, t.mimeType = i;
    });
  },
  filter(e) {
    const t = [], i = [];
    for (let n = 0; n < e.length; ++n) {
      const r = e[n], s = qt.extname(r.name).toLowerCase();
      let a = this.readers[s];
      if (a)
        t.push({ reader: s, name: r.name, files: [r] });
      else if (a = o.find(this.readers, (l) => l.getAdditionalFiles().includes(s)), a)
        i.push({ reader: a.mimeType, file: r });
      else {
        const l = { message: Y.t("errors.UNSUPPORTED_FILE_FORMAT", { file: r.name }) };
        ne.emit("error", l);
      }
    }
    return o.forEach(i, (n) => {
      const r = o.find(t, (s) => s.reader === n.reader);
      if (r) r.files.push(n.file);
      else {
        const s = { message: Y.t("errors.UNSUPPORTED_FILE_FORMAT", { file: n.name }) };
        ne.emit("error", s);
      }
    }), t;
  },
  async read(e, t) {
    const i = this.readers[e.reader];
    Re.show({ message: Y.t("reader.READING_FILE", { file: e.name }), html: !0 });
    try {
      const n = await i.read(e.files, t);
      return Re.hide(), n;
    } catch (n) {
      Re.hide(), ne.emit("error", n);
    }
  },
  getSupportedFormats() {
    return Object.keys(this.readers);
  }
};
function Iy(e, t, i) {
  const n = i.propertyMapping, r = o.uniq(o.values(n).map((a) => a.split(".")[0])), s = i.settingsKey || "settings";
  return {
    async get(a) {
      const l = {};
      return o.forOwn(n, (c, u) => {
        c && o.set(l, u, V.get(c));
      }), l;
    },
    async patch(a, l) {
      const c = r.map((u) => V.get(u));
      o.forOwn(l, (u, d) => {
        o.get(n, d) && V.set(n[d], u);
      }), r.forEach((u, d) => {
        const f = o.kebabCase(`${u}-changed`);
        ne.emit(f, V.get(u), c[d]);
      }), this.saveSettings();
    },
    saveSettings() {
      const a = {};
      o.forOwn(n, (l, c) => {
        l && V.has(l) && o.set(a, c, V.get(l));
      }), nt.set(s, a);
    },
    restoreSettings() {
      let a = nt.get(s);
      a && (o.get(a, "utc") && o.has(n, "timezone") && !o.get(a, "timezone") && o.set(a, "timezone", "UTC"), o.forOwn(n, (l, c) => {
        l && o.has(a, c) && V.set(l, o.get(a, c));
      }));
    },
    getSchema() {
      return i.settingsSchema;
    },
    getSettingsMapping() {
      return n;
    }
  };
}
function Ru() {
  const e = this;
  e.createService("users"), e.createService("authorisations"), e.createService("import-export"), e.createService("account", { methods: ["create", "verifyEmail"] });
  const t = o.get(me, "settings.propertyMapping", {
    shortTime: "time.format.time.short",
    longTime: "time.format.time.long",
    shortDate: "time.format.date.short",
    longDate: "time.format.date.long",
    shortYear: "time.format.year.short",
    longYear: "time.format.year.long",
    timezone: "time.format.timezone",
    timelineStep: "time.step",
    timelineInterval: "time.interval",
    timeseriesSpan: "timeseries.span",
    timeseriesGroupBy: "timeseries.groupBy",
    location: "locationFormat",
    navigator: "navigator",
    restoreView: "restore.view",
    restoreLayers: "restore.layers",
    defaultLength: "units.default.length",
    defaultAltitude: "units.default.altitude",
    defaultArea: "units.default.area",
    defaultVelocity: "units.default.velocity",
    defaultTemperature: "units.default.temperature",
    defaultAngle: "units.default.angle",
    defaultEquivalentDoseRate: "units.default.equivalentDoseRate",
    defaultNotation: "units.default.notation",
    defaultPrecision: "units.default.precision"
  }), i = o.get(me, "settings.schema", "settings.update");
  e.createService("settings", {
    service: Iy,
    propertyMapping: t,
    settingsSchema: i
  });
}
function _l(e) {
  setTimeout(() => {
    window.URL.revokeObjectURL(e.href);
  }, 1e4), e.remove();
}
function zr(e, t, i = {}) {
  const { mimeType: n, byteOrderMark: r, encoding: s } = typeof i == "string" ? { mimeType: i } : i, a = s !== void 0 ? new TextEncoder(s).encode([t]) : t, l = r !== void 0 ? [r, a] : [a], c = new Blob(l, { type: n || "application/octet-stream" }), u = document.createElement("a");
  u.href = window.URL.createObjectURL(c), u.setAttribute("download", e), typeof u.download > "u" && u.setAttribute("target", "_blank"), u.classList.add("hidden"), u.style.position = "fixed", document.body.appendChild(u);
  try {
    return u.click(), _l(u), !0;
  } catch (d) {
    return _l(u), d;
  }
}
async function zy(e) {
  return (await q.getService("account").verifyEmail({ email: e })).status === 200;
}
function Ny(e) {
  return q.getService("account").create({
    action: "resendVerifySignup",
    value: { email: e }
  });
}
function $u(e, t) {
  return q.getService("account").create({
    action: "verifySignupShort",
    value: { user: { email: t }, token: e }
  });
}
function jy(e) {
  return q.getService("account").create({
    action: "sendResetPwd",
    value: { email: e }
  });
}
function Vy(e, t, i) {
  return q.getService("account").create({
    action: "resetPwdShort",
    value: { user: { email: e }, token: t, password: i }
  });
}
function Uy(e, t, i) {
  return q.getService("account").create({
    action: "passwordChange",
    value: { user: { email: e }, oldPassword: t, password: i }
  });
}
function qy(e, t, i) {
  return q.getService("account").create({
    action: "identityChange",
    value: { user: { email: e }, changes: { email: t }, password: i }
  });
}
function Gy(e) {
  return $u(e);
}
const Ky = {
  id: {
    type: String,
    required: !0
  },
  label: {
    type: String,
    default: null
  },
  icon: {
    type: String,
    default: void 0
  },
  iconRight: {
    type: Boolean,
    default: !1
  },
  color: {
    type: String,
    default: "grey-9"
  },
  size: {
    type: String,
    default: "md"
  },
  flat: {
    type: Boolean,
    default: !0
  },
  outline: {
    type: Boolean,
    default: !1
  },
  badge: {
    type: Object,
    default: () => null
  },
  tooltip: {
    type: String,
    default: ""
  },
  disabled: {
    type: [Boolean, Function],
    default: !1
  },
  toggled: {
    type: Boolean,
    default: !1
  },
  toggle: {
    type: Object,
    default: () => {
    }
  },
  stack: {
    type: Boolean,
    default: !1
  },
  loading: {
    type: Boolean,
    default: !1
  },
  propagate: {
    type: Boolean,
    default: !0
  },
  context: {
    type: Object,
    default: () => null
  },
  handler: {
    type: Function,
    default: null
  },
  closePopup: {
    type: [Boolean, Number, String],
    default: !1
  },
  dialog: {
    type: Object,
    default: null
  },
  route: {
    type: Object,
    default: () => null
  },
  url: {
    type: String,
    default: null
  },
  renderer: {
    type: String,
    default: "button",
    validator: (e) => ["button", "form-button", "item", "fab", "fab-action", "tab"].includes(e)
  }
};
function Iu(e, t) {
  return q.getService(e, t);
}
async function Hy(e, t, i = {}, n = 50) {
  return e.find({ query: o.merge({}, i, { $limit: n, $select: t }) });
}
async function zu(e, t = "createdAt", i = {}) {
  const n = await e.find({ query: o.merge({}, i, { $sort: { [t]: 1 }, $limit: 1 }) });
  return o.get(n, "data[0]");
}
async function Nu(e, t = "createdAt", i = {}) {
  const n = await zu(e, t, i);
  return o.get(n, t);
}
async function ju(e, t = "createdAt", i = {}) {
  const n = await e.find({ query: o.merge({}, i, { $sort: { [t]: -1 }, $limit: 1 }) });
  return o.get(n, "data[0]");
}
async function Vu(e, t = "createdAt", i = {}) {
  const n = await ju(e, t, i);
  return o.get(n, t);
}
async function Wy(e, t, i = {}) {
  const n = o.merge({}, i, { $distinct: t }), r = await e.find({ query: n });
  return Array.isArray(r) ? r : [r];
}
async function Uu(e, t, i = !1, n = !1) {
  const r = {
    $text: {
      $search: t,
      $caseSensitive: i,
      $diacriticSensitive: n
    }
  };
  return e.find({ query: r });
}
async function Zy(e, t, i, n = !1, r = !1) {
  const s = await Uu(e, i, n, r);
  for (const a of s.data) {
    const l = o.get(a, t);
    if (l && o.size(i) === o.size(l)) {
      let c = i, u = l;
      if (r || (c = o.deburr(c), u = o.deburr(u)), n || (c = o.toUpper(c), u = o.toUpper(u)), c === u) return !0;
    }
  }
  return !1;
}
const Ll = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
}, Yi = {
  white: "#fff",
  dark: "#333",
  red: "#f44336",
  pink: "#e91e63",
  purple: "#9c27b0",
  "deep-purple": "#673ab7",
  indigo: "#3f51b5",
  blue: "#2196f3",
  "light-blue": "#03a9f4",
  cyan: "#00bcd4",
  teal: "#009688",
  green: "#4caf50",
  "light-green": "#8bc34a",
  lime: "#cddc39",
  yellow: "#ffeb3b",
  amber: "#ffc107",
  orange: "#ff9800",
  "deep-orange": "#ff5722",
  brown: "#795548",
  grey: "#9e9e9e",
  "blue-grey": "#607d8b"
};
function Ut(e, t) {
  return e ? e.startsWith("#") || e.startsWith("hsl") || e.startsWith("rgb") ? e : o.has(Ll, e) ? Ll[e] : Ft.getPaletteColor(e) : t;
}
function Nr(e) {
  return e.startsWith("#") ? e : Yi[e] || "#ffffff";
}
function Jy(e, t = !1) {
  if (Yi[e]) return e;
  const i = o.findKey(Yi, (n) => n === e);
  return i || t && qu(e) || "white";
}
function qu(e) {
  let t = Number.MAX_VALUE, i = null;
  for (const n in Yi) {
    const r = Pt.deltaE(e, Yi[n]);
    r < t && (t = r, i = n);
  }
  return i;
}
function Qy(e, t = "white", i = "black") {
  const n = Ut(e);
  return Ft.luminosity(n) < 0.5 ? t : i;
}
function Zn(e) {
  if (!e) {
    z.warn("[KDK] buildColorScale: 'options' argument must be defined");
    return;
  }
  let t = e.colors;
  t || (e.scale ? (z.warn("[KDK] buildColorScale: please update 'scale' property to 'colors'"), t = e.scale) : (z.warn("[KDK] buildColorScale: no colors defined, using default default colors 'Spectral'"), t = "Spectral"));
  let i = Pt.scale(t);
  return e.classes ? Array.isArray(e.classes) ? i = i.classes(e.classes) : e.domain ? i = i.domain(e.domain).classes(e.classes) : i = i.classes(e.classes) : e.domain && (i = i.domain(e.domain)), i;
}
function Yy(e) {
  return qt.basename(e);
}
function Gu(e) {
  return qt.extname(e);
}
function Xy(e) {
  return qt.basename(e, Gu(e));
}
function ev(e) {
  return qt.dirname(e);
}
const tv = {
  title: {
    type: String,
    default: ""
  },
  item: {
    type: Object,
    default: () => null
  },
  actions: {
    type: Array,
    default: () => null
  },
  actionsFilter: {
    type: [String, Array],
    default: () => null
  },
  hideSeparator: {
    type: Boolean,
    default: !1
  },
  hideHeader: {
    type: Boolean,
    default: !1
  },
  dense: {
    type: Boolean,
    default: !1
  }
};
function Ku(e, t, i) {
  return Math.min(Math.max(e, t), i);
}
function Hu(e, t = 0.5) {
  return 1 - Math.pow(1 - e, 1 / t);
}
function Wu(e, t = 0, i = 1) {
  return t + e * i;
}
function Zu(e, t = 0.42, i = 0, n = 0.58, r = 1) {
  return (1 - e) * (1 - e) * (1 - e) * i + 3 * (1 - e) * (1 - e) * e * t + 3 * (1 - e) * e * e * n + e * e * e * r;
}
const Hi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clamp: Ku,
  cubicBezier: Zu,
  easeOut: Hu,
  linear: Wu
}, Symbol.toStringTag, { value: "Module" }));
class xl extends _c {
  constructor(t, i) {
    super(t, "PermissionDeniedNotifications", 499, "permission-denied-notifications", i);
  }
}
class Sl extends _c {
  constructor(t, i) {
    super(t, "NotificationsNotSupported", 498, "notifications-not-supported", i);
  }
}
async function iv() {
  if (!("PushManager" in window)) throw new Sl("Push isn't supported on this browser");
  if (!("Notification" in window)) throw new Sl("This browser does not support notifications");
  return !0;
}
async function nv() {
  if (window.Notification.permission === "default")
    try {
      return await window.Notification.requestPermission();
    } catch {
      throw new xl("Denied permission to send notifications");
    }
  else if (window.Notification.permission === "denied") throw new xl("Denied permission to send notifications");
}
async function rv() {
  return await (await navigator.serviceWorker.ready).pushManager.getSubscription();
}
async function sv(e) {
  const i = await (await navigator.serviceWorker.getRegistration()).pushManager.subscribe({
    userVisibleOnly: !0,
    applicationServerKey: e
  });
  return JSON.parse(JSON.stringify(i));
}
async function ov(e, t, i) {
  return o.has(e, i) ? o.find(o.get(e, i), (n) => n.endpoint === t.endpoint) ? o.get(e, i) : o.get(e, i).push(t) : o.set(e, i, [t]);
}
async function av() {
  if (o.get(Vt.getData("application"), "mode") !== "PWA") {
    z.error("[KDK] Cannot subscribe to push notification: the application must run in PWA mode");
    return;
  }
  try {
    await iv(), await nv();
  } catch (a) {
    Xe.create({ type: "negative", message: Y.t(`errors.${a.code}`) });
    return;
  }
  const t = q.service("api/users"), i = fe.utc().toISOString(), n = await rv(), r = V.get("user");
  if (r || z.error("[KDK] User must be authenticated before calling 'subscribeToPushNotifications'"), n && o.find(o.get(r, "subscriptions", []), (a) => a.endpoint === n.endpoint)) {
    const a = o.map(r.subscriptions, (l) => (l.endpoint === n.endpoint && (l.lastActivity = i), l));
    t.patch(r._id, { subscriptions: a }), z.debug(`[KDK] New connection with subscription endpoint: ${n.endpoint}`);
    return;
  }
  const s = await sv(V.get("capabilities.api.vapidPublicKey"));
  s.fingerprint = Vt.fingerprint, s.browser = o.pick(Vt.getData("browser"), ["name", "version"]), s.system = o.pick(Vt.getData("system"), ["os"]), s.lastActivity = i, await ov(r, s, "subscriptions"), t.patch(r._id, { subscriptions: r.subscriptions }), z.debug(`[KDK] New webpush subscription registered with endpoint: ${s.endpoint}`);
}
let Rn = null;
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault(), Rn = e;
});
function Ju() {
  Oi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.INSTALL_MESSAGE"),
    cancel: {
      id: "ignore-button",
      label: Y.t("utils.pwa.IGNORE"),
      color: "primary",
      outline: !0
    },
    ok: {
      id: "install-button",
      label: Y.t("utils.pwa.INSTALL"),
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  }).onOk(async () => {
    Rn.prompt();
    const { outcome: e } = await Rn.userChoice;
    e === "accepted" && location.reload();
  });
}
function Qu() {
  Oi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.IOS_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  });
}
function Yu() {
  Oi.create({
    title: Y.t("utils.pwa.INSTALL_TITLE"),
    message: Y.t("utils.pwa.FIREFOX_DESKTOP_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: !0,
    position: "bottom",
    html: !0
  });
}
const bn = {};
function lv(e) {
  Object.assign(je, {
    request: e,
    exit: e,
    toggle: e
  });
}
function Xu() {
  return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null;
}
function ed() {
  const e = je.activeEl = je.isActive === !1 ? null : Xu();
  lp(
    e === null || e === document.documentElement ? document.body : e
  );
}
function cv() {
  je.isActive = je.isActive === !1, ed();
}
function Cl(e, t) {
  try {
    const i = e[t]();
    return i === void 0 ? Promise.resolve() : i;
  } catch (i) {
    return Promise.reject(i);
  }
}
const je = rn({
  isActive: !1,
  activeEl: null
}, {
  isCapable: !1,
  install({ $q: e }) {
    e.fullscreen = this;
  }
});
bn.request = [
  "requestFullscreen",
  "msRequestFullscreen",
  "mozRequestFullScreen",
  "webkitRequestFullscreen"
].find((e) => document.documentElement[e] !== void 0), je.isCapable = bn.request !== void 0, je.isCapable === !1 ? lv(() => Promise.reject("Not capable")) : (Object.assign(je, {
  request(e) {
    const t = e || document.documentElement, { activeEl: i } = je;
    return t === i ? Promise.resolve() : (i !== null && t.contains(i) === !0 ? je.exit() : Promise.resolve()).finally(() => Cl(t, bn.request));
  },
  exit() {
    return je.isActive === !0 ? Cl(document, bn.exit) : Promise.resolve();
  },
  toggle(e) {
    return je.isActive === !0 ? je.exit() : je.request(e);
  }
}), bn.exit = [
  "exitFullscreen",
  "msExitFullscreen",
  "mozCancelFullScreen",
  "webkitExitFullscreen"
].find((e) => document[e]), je.isActive = !!Xu(), je.isActive === !0 && ed(), [
  "onfullscreenchange",
  "onmsfullscreenchange",
  "onwebkitfullscreenchange"
].forEach((e) => {
  document[e] = cv;
}));
const td = _o(je, "isActive");
function zo(e) {
  if (o.isNumber(e))
    return e > 100 ? e : bt.width * e / 100;
  if (!o.isObject(e)) {
    z.warn(`[KDK] Invalid width parameter ${e}`);
    return;
  }
  let t = o.get(e, bt.name);
  if (!t) {
    z.warn(`[KDK] Cannot find width value for breakpoint ${bt.name}`);
    return;
  }
  if (!o.isNumber(t)) {
    z.warn(`[KDK] Invalid width value ${t} for breakpoint ${bt.name}`);
    return;
  }
  return zo(t);
}
function No(e) {
  if (o.isNumber(e))
    return e > 100 ? e : bt.height * e / 100;
  if (!o.isObject(e)) {
    z.warn(`[KDK] Invalid height parameter ${e}`);
    return;
  }
  let t = o.get(e, bt.name);
  if (!t) {
    z.warn(`[KDK] Cannot find height value for breakpoint ${bt.name}`);
    return;
  }
  if (!o.isNumber(t)) {
    z.warn(`[KDK] Invalid height value ${t} for breakpoint ${bt.name}`);
    return;
  }
  return No(t);
}
function uv(e) {
  if (o.isArray(e)) {
    if (e.length === 2) {
      z.warn(`[KDK] Invalid size parameter ${e}`);
      return;
    }
    return e;
  }
  if (!o.isObject(e)) {
    z.warn(`[KDK] Invalid size parameter ${e}`);
    return;
  }
  let t = o.get(e, bt.name);
  return [zo(t[0]), No(t[1])];
}
function dv() {
  return bt.width > bt.height ? "portrait" : "landscape";
}
async function id() {
  return new Promise((e, t) => {
    je.toggle().then(() => {
      e(!0);
    }).catch((i) => {
      z.warn(`[KDK] Cannot toggle fullscreen mode: ${i}`), t(!1);
    });
  });
}
async function nd(e) {
  screen.orientation && screen.orientation.lock && typeof screen.orientation.lock == "function" && await screen.orientation.lock(e);
}
function Ht(e, {
  context: t = null,
  created: i = null,
  updated: n = null,
  patched: r = null,
  removed: s = null,
  all: a = null
} = {}, l) {
  Rt(l), typeof e == "string" && (e = q.getService(e, t));
  const c = (u, d) => u ? (f) => u(f, d) : null;
  return e && ((i || a) && (i = c(i || a, "created"), e.on("created", i)), (n || a) && (n = c(n || a, "updated"), e.on("updated", n)), (r || a) && (r = c(r || a, "patched"), e.on("patched", r)), (s || a) && (s = c(s || a, "removed"), e.on("removed", s))), { service: e, created: i, updated: n, patched: r, removed: s };
}
function Rt(e) {
  if (!e) return;
  const { service: t, created: i, updated: n, patched: r, removed: s } = e;
  i && t.off("created", i), n && t.off("updated", n), r && t.off("patched", r), s && t.off("removed", s);
}
const fv = { width: 24, height: 24 }, Us = "black", hv = 12, mv = 12;
function gv(e) {
  return { width: e * 2, height: e * 2 };
}
const Xi = {
  circle: {
    viewBox: [0, 0, 100, 100],
    content: '<circle cx="50" cy="50" r="50" />'
  },
  rect: {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 0.9), height: Math.round(e * 2 * 0.9) })
  },
  "rounded-rect": {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" rx="20" ry="20" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 0.9), height: Math.round(e * 2 * 0.9) })
  },
  diamond: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 50, 50 100, 0 50" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.2), height: Math.round(e * 2 * 1.2) })
  },
  triangle: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 100, 0 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.125), height: Math.round(e * 2 * 1.025) })
  },
  "triangle-down": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 0, 50 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.125), height: Math.round(e * 2 * 1.025) })
  },
  "triangle-left": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 50, 100 0, 100 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.025), height: Math.round(e * 2 * 1.125) })
  },
  "triangle-right": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 50, 0 100" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.025), height: Math.round(e * 2 * 1.125) })
  },
  star: {
    viewBox: [0, 0, 48, 48],
    content: '<path d="m24,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z" />',
    radiusToSize: (e) => ({ width: Math.round(e * 2 * 1.4), height: Math.round(e * 2 * 1.4) })
  },
  "marker-pin": {
    viewBox: [0, 0, 384, 512],
    content: '<path d="M384 192c0 87.4-117 243-168.3 307.2c-12.3 15.3-35.1 15.3-47.4 0C117 435 0 279.4 0 192C0 86 86 0 192 0s192 86 192 192z" />',
    icon: {
      translation: ["-50%", "-70%"]
    },
    text: {
      translation: ["-50%", "-70%"]
    },
    anchor: "bottom-center"
  },
  "square-pin": {
    viewBox: [0, 0, 56, 56],
    content: '<path d="M 27.9532 52.3633 C 29.0079 52.3633 29.9923 51.9180 30.9298 50.3008 L 35.2657 43.0586 L 43.0938 43.0586 C 50.0783 43.0586 53.8280 39.1914 53.8280 32.3242 L 53.8280 14.3711 C 53.8280 7.5039 50.0783 3.6367 43.0938 3.6367 L 12.9064 3.6367 C 5.9454 3.6367 2.1720 7.4805 2.1720 14.3711 L 2.1720 32.3242 C 2.1720 39.2148 5.9454 43.0586 12.9064 43.0586 L 20.6407 43.0586 L 24.9766 50.3008 C 25.9142 51.9180 26.8985 52.3633 27.9532 52.3633 Z"/>',
    icon: {
      translation: ["-50%", "-75%"]
    },
    text: {
      translation: ["-50%", "-60%"]
    },
    anchor: "bottom-center"
  }
};
function pv(e, t, i) {
  return e.slice(0, -1) + ` ${t}="${i}">`;
}
function Lt(e, t, i) {
  return e.slice(0, -2) + ` ${t}="${i}" />`;
}
function El(e) {
  return Array.isArray(e) ? { width: o.toNumber(e[0]), height: o.toNumber(e[1]) } : { width: o.toNumber(e), height: o.toNumber(e) };
}
function rd(e) {
  if (!e) {
    z.warn("[KDK] 'options' argument is required");
    return;
  }
  let t = "middle-center", i;
  e.shape && e.shape !== "none" && (typeof e.shape == "object" ? i = e.shape : (i = Xi[e.shape], i || (z.warn(`[KDK] unknown shape '${e.shape}'. Using default shape 'circle'`), i = Xi.circle)), t = i.anchor || t);
  let n = fv;
  e.size ? n = El(e.size) : e.radius && (n = o.get(i, "radiusToSize", gv)(e.radius));
  const r = o.get(e, "extraStyle", ""), a = `<div ${o.get(e, "id") ? `id=${e.id}` : ""} style="position: relative; width: ${n.width}px; height: ${n.height}px; ${r}">`, l = "</div>";
  let c = "", u = "", d = "", f = "";
  if (i) {
    const x = i.extraStyle || "", w = i.translation || [0, 0], M = i.rotation || 0;
    c = `<svg xmlns="http://www.w3.org/2000/svg" width="${n.width}" height="${n.height}" preserveAspectRatio="none"
                   style="transform: translate(${w[0]},${w[1]}) rotate(${M}deg); ${x}">`, c = pv(c, "viewBox", o.join(i.viewBox, " ")), u = i.content, d = "", f = "</svg>";
    const p = e.color ? Ut(e.color) : "none";
    if (u = Lt(u, "fill", p), o.isNil(e.opacity) || (u = Lt(u, "fill-opacity", e.opacity)), e.stroke) {
      const y = Ut(e.stroke.color, Us);
      if (y !== "transparent") {
        u = Lt(u, "stroke", y);
        const S = e.stroke.width || 1;
        u = Lt(u, "stroke-width", S * 2), u = Lt(u, "vector-effect", "non-scaling-stroke"), e.stroke.cap && (u = Lt(u, "stroke-linecap", e.stroke.cap)), e.stroke.join && (u = Lt(u, "stroke-linejoin", e.stroke.join)), e.stroke.dashArray && (u = Lt(u, "stroke-dasharray", e.stroke.dashArray)), e.stroke.dashOffset && (u = Lt(u, "stroke-dashoffset", e.stroke.dashOffset)), o.has(e, "stroke.opacity") && (u = Lt(u, "stroke-opacity", e.stroke.opacity));
        const C = Gt();
        o.get(i, "clipPath", !0) && (u = Lt(u, "clip-path", `url(#${C})`), d = `<clipPath id="${C}">${o.clone(i.content)}</clipPath>`);
      }
    }
  }
  let h = "";
  if (e.icon)
    if (!o.isNil(e.icon.classes) || !o.isNil(e.icon.url)) {
      if (!o.isEmpty(e.icon.classes) || !o.isEmpty(e.icon.url)) {
        let x = "";
        if (e.icon.url) {
          let y = e.icon.size ? El(e.icon.size) : n;
          h = `<img src="${e.icon.url}" `, h += `width=${y.width} height=${y.height} `;
        } else {
          h += `<i class="${e.icon.classes}" `;
          const y = Ut(e.icon.color, Us);
          x += `color: ${y};`;
          let S = e.icon.size || hv;
          x += `font-size: ${S}px;`;
        }
        const w = e.icon.opacity || 1, M = e.icon.translation || o.get(i, "icon.translation", ["-50%", "-50%"]), p = e.icon.rotation || o.get(i, "icon.rotation", 0);
        h += `style="position: absolute; top: 50%; left: 50%; transform: translate(${M[0]},${M[1]}) rotate(${p}deg); opacity: ${w}; ${x}"`, h += "/>";
      }
    } else
      z.warn("[KDK] icon must contain either the 'classes' property or the 'url' property");
  let g = "";
  if (e.text) {
    if (o.isNil(e.text.label))
      z.warn("[KDK] text must contain the 'label' property");
    else if (!o.isEmpty(e.text.label)) {
      g = "<span ", e.text.classes && (g += `classes="${e.text.classes}" `);
      const x = Ut(e.text.color, Us), w = e.text.size || mv, M = e.text.translation || o.get(i, "text.translation", ["-50%", "-50%"]), p = e.text.rotation || o.get(i, "icon.rotation", 0), y = e.text.extraStyle || "";
      g += `style="position: absolute; 5px; top: 50%; left: 50%; transform: translate(${M[0]},${M[1]}) rotate(${p}deg); color: ${x}; font-size: ${w}px; ${y}"`, g += ">", g += e.text.label, g += "</span>";
    }
  }
  let v = "";
  return e.html && (v = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">', v += e.html, v += "</div>"), {
    html: a + c + d + u + f + h + g + v + l,
    size: n,
    anchor: t
  };
}
async function sd(e) {
  let t = V.get("user");
  t || (await Ce.setItem("authentication", e), t = e.user ? e.user : { name: Y.t("composables.ANONYMOUS"), anonymous: !0 }, V.set("user", t), await jo());
}
async function od(e, t) {
  const i = {
    strategy: "local",
    email: e,
    password: t
  }, n = await q.authenticate(i);
  await sd(n);
}
async function yv(e) {
  delete e.confirmPassword, await q.getService("users").create(e), await od(e.email, e.password);
}
async function vv() {
  try {
    await Ce.removeItem("authentication"), await q.logout(), V.set("user", null);
  } catch (e) {
    throw V.set("user", null), await q.authentication.removeAccessToken(), e;
  }
}
async function ad() {
  try {
    let e;
    q.isDisconnected && (e = await Ce.getItem("authentication"), e && (q.emit("login", e), q.emit("authenticated", e))), e || (e = await q.reAuthenticate()), await sd(e);
  } catch (e) {
    throw await q.authentication.removeAccessToken(), e;
  }
}
async function jo() {
  const e = V.get("user");
  if (!e) return;
  const t = await as(e, q), i = V.get("user.abilities"), n = o.get(t, "rules"), r = o.get(i, "rules");
  o.isEqual(n, r) || (V.set("user.abilities", t), Cc.debug("[KDK] New user abilities: ", t.rules));
}
async function Vo(e) {
  e._id === V.get("user._id") && (V.patch("user", e), await jo());
}
async function Uo(e) {
  await Ce.removeItem("authentication"), await q.authentication.removeAccessToken(), await q.authentication.reset(), V.set("user", null), q.emit("logout", e);
}
function ld() {
  const e = q.getService("users");
  e.on("patched", Vo), e.on("logout", Uo);
}
function bv() {
  const e = q.getService("users");
  e.off("patched", Vo), e.off("logout", Uo);
}
async function wv(e) {
  const t = q.getService("tags");
  if (!t)
    return z.warn("[KDK] Tags service not found"), [];
  const i = (await t.find({ service: e })).data;
  for (const n of i)
    n.label = n.name;
  return i;
}
function _v(e) {
  const t = fe().tz(e).format("Z");
  return `${e} (${t})`;
}
function Lv(e, t) {
  return t ? fe.tz(e, t) : fe(e).local();
}
function xv(e, t) {
  return pe.convertToLocal(e).format(t);
}
function Sv(e, t) {
  return pe.convertToLocal(e).format(t);
}
function Cv(e, t) {
  return pe.getFormatTimezone() ? fe.tz(e, t, pe.getFormatTimezone()) : fe(e, t);
}
function Ev(e, t) {
  return pe.getFormatTimezone() ? fe.tz(e, t, pe.getFormatTimezone()) : fe(e, t);
}
Xe.setDefaults({
  position: "bottom-left",
  timeout: 5e3,
  textColor: "white"
});
Re.setDefaults({
  spinnerColor: "primary",
  spinnerSize: 140,
  messageColor: "white",
  customClass: "full-width"
});
function ds(e) {
  let t = e;
  if (typeof e == "function" && (t = new Promise(e)), t.isResolved) return t;
  let i = !0, n = !1, r = !1;
  const s = t.then(
    (a) => (r = !0, i = !1, a),
    (a) => {
      throw n = !0, i = !1, a;
    }
  );
  return s.isFulfilled = () => r, s.isPending = () => i, s.isRejected = () => n, s;
}
function Tv(e) {
  return (e.toUpperCase().match(/\b\w/g) || []).join("");
}
function Pv(e) {
  return _m.validate(e);
}
function kv(e, t, i, n, r) {
  const s = document.createElement("img");
  s.onload = function() {
    const a = document.createElement("canvas"), l = a.getContext("2d");
    a.width = t, a.height = i, l.drawImage(this, 0, 0, t, i), r(a.toDataURL("image/jpeg", n));
  }, s.src = e;
}
function Mv(e) {
  const t = atob(e.split(",")[1]), i = e.split(",")[0].split(":")[1].split(";")[0], n = new ArrayBuffer(t.length), r = new Uint8Array(n);
  for (let s = 0; s < t.length; s++)
    r[s] = t.charCodeAt(s);
  return new Blob([n], { type: i });
}
const cd = function(e) {
  e = new Uint8Array(e);
  const t = 32768, i = [];
  for (let n = 0; n < e.length; n += t)
    i.push(String.fromCharCode.apply(null, e.subarray(n, n + t)));
  return btoa(i.join(""));
};
function ud(e, t, i) {
  const n = new Blob([e], { type: i });
  zr(t, n);
}
async function qo(e) {
  return new Promise((t, i) => {
    Oi.create(e).onOk((n) => t({ ok: !0, data: n })).onCancel(() => t({ cancel: !0 })).onDismiss(() => t({ dismiss: !0 }));
  });
}
function Go(e, t = "icon.name") {
  const i = typeof e == "object" ? o.get(e, t, "") : e;
  return typeof i == "object" ? "" : i.startsWith("fa-") ? `fas ${i}` : i;
}
function dd(e, t = "icon.name") {
  o.set(e, t, Go(e, t));
}
function Fv(e) {
  if (e.startsWith("kdk:") === !0)
    return { icon: "img:kdk/" + e.substring(4) };
}
function sn(e) {
  const t = {};
  function i(n, r) {
    o.forOwn(n, (s, a) => {
      const l = r ? r + "." + a : a;
      s && typeof s == "object" ? i(s, l) : t[l] = s;
    });
  }
  return i(e), t;
}
const Dv = /^[0-9a-fA-F]{24}$/;
function fd(e) {
  return e.length === 24 && Dv.test(e);
}
async function hd(e) {
  try {
    return (await import(`@schemas/${e}.json`)).default;
  } catch (t) {
    z.error(t);
  }
}
function Av(e) {
  try {
    return ns(Wh(() => import(`@components/${e}.vue`)));
  } catch (t) {
    z.error(t);
  }
}
const Ov = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CardSectionProps: tv,
  Colors: Yi,
  Fullscreen: td,
  get InstallPwaPrompt() {
    return Rn;
  },
  Shapes: Xi,
  actionProps: Ky,
  base64Encode: cd,
  bindContent: Wn,
  bindHandler: pu,
  bindParams: $r,
  bindProperties: Rr,
  buildColorScale: Zn,
  changeIdentity: Gy,
  changePassword: Uy,
  clamp: Ku,
  computeResponsiveHeight: No,
  computeResponsiveSize: uv,
  computeResponsiveWidth: zo,
  containsText: Zy,
  createQuerablePromise: ds,
  createShape: rd,
  createThumbnail: kv,
  cubicBezier: Zu,
  dataUriToBlob: Mv,
  dialog: qo,
  dotify: sn,
  downloadAsBlob: ud,
  easeOut: Hu,
  filterContent: Ki,
  findClosestColor: qu,
  fromQuasarDate: Cv,
  fromQuasarTime: Ev,
  generateHandler: _r,
  getBaseName: Xy,
  getBoundValue: Ro,
  getBrowserLocale: iu,
  getCollectionService: Iu,
  getColorFromPalette: Nr,
  getContrastColor: Qy,
  getDir: ev,
  getDistinctValues: Wy,
  getExtension: Gu,
  getFallbackLocale: nu,
  getFileName: Yy,
  getHtmlColor: Ut,
  getIconName: Go,
  getInitials: Tv,
  getLatestItem: ju,
  getLatestTime: Vu,
  getLocale: Bt,
  getOldestItem: zu,
  getOldestTime: Nu,
  getOrientation: dv,
  getPaletteFromColor: Jy,
  getTagsFilterOptions: wv,
  getTimezoneLabel: _v,
  installDefaultPrompt: Ju,
  installFFDesktopPrompt: Yu,
  installSafariPrompt: Qu,
  isEmailValid: Pv,
  isObjectID: fd,
  linear: Wu,
  listItems: Hy,
  listenToServiceEvents: Ht,
  loadComponent: Av,
  loadSchema: hd,
  lockOrientation: nd,
  login: od,
  logout: vv,
  logoutUser: Uo,
  mapIconFunction: Fv,
  processIcon: dd,
  register: yv,
  resendVerifySignup: Ny,
  resetPassword: Vy,
  restoreSession: ad,
  searchText: Uu,
  sendChangeIdentity: qy,
  sendResetPassword: jy,
  subscribeToPushNotifications: av,
  subscribeToUserChanges: ld,
  toLocalTimezone: Lv,
  toQuasarDate: xv,
  toQuasarTime: Sv,
  toggleFullscreen: id,
  unlistenToServiceEvents: Rt,
  unsubscribeToUserChanges: bv,
  updateAbilities: jo,
  updateUser: Vo,
  verifyEmail: zy,
  verifySignup: $u
}, Symbol.toStringTag, { value: "Module" })), Bv = {
  mounted(e, t) {
    e.__state = {
      dropCallback: o.get(t.value, "dropCallback"),
      acceptedTypes: o.get(t.value, "mimeTypes"),
      maxFiles: o.get(t.value, "maxFiles"),
      fontSize: o.get(t.value, "fontSize", "2rem"),
      enabled: o.get(t.value, "enabled", !0)
    }, e.style.position = "relative";
    const i = document.createElement("div");
    i.className = "drag-overlay", i.innerHTML = '<div class="drag-overlay-box" />', e.appendChild(i);
    const n = document.createElement("style");
    n.textContent = `
      .drag-overlay {
        display: none;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        justify-content: center;
        align-items: center;
        font-size: ${e.__state.fontSize};
        z-index: 9999;
        pointer-events: none;
      }
      .drag-overlay-box {
        display: flex;
        border: 3px dashed;
        width: 95%; height: 95%;
        border-radius: 5px;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }
    `, document.head.appendChild(n);
    const r = () => i.style.display = "flex", s = () => i.style.display = "none";
    let a = 0, l = !1;
    const c = (h) => {
      if (!e.__state.enabled) return;
      h.preventDefault();
      const g = h.dataTransfer.items;
      let v = [], x = [], w, M;
      if (e.__state.maxFiles && o.size(g) > e.__state.maxFiles)
        w = Ft.getPaletteColor("negative"), M = Y.tc("directives.MAX_FILES_REACHED", e.__state.maxFiles);
      else {
        for (const y of g)
          y.kind === "file" && o.includes(e.__state.acceptedTypes, y.type) ? x.push(y) : v.push(y);
        o.isEmpty(x) ? (w = Ft.getPaletteColor("negative"), M = Y.tc("directives.ALL_FILES_ARE_UNSUPPORTED", v.length)) : o.isEmpty(v) ? (w = Ft.getPaletteColor("positive"), M = Y.tc("directives.DROP_FILES", x.length)) : (w = Ft.getPaletteColor("warning"), M = Y.t("directives.SOME_FILES_ARE_UNSUPPORTED"));
      }
      l = o.size(x) > 0, i.style.background = "#0007";
      const p = i.querySelector(".drag-overlay-box");
      p.textContent = M, p.style.borderColor = w, p.style.color = "white", p.style.textShadow = "-2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black", p.style.padding = "20px;", a++, r();
    }, u = (h) => {
      h.preventDefault();
    }, d = (h) => {
      h.preventDefault(), a--, a === 0 && s();
    }, f = async (h) => {
      if (h.preventDefault(), a = 0, s(), !l) return;
      const g = Array.from(h.dataTransfer.files);
      if (e.__state.dropCallback && typeof e.__state.dropCallback == "function") {
        const v = Pi.filter(g);
        for (const x of v) {
          const w = await Pi.read(x);
          await e.__state.dropCallback(w);
        }
      } else z.warn("[KDK] Missing 'dropCallback' argument in 'v-drop-file' directive");
    };
    e.__handlers = { onDragEnter: c, onDragOver: u, onDragLeave: d, onDrop: f }, e.addEventListener("dragenter", c), e.addEventListener("dragover", u), e.addEventListener("dragleave", d), e.addEventListener("drop", f);
  },
  updated(e, t) {
    t.value !== t.oldValue && (e.__state = {
      dropCallback: o.get(t.value, "dropCallback"),
      acceptedTypes: o.get(t.value, "mimeTypes"),
      maxFiles: o.get(t.value, "maxFiles"),
      fontSize: o.get(t.value, "fontSize", "2rem"),
      enabled: o.get(t.value, "enabled", !0)
    });
  },
  beforeUnmount(e, t) {
    const { onDragEnter: i, onDragOver: n, onDragLeave: r, onDrop: s } = e.__handlers;
    e.removeEventListener("dragenter", i), e.removeEventListener("dragover", n), e.removeEventListener("dragleave", r), e.removeEventListener("drop", s), delete e.__handlers, delete e.__state;
  }
}, Rv = {
  mounted(e, t) {
    Vt.touch || (e.__vHoverEnter__ = t.value.enter || (() => {
    }), e.__vHoverOver__ = t.value.over || (() => {
    }), e.__vHoverLeave__ = t.value.leave || (() => {
    }), e.addEventListener("mouseenter", e.__vHoverEnter__), e.addEventListener("mouseover", e.__vHoverOver__), e.addEventListener("mouseleave", e.__vHoverLeave__));
  },
  beforeUnmount(e, t) {
    e.removeEventListener("mouseenter", e.__vHoverEnter__), e.removeEventListener("mouseover", e.__vHoverOver__), e.removeEventListener("mouseleave", e.__vHoverLeave__), delete e.__vHoverEnter__, delete e.__vHoverOver__, delete e.__vHoverLeave__;
  }
}, $v = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vDropFile: Bv,
  vHover: Rv
}, Symbol.toStringTag, { value: "Module" }));
function Ko(e, t = {}) {
  const i = t.matches || o.matches, { store: n, set: r, get: s, has: a } = Ot(`selections.${e}`);
  function l() {
    g() && p() && r("items", []);
  }
  function c() {
    return s("mode");
  }
  function u(T) {
    return r("mode", T);
  }
  function d() {
    return s("mode") === "single";
  }
  function f() {
    return s("mode") !== "single";
  }
  function h(T = !0) {
    return r("enabled", T);
  }
  function g() {
    return s("enabled");
  }
  function v() {
    return s("filter");
  }
  function x(T) {
    return r("filter", T);
  }
  function w(T) {
    if (!g()) return;
    const k = v();
    if (k && !k(T)) return;
    const I = s("items");
    o.find(I, i(T)) || r("items", I.concat([T]));
  }
  function M(T) {
    if (!g()) return;
    const k = s("items");
    o.remove(k, i(T)), r("items", o.clone(k));
  }
  function p() {
    return a("items") && s("items").length > 0;
  }
  function y() {
    return p();
  }
  function S() {
    return o.last(s("items"));
  }
  function C() {
    return s("items");
  }
  return a("items") || (r("items", []), r("mode", "single"), r("enabled", !0)), {
    selection: n,
    clearSelection: l,
    getSelectionMode: c,
    setSelectionMode: u,
    isSingleSelectionMode: d,
    isMultipleSelectionMode: f,
    setSelectionEnabled: h,
    isSelectionEnabled: g,
    getSelectionFilter: v,
    setSelectionFilter: x,
    selectItem: w,
    unselectItem: M,
    hasSelectedItem: p,
    hasSelectedItems: y,
    getSelectedItem: S,
    getSelectedItems: C
  };
}
const tt = Zh({
  activity: null,
  name: null,
  state: null,
  config: null
}), jr = xc(null), md = {};
function gd(e, t = {}) {
  o.defaults(t, { selection: !0 }), tt.name = e, tt.state = Ot(`store.${e}.state`, t.state).store, tt.config = Ot(`store.${e}.options`, me[e]).store;
  function i(r) {
    tt.activity !== r && (r ? (tt.activity = r, jr.value = r, z.debug("[KDK] Current activity set to", r)) : (tt.activity = null, jr.value = null, z.debug("[KDK] Current activity cleared")));
  }
  Ue(() => {
    tt.name = null, tt.state = null, tt.config = null, i(null);
  });
  const n = {
    CurrentActivityContext: tt,
    setCurrentActivity: i
  };
  return t.selection && Object.assign(n, {
    ...Ko(e)
  }), o.set(md, e, n), n;
}
function di(e = {}) {
  o.defaults(e, { selection: !0 });
  const t = {
    CurrentActivityContext: tt,
    CurrentActivity: jr,
    kActivity: Ei(jr),
    kActivityName: Ei(_o(tt, "name"))
  };
  return tt.name && Object.assign(t, o.get(md, tt.name)), t;
}
function Iv(e = {}) {
  const t = ue(0);
  Sc(() => s());
  function i() {
    const a = q.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!a)
      throw new Error("[KDK] Cannot retrieve target service " + e.service.value);
    return a;
  }
  function n() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function r() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  async function s() {
    const a = o.merge(n(), r(), { $limit: 0 });
    z.debug(`[KDK] Count service '${e.service.value}' with query`, a);
    const l = await i().find({ query: a });
    t.value = l.total;
  }
  return qn(async () => {
    const a = i();
    a.on("created", s), a.on("removed", s);
  }), Ue(() => {
    const a = i();
    a.off("created", s), a.off("removed", s);
  }), {
    counter: t
  };
}
function zv(e = {}) {
  const { CurrentActivityContext: t } = di(), i = t.state.tagsFilter, n = t.state.timeFilter, r = ue({});
  let s;
  const a = W(() => o.get(i, "selection", [])), l = W(() => !o.isEmpty(a.value)), c = W(() => o.cloneDeep(n)), u = W(() => {
    const w = o.get(n, "start"), M = o.get(n, "end");
    return w && M && w !== M;
  });
  Le(a, () => x(), { immediate: !0 }), Le(c, (w, M) => {
    M && M.start !== null && M.end !== null && x();
  }, { deep: !0 });
  function d() {
    return Iu(e.service.value, e.context ? e.context.value : null);
  }
  function f() {
    return o.get(e, "baseQuery.value", {});
  }
  function h() {
    return o.get(e, "timeField.value", "createdAt");
  }
  function g() {
    return o.get(e, "tagFields", []);
  }
  async function v() {
    const w = h(), M = await Nu(d(), w, f());
    M && o.set(n, "min", M);
    const p = await Vu(d(), w, f());
    p && o.set(n, "max", p);
    const y = g();
    let S = [];
    o.forEach(y, (C, T) => {
      const k = o.map(C, (I, A) => o.merge({ scope: T, name: A }, I));
      o.size(k) > 1 && (S = o.concat(S, k));
    }), o.set(i, "options", S);
  }
  function x() {
    const w = {};
    if (l.value) {
      const M = g();
      o.forEach(M, (p, y) => {
        const S = o.map(o.filter(a.value, { scope: y }), (C) => C.name);
        o.isEmpty(S) || o.merge(w, { [y]: { $in: S } });
      });
    }
    u.value && o.merge(w, {
      [h()]: {
        $gte: c.value.start,
        $lte: c.value.end
      }
    }), r.value = w;
  }
  return Qt(async () => {
    await v(), s = Ht(d(), {
      created: () => v(),
      updated: () => v(),
      patched: () => v(),
      removed: () => v()
    });
  }), Ue(() => {
    Rt(s);
  }), {
    filterQuery: r,
    hasTagsSelection: l,
    hasTimeSelection: u
  };
}
function Nv(e = {}) {
  const t = ue(null);
  let i;
  Sc(() => a());
  function n() {
    const l = q.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!l)
      throw new Error("[KDK] Cannot retrieve target service " + e.service.value);
    return l;
  }
  function r() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function s() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  async function a() {
    let l, c;
    const u = e.property ? e.property.value : "createdAt", d = { $sort: { [u]: 1 }, $limit: 1 };
    z.debug(`[KDK] Get min timestamp on service '${e.service.value}' with query`, d);
    const f = await n().find({ query: o.merge({}, r(), s(), d) });
    o.size(f.data) > 0 && (l = f.data[0]);
    const h = { $sort: { [u]: -1 }, $limit: 1 };
    z.debug(`[KDK] Get max timestamp on service '${e.service.value}' with query`, h);
    const g = await n().find({ query: o.merge({}, r(), s(), h) });
    o.size(g.data) > 0 && (c = g.data[0]), t.value = { start: o.get(l, u), end: o.get(c, u) };
  }
  return qn(() => {
    i = Ht(n(), { all: a });
  }), Ue(() => {
    Rt(i);
  }), {
    timeRange: t
  };
}
function jv(e) {
  o.defaults(e, {
    // This value can be overriden in activities if they want to manage pagination by themselves
    // nbItemsPerPage = 0 means that the client does not handle pagination and server defaults will be used
    nbItemsPerPage: ue(12),
    // This value indicate if items of each page replace or are appended to previous ones
    appendItems: ue(!1),
    // Only invoke refresh at most once per every refreshThrottle milliseconds
    refreshThrottle: ue(500),
    // Refresh strategy to be used
    listStrategy: ue("smart"),
    // Item processor to be used
    processor: ue()
  });
  const t = ue(null), i = ue(0), n = ue(1);
  let r = null, s;
  const a = W(() => e.nbItemsPerPage.value > 0 ? Math.ceil(i.value / e.nbItemsPerPage.value) : 1);
  function l() {
    const M = q.getService(e.service.value, e.contextId ? e.contextId.value : null);
    if (!M)
      throw new Error("Cannot retrieve target service " + e.service.value);
    return M;
  }
  function c() {
    return e.baseQuery ? e.baseQuery.value : {};
  }
  function u() {
    return e.filterQuery ? e.filterQuery.value : {};
  }
  function d() {
    return e.nbItemsPerPage.value > 0 ? {
      $limit: e.nbItemsPerPage.value,
      $skip: (n.value - 1) * e.nbItemsPerPage.value
    } : {};
  }
  function f(M) {
    typeof e.processor.value == "function" && (M = e.processor.value(M)), t.value = M;
  }
  function h(M) {
    g(), r = l().watch({ listStrategy: e.listStrategy.value }).find({ query: M }).subscribe((p) => {
      if (p.type === "FeatureCollection")
        f(p.features);
      else if (e.appendItems.value) {
        const y = o.unionBy(p.data, t.value, "_id"), S = o.get(c(), "$sort");
        f(S ? o.orderBy(
          y,
          // Sort function for each sort property
          o.map(o.keys(S), (C) => (T) => {
            const k = o.get(T, C);
            return typeof k == "string" ? k.toLowerCase() : k;
          }),
          // Sort order for each sort property
          o.map(o.values(S), (C) => C > 0 ? "asc" : "desc")
        ) : y);
      } else
        f(p.data);
      i.value = p.total;
    }, (p) => {
      z.error(p);
    });
  }
  function g() {
    r && (r.unsubscribe(), r = null);
  }
  const v = o.throttle(() => {
    const M = {
      $locale: Bt(),
      ...c(),
      ...u(),
      ...d()
    };
    h(M);
  }, e.refreshThrottle.value, { leading: !1 });
  function x() {
    o.isNil(t.value) || (e.appendItems.value && f([]), n.value = 1, v());
  }
  function w(M) {
    M = Array.isArray(M) ? M : [M], M = o.intersectionWith(t.value, M, (p, y) => p._id && y._id && p._id.toString() === y._id.toString()), M.length > 0 && x();
  }
  return Le(e.service, x), Le(e.listStrategy, x), Le(e.nbItemsPerPage, x), Le(e.appendItems, x), e.contextId && Le(e.contextId, x), e.baseQuery && Le(e.baseQuery, x), e.filterQuery && Le(e.filterQuery, x), qn(() => {
    e.appendItems.value && (s = Ht(l(), {
      patched: w,
      updated: w,
      removed: w
    }));
  }), Ue(() => {
    g(), e.appendItems.value && Rt(s);
  }), {
    items: t,
    nbTotalItems: i,
    currentPage: n,
    nbPages: a,
    setCollectionItems: f,
    subscribe: h,
    unsubscribe: g,
    getCollectionBaseQuery: c,
    getCollectionFilterQuery: u,
    getCollectionPaginationQuery: d,
    resetCollection: x,
    refreshCollection: v
  };
}
function Vv(e) {
  const t = xo(), i = e?.fallbackRoute || "home";
  let n;
  function r() {
    return ct.getService();
  }
  async function s(f) {
    let h = ct.get();
    if (h && c(), _.isString(f)) {
      const g = ct.getService();
      try {
        z.debug(`[KDK] Setting context to '${f}'`), h = await g.get(f);
      } catch (v) {
        z.debug(`[KDK] cannot get event with id ${f}: ${v}`), setTimeout(() => t.push({ name: i }), 2e3);
      }
    } else if (_.isObject(f))
      z.debug(`[KDK] Setting context to '${f._id}'`), h = f;
    else {
      z.error("[KDK] Setting context: invalid parameter", f);
      return;
    }
    ct.set(h), l();
  }
  function a() {
    ct.get() && c(), ct.set(null);
  }
  function l() {
    n = Ht(ct.getService(), {
      patched: u,
      removed: d
    });
  }
  function c() {
    Rt(n);
  }
  function u(f) {
    const h = ct.get();
    h._id === f._id && Object.assign(h, _.omit(f, ["_id"]));
  }
  function d(f) {
    ct.get()._id === f._id && Oi.create({
      title: Y.t("ALERT"),
      message: Y.t("composables.context.REMOVED_MESSAGE"),
      persistent: !0,
      position: "bottom",
      html: !0,
      backdropFilter: "blur(4px)",
      ok: {
        label: Y.t("OK"),
        flat: !0
      }
    }).onOk(async () => {
      t.push({ name: i });
    });
  }
  return {
    Context: Ei(ct.getRef("store")),
    getService: r,
    setContext: s,
    clearContext: a
  };
}
function fs() {
  return Lc(eu);
}
function Uv() {
  const e = fs(), t = So();
  function i(r) {
    if (r.ignore) {
      z.error(r);
      return;
    }
    const s = { type: "negative", message: r.message || r.error_message || r.error, html: !0 };
    r.retryHandler && (s.actions = [{
      label: this.$t("RETRY"),
      handler: r.retryHandler
    }], s.timeout = 2e4), e.notify(s);
  }
  function n(r) {
    r.query && (r.query.error_message || r.query.error) ? i(r.query) : r.params && r.params.token && r.params.token.startsWith("error=") && i({ message: r.params.token.split("=")[1] });
  }
  return Le(t, (r, s) => n(r)), Qt(() => {
    n(t), ne.on("error-hook", (r) => {
      o.get(r.error, "data.name") !== "TokenExpiredError" && ne.emit("error", r.error);
    }), ne.on("error", (r) => {
      const s = o.get(r, "data.translation");
      s ? (r.message = Y.tie("errors." + s.key, s.params), s.keys && s.keys.forEach((a) => {
        r.message += "<br/>" + Y.tie("errors." + a, s.params);
      })) : r.code && (r.message = Y.tie("errors." + r.code)), i(r);
    });
  }), {
    showError: i,
    showRouteError: n
  };
}
function qv() {
  function e(r, s) {
    _.has(r, "view") && ee.setView(r.view), _.has(r, "padding") && ee.setPadding(r.padding), _.has(r, "header") && ee.setHeader(r.header, s), _.has(r, "footer") && ee.setFooter(r.footer, s), _.has(r, "page") && ee.setPage(r.page, s), _.has(r, "stickies") && ee.setStickies(r.stickies, s), _.has(r, "fab") && ee.setFab(r.fab, s), ee.placements.forEach((a) => {
      _.has(r, `panes.${a}`) && ee.setPane(a, _.get(r, `panes.${a}`), s), _.has(r, `windows.${a}`) && ee.setWindow(a, _.get(r, `windows.${a}`), s);
    }), _.has(r, "leftPane") && ee.setPane("left", r.leftPane, s), _.has(r, "rightPane") && ee.setPane("right", r.rightPane, s), _.has(r, "topPane") && ee.setPane("top", r.topPane, s), _.has(r, "bottomPane") && ee.setPane("bottom", r.bottomPane, s), _.has(r, "mode") && ee.setMode(r.mode);
  }
  function t() {
    ee.clearFocus(), ee.clearView(), ee.clearPadding(), ee.clearHeader(), ee.clearFooter(), ee.clearPage(), ee.clearStickies(), ee.clearFab(), ee.placements.forEach((r) => {
      ee.clearPane(r), ee.clearWindow(r);
    }), ee.clearMode();
  }
  function i(r) {
    r && ee.setMode(r);
  }
  const n = {};
  return ee.placements.forEach((r) => {
    n[`set${_.upperFirst(r)}Pane`] = (s, a) => {
      ee.setPane(r, s, a);
    }, n[`set${_.upperFirst(r)}PaneMode`] = (s) => {
      ee.setPaneMode(r, s);
    }, n[`set${_.upperFirst(r)}PaneFilter`] = (s) => {
      ee.setPaneFilter(r, s);
    }, n[`set${_.upperFirst(r)}PaneVisible`] = (s) => {
      ee.setPaneVisible(r, s);
    }, n[`set${_.upperFirst(r)}PaneOpener`] = (s) => {
      ee.setPaneOpener(r, s);
    }, n[`clear${_.upperFirst(r)}Pane`] = () => {
      ee.clearPane(r);
    };
  }), {
    Layout: ee,
    configureLayout: e,
    clearLayout: t,
    setLayoutMode: i,
    ...n
  };
}
function Gv() {
  const e = q.getService("messages");
  async function t(i, n) {
    return e.create(i, { query: n });
  }
  return {
    createMessage: t
  };
}
function Kv(e = { updateTimeout: 5e3 }) {
  const t = fs(), i = "install";
  function n() {
    const s = me.buildMode !== "pwa", a = window.matchMedia("(display-mode: standalone)").matches, l = o.get(Vt, "within.iframe", !1);
    s || a || l || nt.get(i, !0) && (Rn && Ju(), t.platform.is.ios && Qu(), t.platform.is.firefox && t.platform.is.desktop && Yu());
  }
  function r(s) {
    s.waiting.addEventListener("statechange", (a) => {
      a.target.state === "activated" && window.location.reload();
    }), t.notify({
      message: Y.t("composables.pwa.UPDATE_MESSAGE"),
      type: "info",
      html: !0,
      timeout: e.updateTimeout,
      spinner: !0
    }), setTimeout(() => {
      s.waiting.postMessage({ type: "SKIP_WAITING" });
    }, e.updateTimeout);
  }
  return Qt(() => {
    ne.on("pwa-updated", r);
  }), Ue(() => {
    ne.off("pwa-updated", r);
  }), {
    installPwa: n
  };
}
let $n = [];
function Hv(e, t, i) {
  if (t.path.startsWith("/oauth/")) return !0;
  if (o.get(t, "meta.authenticated") && o.get(t, "meta.unauthenticated") || o.get(t, "meta.public"))
    return t.path === "/" ? "home" : !0;
  if (o.get(t, "meta.authenticated"))
    return e ? !0 : "login";
  if (o.get(t, "meta.unauthenticated"))
    return e ? "home" : t.path === "/" ? "login" : !0;
}
function Wv(e, t, i) {
  if (o.has(t, "meta.can")) {
    if (!e) return "login";
    let n = o.get(t, "meta.can");
    return n = n.map((r) => {
      if (typeof r == "string" && r.startsWith(":")) {
        const s = r.substring(1);
        return o.get(t, `query.${s}`, o.get(t, `params.${s}`));
      } else
        return r;
    }), q.can(...n, e) || o.get(t, "meta.redirect", "home");
  } else return !0;
}
function Zv(e, t, i) {
  const n = o.get(t, "matched", []), r = n[n.length - 1];
  return !(r.name === "not-found" || r.name === "index");
}
function In(e, t, i) {
  const n = V.get("user");
  for (const r of $n) {
    const s = r(n, e, t);
    if (typeof s == "string")
      return z.debug("[KDK] Navigation guard would redirect to route " + s), typeof i == "function" ? i({ name: s }) : s;
    if (!s)
      return z.debug("[KDK] Navigation aborted by guard"), typeof i == "function" ? i(!1) : !1;
  }
  return z.debug("[KDK] Navigation guards passed"), typeof i == "function" ? i() : !0;
}
In.registerGuard = function(e) {
  $n.includes(e) || $n.push(e);
};
In.unregisterGuard = function(e) {
  $n = $n.filter((t) => t !== e);
};
function Jv(e = {}) {
  const t = "disconnect-dialog", i = "reconnect-dialog", n = xo(), r = So(), s = fs(), a = ue(!1);
  let l = null, c = null, u = !1;
  const d = V.getRef("user");
  function f() {
    return "redirect";
  }
  async function h() {
    let w = In(r);
    if (typeof e.redirect == "function" && (w = await e.redirect(r, w, d.value)), typeof w == "string")
      if (w === "login")
        r.path !== "/" && nt.set(f(), o.pick(r, ["name", "query", "params"])), await n.push({ name: "login" });
      else {
        const M = nt.get(f());
        M ? (nt.clear(f()), await n.push(M)) : await n.push({ name: w });
      }
    else
      nt.clear(f()), typeof w == "object" ? await n.push(w) : w || await n.push({ name: d.value ? "home" : "login" });
    a.value || (n && n.beforeEach(In), a.value = !0);
  }
  function g() {
    if (c && (c.hide(), c = null), !l && !u) {
      if (Re.hide(), !nt.get(t, !0)) {
        l = !0;
        return;
      }
      l = s.dialog({
        title: Y.t("composables.session.ALERT"),
        message: Y.t("composables.session.DISCONNECT"),
        html: !0,
        persistent: !0,
        cancel: {
          id: "ignore-button",
          label: Y.t("composables.session.IGNORE"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "close-button",
          label: Y.t("CLOSE"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        l = null, u = !1;
      }).onCancel(() => {
        l = null, u = !0;
      });
    }
  }
  function v() {
    if (l && (typeof l.hide == "function" && l.hide(), l = null), u = !1, !c) {
      if (!nt.get(i, !0)) return;
      c = s.dialog({
        title: Y.t("composables.session.INFORMATION"),
        message: Y.t("composables.session.RECONNECT"),
        html: !0,
        cancel: {
          id: "ignore-button",
          label: Y.t("composables.session.IGNORE"),
          color: "primary",
          outline: !0
        },
        ok: {
          id: "update-button",
          label: Y.t("composables.session.RELOAD"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        window.location.reload();
      }).onCancel(() => {
        c = null;
      });
    }
  }
  function x() {
    s.dialog({
      title: Y.t("composables.session.ALERT"),
      message: Y.t("composables.session.REFUSED"),
      html: !0,
      ok: {
        label: Y.t("composables.session.RETRY"),
        flat: !0
      },
      position: "bottom"
    }).onOk(() => window.location.reload());
  }
  return Qt(async () => {
    q.socket && (q.socket.io.on("reconnect_error", g), q.socket.io.on("reconnect", v), q.socket.on("rate-limit", x)), ne.on("user-abilities-changed", h), q.on("logout", () => {
      n.push({ name: "logout" });
    });
    try {
      await ad();
    } catch {
      await h();
    }
  }), Ue(() => {
    q.socket && (q.socket.off("reconnect_error", g), q.socket.off("reconnect", v), q.socket.off("rate-limit", x)), ne.off("user-abilities-changed", h);
  }), {
    User: d,
    redirect: h,
    isInitialized: a,
    onReconnectError: g,
    onReconnect: v,
    onRateLimit: x
  };
}
const Tl = Bt();
function Qv() {
  const e = ue(null), t = ue(null);
  async function i(r, s) {
    if (typeof r == "string") {
      z.trace("[KDK] Loading schema ", r);
      const a = await import(`@schemas/${r}.json`);
      t.value = o.cloneDeep(a.default);
    } else
      z.trace("[KDK] setting schema ", r.$id), t.value = o.cloneDeep(r);
    if (s) {
      let a = s;
      typeof s == "string" && (a = o.split(s, ",")), z.trace("[KDK] Filtering schema with ", a), o.forOwn(t.value.properties, (l, c) => {
        a.includes(c) || delete t.value.properties[c];
      }), t.value.$id += a.join(), t.value.required = o.intersection(t.value.required, a);
    }
    z.trace("[KDK] Compiling schema ", t.value.$id), e.value = Po.register(t.value);
  }
  function n(r) {
    if (!e.value) {
      z.error("[KDK] schema 'validator' not instantiated");
      return;
    }
    const s = e.value(r);
    return s || Aa[Tl] && Aa[Tl](e.value.errors), { isValid: s, errors: e.value.errors };
  }
  return {
    schema: Ei(t),
    compile: i,
    validate: n
  };
}
ue(null);
function Yv(e = {}) {
  const t = fs(), i = o.get(e, "dense", "sm"), n = o.get(e, "wide", "sm"), r = W(() => t.screen.lt[i]), s = W(() => t.screen.gt[n]), a = W(() => t.screen.width >= t.screen.height ? "landscape" : "portrait");
  return {
    Screen: Ei(t.screen),
    dense: r,
    wide: s,
    orientation: a,
    Fullscreen: Ei(td),
    toggleFullscreen: id,
    lockOrientation: nd
  };
}
const wn = ue({
  client: {
    number: o.get(me, "version"),
    buildNumber: o.get(me, "buildNumber")
  },
  api: {
    number: void 0,
    buildNumber: void 0
  },
  flavor: o.get(me, "flavor")
});
let Pl = !1;
function Xv() {
  const e = W(() => {
    const i = wn.value.client;
    let n = i.number;
    return i.buildNumber && (n += ` (${i.buildNumber})`), n;
  }), t = W(() => {
    const i = wn.value.api;
    let n = i.number;
    return i.buildNumber && (n += ` (${i.buildNumber})`), n;
  });
  return Pl || (Pl = !0, wn.value.api.number = Dr.get("version"), wn.value.api.buildNumber = Dr.get("buildNumber")), {
    Version: Ei(wn),
    clientVersionName: e,
    apiVersionName: t
  };
}
const eb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActivity: gd,
  useCollection: jv,
  useCollectionCounter: Iv,
  useCollectionFilter: zv,
  useCollectionTimeRange: Nv,
  useContext: Vv,
  useCurrentActivity: di,
  useErrors: Uv,
  useLayout: qv,
  useMessages: Gv,
  usePwa: Kv,
  useSchema: Qv,
  useScreen: Yv,
  useSelection: Ko,
  useSession: Jv,
  useStore: Ot,
  useVersion: Xv
}, Symbol.toStringTag, { value: "Module" }));
function tb(e) {
  return {
    methods: {
      getAppName() {
        return me.appName;
      },
      configurePadding() {
        o.has(this.activityOptions, "padding") && ee.setPadding(o.get(this.activityOptions, "padding"));
      },
      clearPadding() {
        ee.setPadding(!0);
      },
      configureHeader() {
        o.has(this.activityOptions, "header") && ee.setHeader(o.get(this.activityOptions, "header"), this);
      },
      clearHeader() {
        ee.setHeader(null);
      },
      configureFooter() {
        o.has(this.activityOptions, "footer") && ee.setFooter(o.get(this.activityOptions, "footer"), this);
      },
      clearFooter() {
        ee.setFooter(null);
      },
      getTopPane() {
        return ee.getPane("top");
      },
      getTopPaneMode() {
        return ee.getPane("top").mode;
      },
      isTopPaneVisible() {
        return ee.getPane("top").visible;
      },
      setTopPane(t, i, n) {
        ee.setPane("top", { content: t, mode: i, filter: n }, this);
      },
      setTopPaneMode(t) {
        ee.setPaneMode("top", t);
      },
      setTopPaneVisible(t) {
        ee.setPaneVisible("top", t);
      },
      configureTopPane() {
        o.has(this.activityOptions, "topPane") && ee.setPane("top", o.get(this.activityOptions, "topPane"), this);
      },
      clearTopPane() {
        ee.setPane("top", null);
      },
      getLeftPane() {
        return ee.getPane("left");
      },
      getLeftPaneMode() {
        return ee.getPane("left").mode;
      },
      isLeftPaneVisible() {
        return ee.getPane("left").visible;
      },
      setLeftPane(t, i, n) {
        ee.setPane("left", { content: t, mode: i, filter: n }, this);
      },
      setLeftPaneMode(t) {
        ee.setPaneMode("left", t);
      },
      setLeftPaneVisible(t) {
        ee.setPaneVisible("left", t);
      },
      configureLeftPane() {
        o.has(this.activityOptions, "leftPane") && ee.setPane("left", o.get(this.activityOptions, "leftPane"), this);
      },
      clearLeftPane() {
        ee.setPane("left", null);
      },
      getBottomPane() {
        return ee.getPane("bottom");
      },
      getBottomPaneMode() {
        return ee.getPane("bottom").mode;
      },
      isBottomPaneVisible() {
        return ee.getPane("bottom").visible;
      },
      setBottomPane(t, i, n) {
        ee.setPane("bottom", { content: t, mode: i, filter: n }, this);
      },
      setBottomPaneMode(t) {
        ee.setPaneMode("bottom", t);
      },
      setBottomPaneVisible(t) {
        ee.setPaneMode("bottom", t);
      },
      configureBottomPane() {
        o.has(this.activityOptions, "bottomPane") && ee.setPane("bottom", o.get(this.activityOptions, "bottomPane"), this);
      },
      clearBottomPane() {
        ee.setPane("bottom", null);
      },
      getRightPane() {
        return ee.getPane("right");
      },
      getRightPaneMode() {
        return this.getRightPane().mode;
      },
      isRightPaneVisible() {
        return this.getRightPane().visible;
      },
      setRightPane(t, i, n) {
        ee.setPane("right", { content: t, mode: i, filter: n }, this);
      },
      setRightPaneMode(t) {
        ee.setPaneMode("right", t);
      },
      setRightPaneVisible(t) {
        ee.setPaneMode("right", t);
      },
      configureRightPane() {
        o.has(this.activityOptions, "rightPane") && ee.setPane("right", o.get(this.activityOptions, "rightPane"), this);
      },
      clearRightPane() {
        ee.setPane("right", null);
      },
      getPage() {
        return ee.getPage();
      },
      setPage(t, i, n, r) {
        ee.setPage({ content: t, mode: i, filter: n, sticky: r }, this);
      },
      setPageMode(t) {
        ee.setPageMode(t);
      },
      configurePage() {
        o.has(this.activityOptions, "page") && ee.setPage(o.get(this.activityOptions, "page"), this);
      },
      clearPage() {
        ee.setPage(null);
      },
      getStickies() {
        return ee.getPage();
      },
      setStickies(t, i, n, r) {
        ee.setStickies({ content: t, mode: i, filter: n, sticky: r }, this);
      },
      setStickiesMode(t) {
        ee.setStickiesMode(t);
      },
      configureStickies() {
        o.has(this.activityOptions, "stickies") && ee.setStickies(o.get(this.activityOptions, "stickies"), this);
      },
      clearStickies() {
        ee.clearStickies();
      },
      getFab() {
        return ee.getFab();
      },
      setFab(t, i, n) {
        ee.setFab({ content: t, mode: i, filter: n }, this);
      },
      configureFab() {
        o.has(this.activityOptions, "fab") && ee.setFab(o.get(this.activityOptions, "fab"), this);
      },
      clearFab() {
        ee.setFab(null);
      },
      configureWindows() {
        if (!o.has(this.activityOptions, "windows")) return;
        const t = o.get(this.activityOptions, "windows", null);
        o.forOwn(t, (i, n) => {
          ee.setWindow(n, i, this);
        });
      },
      clearWindows() {
        const t = o.get(this.activityOptions, "windows", null);
        o.forOwn(t, (i, n) => {
          ee.setWindow(n, null);
        });
      },
      openWindow(t) {
        ee.setWindowVisible(t, !0);
      },
      closeWindow(t) {
        ee.setWindowVisible(t, !1);
      },
      findWindow(t) {
        return ee.findWindow(t);
      },
      isWidgetWindowVisible(t) {
        const { window: i } = this.findWindow(t);
        return i && i.visible;
      },
      openWidget(t) {
        ee.openWidget(t);
      },
      closeWidget(t) {
        ee.closeWidget(t);
      },
      clearFocus() {
        ee.clearFocus();
      },
      clearMode() {
        ee.clearMode();
      },
      clearActivity() {
        this.clearPadding(), this.clearFocus(), this.clearHeader(), this.clearFooter(), this.clearTopPane(), this.clearBottomPane(), this.clearLeftPane(), this.clearRightPane(), this.clearPage(), this.clearStickies(), this.clearFab(), this.clearWindows(), this.clearMode();
      },
      configureActivity() {
        this.configurePadding(), this.configureHeader(), this.configureFooter(), this.configureTopPane(), this.configureLeftPane(), this.configureBottomPane(), this.configureRightPane(), this.configurePage(), this.configureStickies(), this.configureFab(), this.configureWindows();
      },
      goBack() {
        this.$router.back();
      },
      refresh() {
        window.location.reload();
      },
      launchTour(t) {
        if (!t) {
          let n = this.$route.name;
          o.has(this.$route, "params.page") && (n += "/" + o.get(this.$route, "params.page")), t = n;
        }
        V.patch("tours.current", { name: t });
      }
    },
    beforeCreate() {
      this.activityName = e || o.camelCase(this.$options.name), this.activityOptions = me[this.activityName];
    },
    mounted() {
      this.configureActivity(), ne.on("user-abilities-changed", this.configureActivity);
    },
    beforeUnmount() {
      ne.off("user-abilities-changed", this.configureActivity), this.clearActivity();
    }
  };
}
const ib = {
  emits: ["applied"],
  props: {
    baseObject: {
      type: Object,
      default: () => {
      }
    },
    baseQuery: {
      type: Object,
      default: () => {
      }
    },
    schemaName: {
      type: String,
      default: void 0
    },
    perspective: {
      type: String,
      default: ""
    },
    // Indicates if the stored object in-memory is only the perspective part (default)
    // or the full structure, ie { perspective: { xxx } }
    // Note: the full structure is always retrieved/sent from/to the service anyway but sometimes
    // it is easier to manipulate a full-object and edit a nested property seen as a perspective on the front side
    perspectiveAsObject: {
      type: Boolean,
      default: !0
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    editorTitle() {
      if (this.getSchema()) {
        const e = this.getSchema().title, t = o.get(this.getObject(), "name");
        return Y.tie(e, { name: t, interpolation: { escapeValue: !1 } });
      }
      return "";
    },
    editorMode() {
      return this.objectId ? "update" : "create";
    },
    applyButton() {
      return this.editorMode === "update" ? this.$t("UPDATE") : this.$t("CREATE");
    }
  },
  data() {
    return {
      isFormReady: !1,
      applyInProgress: !1
    };
  },
  methods: {
    getBaseObject() {
      const e = {}, t = this.getObject() || this.baseObject;
      return this.perspective !== "" ? (this.perspectiveAsObject ? Object.assign(e, o.get(t, this.perspective)) : o.set(e, this.perspective, o.get(t, this.perspective)), t._id && (e._id = t._id)) : Object.assign(e, t), e;
    },
    getBaseQuery() {
      const e = {};
      return Object.assign(e, this.baseQuery), this.editorMode === "update" && this.perspective && this.perspectiveAsObject && Object.assign(e, { $select: ["_id", this.perspective] }), e;
    },
    getSchemaName() {
      if (this.schemaName) return this.schemaName;
      let e = o.get(this.$route, "meta.schemaName");
      return e || (e = this.service + (this.objectId ? ".update" : ".create"), this.perspective && (e += "-" + this.perspective), e);
    },
    onFormReferenceCreated(e) {
      e && (this.form = e);
    },
    onFormReady() {
      this.isFormReady = !0, this.fillEditor();
    },
    fillEditor() {
      if (!this.isFormReady) throw new Error("Cannot fill the editor with a non-ready form");
      this.getObject() && (this.perspective !== "" ? this.form.fill(o.get(this.getObject(), this.perspective)) : this.form.fill(this.getObject()));
    },
    clearEditor() {
      if (!this.isFormReady) throw new Error("Cannot clear the editor with a non-ready form");
      this.form.clear();
    },
    resetEditor() {
      if (!this.isFormReady) throw new Error("Cannot reset the editor with a non-ready form");
      this.fillEditor();
    },
    async apply() {
      if (!this.getService()) throw new Error("Cannot apply the editor with undefined service");
      if (!this.form) throw new Error("Cannot apply the editor with a non-ready form");
      if (!this.form.validate().isValid) return;
      const e = this.getBaseObject();
      await this.form.apply(e);
      const t = async (n) => {
        await this.form.submitted(n), this.$emit("applied", n);
      }, i = this.getBaseQuery(e);
      this.applyInProgress = !0;
      try {
        if (this.editorMode === "update")
          if (this.perspective !== "") {
            const n = {};
            this.perspectiveAsObject ? o.set(n, this.perspective, o.omit(e, ["_id"])) : o.set(n, this.perspective, o.get(e, this.perspective));
            const r = await this.getService().patch(this.objectId, n, { query: i });
            e._id && (r._id = e._id), t(r);
          } else {
            const n = await this.getService().patch(this.objectId, e, { query: i });
            t(n);
          }
        else if (this.editorMode === "create") {
          const n = await this.getService().create(e, { query: i });
          t(n);
        } else
          z.warn("[KDK] Invalid editor mode");
      } catch (n) {
        return z.error(n), !1;
      }
      return this.applyInProgress = !1, !0;
    },
    async refresh() {
      this.form = null, await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]), this.isFormReady && this.fillEditor();
    }
  }
}, nb = {
  emits: [
    "item-selected",
    "item-toggled",
    "item-expanded"
  ],
  props: {
    service: {
      type: String,
      required: !0
    },
    item: {
      type: Object,
      required: !0
    },
    actions: {
      type: [Object, Array],
      default: () => null
    },
    filter: {
      type: Object,
      default: () => {
      }
    },
    handlerContext: {
      type: Object,
      default: () => null
    },
    options: {
      type: Object,
      default: function() {
        return {};
      }
    },
    bindActions: {
      type: Boolean,
      default: !0
    }
  },
  watch: {
    // Make configured actions reactive as item actions are built from
    item: function() {
      this.configureActions();
    },
    actions: function() {
      this.configureActions();
    }
  },
  data() {
    return {
      itemActions: null
    };
  },
  computed: {
    name() {
      return o.get(this.item, this.options.nameField || "name", "");
    },
    description() {
      return o.get(this.item, this.options.descriptionField || "description", "");
    },
    avatar() {
      return o.get(this.options, "avatar", !0);
    }
  },
  methods: {
    setActions(e) {
      this.itemActions = this.bindActions ? Wn(o.cloneDeep(e), this.handlerContext || this) : e;
    },
    clearActions() {
      this.itemActions = null;
    },
    filteredActions() {
      return this.actions ? Ki(this.actions, this.filter || {}) : [];
    },
    // This method should be overridden in items
    configureActions() {
      const e = this.filteredActions();
      e && e.length > 0 ? this.setActions(e) : this.clearActions();
    },
    onItemToggled(e) {
      this.$emit("item-toggled", this.item, e);
    },
    onItemSelected(e) {
      this.$emit("item-selected", this.item, e);
    },
    onItemExpanded(e) {
      this.$emit("item-expanded", this.item, e);
    },
    canViewItem() {
      return q.can("read", this.service, this.item);
    },
    viewItem() {
      const e = this.$route.fullPath + `/view/${this.item._id}`;
      this.$router.push(e);
    },
    canEditItem() {
      return q.can("update", this.service, this.item);
    },
    editItem(e = void 0, t = void 0) {
      const i = this.$route;
      let n = "edit/" + this.item._id;
      i.path.endsWith("/") || (n = `/${n}`), e && (t ? n += `/${t}` : n += `/${e}`), this.$router.push({
        path: i.path + n,
        params: i.params,
        query: i.query
      });
    },
    canRemoveItem() {
      return q.can("remove", this.service, this.item);
    },
    removeItem(e, t = "name") {
      if (e === "confirm" || e === "input") {
        const i = o.get(this.item, t), n = {
          type: "text",
          model: "",
          isValid: (r) => r === i
        };
        Oi.create({
          title: this.$t("mixins.baseItem.REMOVE_ITEM_TITLE", { name: i }),
          message: e === "input" ? this.$t("mixins.baseItem.REMOVE_ITEM_MESSAGE") : "",
          html: !0,
          prompt: e === "input" ? n : void 0,
          persistent: !0,
          ok: {
            label: this.$t("YES"),
            flat: !0
          },
          cancel: {
            label: this.$t("NO"),
            flat: !0
          }
        }).onOk(() => {
          q.getService(this.service).remove(this.item._id);
        });
      } else
        q.getService(this.service).remove(this.item._id);
    },
    exportItem() {
      const e = this.name, t = e + ".json";
      zr(t, JSON.stringify(this.item)) ? Xe.create({ type: "positive", message: this.$t("mixins.baseItem.ITEM_EXPORTED", { name: e, file: t }) }) : Xe.create({ type: "negative", message: this.$t("mixins.baseItme.CANNOT_EXPORT_ITEM") });
    }
  },
  created() {
    this.configureActions(), ne.on("user-abilities-changed", this.configureActions);
  },
  beforeUnmount() {
    ne.off("user-abilities-changed", this.configureActions);
  }
};
function rb(e) {
  const t = Object.assign({ noopener: !0 }, e), i = [];
  for (const n in t) {
    const r = t[n];
    r === !0 ? i.push(n) : (Tg(r) || typeof r == "string" && r !== "") && i.push(n + "=" + r);
  }
  return i.join(",");
}
function kl(e, t, i) {
  let n = window.open;
  if (Ti.is.cordova === !0) {
    if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0)
      n = cordova.InAppBrowser.open;
    else if (navigator !== void 0 && navigator.app !== void 0)
      return navigator.app.loadUrl(e, {
        openExternal: !0
      });
  }
  const r = n(e, "_blank", rb(i));
  if (r)
    return Ti.is.desktop && r.focus(), r;
}
const sb = (e, t, i) => {
  if (Ti.is.ios === !0 && window.SafariViewController !== void 0) {
    window.SafariViewController.isAvailable((n) => {
      n ? window.SafariViewController.show(
        { url: e },
        Zi,
        t
      ) : kl(e, t, i);
    });
    return;
  }
  return kl(e, t, i);
}, ob = {
  props: {
    values: {
      type: Object,
      default: () => null
    },
    properties: {
      type: Object,
      required: !0
    },
    required: {
      type: Boolean,
      default: !1
    },
    readOnly: {
      type: Boolean,
      default: !1
    },
    dense: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    label() {
      const e = o.get(this.properties, "description", "");
      return Y.tie(o.get(this.properties.field, "label", e));
    },
    hasHelper() {
      return !o.isEmpty(o.get(this.properties.field, "helper", {}));
    },
    helperLabel() {
      return o.get(this.properties.field.helper, "label", null);
    },
    helperIcon() {
      return o.get(this.properties.field.helper, "icon", void 0);
    },
    helperTooltip() {
      return o.get(this.properties.field.helper, "tooltip", "");
    },
    helperUrl() {
      return o.get(this.properties.field.helper, "url", null);
    },
    helperDialog() {
      return o.get(this.properties.field.helper, "dialog", null);
    },
    helperContext() {
      return o.get(this.properties.field.helper, "context", null);
    },
    hasError() {
      return !o.isEmpty(this.error);
    },
    errorLabel() {
      let e = o.get(this.properties.field, "errorLabel", "");
      return e || (e = this.error), Y.tie(e);
    },
    disabled() {
      return o.get(this.properties.field, "disabled", !1);
    }
  },
  data() {
    return {
      // The model to used for data binding with the field
      model: this.emptyModel(),
      // The error message
      error: ""
    };
  },
  watch: {
    values: function() {
      this.values ? this.updateValue(o.get(this.values, this.properties.name)) : this.clear();
    }
  },
  methods: {
    updateValue(e) {
      o.isNil(e) ? this.clear() : this.fill(e);
    },
    emptyModel() {
      return null;
    },
    isEmpty() {
      return o.isEqual(this.model, this.emptyModel());
    },
    value() {
      return this.model;
    },
    fill(e) {
      this.model = e, this.error = "";
    },
    clear() {
      this.fill(o.get(this.properties, "default", this.emptyModel()));
    },
    validate() {
      this.error = "";
    },
    invalidate(e) {
      this.error = e;
    },
    async onChanged() {
      const e = o.get(this.properties, "nullable", !1);
      o.isNil(this.model) && !e && this.clear(), await this.$nextTick(), this.$emit("field-changed", this.properties.name, this.model);
    },
    apply(e, t) {
      o.set(e, t, this.value());
    },
    submitted(e, t) {
    },
    onHelperDialogConfirmed(e) {
      e.url && sb(e.url);
    }
  },
  created() {
    this.values && this.updateValue(o.get(this.values, this.properties.name));
  }
}, ab = {
  props: {
    perspective: {
      type: String,
      default: ""
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    viewerTitle() {
      if (this.getSchema()) {
        const e = this.getSchema().title;
        return this.$t(e, { object: this.getObject() });
      }
      return "";
    }
  },
  methods: {
    getSchemaName() {
      let e = this.service + ".get";
      return this.perspective && (e += "-" + this.perspective), e;
    },
    async refresh() {
      await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]);
    }
  }
}, lb = {
  emits: ["opened", "closed"],
  props: {
    routerMode: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      isModalOpened: !1,
      isModalMaximized: !1
    };
  },
  methods: {
    openModal(e = !1) {
      this.isModalMaximized = e, this.isModalOpened = !0, this.$emit("opened");
    },
    closeModal() {
      this.isModalOpened = !1, this.routerMode && this.$router.push(this.previousRoute), this.$emit("closed");
    }
  },
  created() {
    this.routerMode && (this.previousRoute = this.$router.options.history.state.back, this.openModal());
  }
}, cb = {
  props: {
    objectId: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      object: null
    };
  },
  methods: {
    getObject() {
      return this.object;
    },
    getObjectId() {
      return this.object ? this.object._id : "";
    },
    loadObject() {
      if (!this.objectId)
        return this.object = null, Promise.resolve(null);
      const e = this.getObjectId() !== this.objectId;
      return (!this.objectPromise || e) && (this.objectPromise = ds((t, i) => {
        this.getService().get(this.objectId).then((n) => {
          this.object = n, t(n);
        }).catch((n) => {
          i(n);
        });
      })), this.objectPromise;
    }
  }
}, ub = {
  props: {
    schemaJson: {
      type: String,
      default: ""
    },
    schemaFunction: {
      type: Function,
      default: null
    },
    schemaProperties: {
      type: [String, Array],
      default: () => []
    }
  },
  data() {
    return {
      schema: null
    };
  },
  methods: {
    getSchema() {
      return this.schema;
    },
    getSchemaId() {
      return o.get(this.schema, "$id", "");
    },
    filterSchema() {
      const e = this.schema.properties;
      let t = typeof this.schemaProperties == "string" ? o.split(this.schemaProperties, ",") : this.schemaProperties;
      typeof t == "string" && (t = [t]), t.length > 0 && (Object.keys(e).forEach((i) => {
        t.includes(i) || delete e[i];
      }), this.schema.$id += t.join(), this.schema.required = o.intersection(this.schema.required, t));
    },
    async loadSchemaFromResource(e) {
      try {
        return this.schema = await hd(e), this.schema = o.cloneDeep(this.schema), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    async loadSchemaFromJson(e) {
      try {
        return this.schema = JSON.parse(e), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    async loadSchemaFromFunction(e) {
      try {
        return this.schema = await e(), this.filterSchema(), this.schema;
      } catch (t) {
        throw ne.emit("error", t), t;
      }
    },
    loadSchema(e) {
      const t = e && !this.getSchemaId().includes(e + ".json");
      return (!this.schemaPromise || t) && (this.schemaPromise = ds(this.schemaJson ? this.loadSchemaFromJson(this.schemaJson) : this.schemaFunction ? this.loadSchemaFromFunction(this.schemaFunction) : this.loadSchemaFromResource(e))), this.schemaPromise;
    }
  }
}, db = {
  props: {
    service: {
      type: String,
      default: ""
    }
  },
  methods: {
    getService() {
      const e = q.getService(this.service);
      if (!e)
        throw new Error("Cannot retrieve target service " + this.service);
      return e;
    }
  }
}, fb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  baseActivity: tb,
  baseEditor: ib,
  baseField: ob,
  baseItem: nb,
  baseModal: lb,
  baseViewer: ab,
  objectProxy: cb,
  schemaProxy: ub,
  service: db
}, Symbol.toStringTag, { value: "Module" })), hb = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`[KDK] reading JSON file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let a = s.result;
        try {
          a = JSON.parse(a);
        } catch (l) {
          z.debug(l), r(new Error(Y.t("errors.INVALID_JSON_FILE", { file: i }), { errors: l }));
        }
        n(a);
      }, s.onerror = (a) => {
        z.debug(a), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i }), { errors: a }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, mb = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`[KDK] reading CSV file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let a = s.result;
        const l = Object.assign({ skipEmptyLines: !0 }, t);
        if (a = Qh.parse(a, l), a.errors.length > 0) {
          z.debug(a.errors), r(new Error(Y.t("errors.INVALID_CSV_FILE", { file: i.name }), { errors: a.errors }));
          return;
        }
        n(a.data);
      }, s.onerror = (a) => {
        z.debug(a), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: a }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, gb = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`[KDK] reading Blob file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        const l = s.result;
        if (!l) {
          r(new Error(Y.t("errors.INVALID_BLOB_FILE", { file: i.name })));
          return;
        }
        n(l);
      }, s.onerror = (l) => {
        z.debug(l), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: l }));
      };
      const a = o.get(t, "type", "arrayBuffer");
      a === "dataUrl" ? s.readAsDataURL(i) : (a !== "arrayBuffer" && z.error(`[KDK] Undefined expected type ${a}. Read as Array buffer.`), s.readAsArrayBuffer(i));
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, pb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BLOBReader: gb,
  CSVReader: mb,
  JSONReader: hb
}, Symbol.toStringTag, { value: "Module" })), yb = {
  async query(e, t) {
    const i = [];
    Array.isArray(e) || (e = [e]);
    const n = o.map(e, (s) => {
      const a = q.getService(s.service, s.context), l = Object.assign({}, s.baseQuery);
      return l[s.field] = { $search: t }, a.find({ query: l });
    }), r = await Promise.all(n);
    for (let s = 0; s < r.length; s++) {
      const a = r[s], l = e[s];
      a.total > 0 && a.data.forEach((c) => {
        c.service = l.service, c.context = l.context, c.field = l.field;
        const u = Go(c);
        o.isEmpty(u) && o.has(l, "icon") && (c.icon = l.icon, dd(c)), i.push(c);
      });
    }
    return i;
  }
};
async function pd() {
  const e = this;
  z.debug("[KDK] Initializing Core module..."), V.set("kdk", { core: { initialized: !1 }, map: { initialized: !1 } }), nt.initialize(), Ce.initialize(), await Vt.initialize(), await Dr.initialize(), Wc.initialize(), gu.initialize(), Ic.initialize(), pe.initialize(), be.initialize(), ct.initialize(), e.configure(Ru), ee.initialize(), vu.initialize(), bu.initialize(), wu.initialize(), Au.initialize(o.get(me, "exporter")), Po.initialize(o.get(me, "schema")), ld(), o.forEach(o.get(me, "readers.core", []), (t) => {
    z.debug(`[KDK] Registering reader ${t.reader} for [${t.mimeTypes}] mime types`), Pi.register(t.mimeTypes, pb[t.reader]);
  }), V.set("kdk.core.initialized", !0), z.debug("[KDK] Core module initialized");
}
const cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Broadcaster: Wc,
  Capabilities: Dr,
  Context: ct,
  Document: wu,
  Events: ne,
  Exporter: Au,
  Filter: vu,
  Layout: ee,
  LocalCache: Ce,
  LocalStorage: nt,
  Platform: Vt,
  Reader: Pi,
  Schema: Po,
  Search: yb,
  Sorter: bu,
  Storage: gu,
  Store: V,
  TemplateContext: us,
  Theme: Ic,
  Time: pe,
  Units: be,
  addQueryParameter: Gc,
  get api() {
    return q;
  },
  authenticationGuard: Hv,
  beforeGuard: In,
  buildEncodedUrl: Kc,
  buildUrl: Gn,
  composables: eb,
  createClient: Do,
  default: pd,
  directives: $v,
  errors: jm,
  hooks: sg,
  i18n: Y,
  initializeApi: og,
  makeDiacriticPattern: eg,
  makeServiceSnapshot: qc,
  mixins: fb,
  permissions: Ym,
  permissionsGuard: Wv,
  publicRouteGuard: Zv,
  services: Ru,
  utils: Ov
}, Symbol.toStringTag, { value: "Module" }));
var We = 63710088e-1, yd = {
  centimeters: We * 100,
  centimetres: We * 100,
  degrees: We / 111325,
  feet: We * 3.28084,
  inches: We * 39.37,
  kilometers: We / 1e3,
  kilometres: We / 1e3,
  meters: We,
  metres: We,
  miles: We / 1609.344,
  millimeters: We * 1e3,
  millimetres: We * 1e3,
  nauticalmiles: We / 1852,
  radians: 1,
  yards: We * 1.0936
};
function Wt(e, t, i) {
  i === void 0 && (i = {});
  var n = { type: "Feature" };
  return (i.id === 0 || i.id) && (n.id = i.id), i.bbox && (n.bbox = i.bbox), n.properties = t || {}, n.geometry = e, n;
}
function dt(e, t, i) {
  if (i === void 0 && (i = {}), !e)
    throw new Error("coordinates is required");
  if (!Array.isArray(e))
    throw new Error("coordinates must be an Array");
  if (e.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Ml(e[0]) || !Ml(e[1]))
    throw new Error("coordinates must contain numbers");
  var n = {
    type: "Point",
    coordinates: e
  };
  return Wt(n, t, i);
}
function Ho(e, t, i) {
  i === void 0 && (i = {});
  for (var n = 0, r = e; n < r.length; n++) {
    var s = r[n];
    if (s.length < 4)
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var a = 0; a < s[s.length - 1].length; a++)
      if (s[s.length - 1][a] !== s[0][a])
        throw new Error("First and last Position are not equivalent.");
  }
  var l = {
    type: "Polygon",
    coordinates: e
  };
  return Wt(l, t, i);
}
function Wo(e, t, i) {
  if (i === void 0 && (i = {}), e.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var n = {
    type: "LineString",
    coordinates: e
  };
  return Wt(n, t, i);
}
function it(e, t) {
  t === void 0 && (t = {});
  var i = { type: "FeatureCollection" };
  return t.id && (i.id = t.id), t.bbox && (i.bbox = t.bbox), i.features = e, i;
}
function vb(e, t, i) {
  i === void 0 && (i = {});
  var n = {
    type: "MultiLineString",
    coordinates: e
  };
  return Wt(n, t, i);
}
function vd(e, t) {
  t === void 0 && (t = "kilometers");
  var i = yd[t];
  if (!i)
    throw new Error(t + " units is invalid");
  return e * i;
}
function bd(e, t) {
  t === void 0 && (t = "kilometers");
  var i = yd[t];
  if (!i)
    throw new Error(t + " units is invalid");
  return e / i;
}
function Vr(e) {
  var t = e % (2 * Math.PI);
  return t * 180 / Math.PI;
}
function Ze(e) {
  var t = e % 360;
  return t * Math.PI / 180;
}
function wd(e, t, i) {
  if (t === void 0 && (t = "kilometers"), i === void 0 && (i = "kilometers"), !(e >= 0))
    throw new Error("length must be a positive number");
  return vd(bd(e, t), i);
}
function Ml(e) {
  return !isNaN(e) && e !== null && !Array.isArray(e);
}
function Zo(e) {
  return !!e && e.constructor === Object;
}
function Zt(e, t, i) {
  if (e !== null)
    for (var n, r, s, a, l, c, u, d = 0, f = 0, h, g = e.type, v = g === "FeatureCollection", x = g === "Feature", w = v ? e.features.length : 1, M = 0; M < w; M++) {
      u = v ? e.features[M].geometry : x ? e.geometry : e, h = u ? u.type === "GeometryCollection" : !1, l = h ? u.geometries.length : 1;
      for (var p = 0; p < l; p++) {
        var y = 0, S = 0;
        if (a = h ? u.geometries[p] : u, a !== null) {
          c = a.coordinates;
          var C = a.type;
          switch (d = i && (C === "Polygon" || C === "MultiPolygon") ? 1 : 0, C) {
            case null:
              break;
            case "Point":
              if (t(
                c,
                f,
                M,
                y,
                S
              ) === !1)
                return !1;
              f++, y++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < c.length; n++) {
                if (t(
                  c[n],
                  f,
                  M,
                  y,
                  S
                ) === !1)
                  return !1;
                f++, C === "MultiPoint" && y++;
              }
              C === "LineString" && y++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < c.length; n++) {
                for (r = 0; r < c[n].length - d; r++) {
                  if (t(
                    c[n][r],
                    f,
                    M,
                    y,
                    S
                  ) === !1)
                    return !1;
                  f++;
                }
                C === "MultiLineString" && y++, C === "Polygon" && S++;
              }
              C === "Polygon" && y++;
              break;
            case "MultiPolygon":
              for (n = 0; n < c.length; n++) {
                for (S = 0, r = 0; r < c[n].length; r++) {
                  for (s = 0; s < c[n][r].length - d; s++) {
                    if (t(
                      c[n][r][s],
                      f,
                      M,
                      y,
                      S
                    ) === !1)
                      return !1;
                    f++;
                  }
                  S++;
                }
                y++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < a.geometries.length; n++)
                if (Zt(a.geometries[n], t, i) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function ki(e, t) {
  if (e.type === "Feature")
    t(e, 0);
  else if (e.type === "FeatureCollection")
    for (var i = 0; i < e.features.length && t(e.features[i], i) !== !1; i++)
      ;
}
function bb(e, t) {
  var i, n, r, s, a, l, c, u, d, f, h = 0, g = e.type === "FeatureCollection", v = e.type === "Feature", x = g ? e.features.length : 1;
  for (i = 0; i < x; i++) {
    for (l = g ? e.features[i].geometry : v ? e.geometry : e, u = g ? e.features[i].properties : v ? e.properties : {}, d = g ? e.features[i].bbox : v ? e.bbox : void 0, f = g ? e.features[i].id : v ? e.id : void 0, c = l ? l.type === "GeometryCollection" : !1, a = c ? l.geometries.length : 1, r = 0; r < a; r++) {
      if (s = c ? l.geometries[r] : l, s === null) {
        if (t(
          null,
          h,
          u,
          d,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            s,
            h,
            u,
            d,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (t(
              s.geometries[n],
              h,
              u,
              d,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    h++;
  }
}
function Mi(e, t) {
  bb(e, function(i, n, r, s, a) {
    var l = i === null ? null : i.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return t(
          Wt(i, r, { bbox: s, id: a }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var c;
    switch (l) {
      case "MultiPoint":
        c = "Point";
        break;
      case "MultiLineString":
        c = "LineString";
        break;
      case "MultiPolygon":
        c = "Polygon";
        break;
    }
    for (var u = 0; u < i.coordinates.length; u++) {
      var d = i.coordinates[u], f = {
        type: c,
        coordinates: d
      };
      if (t(Wt(f, r), n, u) === !1)
        return !1;
    }
  });
}
function _d(e, t) {
  Mi(e, function(i, n, r) {
    var s = 0;
    if (i.geometry) {
      var a = i.geometry.type;
      if (!(a === "Point" || a === "MultiPoint")) {
        var l, c = 0, u = 0, d = 0;
        if (Zt(
          i,
          function(f, h, g, v, x) {
            if (l === void 0 || n > c || v > u || x > d) {
              l = f, c = n, u = v, d = x, s = 0;
              return;
            }
            var w = Wo(
              [l, f],
              i.properties
            );
            if (t(
              w,
              n,
              r,
              x,
              s
            ) === !1)
              return !1;
            s++, l = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function wb(e, t, i) {
  var n = i, r = !1;
  return _d(
    e,
    function(s, a, l, c, u) {
      r === !1 && i === void 0 ? n = s : n = t(
        n,
        s,
        a,
        l,
        c,
        u
      ), r = !0;
    }
  ), n;
}
function xi(e, t) {
  t === void 0 && (t = {});
  var i = 0, n = 0, r = 0;
  return Zt(e, function(s) {
    i += s[0], n += s[1], r++;
  }, !0), dt([i / r, n / r], t.properties);
}
function rt(e) {
  if (!e)
    throw new Error("coord is required");
  if (!Array.isArray(e)) {
    if (e.type === "Feature" && e.geometry !== null && e.geometry.type === "Point")
      return e.geometry.coordinates;
    if (e.type === "Point")
      return e.coordinates;
  }
  if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1]))
    return e;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function ft(e) {
  if (Array.isArray(e))
    return e;
  if (e.type === "Feature") {
    if (e.geometry !== null)
      return e.geometry.coordinates;
  } else if (e.coordinates)
    return e.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function ri(e) {
  return e.type === "Feature" ? e.geometry : e;
}
function Si(e, t) {
  return e.type === "FeatureCollection" ? "FeatureCollection" : e.type === "GeometryCollection" ? "GeometryCollection" : e.type === "Feature" && e.geometry !== null ? e.geometry.type : e.type;
}
function _b(e, t, i, n) {
  n === void 0 && (n = {});
  var r = rt(e), s = Ze(r[0]), a = Ze(r[1]), l = Ze(i), c = bd(t, n.units), u = Math.asin(Math.sin(a) * Math.cos(c) + Math.cos(a) * Math.sin(c) * Math.cos(l)), d = s + Math.atan2(Math.sin(l) * Math.sin(c) * Math.cos(a), Math.cos(c) - Math.sin(a) * Math.sin(u)), f = Vr(d), h = Vr(u);
  return dt([f, h], n.properties);
}
function Lb(e, t, i) {
  i === void 0 && (i = {});
  for (var n = i.steps || 64, r = i.properties ? i.properties : !Array.isArray(e) && e.type === "Feature" && e.properties ? e.properties : {}, s = [], a = 0; a < n; a++)
    s.push(_b(e, t, a * -360 / n, i).geometry.coordinates);
  return s.push(s[0]), Ho([s], r);
}
function Ld(e, t) {
  t === void 0 && (t = {});
  var i = Number(e[0]), n = Number(e[1]), r = Number(e[2]), s = Number(e[3]);
  if (e.length === 6)
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  var a = [i, n], l = [i, s], c = [r, s], u = [r, n];
  return Ho([[a, u, c, l, a]], t.properties, { bbox: e, id: t.id });
}
function zn(e, t, i) {
  if (i === void 0 && (i = {}), !e)
    throw new Error("point is required");
  if (!t)
    throw new Error("polygon is required");
  var n = rt(e), r = ri(t), s = r.type, a = t.bbox, l = r.coordinates;
  if (a && xb(n, a) === !1)
    return !1;
  s === "Polygon" && (l = [l]);
  for (var c = !1, u = 0; u < l.length && !c; u++)
    if (Fl(n, l[u][0], i.ignoreBoundary)) {
      for (var d = !1, f = 1; f < l[u].length && !d; )
        Fl(n, l[u][f], !i.ignoreBoundary) && (d = !0), f++;
      d || (c = !0);
    }
  return c;
}
function Fl(e, t, i) {
  var n = !1;
  t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] && (t = t.slice(0, t.length - 1));
  for (var r = 0, s = t.length - 1; r < t.length; s = r++) {
    var a = t[r][0], l = t[r][1], c = t[s][0], u = t[s][1], d = e[1] * (a - c) + l * (c - e[0]) + u * (e[0] - a) === 0 && (a - e[0]) * (c - e[0]) <= 0 && (l - e[1]) * (u - e[1]) <= 0;
    if (d)
      return !i;
    var f = l > e[1] != u > e[1] && e[0] < (c - a) * (e[1] - l) / (u - l) + a;
    f && (n = !n);
  }
  return n;
}
function xb(e, t) {
  return t[0] <= e[0] && t[1] <= e[1] && t[2] >= e[0] && t[3] >= e[1];
}
function Dl(e) {
  if (!e)
    throw new Error("geojson is required");
  var t = [];
  return Mi(e, function(i) {
    Sb(i, t);
  }), it(t);
}
function Sb(e, t) {
  var i = [], n = e.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        i = ft(n);
        break;
      case "LineString":
        i = [ft(n)];
    }
    i.forEach(function(r) {
      var s = Cb(r, e.properties);
      s.forEach(function(a) {
        a.id = t.length, t.push(a);
      });
    });
  }
}
function Cb(e, t) {
  var i = [];
  return e.reduce(function(n, r) {
    var s = Wo([n, r], t);
    return s.bbox = Eb(n, r), i.push(s), r;
  }), i;
}
function Eb(e, t) {
  var i = e[0], n = e[1], r = t[0], s = t[1], a = i < r ? i : r, l = n < s ? n : s, c = i > r ? i : r, u = n > s ? n : s;
  return [a, l, c, u];
}
var Al = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tb(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Pb(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var i = function n() {
      var r = !1;
      try {
        r = this instanceof n;
      } catch {
      }
      return r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var r = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(i, n, r.get ? r : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), i;
}
var gr = { exports: {} }, Lr = { exports: {} }, kb = Lr.exports, Ol;
function Mb() {
  return Ol || (Ol = 1, function(e, t) {
    (function(i, n) {
      e.exports = n();
    })(kb, function() {
      function i(p, y, S, C, T) {
        (function k(I, A, P, D, F) {
          for (; D > P; ) {
            if (D - P > 600) {
              var O = D - P + 1, $ = A - P + 1, X = Math.log(O), te = 0.5 * Math.exp(2 * X / 3), H = 0.5 * Math.sqrt(X * te * (O - te) / O) * ($ - O / 2 < 0 ? -1 : 1), oe = Math.max(P, Math.floor(A - $ * te / O + H)), he = Math.min(D, Math.floor(A + (O - $) * te / O + H));
              k(I, A, oe, he, F);
            }
            var ce = I[A], de = P, R = D;
            for (n(I, P, A), F(I[D], ce) > 0 && n(I, P, D); de < R; ) {
              for (n(I, de, R), de++, R--; F(I[de], ce) < 0; ) de++;
              for (; F(I[R], ce) > 0; ) R--;
            }
            F(I[P], ce) === 0 ? n(I, P, R) : n(I, ++R, D), R <= A && (P = R + 1), A <= R && (D = R - 1);
          }
        })(p, y, S || 0, C || p.length - 1, T || r);
      }
      function n(p, y, S) {
        var C = p[y];
        p[y] = p[S], p[S] = C;
      }
      function r(p, y) {
        return p < y ? -1 : p > y ? 1 : 0;
      }
      var s = function(p) {
        p === void 0 && (p = 9), this._maxEntries = Math.max(4, p), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function a(p, y, S) {
        if (!S) return y.indexOf(p);
        for (var C = 0; C < y.length; C++) if (S(p, y[C])) return C;
        return -1;
      }
      function l(p, y) {
        c(p, 0, p.children.length, y, p);
      }
      function c(p, y, S, C, T) {
        T || (T = w(null)), T.minX = 1 / 0, T.minY = 1 / 0, T.maxX = -1 / 0, T.maxY = -1 / 0;
        for (var k = y; k < S; k++) {
          var I = p.children[k];
          u(T, p.leaf ? C(I) : I);
        }
        return T;
      }
      function u(p, y) {
        return p.minX = Math.min(p.minX, y.minX), p.minY = Math.min(p.minY, y.minY), p.maxX = Math.max(p.maxX, y.maxX), p.maxY = Math.max(p.maxY, y.maxY), p;
      }
      function d(p, y) {
        return p.minX - y.minX;
      }
      function f(p, y) {
        return p.minY - y.minY;
      }
      function h(p) {
        return (p.maxX - p.minX) * (p.maxY - p.minY);
      }
      function g(p) {
        return p.maxX - p.minX + (p.maxY - p.minY);
      }
      function v(p, y) {
        return p.minX <= y.minX && p.minY <= y.minY && y.maxX <= p.maxX && y.maxY <= p.maxY;
      }
      function x(p, y) {
        return y.minX <= p.maxX && y.minY <= p.maxY && y.maxX >= p.minX && y.maxY >= p.minY;
      }
      function w(p) {
        return { children: p, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function M(p, y, S, C, T) {
        for (var k = [y, S]; k.length; ) if (!((S = k.pop()) - (y = k.pop()) <= C)) {
          var I = y + Math.ceil((S - y) / C / 2) * C;
          i(p, I, y, S, T), k.push(y, I, I, S);
        }
      }
      return s.prototype.all = function() {
        return this._all(this.data, []);
      }, s.prototype.search = function(p) {
        var y = this.data, S = [];
        if (!x(p, y)) return S;
        for (var C = this.toBBox, T = []; y; ) {
          for (var k = 0; k < y.children.length; k++) {
            var I = y.children[k], A = y.leaf ? C(I) : I;
            x(p, A) && (y.leaf ? S.push(I) : v(p, A) ? this._all(I, S) : T.push(I));
          }
          y = T.pop();
        }
        return S;
      }, s.prototype.collides = function(p) {
        var y = this.data;
        if (!x(p, y)) return !1;
        for (var S = []; y; ) {
          for (var C = 0; C < y.children.length; C++) {
            var T = y.children[C], k = y.leaf ? this.toBBox(T) : T;
            if (x(p, k)) {
              if (y.leaf || v(p, k)) return !0;
              S.push(T);
            }
          }
          y = S.pop();
        }
        return !1;
      }, s.prototype.load = function(p) {
        if (!p || !p.length) return this;
        if (p.length < this._minEntries) {
          for (var y = 0; y < p.length; y++) this.insert(p[y]);
          return this;
        }
        var S = this._build(p.slice(), 0, p.length - 1, 0);
        if (this.data.children.length) if (this.data.height === S.height) this._splitRoot(this.data, S);
        else {
          if (this.data.height < S.height) {
            var C = this.data;
            this.data = S, S = C;
          }
          this._insert(S, this.data.height - S.height - 1, !0);
        }
        else this.data = S;
        return this;
      }, s.prototype.insert = function(p) {
        return p && this._insert(p, this.data.height - 1), this;
      }, s.prototype.clear = function() {
        return this.data = w([]), this;
      }, s.prototype.remove = function(p, y) {
        if (!p) return this;
        for (var S, C, T, k = this.data, I = this.toBBox(p), A = [], P = []; k || A.length; ) {
          if (k || (k = A.pop(), C = A[A.length - 1], S = P.pop(), T = !0), k.leaf) {
            var D = a(p, k.children, y);
            if (D !== -1) return k.children.splice(D, 1), A.push(k), this._condense(A), this;
          }
          T || k.leaf || !v(k, I) ? C ? (S++, k = C.children[S], T = !1) : k = null : (A.push(k), P.push(S), S = 0, C = k, k = k.children[0]);
        }
        return this;
      }, s.prototype.toBBox = function(p) {
        return p;
      }, s.prototype.compareMinX = function(p, y) {
        return p.minX - y.minX;
      }, s.prototype.compareMinY = function(p, y) {
        return p.minY - y.minY;
      }, s.prototype.toJSON = function() {
        return this.data;
      }, s.prototype.fromJSON = function(p) {
        return this.data = p, this;
      }, s.prototype._all = function(p, y) {
        for (var S = []; p; ) p.leaf ? y.push.apply(y, p.children) : S.push.apply(S, p.children), p = S.pop();
        return y;
      }, s.prototype._build = function(p, y, S, C) {
        var T, k = S - y + 1, I = this._maxEntries;
        if (k <= I) return l(T = w(p.slice(y, S + 1)), this.toBBox), T;
        C || (C = Math.ceil(Math.log(k) / Math.log(I)), I = Math.ceil(k / Math.pow(I, C - 1))), (T = w([])).leaf = !1, T.height = C;
        var A = Math.ceil(k / I), P = A * Math.ceil(Math.sqrt(I));
        M(p, y, S, P, this.compareMinX);
        for (var D = y; D <= S; D += P) {
          var F = Math.min(D + P - 1, S);
          M(p, D, F, A, this.compareMinY);
          for (var O = D; O <= F; O += A) {
            var $ = Math.min(O + A - 1, F);
            T.children.push(this._build(p, O, $, C - 1));
          }
        }
        return l(T, this.toBBox), T;
      }, s.prototype._chooseSubtree = function(p, y, S, C) {
        for (; C.push(y), !y.leaf && C.length - 1 !== S; ) {
          for (var T = 1 / 0, k = 1 / 0, I = void 0, A = 0; A < y.children.length; A++) {
            var P = y.children[A], D = h(P), F = (O = p, $ = P, (Math.max($.maxX, O.maxX) - Math.min($.minX, O.minX)) * (Math.max($.maxY, O.maxY) - Math.min($.minY, O.minY)) - D);
            F < k ? (k = F, T = D < T ? D : T, I = P) : F === k && D < T && (T = D, I = P);
          }
          y = I || y.children[0];
        }
        var O, $;
        return y;
      }, s.prototype._insert = function(p, y, S) {
        var C = S ? p : this.toBBox(p), T = [], k = this._chooseSubtree(C, this.data, y, T);
        for (k.children.push(p), u(k, C); y >= 0 && T[y].children.length > this._maxEntries; ) this._split(T, y), y--;
        this._adjustParentBBoxes(C, T, y);
      }, s.prototype._split = function(p, y) {
        var S = p[y], C = S.children.length, T = this._minEntries;
        this._chooseSplitAxis(S, T, C);
        var k = this._chooseSplitIndex(S, T, C), I = w(S.children.splice(k, S.children.length - k));
        I.height = S.height, I.leaf = S.leaf, l(S, this.toBBox), l(I, this.toBBox), y ? p[y - 1].children.push(I) : this._splitRoot(S, I);
      }, s.prototype._splitRoot = function(p, y) {
        this.data = w([p, y]), this.data.height = p.height + 1, this.data.leaf = !1, l(this.data, this.toBBox);
      }, s.prototype._chooseSplitIndex = function(p, y, S) {
        for (var C, T, k, I, A, P, D, F = 1 / 0, O = 1 / 0, $ = y; $ <= S - y; $++) {
          var X = c(p, 0, $, this.toBBox), te = c(p, $, S, this.toBBox), H = (T = X, k = te, I = void 0, A = void 0, P = void 0, D = void 0, I = Math.max(T.minX, k.minX), A = Math.max(T.minY, k.minY), P = Math.min(T.maxX, k.maxX), D = Math.min(T.maxY, k.maxY), Math.max(0, P - I) * Math.max(0, D - A)), oe = h(X) + h(te);
          H < F ? (F = H, C = $, O = oe < O ? oe : O) : H === F && oe < O && (O = oe, C = $);
        }
        return C || S - y;
      }, s.prototype._chooseSplitAxis = function(p, y, S) {
        var C = p.leaf ? this.compareMinX : d, T = p.leaf ? this.compareMinY : f;
        this._allDistMargin(p, y, S, C) < this._allDistMargin(p, y, S, T) && p.children.sort(C);
      }, s.prototype._allDistMargin = function(p, y, S, C) {
        p.children.sort(C);
        for (var T = this.toBBox, k = c(p, 0, y, T), I = c(p, S - y, S, T), A = g(k) + g(I), P = y; P < S - y; P++) {
          var D = p.children[P];
          u(k, p.leaf ? T(D) : D), A += g(k);
        }
        for (var F = S - y - 1; F >= y; F--) {
          var O = p.children[F];
          u(I, p.leaf ? T(O) : O), A += g(I);
        }
        return A;
      }, s.prototype._adjustParentBBoxes = function(p, y, S) {
        for (var C = S; C >= 0; C--) u(y[C], p);
      }, s.prototype._condense = function(p) {
        for (var y = p.length - 1, S = void 0; y >= 0; y--) p[y].children.length === 0 ? y > 0 ? (S = p[y - 1].children).splice(S.indexOf(p[y]), 1) : this.clear() : l(p[y], this.toBBox);
      }, s;
    });
  }(Lr)), Lr.exports;
}
var qs = {}, Bl;
function xd() {
  return Bl || (Bl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.earthRadius = 63710088e-1, e.factors = {
      centimeters: e.earthRadius * 100,
      centimetres: e.earthRadius * 100,
      degrees: e.earthRadius / 111325,
      feet: e.earthRadius * 3.28084,
      inches: e.earthRadius * 39.37,
      kilometers: e.earthRadius / 1e3,
      kilometres: e.earthRadius / 1e3,
      meters: e.earthRadius,
      metres: e.earthRadius,
      miles: e.earthRadius / 1609.344,
      millimeters: e.earthRadius * 1e3,
      millimetres: e.earthRadius * 1e3,
      nauticalmiles: e.earthRadius / 1852,
      radians: 1,
      yards: e.earthRadius * 1.0936
    }, e.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / e.earthRadius,
      yards: 1.0936133
    }, e.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function t(D, F, O) {
      O === void 0 && (O = {});
      var $ = { type: "Feature" };
      return (O.id === 0 || O.id) && ($.id = O.id), O.bbox && ($.bbox = O.bbox), $.properties = F || {}, $.geometry = D, $;
    }
    e.feature = t;
    function i(D, F, O) {
      switch (D) {
        case "Point":
          return n(F).geometry;
        case "LineString":
          return l(F).geometry;
        case "Polygon":
          return s(F).geometry;
        case "MultiPoint":
          return f(F).geometry;
        case "MultiLineString":
          return d(F).geometry;
        case "MultiPolygon":
          return h(F).geometry;
        default:
          throw new Error(D + " is invalid");
      }
    }
    e.geometry = i;
    function n(D, F, O) {
      if (O === void 0 && (O = {}), !D)
        throw new Error("coordinates is required");
      if (!Array.isArray(D))
        throw new Error("coordinates must be an Array");
      if (D.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
      if (!k(D[0]) || !k(D[1]))
        throw new Error("coordinates must contain numbers");
      var $ = {
        type: "Point",
        coordinates: D
      };
      return t($, F, O);
    }
    e.point = n;
    function r(D, F, O) {
      return O === void 0 && (O = {}), u(D.map(function($) {
        return n($, F);
      }), O);
    }
    e.points = r;
    function s(D, F, O) {
      O === void 0 && (O = {});
      for (var $ = 0, X = D; $ < X.length; $++) {
        var te = X[$];
        if (te.length < 4)
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        for (var H = 0; H < te[te.length - 1].length; H++)
          if (te[te.length - 1][H] !== te[0][H])
            throw new Error("First and last Position are not equivalent.");
      }
      var oe = {
        type: "Polygon",
        coordinates: D
      };
      return t(oe, F, O);
    }
    e.polygon = s;
    function a(D, F, O) {
      return O === void 0 && (O = {}), u(D.map(function($) {
        return s($, F);
      }), O);
    }
    e.polygons = a;
    function l(D, F, O) {
      if (O === void 0 && (O = {}), D.length < 2)
        throw new Error("coordinates must be an array of two or more positions");
      var $ = {
        type: "LineString",
        coordinates: D
      };
      return t($, F, O);
    }
    e.lineString = l;
    function c(D, F, O) {
      return O === void 0 && (O = {}), u(D.map(function($) {
        return l($, F);
      }), O);
    }
    e.lineStrings = c;
    function u(D, F) {
      F === void 0 && (F = {});
      var O = { type: "FeatureCollection" };
      return F.id && (O.id = F.id), F.bbox && (O.bbox = F.bbox), O.features = D, O;
    }
    e.featureCollection = u;
    function d(D, F, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiLineString",
        coordinates: D
      };
      return t($, F, O);
    }
    e.multiLineString = d;
    function f(D, F, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiPoint",
        coordinates: D
      };
      return t($, F, O);
    }
    e.multiPoint = f;
    function h(D, F, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "MultiPolygon",
        coordinates: D
      };
      return t($, F, O);
    }
    e.multiPolygon = h;
    function g(D, F, O) {
      O === void 0 && (O = {});
      var $ = {
        type: "GeometryCollection",
        geometries: D
      };
      return t($, F, O);
    }
    e.geometryCollection = g;
    function v(D, F) {
      if (F === void 0 && (F = 0), F && !(F >= 0))
        throw new Error("precision must be a positive number");
      var O = Math.pow(10, F || 0);
      return Math.round(D * O) / O;
    }
    e.round = v;
    function x(D, F) {
      F === void 0 && (F = "kilometers");
      var O = e.factors[F];
      if (!O)
        throw new Error(F + " units is invalid");
      return D * O;
    }
    e.radiansToLength = x;
    function w(D, F) {
      F === void 0 && (F = "kilometers");
      var O = e.factors[F];
      if (!O)
        throw new Error(F + " units is invalid");
      return D / O;
    }
    e.lengthToRadians = w;
    function M(D, F) {
      return y(w(D, F));
    }
    e.lengthToDegrees = M;
    function p(D) {
      var F = D % 360;
      return F < 0 && (F += 360), F;
    }
    e.bearingToAzimuth = p;
    function y(D) {
      var F = D % (2 * Math.PI);
      return F * 180 / Math.PI;
    }
    e.radiansToDegrees = y;
    function S(D) {
      var F = D % 360;
      return F * Math.PI / 180;
    }
    e.degreesToRadians = S;
    function C(D, F, O) {
      if (F === void 0 && (F = "kilometers"), O === void 0 && (O = "kilometers"), !(D >= 0))
        throw new Error("length must be a positive number");
      return x(w(D, F), O);
    }
    e.convertLength = C;
    function T(D, F, O) {
      if (F === void 0 && (F = "meters"), O === void 0 && (O = "kilometers"), !(D >= 0))
        throw new Error("area must be a positive number");
      var $ = e.areaFactors[F];
      if (!$)
        throw new Error("invalid original units");
      var X = e.areaFactors[O];
      if (!X)
        throw new Error("invalid final units");
      return D / $ * X;
    }
    e.convertArea = T;
    function k(D) {
      return !isNaN(D) && D !== null && !Array.isArray(D);
    }
    e.isNumber = k;
    function I(D) {
      return !!D && D.constructor === Object;
    }
    e.isObject = I;
    function A(D) {
      if (!D)
        throw new Error("bbox is required");
      if (!Array.isArray(D))
        throw new Error("bbox must be an Array");
      if (D.length !== 4 && D.length !== 6)
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      D.forEach(function(F) {
        if (!k(F))
          throw new Error("bbox must only contain numbers");
      });
    }
    e.validateBBox = A;
    function P(D) {
      if (!D)
        throw new Error("id is required");
      if (["string", "number"].indexOf(typeof D) === -1)
        throw new Error("id must be a number or a string");
    }
    e.validateId = P;
  }(qs)), qs;
}
var Be = {}, Rl;
function Fb() {
  if (Rl) return Be;
  Rl = 1, Object.defineProperty(Be, "__esModule", { value: !0 });
  var e = /* @__PURE__ */ xd();
  function t(p, y, S) {
    if (p !== null)
      for (var C, T, k, I, A, P, D, F = 0, O = 0, $, X = p.type, te = X === "FeatureCollection", H = X === "Feature", oe = te ? p.features.length : 1, he = 0; he < oe; he++) {
        D = te ? p.features[he].geometry : H ? p.geometry : p, $ = D ? D.type === "GeometryCollection" : !1, A = $ ? D.geometries.length : 1;
        for (var ce = 0; ce < A; ce++) {
          var de = 0, R = 0;
          if (I = $ ? D.geometries[ce] : D, I !== null) {
            P = I.coordinates;
            var Q = I.type;
            switch (F = S && (Q === "Polygon" || Q === "MultiPolygon") ? 1 : 0, Q) {
              case null:
                break;
              case "Point":
                if (y(
                  P,
                  O,
                  he,
                  de,
                  R
                ) === !1)
                  return !1;
                O++, de++;
                break;
              case "LineString":
              case "MultiPoint":
                for (C = 0; C < P.length; C++) {
                  if (y(
                    P[C],
                    O,
                    he,
                    de,
                    R
                  ) === !1)
                    return !1;
                  O++, Q === "MultiPoint" && de++;
                }
                Q === "LineString" && de++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (C = 0; C < P.length; C++) {
                  for (T = 0; T < P[C].length - F; T++) {
                    if (y(
                      P[C][T],
                      O,
                      he,
                      de,
                      R
                    ) === !1)
                      return !1;
                    O++;
                  }
                  Q === "MultiLineString" && de++, Q === "Polygon" && R++;
                }
                Q === "Polygon" && de++;
                break;
              case "MultiPolygon":
                for (C = 0; C < P.length; C++) {
                  for (R = 0, T = 0; T < P[C].length; T++) {
                    for (k = 0; k < P[C][T].length - F; k++) {
                      if (y(
                        P[C][T][k],
                        O,
                        he,
                        de,
                        R
                      ) === !1)
                        return !1;
                      O++;
                    }
                    R++;
                  }
                  de++;
                }
                break;
              case "GeometryCollection":
                for (C = 0; C < I.geometries.length; C++)
                  if (t(I.geometries[C], y, S) === !1)
                    return !1;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
  }
  function i(p, y, S, C) {
    var T = S;
    return t(
      p,
      function(k, I, A, P, D) {
        I === 0 && S === void 0 ? T = k : T = y(
          T,
          k,
          I,
          A,
          P,
          D
        );
      },
      C
    ), T;
  }
  function n(p, y) {
    var S;
    switch (p.type) {
      case "FeatureCollection":
        for (S = 0; S < p.features.length && y(p.features[S].properties, S) !== !1; S++)
          ;
        break;
      case "Feature":
        y(p.properties, 0);
        break;
    }
  }
  function r(p, y, S) {
    var C = S;
    return n(p, function(T, k) {
      k === 0 && S === void 0 ? C = T : C = y(C, T, k);
    }), C;
  }
  function s(p, y) {
    if (p.type === "Feature")
      y(p, 0);
    else if (p.type === "FeatureCollection")
      for (var S = 0; S < p.features.length && y(p.features[S], S) !== !1; S++)
        ;
  }
  function a(p, y, S) {
    var C = S;
    return s(p, function(T, k) {
      k === 0 && S === void 0 ? C = T : C = y(C, T, k);
    }), C;
  }
  function l(p) {
    var y = [];
    return t(p, function(S) {
      y.push(S);
    }), y;
  }
  function c(p, y) {
    var S, C, T, k, I, A, P, D, F, O, $ = 0, X = p.type === "FeatureCollection", te = p.type === "Feature", H = X ? p.features.length : 1;
    for (S = 0; S < H; S++) {
      for (A = X ? p.features[S].geometry : te ? p.geometry : p, D = X ? p.features[S].properties : te ? p.properties : {}, F = X ? p.features[S].bbox : te ? p.bbox : void 0, O = X ? p.features[S].id : te ? p.id : void 0, P = A ? A.type === "GeometryCollection" : !1, I = P ? A.geometries.length : 1, T = 0; T < I; T++) {
        if (k = P ? A.geometries[T] : A, k === null) {
          if (y(
            null,
            $,
            D,
            F,
            O
          ) === !1)
            return !1;
          continue;
        }
        switch (k.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (y(
              k,
              $,
              D,
              F,
              O
            ) === !1)
              return !1;
            break;
          }
          case "GeometryCollection": {
            for (C = 0; C < k.geometries.length; C++)
              if (y(
                k.geometries[C],
                $,
                D,
                F,
                O
              ) === !1)
                return !1;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      $++;
    }
  }
  function u(p, y, S) {
    var C = S;
    return c(
      p,
      function(T, k, I, A, P) {
        k === 0 && S === void 0 ? C = T : C = y(
          C,
          T,
          k,
          I,
          A,
          P
        );
      }
    ), C;
  }
  function d(p, y) {
    c(p, function(S, C, T, k, I) {
      var A = S === null ? null : S.type;
      switch (A) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return y(
            e.feature(S, T, { bbox: k, id: I }),
            C,
            0
          ) === !1 ? !1 : void 0;
      }
      var P;
      switch (A) {
        case "MultiPoint":
          P = "Point";
          break;
        case "MultiLineString":
          P = "LineString";
          break;
        case "MultiPolygon":
          P = "Polygon";
          break;
      }
      for (var D = 0; D < S.coordinates.length; D++) {
        var F = S.coordinates[D], O = {
          type: P,
          coordinates: F
        };
        if (y(e.feature(O, T), C, D) === !1)
          return !1;
      }
    });
  }
  function f(p, y, S) {
    var C = S;
    return d(
      p,
      function(T, k, I) {
        k === 0 && I === 0 && S === void 0 ? C = T : C = y(
          C,
          T,
          k,
          I
        );
      }
    ), C;
  }
  function h(p, y) {
    d(p, function(S, C, T) {
      var k = 0;
      if (S.geometry) {
        var I = S.geometry.type;
        if (!(I === "Point" || I === "MultiPoint")) {
          var A, P = 0, D = 0, F = 0;
          if (t(
            S,
            function(O, $, X, te, H) {
              if (A === void 0 || C > P || te > D || H > F) {
                A = O, P = C, D = te, F = H, k = 0;
                return;
              }
              var oe = e.lineString(
                [A, O],
                S.properties
              );
              if (y(
                oe,
                C,
                T,
                H,
                k
              ) === !1)
                return !1;
              k++, A = O;
            }
          ) === !1)
            return !1;
        }
      }
    });
  }
  function g(p, y, S) {
    var C = S, T = !1;
    return h(
      p,
      function(k, I, A, P, D) {
        T === !1 && S === void 0 ? C = k : C = y(
          C,
          k,
          I,
          A,
          P,
          D
        ), T = !0;
      }
    ), C;
  }
  function v(p, y) {
    if (!p) throw new Error("geojson is required");
    d(p, function(S, C, T) {
      if (S.geometry !== null) {
        var k = S.geometry.type, I = S.geometry.coordinates;
        switch (k) {
          case "LineString":
            if (y(S, C, T, 0, 0) === !1)
              return !1;
            break;
          case "Polygon":
            for (var A = 0; A < I.length; A++)
              if (y(
                e.lineString(I[A], S.properties),
                C,
                T,
                A
              ) === !1)
                return !1;
            break;
        }
      }
    });
  }
  function x(p, y, S) {
    var C = S;
    return v(
      p,
      function(T, k, I, A) {
        k === 0 && S === void 0 ? C = T : C = y(
          C,
          T,
          k,
          I,
          A
        );
      }
    ), C;
  }
  function w(p, y) {
    if (y = y || {}, !e.isObject(y)) throw new Error("options is invalid");
    var S = y.featureIndex || 0, C = y.multiFeatureIndex || 0, T = y.geometryIndex || 0, k = y.segmentIndex || 0, I = y.properties, A;
    switch (p.type) {
      case "FeatureCollection":
        S < 0 && (S = p.features.length + S), I = I || p.features[S].properties, A = p.features[S].geometry;
        break;
      case "Feature":
        I = I || p.properties, A = p.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        A = p;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (A === null) return null;
    var P = A.coordinates;
    switch (A.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        return k < 0 && (k = P.length + k - 1), e.lineString(
          [P[k], P[k + 1]],
          I,
          y
        );
      case "Polygon":
        return T < 0 && (T = P.length + T), k < 0 && (k = P[T].length + k - 1), e.lineString(
          [
            P[T][k],
            P[T][k + 1]
          ],
          I,
          y
        );
      case "MultiLineString":
        return C < 0 && (C = P.length + C), k < 0 && (k = P[C].length + k - 1), e.lineString(
          [
            P[C][k],
            P[C][k + 1]
          ],
          I,
          y
        );
      case "MultiPolygon":
        return C < 0 && (C = P.length + C), T < 0 && (T = P[C].length + T), k < 0 && (k = P[C][T].length - k - 1), e.lineString(
          [
            P[C][T][k],
            P[C][T][k + 1]
          ],
          I,
          y
        );
    }
    throw new Error("geojson is invalid");
  }
  function M(p, y) {
    if (y = y || {}, !e.isObject(y)) throw new Error("options is invalid");
    var S = y.featureIndex || 0, C = y.multiFeatureIndex || 0, T = y.geometryIndex || 0, k = y.coordIndex || 0, I = y.properties, A;
    switch (p.type) {
      case "FeatureCollection":
        S < 0 && (S = p.features.length + S), I = I || p.features[S].properties, A = p.features[S].geometry;
        break;
      case "Feature":
        I = I || p.properties, A = p.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        A = p;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (A === null) return null;
    var P = A.coordinates;
    switch (A.type) {
      case "Point":
        return e.point(P, I, y);
      case "MultiPoint":
        return C < 0 && (C = P.length + C), e.point(P[C], I, y);
      case "LineString":
        return k < 0 && (k = P.length + k), e.point(P[k], I, y);
      case "Polygon":
        return T < 0 && (T = P.length + T), k < 0 && (k = P[T].length + k), e.point(P[T][k], I, y);
      case "MultiLineString":
        return C < 0 && (C = P.length + C), k < 0 && (k = P[C].length + k), e.point(P[C][k], I, y);
      case "MultiPolygon":
        return C < 0 && (C = P.length + C), T < 0 && (T = P[C].length + T), k < 0 && (k = P[C][T].length - k), e.point(
          P[C][T][k],
          I,
          y
        );
    }
    throw new Error("geojson is invalid");
  }
  return Be.coordAll = l, Be.coordEach = t, Be.coordReduce = i, Be.featureEach = s, Be.featureReduce = a, Be.findPoint = M, Be.findSegment = w, Be.flattenEach = d, Be.flattenReduce = f, Be.geomEach = c, Be.geomReduce = u, Be.lineEach = v, Be.lineReduce = x, Be.propEach = n, Be.propReduce = r, Be.segmentEach = h, Be.segmentReduce = g, Be;
}
var $l;
function Db() {
  if ($l) return gr.exports;
  $l = 1;
  var e = Mb(), t = /* @__PURE__ */ xd(), i = /* @__PURE__ */ Fb(), n = Fi.default, r = i.featureEach;
  i.coordEach, t.polygon;
  var s = t.featureCollection;
  function a(l) {
    var c = new e(l);
    return c.insert = function(u) {
      if (u.type !== "Feature") throw new Error("invalid feature");
      return u.bbox = u.bbox ? u.bbox : n(u), e.prototype.insert.call(this, u);
    }, c.load = function(u) {
      var d = [];
      return Array.isArray(u) ? u.forEach(function(f) {
        if (f.type !== "Feature") throw new Error("invalid features");
        f.bbox = f.bbox ? f.bbox : n(f), d.push(f);
      }) : r(u, function(f) {
        if (f.type !== "Feature") throw new Error("invalid features");
        f.bbox = f.bbox ? f.bbox : n(f), d.push(f);
      }), e.prototype.load.call(this, d);
    }, c.remove = function(u, d) {
      if (u.type !== "Feature") throw new Error("invalid feature");
      return u.bbox = u.bbox ? u.bbox : n(u), e.prototype.remove.call(this, u, d);
    }, c.clear = function() {
      return e.prototype.clear.call(this);
    }, c.search = function(u) {
      var d = e.prototype.search.call(this, this.toBBox(u));
      return s(d);
    }, c.collides = function(u) {
      return e.prototype.collides.call(this, this.toBBox(u));
    }, c.all = function() {
      var u = e.prototype.all.call(this);
      return s(u);
    }, c.toJSON = function() {
      return e.prototype.toJSON.call(this);
    }, c.fromJSON = function(u) {
      return e.prototype.fromJSON.call(this, u);
    }, c.toBBox = function(u) {
      var d;
      if (u.bbox) d = u.bbox;
      else if (Array.isArray(u) && u.length === 4) d = u;
      else if (Array.isArray(u) && u.length === 6) d = [u[0], u[1], u[3], u[4]];
      else if (u.type === "Feature") d = n(u);
      else if (u.type === "FeatureCollection") d = n(u);
      else throw new Error("invalid geojson");
      return {
        minX: d[0],
        minY: d[1],
        maxX: d[2],
        maxY: d[3]
      };
    }, c;
  }
  return gr.exports = a, gr.exports.default = a, gr.exports;
}
var Ab = Db();
const Ob = /* @__PURE__ */ Tb(Ab);
function Jo(e, t) {
  var i = {}, n = [];
  if (e.type === "LineString" && (e = Wt(e)), t.type === "LineString" && (t = Wt(t)), e.type === "Feature" && t.type === "Feature" && e.geometry !== null && t.geometry !== null && e.geometry.type === "LineString" && t.geometry.type === "LineString" && e.geometry.coordinates.length === 2 && t.geometry.coordinates.length === 2) {
    var r = Il(e, t);
    return r && n.push(r), it(n);
  }
  var s = Ob();
  return s.load(Dl(t)), ki(Dl(e), function(a) {
    ki(s.search(a), function(l) {
      var c = Il(a, l);
      if (c) {
        var u = ft(c).join(",");
        i[u] || (i[u] = !0, n.push(c));
      }
    });
  }), it(n);
}
function Il(e, t) {
  var i = ft(e), n = ft(t);
  if (i.length !== 2)
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (n.length !== 2)
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  var r = i[0][0], s = i[0][1], a = i[1][0], l = i[1][1], c = n[0][0], u = n[0][1], d = n[1][0], f = n[1][1], h = (f - u) * (a - r) - (d - c) * (l - s), g = (d - c) * (s - u) - (f - u) * (r - c), v = (a - r) * (s - u) - (l - s) * (r - c);
  if (h === 0)
    return null;
  var x = g / h, w = v / h;
  if (x >= 0 && x <= 1 && w >= 0 && w <= 1) {
    var M = r + x * (a - r), p = s + x * (l - s);
    return dt([M, p]);
  }
  return null;
}
function ao(e, t) {
  t === void 0 && (t = {});
  var i = ri(e);
  switch (!t.properties && e.type === "Feature" && (t.properties = e.properties), i.type) {
    case "Polygon":
      return Bb(i, t);
    case "MultiPolygon":
      return Rb(i, t);
    default:
      throw new Error("invalid poly");
  }
}
function Bb(e, t) {
  t === void 0 && (t = {});
  var i = ri(e), n = i.coordinates, r = t.properties ? t.properties : e.type === "Feature" ? e.properties : {};
  return Sd(n, r);
}
function Rb(e, t) {
  t === void 0 && (t = {});
  var i = ri(e), n = i.coordinates, r = t.properties ? t.properties : e.type === "Feature" ? e.properties : {}, s = [];
  return n.forEach(function(a) {
    s.push(Sd(a, r));
  }), it(s);
}
function Sd(e, t) {
  return e.length > 1 ? vb(e, t) : Wo(e[0], t);
}
function $b(e, t) {
  var i = !0;
  return Mi(e, function(n) {
    Mi(t, function(r) {
      if (i === !1)
        return !1;
      i = Ib(n.geometry, r.geometry);
    });
  }), i;
}
function Ib(e, t) {
  switch (e.type) {
    case "Point":
      switch (t.type) {
        case "Point":
          return !Vb(e.coordinates, t.coordinates);
        case "LineString":
          return !zl(t, e);
        case "Polygon":
          return !zn(e, t);
      }
      break;
    case "LineString":
      switch (t.type) {
        case "Point":
          return !zl(e, t);
        case "LineString":
          return !zb(e, t);
        case "Polygon":
          return !Nl(t, e);
      }
      break;
    case "Polygon":
      switch (t.type) {
        case "Point":
          return !zn(t, e);
        case "LineString":
          return !Nl(e, t);
        case "Polygon":
          return !Nb(t, e);
      }
  }
  return !1;
}
function zl(e, t) {
  for (var i = 0; i < e.coordinates.length - 1; i++)
    if (jb(e.coordinates[i], e.coordinates[i + 1], t.coordinates))
      return !0;
  return !1;
}
function zb(e, t) {
  var i = Jo(e, t);
  return i.features.length > 0;
}
function Nl(e, t) {
  for (var i = 0, n = t.coordinates; i < n.length; i++) {
    var r = n[i];
    if (zn(r, e))
      return !0;
  }
  var s = Jo(t, ao(e));
  return s.features.length > 0;
}
function Nb(e, t) {
  for (var i = 0, n = e.coordinates[0]; i < n.length; i++) {
    var r = n[i];
    if (zn(r, t))
      return !0;
  }
  for (var s = 0, a = t.coordinates[0]; s < a.length; s++) {
    var l = a[s];
    if (zn(l, e))
      return !0;
  }
  var c = Jo(ao(e), ao(t));
  return c.features.length > 0;
}
function jb(e, t, i) {
  var n = i[0] - e[0], r = i[1] - e[1], s = t[0] - e[0], a = t[1] - e[1], l = n * a - r * s;
  return l !== 0 ? !1 : Math.abs(s) >= Math.abs(a) ? s > 0 ? e[0] <= i[0] && i[0] <= t[0] : t[0] <= i[0] && i[0] <= e[0] : a > 0 ? e[1] <= i[1] && i[1] <= t[1] : t[1] <= i[1] && i[1] <= e[1];
}
function Vb(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function Cd(e, t) {
  var i = !1;
  return Mi(e, function(n) {
    Mi(t, function(r) {
      if (i === !0)
        return !0;
      i = !$b(n.geometry, r.geometry);
    });
  }), i;
}
function hs(e, t, i = !1) {
  if (i) {
    let n = 0;
    for (; n < t.length && !(e.valueOf() < t[n].valueOf()); n++)
      ;
    return n > 0 && n--, { index: n, difference: Math.abs(e.diff(t[n])) };
  } else {
    let n = -1, r = 1 / 0;
    return t.forEach((s, a) => {
      const l = Math.abs(e.diff(s));
      l < r && (r = l, n = a);
    }), { index: n, difference: r };
  }
}
function Ub(e, t = "minimum") {
  let i = t === "minimum" ? 1 / 0 : 0;
  return e.forEach((n, r) => {
    if (r < e.length - 1) {
      const s = Math.abs(n.diff(e[r + 1]));
      t === "minimum" ? s < i && (i = s) : s > i && (i = s);
    }
  }), i;
}
function st(e, t) {
  let i = o.get(t, "featureId");
  return i || (i = "_id"), i = Array.isArray(i) ? i : [i], i.map((n) => o.get(e, "properties." + n, o.get(e, n))).join("-");
}
function qb(e, t) {
  let i = t.featureLabel || "name";
  return i = Array.isArray(i) ? i : [i], i.reduce((n, r) => (r = o.get(e, `properties.${r}`), n ? n + ` - ${r}` : r), "");
}
function Gb(e, t, i, n) {
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: [t, e]
    },
    properties: {
      name: Xs(e, t).format(i, n)
    }
  };
}
function Ie(e) {
  return Array.isArray(e) ? e : e.type === "FeatureCollection" ? e.features : [e];
}
const jl = ["right", "left", "top", "bottom", "top-left", "top-right", "bottom-right", "bottom-left"];
async function Ed(e) {
  const { kActivity: t } = di(), i = t.value.getContextParameters("layers").layers, n = t.value.getContextParameters("view"), r = V.get("capabilities.api.gateway") + "/capture", s = {
    method: "POST",
    mode: "cors",
    headers: {
      "Content-Type": "application/json"
    }
  }, a = await q.get("storage").getItem(me.gatewayJwt);
  a && (s.headers.Authorization = "Bearer " + a);
  let l = null;
  l = Xe.create({
    group: "capture",
    icon: "las la-hourglass-half",
    message: Y.t("KCapture.PRINTING_VIEW"),
    color: "primary",
    timeout: 0,
    spinner: !0
  });
  const c = [], u = Zb(e.dateTime.start, e.dateTime.end);
  try {
    for (let d = 0; d < u.length; d++) {
      s.body = JSON.stringify({
        activity: t.value.is3D() ? "globe" : "map",
        layers: i,
        bbox: [n.west, n.south, n.east, n.north],
        size: { width: +e.resolution.width, height: +e.resolution.height },
        layout: Kb(e),
        time: u[d],
        basePath: o.has(e, "basePath") ? e.basePath : "/#/home/",
        lang: Bt()
      });
      const f = await fetch(r, s);
      if (f.ok) {
        const h = await f.arrayBuffer();
        c.push(h);
      } else
        ne.emit("error", { message: Y.t("errors." + f.status) });
    }
    if (e.format === "pdf") {
      const d = await Qb(c, o.toNumber(e.resolution.width), o.toNumber(e.resolution.height));
      zr(Y.t("utils.capture.CAPTURE_PDF_FILE", { time: o.get(u, "[0]", "") }), d);
    } else
      o.forEach(c, (d, f) => {
        const h = u[f];
        zr(Y.t("utils.capture.CAPTURE_IMAGE_FILE", { time: o.get(u, `[${f}]`, "") }), new Uint8Array(d));
      });
    l();
  } catch (d) {
    l(), z.error(d), ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
  }
}
function Kb(e) {
  const t = {
    panes: {
      left: { opener: !1, visible: !1 },
      top: { opener: !1, visible: !1 },
      right: { opener: !1, visible: !1 },
      bottom: { opener: !1, visible: !1 }
    },
    fab: { visible: !1 }
  };
  return o.has(e, "header") && !o.isEmpty(e.header) && o.set(t, "header", Vl(e.header, "header")), o.has(e, "footer") && !o.isEmpty(e.footer) && o.set(t, "footer", Vl(e.footer, "footer")), o.includes(jl, e.north) && o.set(t, "stickies", Hb(e.north)), o.includes(jl, e.legend) && o.set(t, `windows.${e.legend}`, Wb()), t;
}
function Vl(e, t) {
  return { content: [{ component: o.get(me, `capture.${t}.component`, "KCaptureTextArea"), text: e, position: t }], visible: !0 };
}
function Hb(e) {
  return { content: [{ ...ee.findSticky("north-sticky"), position: e, offset: [0, 5], visible: !0 }] };
}
function Wb() {
  return {
    content: [{ id: "legend-widget", label: "KLegend.LABEL", icon: "las la-list", scrollable: !0, content: { component: "legend/KLegend" } }],
    current: "legend-widget",
    state: "pinned",
    controls: {
      pin: !1,
      unpin: !1,
      maximize: !1,
      restore: !1,
      close: !1,
      resize: !1
    },
    sizePolicy: {
      pinned: {
        xs: [35, 100],
        sm: [30, 100],
        md: [25, 100],
        lg: [20, 100],
        xl: [15, 100]
      }
    },
    visible: !0
  };
}
function Zb(e, t) {
  if (e === t) return [e];
  const i = fe.utc(e), n = fe.utc(t), r = V.get("time.interval"), s = [];
  let a = i.clone();
  for (; a.isSameOrBefore(n); )
    s.push(a.toISOString()), a.add(r, "minutes");
  return s;
}
function Jb(e, t) {
  const i = { type: "image", rotate: 0 };
  return e > t ? (i.width = 287, i.height = 287 * t / e, i.position = { x: 5, y: (210 - i.height) / 2 }) : (i.height = 200, i.width = 200 * e / t, i.position = { y: 5, x: (297 - i.width) / 2 }), i;
}
async function Qb(e, t, i) {
  const n = {
    schemas: [{ capture: Jb(t, i) }],
    basePdf: "data:application/pdf;base64,JVBERi0xLjQKJeLjz9MKMSAwIG9iaiA8PC9UeXBlL1hPYmplY3QvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHRdL0ZvbnQgMiAwIFI+Pi9TdWJ0eXBlL0Zvcm0vQkJveFswIDAgMjk4IDQyMF0vTWF0cml4WzEgMCAwIDEgMCAwXS9MZW5ndGggNDQvRm9ybVR5cGUgMS9GaWx0ZXIvRmxhdGVEZWNvZGU+PnN0cmVhbQp4nDPQM1Qo5ypUMFAw0DNRMLI01zNXMDG01DNTKEpVCNdSyOMKVAAAiEAHjgplbmRzdHJlYW0KZW5kb2JqCjMgMCBvYmogPDwvTGVuZ3RoIDgxL0ZpbHRlci9GbGF0ZURlY29kZT4+c3RyZWFtCnicK+RyCuEyNlMwNbXUMzZVCEnhcg3hCuQqVDDQMzMwNDNUMABBKNvY2FDP2ETB2MBMz8xcITlXQT8izVDBJV8hkAukzFAhyJ0rmAsAxQ8Q1AplbmRzdHJlYW0KZW5kb2JqCjQgMCBvYmo8PC9UeXBlL1BhZ2VzL0NvdW50IDEvS2lkc1s1IDAgUl0+PgplbmRvYmoKNSAwIG9iajw8L1BhcmVudCA0IDAgUi9UeXBlL1BhZ2UvQ29udGVudHMgMyAwIFIvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHQvSW1hZ2VCL0ltYWdlQy9JbWFnZUldL1hPYmplY3Q8PC9YZjEgMSAwIFI+Pj4+L01lZGlhQm94WzAgMCA4NDEuOTUgNTk1LjM1XT4+CmVuZG9iagoyIDAgb2JqPDw+PgplbmRvYmoKNiAwIG9iajw8L1R5cGUvQ2F0YWxvZy9QYWdlcyA0IDAgUj4+CmVuZG9iago3IDAgb2JqPDwvUHJvZHVjZXIoUERGaWxsOiBGcmVlIFBERiBXcml0ZXIgYW5kIFRvb2xzKS9Nb2REYXRlKEQ6MjAwOTEwMTgyMjMwMTArMDInMDAnKS9DcmVhdGlvbkRhdGUoRDoyMDA5MTAxODIyMzAxMCswMicwMCcpPj4KZW5kb2JqCnhyZWYKMCA4CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDAxNSAwMDAwMCBuIAowMDAwMDAwNjAyIDAwMDAwIG4gCjAwMDAwMDAyNDQgMDAwMDAgbiAKMDAwMDAwMDM5MSAwMDAwMCBuIAowMDAwMDAwNDQxIDAwMDAwIG4gCjAwMDAwMDA2MjEgMDAwMDAgbiAKMDAwMDAwMDY2NSAwMDAwMCBuIAp0cmFpbGVyCjw8L1Jvb3QgNiAwIFIvSW5mbyA3IDAgUi9TaXplIDg+PgpzdGFydHhyZWYKNzk5CiUlRU9GCg=="
  }, r = { image: Yh }, s = [];
  return o.forEach(e, (a) => {
    s.push({ capture: `data:image/png;base64,${cd(a)}` });
  }), await Xh({ template: n, plugins: r, inputs: s });
}
function gt(e, t, i, n, r) {
  const s = o.get(e, t);
  if (s && s.startsWith(i))
    if (t === "cesium.url" && o.get(e, "cesium.type") === "OpenStreetMap") {
      const a = o.get(e, "cesium.fileExtension", "png");
      o.set(e, "cesium.fileExtension", a + `?${n}=${r}`);
    } else
      o.set(e, t, Gn(s, { [n]: r }));
}
async function Qo(e, t) {
  t || (t = q);
  let i = t.hasConfig("gatewayJwt") ? await t.get("storage").getItem(t.getConfig("gatewayJwt")) : null, n = t.getConfig("gatewayJwtField");
  const r = t.hasConfig("gateway") ? t.getConfig("gateway") : V.get("capabilities.api.gateway");
  i && e.forEach((a) => {
    gt(a, "iconUrl", r, n, i), gt(a, "leaflet.source", r, n, i), gt(a, "leaflet.url", r, n, i), gt(a, "opendap.url", r, n, i), gt(a, "geotiff.url", r, n, i), gt(a, "wfs.url", r, n, i), gt(a, "wcs.url", r, n, i), gt(a, "cesium.url", r, n, i), gt(a, "cesium.source", r, n, i);
  }), i = t.hasConfig("apiJwt") ? await t.get("storage").getItem(t.getConfig("apiJwt")) : null, n = "jwt";
  const s = t.getConfig("domain");
  return i && (e.forEach((a) => {
    gt(a, "geotiff.url", s, n, i);
  }), e.forEach((a) => {
    gt(a, "geotiff.url", "/", n, i);
  })), e;
}
function Td(e, t) {
  const i = o.clone(e), n = {};
  return o.forEach(t, (r) => {
    let s = null;
    o.has(r, "options.filter") ? s = o.get(r, "options.filter") : o.has(r, "layers") && (s = { name: { $in: o.get(r, "layers") } }), n[r.name] = s ? o.remove(i, Pe(s)) : [], n[r.name] = o.orderBy(
      n[r.name],
      [(a) => o.get(a, o.get(r, "options.orderBy", "_id"))],
      [o.get(r, "options.order", "asc")]
    ), e.length > 0 && r?.layers && (n[r.name] = r.layers.map((a) => e.find((l) => l.name === a)));
  }), n;
}
function Pd(e, t) {
  const i = o.flatten(o.values(t)), n = o.difference(e, i);
  return o.orderBy(n, [(r) => o.get(r, "_id")], ["asc"]);
}
function ms(e) {
  e.i18n && Y.registerTranslation(e.i18n), o.has(e, "label") || (e.label = Y.tie(e.name)), o.has(e, "description") && (e.description = Y.tie(e.description));
}
async function Ur(e = {}) {
  o.defaults(e, {
    query: {},
    context: "",
    planetApi: q
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: e.query });
    o.forEach(n.data, ms), t = t.concat(n.data.map((r) => Object.assign(r, { getPlanetApi: () => e.planetApi })));
  }
  return await Qo(t, e.planetApi), t;
}
async function qr(e = {}) {
  o.defaults(e, {
    query: {},
    context: "",
    planetApi: q
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Category" }, e.query) });
    o.forEach(n.data, ms), t = t.concat(n.data);
  }
  return t;
}
async function Gr(e = {}) {
  o.defaults(e, {
    query: {},
    context: "",
    planetApi: q
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Sublegend" }, e.query) });
    o.forEach(n.data, ms), t = t.concat(n.data);
  }
  return t;
}
function Yb(e, t) {
  const i = o.clone(e), n = {};
  return o.forEach(t, (r) => {
    let s = null;
    o.has(r, "options.filter") && (s = o.get(r, "options.filter")), n[r.name] = s ? o.remove(i, Pe(s)) : [];
  }), n;
}
async function kd(e = {}) {
  o.defaults(e, {
    query: {},
    context: "",
    planetApi: q
  });
  let t = [];
  const i = e.planetApi.getService("catalog", e.context);
  if (i) {
    const n = await i.find({ query: Object.assign({ type: "Context" }, e.query) });
    o.forEach(n.data, ms), t = t.concat(n.data);
  }
  return t;
}
function Md(e) {
  var t = [];
  return e.type === "FeatureCollection" ? ki(e, function(i) {
    Zt(i, function(n) {
      t.push(dt(n, i.properties));
    });
  }) : Zt(e, function(i) {
    t.push(dt(i, e.properties));
  }), it(t);
}
function Xb(e) {
  var t, i, n = {
    type: "FeatureCollection",
    features: []
  };
  if (e.type === "Feature" ? i = e.geometry : i = e, i.type === "LineString")
    t = [i.coordinates];
  else if (i.type === "MultiLineString")
    t = i.coordinates;
  else if (i.type === "MultiPolygon")
    t = [].concat.apply([], i.coordinates);
  else if (i.type === "Polygon")
    t = i.coordinates;
  else
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  return t.forEach(function(r) {
    t.forEach(function(s) {
      for (var a = 0; a < r.length - 1; a++)
        for (var l = a; l < s.length - 1; l++)
          if (!(r === s && (Math.abs(a - l) === 1 || // segments are first and last segment of lineString
          a === 0 && l === r.length - 2 && // lineString is closed
          r[a][0] === r[r.length - 1][0] && r[a][1] === r[r.length - 1][1]))) {
            var c = e0(r[a][0], r[a][1], r[a + 1][0], r[a + 1][1], s[l][0], s[l][1], s[l + 1][0], s[l + 1][1]);
            c && n.features.push(dt([c[0], c[1]]));
          }
    });
  }), n;
}
function e0(e, t, i, n, r, s, a, l) {
  var c, u, d, f, h, g = {
    x: null,
    y: null,
    onLine1: !1,
    onLine2: !1
  };
  return c = (l - s) * (i - e) - (a - r) * (n - t), c === 0 ? g.x !== null && g.y !== null ? g : !1 : (u = t - s, d = e - r, f = (a - r) * u - (l - s) * d, h = (i - e) * u - (n - t) * d, u = f / c, d = h / c, g.x = e + u * (i - e), g.y = t + u * (n - t), u >= 0 && u <= 1 && (g.onLine1 = !0), d >= 0 && d <= 1 && (g.onLine2 = !0), g.onLine1 && g.onLine2 ? [g.x, g.y] : !1);
}
function t0(e, t) {
  t === void 0 && (t = {});
  var i = typeof t == "object" ? t.mutate : t;
  if (!e)
    throw new Error("geojson is required");
  var n = Si(e), r = [];
  switch (n) {
    case "LineString":
      r = Gs(e);
      break;
    case "MultiLineString":
    case "Polygon":
      ft(e).forEach(function(a) {
        r.push(Gs(a));
      });
      break;
    case "MultiPolygon":
      ft(e).forEach(function(a) {
        var l = [];
        a.forEach(function(c) {
          l.push(Gs(c));
        }), r.push(l);
      });
      break;
    case "Point":
      return e;
    case "MultiPoint":
      var s = {};
      ft(e).forEach(function(a) {
        var l = a.join("-");
        Object.prototype.hasOwnProperty.call(s, l) || (r.push(a), s[l] = !0);
      });
      break;
    default:
      throw new Error(n + " geometry not supported");
  }
  return e.coordinates ? i === !0 ? (e.coordinates = r, e) : { type: n, coordinates: r } : i === !0 ? (e.geometry.coordinates = r, e) : Wt({ type: n, coordinates: r }, e.properties, {
    bbox: e.bbox,
    id: e.id
  });
}
function Gs(e) {
  var t = ft(e);
  if (t.length === 2 && !Ul(t[0], t[1]))
    return t;
  var i = [], n = t.length - 1, r = i.length;
  i.push(t[0]);
  for (var s = 1; s < n; s++) {
    var a = i[i.length - 1];
    t[s][0] === a[0] && t[s][1] === a[1] || (i.push(t[s]), r = i.length, r > 2 && ql(i[r - 3], i[r - 1], i[r - 2]) && i.splice(i.length - 2, 1));
  }
  if (i.push(t[t.length - 1]), r = i.length, Ul(t[0], t[t.length - 1]) && r < 4)
    throw new Error("invalid polygon");
  return ql(i[r - 3], i[r - 1], i[r - 2]) && i.splice(i.length - 2, 1), i;
}
function Ul(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function ql(e, t, i) {
  var n = i[0], r = i[1], s = e[0], a = e[1], l = t[0], c = t[1], u = n - s, d = r - a, f = l - s, h = c - a, g = u * h - d * f;
  return g !== 0 ? !1 : Math.abs(f) >= Math.abs(h) ? f > 0 ? s <= n && n <= l : l <= n && n <= s : h > 0 ? a <= r && r <= c : c <= r && r <= a;
}
function Yo(e, t, i) {
  i === void 0 && (i = {});
  var n;
  i.final ? n = Gl(rt(t), rt(e)) : n = Gl(rt(e), rt(t));
  var r = n > 180 ? -(360 - n) : n;
  return r;
}
function Gl(e, t) {
  var i = Ze(e[1]), n = Ze(t[1]), r = Ze(t[0] - e[0]);
  r > Math.PI && (r -= 2 * Math.PI), r < -Math.PI && (r += 2 * Math.PI);
  var s = Math.log(Math.tan(n / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)), a = Math.atan2(r, s);
  return (Vr(a) + 360) % 360;
}
function Xo(e, t, i) {
  i === void 0 && (i = {});
  var n = rt(e), r = rt(t);
  r[0] += r[0] - n[0] > 180 ? -360 : n[0] - r[0] > 180 ? 360 : 0;
  var s = i0(n, r), a = wd(s, "meters", i.units);
  return a;
}
function i0(e, t, i) {
  i = i === void 0 ? We : Number(i);
  var n = i, r = e[1] * Math.PI / 180, s = t[1] * Math.PI / 180, a = s - r, l = Math.abs(t[0] - e[0]) * Math.PI / 180;
  l > Math.PI && (l -= 2 * Math.PI);
  var c = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(r / 2 + Math.PI / 4)), u = Math.abs(c) > 1e-11 ? a / c : Math.cos(r), d = Math.sqrt(a * a + u * u * l * l), f = d * n;
  return f;
}
function ea(e, t, i, n) {
  n === void 0 && (n = {});
  var r = t < 0, s = wd(Math.abs(t), n.units, "meters");
  r && (s = -Math.abs(s));
  var a = rt(e), l = n0(a, s, i);
  return l[0] += l[0] - a[0] > 180 ? -360 : a[0] - l[0] > 180 ? 360 : 0, dt(l, n.properties);
}
function n0(e, t, i, n) {
  n = n === void 0 ? We : Number(n);
  var r = t / n, s = e[0] * Math.PI / 180, a = Ze(e[1]), l = Ze(i), c = r * Math.cos(l), u = a + c;
  Math.abs(u) > Math.PI / 2 && (u = u > 0 ? Math.PI - u : -Math.PI - u);
  var d = Math.log(Math.tan(u / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)), f = Math.abs(d) > 1e-11 ? c / d : Math.cos(a), h = r * Math.sin(l) / f, g = s + h;
  return [
    (g * 180 / Math.PI + 540) % 360 - 180,
    u * 180 / Math.PI
  ];
}
function ta(e) {
  if (!e)
    throw new Error("geojson is required");
  switch (e.type) {
    case "Feature":
      return Fd(e);
    case "FeatureCollection":
      return r0(e);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return ia(e);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Fd(e) {
  var t = { type: "Feature" };
  return Object.keys(e).forEach(function(i) {
    switch (i) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        t[i] = e[i];
    }
  }), t.properties = Dd(e.properties), t.geometry = ia(e.geometry), t;
}
function Dd(e) {
  var t = {};
  return e && Object.keys(e).forEach(function(i) {
    var n = e[i];
    typeof n == "object" ? n === null ? t[i] = null : Array.isArray(n) ? t[i] = n.map(function(r) {
      return r;
    }) : t[i] = Dd(n) : t[i] = n;
  }), t;
}
function r0(e) {
  var t = { type: "FeatureCollection" };
  return Object.keys(e).forEach(function(i) {
    switch (i) {
      case "type":
      case "features":
        return;
      default:
        t[i] = e[i];
    }
  }), t.features = e.features.map(function(i) {
    return Fd(i);
  }), t;
}
function ia(e) {
  var t = { type: e.type };
  return e.bbox && (t.bbox = e.bbox), e.type === "GeometryCollection" ? (t.geometries = e.geometries.map(function(i) {
    return ia(i);
  }), t) : (t.coordinates = Ad(e.coordinates), t);
}
function Ad(e) {
  var t = e;
  return typeof t[0] != "object" ? t.slice() : t.map(function(i) {
    return Ad(i);
  });
}
function s0(e, t, i) {
  if (i = i || {}, !Zo(i)) throw new Error("options is invalid");
  var n = i.pivot, r = i.mutate;
  if (!e) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("angle is required");
  return t === 0 || (n || (n = xi(e)), (r === !1 || r === void 0) && (e = ta(e)), Zt(e, function(s) {
    var a = Yo(n, s), l = a + t, c = Xo(n, s), u = ft(ea(n, c, l));
    s[0] = u[0], s[1] = u[1];
  })), e;
}
function o0(e, t) {
  t === void 0 && (t = {});
  var i = Fi(e), n = (i[0] + i[2]) / 2, r = (i[1] + i[3]) / 2;
  return dt([n, r], t.properties, t);
}
function a0(e, t, i) {
  if (i = i || {}, !Zo(i)) throw new Error("options is invalid");
  var n = i.origin, r = i.mutate;
  if (!e) throw new Error("geojson required");
  if (typeof t != "number" || t === 0)
    throw new Error("invalid factor");
  var s = Array.isArray(n) || typeof n == "object";
  return r !== !0 && (e = ta(e)), e.type === "FeatureCollection" && !s ? (ki(e, function(a, l) {
    e.features[l] = Kl(a, t, n);
  }), e) : Kl(e, t, n);
}
function Kl(e, t, i) {
  var n = Si(e) === "Point";
  return i = l0(e, i), t === 1 || n || Zt(e, function(r) {
    var s = Xo(i, r), a = Yo(i, r), l = s * t, c = ft(ea(i, l, a));
    r[0] = c[0], r[1] = c[1], r.length === 3 && (r[2] *= t);
  }), e;
}
function l0(e, t) {
  if (t == null && (t = "centroid"), Array.isArray(t) || typeof t == "object")
    return rt(t);
  var i = e.bbox ? e.bbox : Fi(e), n = i[0], r = i[1], s = i[2], a = i[3];
  switch (t) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return dt([n, r]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return dt([s, r]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return dt([n, a]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return dt([s, a]);
    case "center":
      return o0(e);
    case void 0:
    case null:
    case "centroid":
      return xi(e);
    default:
      throw new Error("invalid origin");
  }
}
function c0(e, t, i, n) {
  if (n = n || {}, !Zo(n)) throw new Error("options is invalid");
  var r = n.units, s = n.zTranslation, a = n.mutate;
  if (!e) throw new Error("geojson is required");
  if (t == null || isNaN(t))
    throw new Error("distance is required");
  if (s && typeof s != "number" && isNaN(s))
    throw new Error("zTranslation is not a number");
  if (s = s !== void 0 ? s : 0, t === 0 && s === 0) return e;
  if (i == null || isNaN(i))
    throw new Error("direction is required");
  return t < 0 && (t = -t, i = i + 180), (a === !1 || a === void 0) && (e = ta(e)), Zt(e, function(l) {
    var c = ft(
      ea(l, t, i, { units: r })
    );
    l[0] = c[0], l[1] = c[1], s && l.length === 3 && (l[2] += s);
  }), e;
}
function Od(e) {
  const t = e.params;
  o.has(t, "query.east") && (o.set(t, "east", o.get(t, "query.east")), o.unset(t, "query.east")), o.has(t, "query.west") && (o.set(t, "west", o.get(t, "query.west")), o.unset(t, "query.west")), o.has(t, "query.north") && (o.set(t, "north", o.get(t, "query.north")), o.unset(t, "query.north")), o.has(t, "query.south") && (o.set(t, "south", o.get(t, "query.south")), o.unset(t, "query.south"));
}
async function lo(e, t, i) {
  const n = await e._get(t), r = o.get(n, "referenceCount", 0) + i;
  return await e._patch(t, { referenceCount: r });
}
async function Bd(e) {
  const t = e.service, i = Array.isArray(e.data) ? e.data : [e.data];
  for (let n = 0; n < i.length; n++) {
    const r = i[n];
    try {
      await lo(t, r._id, 1);
    } catch {
      r.referenceCount = 1, await t._create(r);
    }
  }
  e.result = e.data;
}
async function Rd(e) {
  const t = e.service;
  if (e.id) {
    const i = await lo(t, e.id, -1);
    i.referenceCount <= 0 && await t._remove(e.id), e.result = i;
  } else {
    e.result = await t._find(Object.assign(e.params, { paginate: !1 }));
    for (let i = 0; i < e.result.length; i++) {
      const n = e.result[i];
      try {
        const { referenceCount: r } = await lo(t, n._id, -1);
        r <= 0 && await t._remove(n._id);
      } catch (r) {
        z.debug("[KDK] reference count update failed: ", r);
      }
    }
  }
}
function $d(e) {
  const t = e.result, i = t.data;
  o.get(i, "[0].type") === "Feature" && (e.result = Object.assign({
    type: "FeatureCollection",
    features: t.data
  }, o.pick(t, ["total", "skip", "limit"])));
}
async function Id(e) {
  const t = e.params;
  if (!o.has(t, "east") || !o.has(t, "west") || !o.has(t, "north") || !o.has(t, "south")) return e;
  const r = (await e.service._find(o.omit(t, ["east", "west", "north", "south"]))).data, s = Ho([[[t.east, t.south], [t.west, t.south], [t.west, t.north], [t.east, t.north], [t.east, t.south]]]);
  let a = [];
  for (let l of r)
    Cd(s, l) && a.push(l);
  o.set(e, "result.data", a);
}
const u0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geoJsonPaginationHook: $d,
  intersectBBoxHook: Id,
  referenceCountCreateHook: Bd,
  referenceCountRemoveHook: Rd,
  removeServerSideParameters: Od
}, Symbol.toStringTag, { value: "Module" })), Pn = Symbol.for("leaflet-event-listeners");
function Dt(e, t, i, n) {
  e[Pn] = [], t.forEach((r) => {
    const s = (...a) => {
      n ? i.$engineEvents.emit(r, n, ...a) : i.$engineEvents.emit(r, ...a);
    };
    e[Pn].push(s), e.on(r, s);
  });
}
function Kr(e, t) {
  e[Pn] && (t.forEach((n, r) => {
    e.off(n, e[Pn][r]);
  }), delete e[Pn]);
}
const Nn = ["touchstart", "touchmove", "touchend", "touchcancel"], ni = {
  Map: [
    "baselayerchange",
    "overlayadd",
    "overlayremove",
    "layeradd",
    "layerremove",
    "zoomlevelschange",
    "resize",
    "unload",
    "viewreset",
    "load",
    "zoomstart",
    "boxzoomstart",
    "boxselectionstart",
    "movestart",
    "zoom",
    "move",
    "rotate",
    "zoomend",
    "boxzoomend",
    "boxselectionend",
    "moveend",
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "mousemove",
    "contextmenu",
    "keypress",
    "preclick",
    "moveend",
    "zoomanim",
    "fullscreenchange"
  ].concat(Nn),
  Popup: ["add", "remove"],
  Tooltip: ["add", "remove"],
  Layer: ["add", "remove", "popupopen", "popupclose", "tooltipopen", "tooltipclose"],
  Feature: [
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "contextmenu",
    "dragstart",
    "dragend",
    "drag",
    "movestart",
    "moveend",
    "move"
  ].concat(Nn),
  Cluster: ["spiderfied", "unspiderfied"]
};
function Hl(e) {
  const t = [], i = [], n = e.properties.gradient, r = Fi(e);
  let s = r[2] - r[0], a = r[3] - r[1];
  s === 0 && (s = 0.1), a === 0 && (a = 0.1), r[0] -= s * 0.1, r[1] -= a * 0.1, r[2] += s * 0.1, r[3] += a * 0.1;
  const l = B.Projection.SphericalMercator.project(B.GeoJSON.coordsToLatLng(r.slice(0, 2))), c = B.Projection.SphericalMercator.project(B.GeoJSON.coordsToLatLng(r.slice(2, 4))), u = { x: Math.min(l.x, c.x), y: Math.min(l.y, c.y) }, d = { x: Math.max(l.x, c.x), y: Math.max(l.y, c.y) }, f = { x: d.x - u.x, y: d.y - u.y }, h = { x: f.x > f.y ? 1 : f.x / f.y, y: f.y > f.x ? 1 : f.y / f.x }, g = (p) => [h.x * ((p.x - u.x) / f.x), h.y * (1 - (p.y - u.y) / f.y)], v = `${r.join("_")}_${n.length}`, w = B.GeoJSON.coordsToLatLngs(e.geometry.coordinates).map((p) => g(B.Projection.SphericalMercator.project(p)));
  for (let p = 0; p < n.length - 1; ++p) {
    const y = w[p], S = w[p + 1];
    t.push(`<linearGradient gradientUnits="userSpaceOnUse" x1="${y[0]}" y1="${y[1]}" x2="${S[0]}" y2="${S[1]}" id="gradient${p}_${v}"><stop offset="0" stop-color="${n[p]}"/><stop offset="1" stop-color="${n[p + 1]}"/></linearGradient>`), i.push(`<path d="M ${y[0]} ${y[1]} L ${S[0]} ${S[1]}" stroke="url(#gradient${p}_${v})" vector-effect="non-scaling-stroke" class="leaflet-interactive"/>`);
  }
  var M = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  return M.setAttribute("xmlns", "http://www.w3.org/2000/svg"), M.setAttribute("viewBox", `0 0 ${h.x} ${h.y}`), M.innerHTML = `<g stroke-linecap="round" stroke-width="${e.properties.weight}"><defs>${t.join("")}</defs>${i.join("")}</g>`, { svg: M, bounds: B.latLngBounds(B.latLng(r[1], r[0]), B.latLng(r[3], r[2])) };
}
const zd = B.SVGOverlay.extend({
  initialize(e, t) {
    const i = Hl(e);
    B.SVGOverlay.prototype.initialize.call(this, i.svg, i.bounds, Object.assign({ interactive: !1 }, t));
    const n = o.get(e.properties, "opacity");
    n !== void 0 && this.setOpacity(n);
  },
  getCenter() {
    return this._bounds.getCenter();
  },
  // This method is called when source data changes
  setData(e) {
    this.onRemove();
    const t = Hl(e);
    this._url = t.svg, this._initImage(), this.setBounds(t.bounds);
    const i = o.get(e.properties, "opacity");
    i !== void 0 && this.setOpacity(i), this.onAdd();
  },
  onAdd() {
    B.SVGOverlay.prototype.onAdd.call(this), this.addInteractiveTarget(this._image);
  }
}), Nd = B.PixiOverlay.extend({
  initialize(e, t) {
    B.setOptions(this, Object.assign({ stroke: "#FFFFFF", weight: 8 }, t)), this.path = {
      geometry: null,
      bounds: null
    }, this.rope = null, this.container = new Te.Container(), Object.assign(this.container, {
      interactive: !0,
      buttonMode: !0
    }), B.PixiOverlay.prototype.initialize.call(
      this,
      (i) => this.render(i),
      this.container,
      {
        autoPreventDefault: !1,
        // see: https://github.com/kalisio/kdk/issues/424
        projectionZoom: () => 12
      }
    ), this.currentZoom = -1, e && this.setData(e);
  },
  setData(e) {
    const t = o.get(e, "type"), i = o.get(e, "geometry.type"), n = o.get(e, "geometry.coordinates");
    if (t !== "Feature" || i !== "LineString" || !Array.isArray(n)) {
      z.warn("Invalid/Unsupported GeoJson object for Gradient Path");
      return;
    }
    this.path.bounds = new B.LatLngBounds(), n.forEach((a) => this.path.bounds.extend([a[1], a[0]]));
    const r = o.get(e, "properties.gradient", o.get(e, "properties.stroke", o.get(this.options, "stroke"))), s = o.get(e, "properties.weight", o.get(this.options, "weight"));
    this.path.geometry = { coords: n, gradient: r, weight: s }, this.currentZoom = -1, this.redraw();
  },
  onAdd(e) {
    this.clickEventHandler = this.handleClickEvent.bind(this), e.on("click", this.clickEventHandler), this.moveEventHandler = this.handleMoveEvent.bind(this), e.on("mousemove", this.moveEventHandler), B.PixiOverlay.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    e.off("click", this.clickEventHandler), e.off("mousemove", this.moveEventHandler), this.rope && (this.container.removeChild(this.rope), this.rope.texture.destroy(!0), this.rope.destroy(!0), this.rope = null), this.container.destroy(!0), B.PixiOverlay.prototype.onRemove.call(this, e);
  },
  getBounds() {
    return this.path.bounds;
  },
  getCenter() {
    const e = Math.floor(this.path.geometry.coords.length / 2), t = this.path.geometry.coords[e];
    return [t[1], t[0]];
  },
  getObjectUnderPointer(e) {
    const t = new Te.Point();
    return this.renderer.events.mapPositionToPoint(t, e.originalEvent.clientX, e.originalEvent.clientY), new Te.EventBoundary(this.container).hitTest(t.x, t.y);
  },
  handleClickEvent(e) {
    if (!this.getPopup()) return;
    this.getObjectUnderPointer(e) ? this.isPopupOpen() ? this.closePopup() : this.openPopup(e.latlng) : this.isPopupOpen() && this.closePopup();
  },
  handleMoveEvent(e) {
    if (!this.getTooltip()) return;
    this.getObjectUnderPointer(e) ? (this.isTooltipOpen() || this.openTooltip(), this._moveTooltip(e)) : this.isTooltipOpen() && this.closeTooltip();
  },
  createSolidTexture(e, t) {
    const i = document.createElement("canvas");
    i.width = 8, i.height = t;
    const n = i.getContext("2d");
    return n.fillStyle = e, n.fillRect(0, 0, i.width, i.height), Te.Texture.from(i);
  },
  createGradientTexture(e, t) {
    const i = document.createElement("canvas");
    i.width = e.length, i.height = t;
    const n = i.getContext("2d"), r = n.createLinearGradient(0, 0, i.width, 1);
    for (let s = 0; s < e.length; s++)
      r.addColorStop(s / (e.length - 1), e[s]);
    return n.fillStyle = r, n.fillRect(0, 0, i.width, i.height), Te.Texture.from(i);
  },
  render(e) {
    const t = e.getMap().getZoom();
    if (t !== this.currentZoom) {
      this.renderer = e.getRenderer();
      let i = null;
      const n = Math.max(1, 2048 * this.path.geometry.weight / Math.pow(2, t));
      Array.isArray(this.path.geometry.gradient) ? i = this.createGradientTexture(this.path.geometry.gradient, n) : i = this.createSolidTexture(this.path.geometry.gradient, n);
      const r = this.path.geometry.coords.map((s) => e.latLngToLayerPoint([s[1], s[0]]));
      this.rope && (this.container.removeChild(this.rope), this.rope.texture.destroy(!0), this.rope.destroy(!0)), this.rope = new Te.SimpleRope(i, r), this.container.addChild(this.rope), this.currentZoom = t;
    }
    this.renderer.render(this.container);
  }
});
B.GradientPath = Nd;
B.SVGGradientPath = zd;
B.gradientPath = function(e) {
  return new B.GradientPath(e);
};
B.svgGradientPath = function(e) {
  return new B.SVGGradientPath(e);
};
function Wl(e) {
  const t = [];
  return Object.keys(e).forEach((n) => t.push(e[n])), t;
}
const d0 = B.Realtime.extend({
  // Override default remove handler for leaflet-realtime due to
  // https://github.com/perliedman/leaflet-realtime/issues/177
  remove(e) {
    return typeof e > "u" ? B.Layer.prototype.remove.call(this) : B.Realtime.prototype.remove.call(this, e);
  },
  // Add FeatureGroup interface so that layer edition works as well
  toGeoJSON() {
    return { type: "FeatureCollection", features: Wl(this._features) };
  },
  clearLayers() {
    this._onNewData(!0, { type: "FeatureCollection", features: [] });
  },
  getLayers() {
    return Wl(this._featureLayers);
  },
  addLayer(e) {
    this._onNewData(!1, e.toGeoJSON());
  },
  removeLayer(e) {
    this.remove(e.toGeoJSON());
  },
  // Additional missing features
  bringToFront() {
    this.options.pane !== "overlayPane" ? B.DomUtil.toFront(this.getPane(this.options.pane)) : this._container && this._container.bringToFront();
  },
  bringToBack() {
    this.options.pane !== "overlayPane" ? B.DomUtil.toBack(this.getPane(this.options.pane)) : this._container && this._container.bringToBack();
  }
});
B.realtime = function(e, t) {
  return new d0(e, t);
};
const f0 = B.MarkerClusterGroup.extend({
  // Override invoke as used by eg bringToFront/bringToBack
  invoke(e, ...t) {
    return B.MarkerClusterGroup.prototype.invoke.call(this, e, t), this._featureGroup.invoke(e, t), this._nonPointGroup.invoke(e, t), this;
  }
});
B.markerClusterGroup = function(e) {
  return new f0(e);
};
const h0 = B.Polyline.prototype._simplifyPoints;
B.Polyline.include({
  _simplifyPoints: function() {
    if (h0.call(this), this.options.offset) {
      const e = this.getBounds().getCenter().lat, t = 156543 / Math.pow(2, this._map.getZoom()) / Math.cos(e * Math.PI / 180), i = Math.max(1, this.options.offset * t);
      for (let n = 0; n < this._parts.length; n++) {
        let r = this._parts[n].map((l) => this._map.layerPointToLatLng(l));
        const s = B.GeoJSON.latLngsToCoords(r, 0, !1, 12), a = Lm({ type: "LineString", coordinates: s }, i, { units: "meters" });
        r = B.GeoJSON.coordsToLatLngs(a.geometry.coordinates, 0), this._parts[n] = r.map((l) => this._map.latLngToLayerPoint(l));
      }
    }
  }
});
const m0 = B.GeoJSON.geometryToLayer;
B.GeoJSON.geometryToLayer = function(e, t) {
  const i = e.geometry, n = e.properties;
  if (i && n && n.geodesic) {
    if (i.type === "LineString")
      return new B.Geodesic(
        [B.GeoJSON.coordsToLatLngs(i.coordinates, 0)],
        Object.assign({ steps: 4 }, t.style(e))
      );
    if (i.type === "MultiLineString") {
      const s = i.coordinates.map((a) => B.GeoJSON.coordsToLatLngs(a, 0));
      return new B.Geodesic(s, Object.assign({ steps: 4 }, t.style(e)));
    } else if (i.type === "Point")
      return new B.GeodesicCircle(
        B.GeoJSON.coordsToLatLng(i.coordinates),
        Object.assign({ fill: !0, steps: 360, radius: n.radius }, t.style(e))
      );
  }
  if (i && n && n.gradient) {
    const s = t.style(e);
    return n.svg ? new zd(e, s) : new Nd(e, s);
  }
  if (i && n && n.mask && (i.type === "Polygon" || i.type === "MultiPolygon"))
    return new MaskLayer(e, t.style(e));
  i && n && n.offset && i.type === "LineString" && (t = Object.assign({ offset: n.offset }, t));
  const r = m0(e, t);
  return i && (t.arrowheads || n && n.arrowheads) && r instanceof B.Polyline && r.arrowheads(t.arrowheads || n.arrowheads), r;
};
function jd(e) {
  return (i, n) => {
    if (!n) return;
    const r = o.get(n, "feature.geometry.type"), s = o.get(i, "geometry.type"), a = o.get(e, "staticGeometry", !1);
    if (!a && s !== r) return;
    if (a && (i.geometry = o.get(n, "feature.geometry")), e.onEachFeature(i, n), n.setStyle) {
      if (i.geometry.type === "Point")
        return;
      if (o.get(n.feature, "style.pane") !== o.get(i, "style.pane")) return;
      n.setStyle(e.style(i));
    }
    o.defaultsDeep(i, o.pick(n.feature, ["time", "runTime"]));
    const l = o.get(n.feature, "properties");
    if (l && (i.properties || (i.properties = {}), o.defaults(i.properties, l)), n.setIcon)
      return;
    if (a) return n;
    const c = i.geometry.coordinates;
    switch (s) {
      case "Point":
        n.setLatLng(B.GeoJSON.coordsToLatLngs(c));
        break;
      case "LineString":
      case "MultiLineString":
        if (typeof n.setData == "function")
          n.setData(i);
        else if (i.properties.geodesic) {
          const u = s === "LineString" ? [B.GeoJSON.coordsToLatLngs(c, 0)] : c.map((d) => B.GeoJSON.coordsToLatLngs(d, 0));
          n.setLatLngs(u);
        } else
          n.setLatLngs(B.GeoJSON.coordsToLatLngs(c, s === "LineString" ? 0 : 1));
        break;
      case "Polygon":
      case "MultiPolygon":
        n.setLatLngs(B.GeoJSON.coordsToLatLngs(c, s === "Polygon" ? 1 : 2));
        break;
    }
    return n;
  };
}
const xr = {
  // Filter to identify layers that require an update at a given frequency
  TimeUpdate: {
    // Possible for realtime layers only
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    $or: [
      // Supported by template URL or time-based features service
      { "leaflet.sourceTemplate": { $exists: !0 } },
      { service: { $exists: !0 } }
    ],
    // Skip layers powered by realtime service events
    serviceEvents: { $ne: !0 },
    // Skip invisible layers
    isVisible: !0
  },
  // Filter to identify layers with variables affected by a unit change
  UnitUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    // Not sure why but this does not seem to work with sift
    //'variables': { $elemMatch: { unit: { $in: units } } },
    variables: { $exists: !0 },
    isVisible: !0,
    $or: [{
      "leaflet.style": { $exists: !0 },
      "leaflet.template": { $exists: !0 }
    }, {
      "leaflet.tooltip.template": { $exists: !0 }
    }]
  },
  // Filter to identify layers with tooltip defining a minZoom/maxZoom
  // thus affected by a zoom change
  TooltipUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": !0,
    isVisible: !0,
    // Supported by permanent tooltips only
    "leaflet.tooltip.options.permanent": !0,
    $or: [
      { "leaflet.tooltip.minZoom": { $exists: !0 } },
      { "leaflet.tooltip.maxZoom": { $exists: !0 } }
    ]
  }
};
function Vd(e, t) {
  const i = o.intersection(e, o.map(t.variables, "unit"));
  if (o.isEmpty(i)) return !1;
  if (o.get(t, "leaflet.tooltip.template", "").includes("Units")) return !0;
  for (const n of t.leaflet.template)
    if (n.startsWith("style.")) {
      const r = o.get(t.leaflet, n);
      if (typeof r == "string" && r.includes("Units")) return !0;
    }
  return !1;
}
function Ud(e) {
  e = sn(e), e = o.pickBy(e, (n) => !o.isNil(n));
  const t = o.keys(e);
  let i;
  if (t.length === 0) return null;
  if (t.length === 1) i = o.get(e, t[0]);
  else {
    const n = ' style="border: 1px solid black; border-collapse: collapse;"';
    i = "<table" + n + ">", i += t.map((r) => "<tr" + n + "><th" + n + ">" + r + "</th><th>" + o.get(e, r) + "</th></tr>").join(""), i += "</table>";
  }
  return i;
}
const qd = {
  size: "marker-size",
  color: "marker-color",
  url: "marker-symbol"
}, Gd = {
  shape: "marker-symbol",
  size: "marker-size",
  color: "marker-color",
  "icon.url": "marker-symbol"
}, Kd = {
  fill: "color",
  "fill-opacity": "opacity",
  radius: "radius",
  stroke: "stroke.color",
  "marker-symbol": "shape",
  "marker-size": "size",
  "marker-color": "color",
  "marker-anchor": "anchor",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  icon: "icon.url",
  "icon-url": "icon.url",
  "icon-html": "html",
  "icon-color": "icon.color",
  "icon-size": "icon.size",
  "icon-anchor": "anchor",
  "icon-class": "icon.classes",
  "icon-opacity": "icon.opacity",
  "icon-classes": "icon.classes",
  "icon-translate": "icon.translate",
  "icon-rotate": "icon.rotate",
  "z-index": "pane",
  pane: "pane"
}, na = {
  stroke: "style.point.stroke.color",
  "stroke-color": "style.point.stroke.color",
  "stroke-opacity": "style.point.stroke.opacity",
  "stroke-width": "style.point.stroke.width",
  fill: "style.point.color",
  "fill-opacity": "style.point.opacity",
  "fill-color": "style.point.color",
  weight: "style.point.stroke.width",
  radius: "style.point.radius",
  "line-cap": "style.point.stroke.lineCap",
  "line-join": "style.point.stroke.lineJoin",
  "dash-array": "style.point.stroke.dashArray",
  "dash-offset": "style.point.stroke.dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-translate": "style.point.icon.translate",
  "z-index": "style.point.pane",
  pane: "style.point.pane"
}, Hd = {
  color: "stroke",
  width: "stroke-width",
  opacity: "stroke-opacity"
}, Wd = {
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "width",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  weight: "width",
  "z-index": "pane",
  pane: "pane"
}, ra = {
  stroke: "style.line.color",
  "stroke-color": "style.line.color",
  "stroke-opacity": "style.line.opacity",
  "stroke-width": "style.line.width",
  weight: "style.line.width",
  "line-cap": "style.line.cap",
  "line-join": "style.line.join",
  "dash-array": "style.line.dashArray",
  "dash-offset": "style.line.dashOffset",
  "z-index": "style.line.pane",
  pane: "style.line.pane"
}, Zd = {
  color: "fill",
  opacity: "fill-opacity"
}, Jd = {
  stroke: "stroke.color",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  fill: "color",
  "fill-color": "color",
  "fill-opacity": "opacity",
  "z-index": "pane",
  pane: "pane"
}, sa = {
  stroke: "style.polygon.stroke.color",
  "stroke-color": "style.polygon.stroke.color",
  "stroke-opacity": "style.polygon.stroke.opacity",
  "stroke-width": "style.polygon.stroke.width",
  fill: "style.polygon.color",
  "fill-opacity": "style.polygon.opacity",
  "fill-color": "style.polygon.color",
  weight: "style.polygon.stroke.width",
  "line-cap": "style.polygon.stroke.cap",
  "line-join": "style.polygon.stroke.join",
  "dash-array": "style.polygon.stroke.dashArray",
  "dash-offset": "style.polygon.stroke.dashOffset",
  "z-index": "style.polygon.pane",
  pane: "style.polygon.pane"
}, jn = ["marker-size", "stroke-width", "stroke-opacity", "fill-opacity"], oa = {
  isVisible: !0,
  isSelectable: !0,
  point: {
    color: "red",
    opacity: 0.5,
    size: 24,
    shape: "circle",
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    },
    icon: {
      classes: "",
      color: "black",
      opacity: 1,
      size: 12
    }
  },
  line: {
    color: "red",
    width: 3,
    opacity: 1
  },
  polygon: {
    color: "red",
    opacity: 0.5,
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    }
  },
  leaflet: {
    cluster: { disableClusteringAtZoom: 18 }
  },
  cesium: {
    cluster: { pixelRange: 80 }
  }
};
function $t(e, t, i = []) {
  let n = {};
  return o.forOwn(e, (r, s) => {
    const a = o.get(t, s);
    a && o.set(n, a, i.includes(a) ? o.toNumber(r) : r);
  }), n;
}
function gs(e) {
  return o.forOwn(e, (t, i) => {
    if (["stroke", "fill", "marker-color"].includes(i)) {
      const n = Eo(t);
      n && o.set(e, i, n);
    }
  }), e;
}
function Qd(e) {
  return e ? Object.assign($t(e.icon, qd, jn), $t(e, Gd, jn)) : {};
}
function li(e) {
  return e ? $t(e, Kd) : {};
}
function aa(e) {
  return e ? $t(e, Hd, jn) : {};
}
function ci(e) {
  return e ? $t(e, Wd) : {};
}
function Yd(e) {
  return e ? Object.assign($t(e, Zd, jn), aa(e.stroke)) : {};
}
function ui(e) {
  return e ? $t(e, Jd) : {};
}
function g0(e, t = [20, 20]) {
  let i = o.get(e, "stroke");
  if (i) {
    let n = o.get(i, "width", 1);
    n > 1 && (n = n / 4), i = { stroke: { width: n } };
  }
  return o.merge({}, e, { size: t }, i);
}
function p0(e, t = [20, 20]) {
  let i = o.get(e, "width", 1);
  return i > 1 && (i = i / 4), { shape: "polyline", stroke: o.merge({}, e, { width: i }), size: t };
}
function y0(e, t = [20, 20]) {
  let i = o.get(e, "stroke");
  if (i) {
    let n = o.get(i, "width", 1);
    n > 1 && (n = n / 4), i = { stroke: { width: n } };
  }
  return o.merge({}, e, { shape: "polygon" }, { size: t }, i);
}
function ps(e) {
  const t = {};
  return e = sn(e), o.forIn(e, (i, n) => {
    if (!o.isString(i)) {
      o.set(t, n, i);
      return;
    }
    const r = i.match(/} else { %>(.*)<% } %>/);
    r ? o.set(t, n, r[1]) : o.set(t, n, i);
  }), t;
}
function la(e, t, i = !0) {
  const n = t.length > 0, r = {}, s = o.keys(sn(o.pick(oa, ["point", "line", "polygon"]))), a = s.map((l) => "");
  return t.forEach((l) => {
    let c = "";
    l.conditions.forEach((u, d) => {
      const f = d === 0 ? "" : u.booleanOperator === "and" ? " && " : " || ", h = typeof u.value != "number" ? `${u.property}.toString()` : u.property;
      if (["in", "nin"].includes(u.comparisonOperator)) {
        const g = u.value.map((x) => typeof x != "number" ? `"${x}"` : x).join(","), v = u.comparisonOperator === "nin" ? "!" : "";
        c += `${f}${v}[${g}].includes(properties.${h})`;
      } else {
        const g = { eq: "===", ne: "!==", gt: ">", gte: ">=", lt: "<", lte: "<=" }[u.comparisonOperator], v = typeof u.value != "number" ? `"${u.value}"` : u.value;
        c += `${f}properties.${h} ${g} ${v}`;
      }
    }), s.forEach((u, d) => {
      if (!o.has(l.values, u)) return;
      const f = u.includes("color") ? Nr(o.get(l.values, u)) : o.get(l.values, u);
      a[d] += `if (${c}) { %>${f}<% } else `;
    });
  }), s.forEach((l, c) => {
    if (!o.has(e, l)) return;
    const u = l.includes("color") ? Nr(o.get(e, l)) : o.get(e, l);
    n ? a[c] += `{ %>${u}<% }` : a[c] = u;
  }), s.forEach((l, c) => {
    o.has(e, l) && (i ? r[`style.${l}`] = n ? `<% ${a[c]} %>` : a[c] : o.set(r, `style.${l}`, n ? `<% ${a[c]} %>` : a[c]));
  }), r.template = (n ? s : []).map((l) => `style.${l}`), r;
}
function ca(e) {
  const t = (n, r, s = null) => {
    if (!n) return;
    const a = o.keys(n)[0];
    let l, c, u;
    a === "$and" || a === "$or" ? (l = o.keys(n[a][0])[0], c = o.keys(n[a][0][l])[0], u = n[a][0][l][c]) : (l = o.keys(n)[0], o.isObject(n[l]) ? (c = o.keys(n[l])[0], u = n[l][c]) : (c = "$eq", u = n[l])), r.push({
      index: r.length,
      booleanOperator: s && s.replace("$", ""),
      property: l.replace("properties.", ""),
      comparisonOperator: c.replace("$", ""),
      value: u
    }), (a === "$and" || a === "$or") && t(n[a][1], r, a);
  }, i = [];
  return t(e, i), i;
}
const v0 = B.Marker.extend({
  // Constructor
  initialize(e, t) {
    const i = o.get(t, "options", {});
    if (Object.assign(i, o.pick(t, ["interactive", "draggable", "pane", "shadowPane"])), t.icon instanceof B.Icon)
      B.Marker.prototype.initialize.call(this, e, {
        icon: t.icon,
        ...i
      });
    else {
      const n = rd(t);
      n ? B.Marker.prototype.initialize.call(this, e, {
        icon: B.divIcon({
          iconSize: [n.size.width, n.size.height],
          iconAnchor: this.getAnchor(n.anchor, n.size),
          popupAnchor: [0, -n.size.height / 2],
          html: n.html,
          className: ""
        }),
        ...i
      }) : z.warn(`[KDK] unable to create the shape with the options: ${t}`);
    }
  },
  getAnchor(e, t) {
    return e === "top-left" ? [0, 0] : e === "top-center" ? [t.width / 2, 0] : e === "top-right" ? [t.width, 0] : e === "middle-left" ? [0, t.height / 2] : e === "middle-right" ? [t.width, t.height / 2] : e === "middle-left" ? [0, t.height / 2] : e === "bottom-left" ? [0, t.height] : e === "bottom-center" ? [t.width / 2, t.height] : e === "bottom-right" ? [t.width, t.height] : [t.width / 2, t.height / 2];
  },
  // Additional missing features
  bringToFront() {
    this._icon && B.DomUtil.toFront(this._icon), this._shadow && B.DomUtil.toFront(this._shadow);
  },
  bringToBack() {
    this._icon && B.DomUtil.toBack(this._icon), this._shadow && B.DomUtil.toBack(this._shadow);
  }
});
B.shapeMarker = function(e, t) {
  return new v0(e, t);
};
const co = {
  "z-index": "pane",
  pane: "pane",
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "weight",
  fill: "fillColor",
  "fill-opacity": "fillOpacity",
  "fill-color": "fillColor",
  weight: "weight",
  radius: "radius",
  "line-cap": "lineCap",
  "line-join": "lineJoin",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-x-offset": "style.point.icon.xOffset",
  "icon-y-offset": "style.point.icon.yOffset",
  "style-line-color": "color",
  "style-line-width": "weight",
  "style-line-opacity": "opacity",
  "style-line-cap": "lineCap",
  "style-line-join": "lineJoin",
  "style-line-dash-array": "dashArray",
  "style-line-dash-offset": "dashOffset",
  "style-polygon-color": "fillColor",
  "style-polygon-opacity": "fillOpacity",
  "style-polygon-rule": "fillRule",
  "style-polygon-stroke-color": "color",
  "style-polygon-stroke-width": "weight",
  "style-polygon-stroke-opacity": "opacity",
  "style-polygon-stroke-cap": "lineCap",
  "style-polygon-stroke-join": "lineJoin",
  "style-polygon-stroke-dash-array": "dashArray",
  "style-polygon-stroke-dash-offset": "dashOffset"
}, b0 = {
  color: "color",
  width: "weight",
  opacity: "opacity",
  cap: "lineCap",
  join: "lineJoin",
  dashArray: "dashArray",
  dashOffset: "dashOffset",
  pane: "pane"
}, w0 = {
  color: "fillColor",
  opacity: "fillOpacity",
  rule: "fillRule",
  pane: "pane"
};
function _0(e, t) {
  if (!e) return {};
  const i = t ? e : {};
  let n = o.has(e, "icon");
  return n && o.set(i, "icon", o.get(e, "icon")), o.forOwn(e, (r, s) => {
    if (o.has(co, s)) {
      const a = o.get(co, s);
      switch (s) {
        case "marker-size":
        case "marker-anchor":
        case "icon-anchor":
          Array.isArray(r) || (r = [r, r]), o.set(i, a, r);
          break;
        default:
          o.set(i, a, r);
      }
      t && o.unset(e, s), a.startsWith("icon") && (n = !0);
    }
  }), n && (o.has(e, "marker.type") || (o.has(e, "icon-url") || o.has(e, "icon-html") ? o.set(i, "type", "marker") : o.has(e, "icon-classes") && o.set(i, "type", "shapeMarker"))), o.has(i, "pane") && o.set(i, "pane", o.get(i, "pane").toString()), o.has(i, "shadowPane") && o.set(i, "shadowPane", o.get(i, "shadowPane").toString()), i;
}
function ua(e, t) {
  if (!e) {
    z.warn("[KDK] 'latlng' should be defined");
    return;
  }
  const i = o.get(t, "shape", "circle");
  return i === "none" || o.has(Xi, i) ? B.shapeMarker(e, t) : B[i](e, t);
}
function da(e) {
  if (!e) return;
  let t = $t(e, b0);
  return t.color = Ut(t.color, "black"), t;
}
function fa(e) {
  if (!e) return;
  let t = $t(e, w0);
  return e.stroke ? Object.assign(t, da(e.stroke)) : t.stroke = !1, t.fillColor = Ut(t.fillColor, "black"), t;
}
function ha(e, t, i, n, r) {
  if (!i) return;
  const s = i.leaflet || i, a = Object.assign({ properties: t.properties, feature: t, zoom: r, chroma: Pt, moment: fe, Units: be, Time: pe }, us.get());
  s.template && (i.variables && (a.variables = o.reduce(
    i.variables,
    (u, d) => Object.assign(u, { [d.name]: d }),
    {}
  )), s.template.forEach((u) => {
    o.set(e, o.get(n, o.kebabCase(u.property), u.property), u.compiler(a));
  }));
  const l = an(t);
  let c = o.get(e, `style.${l}.visibility`, o.get(e, "style.visibility", !0));
  return typeof c == "string" && (c = c === "true"), c || o.set(e, `style.${l}.pane`, "kdk-hidden-features"), s.pane && !o.has(e, `style.${l}.pane`) && o.set(e, `style.${l}.pane`, s.pane), s.shadowPane && !o.has(e, `style.${l}.shadowPane`) && o.set(e, `style.${l}.shadowPane`, s.shadowPane), o.has(s, "interactive") && !o.has(e, `style.${l}.interactive`) && o.set(e, `style.${l}.interactive`, s.interactive), e;
}
function ma(e, t, i = {}, n) {
  const r = t ? o.get(t.leaflet || t, "layerPointStyle") : {}, s = ha({ style: { point: o.merge({}, i, r) } }, e, t, na, n), a = o.get(t, "ignoreFeatureStyle") ? {} : e.style ? o.get(e, "style", {}) : li(e.properties);
  return o.merge({}, i, r, s ? s.style.point : {}, a);
}
function ga(e, t, i = {}, n) {
  const r = t ? o.get(t.leaflet || t, "layerLineStyle") : {}, s = ha({ style: { line: o.merge({}, i, r) } }, e, t, ra, n), a = o.get(t, "ignoreFeatureStyle") ? {} : e.style ? o.get(e, "style", {}) : ci(e.properties), l = o.merge({}, i, r, s ? s.style.line : {}, a);
  return da(l);
}
function pa(e, t, i = {}, n) {
  const r = t ? o.get(t.leaflet || t, "layerPolygonStyle") : {}, s = ha({ style: { polygon: o.merge({}, i, r) } }, e, t, sa, n), a = o.get(t, "ignoreFeatureStyle") ? {} : e.style ? o.get(e, "style", {}) : ui(e.properties), l = o.merge({}, i, r, s ? s.style.polygon : {}, a);
  return fa(l);
}
function Mt(e) {
  return e.x * 536870912 + e.y * 32 + e.z;
}
function L0(e) {
  const t = Math.floor(e / 536870912), i = Math.floor((e - t * 536870912) / 32), n = L.point(t, i);
  return n.z = e - (t * 536870912 + i * 32), n;
}
function Xd(e, t) {
  const i = {
    x: t.x,
    y: t.y,
    z: t.z
  };
  for (; i.z > 1; ) {
    const n = Mt(i);
    if (e.has(n)) return !0;
    i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1;
  }
  return !1;
}
function ef(e, t) {
  const i = {
    x: t.x,
    y: t.y,
    z: t.z
  };
  for (i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1; i.z > 1; ) {
    const n = Mt(i);
    if (e.has(n)) return i;
    i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), i.z -= 1;
  }
}
function x0(e, t, i) {
  const n = t.getNorthWest();
  let r = 1;
  for (; ; ) {
    const a = e._map.project(n, r).unscaleBy(e.getTileSize());
    a.x = Math.floor(a.x), a.y = Math.floor(a.y), a.z = r;
    const l = e._tileCoordsToBounds(a), c = l.getEast() - l.getWest(), u = l.getNorth() - l.getSouth();
    if (c < i.lng || u < i.lat) break;
    r += 1;
  }
  return Math.max(1, r - 1);
}
const tf = ["actions", "label", "isVisible", "isDisabled"];
function At(e) {
  return e._id === void 0;
}
function fi(e) {
  return o.get(e, "scope") === "user";
}
function on(e) {
  return o.get(e, "service") === "features";
}
function nf(e) {
  return o.has(e, "schema");
}
function rf(e) {
  return o.get(e, "isSelectable", !0);
}
function sf(e) {
  return o.get(e, "isHighlightable", !0);
}
function of(e) {
  return o.get(e, "isProbable", !1);
}
function af(e) {
  return e._id ? !1 : o.get(e, "isStorable", fi(e));
}
function lf(e) {
  return o.get(e, "isEditable", fi(e));
}
function ys(e) {
  return o.get(e, "isCachable", e.type === "BaseLayer" || o.has(e, "service") || o.get(e, "leaflet.type") === "pmtiles" || o.get(e, "leaflet.type") === "geoJson");
}
async function cf(e) {
  return await Ce.has(o.get(e, "leaflet.source"));
}
async function ya(e, t) {
  ys(e) && (e.type === "BaseLayer" ? await uf(e, t) : e.service ? await S0(e, t) : o.get(e, "leaflet.type") === "geoJson" ? await df(e) : o.get(e, "leaflet.type") === "pmtiles" && await hf(e, t));
}
async function Ks(e, t, i, n) {
  const r = e.replace("{z}", n).replace("{x}", t).replace("{y}", i), s = new URL(r);
  s.searchParams.delete("jwt"), await Ce.set("layers", s.href, r);
}
async function uf(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || o.get(e, "leaflet.maxNativeZoom"), s = t.nbConcurrentRequests || 10, a = o.get(e, "leaflet.source");
  let l = [];
  for (let c = n; c <= r; c++) {
    let d = new rs().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], c, o.get(e, "leaflet.tms"));
    for (let f = d.minY; f <= d.maxY; f++)
      for (let h = d.minX; h <= d.maxX; h++)
        l.push(Ks(a, h, f, c)), l.length === s && (await Promise.all(l), l = []);
  }
  l.push(Ks(a, 0, 0, 0)), e.iconUrl && l.push(Ks(e.iconUrl)), await Promise.all(l);
}
async function S0(e, t) {
  await q.createOfflineFeaturesService(e.service, {
    baseQuery: {
      south: t.bounds[0][0],
      north: t.bounds[1][0],
      west: t.bounds[0][1],
      east: t.bounds[1][1]
    },
    clear: !1
  });
}
async function df(e) {
  const t = o.get(e, "leaflet.source");
  let i = new URL(t);
  i.searchParams.delete("jwt"), await Ce.set("layers", i.href, t);
}
async function ff(e, t, i, n, r) {
  const s = em(n, t, i), a = await e.getHeader();
  let l = a.rootDirectoryOffset, c = a.rootDirectoryLength;
  for (let u = 0; u <= 3; u++) {
    r.add(`${l}-${l + c - 1}`);
    const d = await e.cache.getDirectory(e.source, l, c, a), f = tm(d, s);
    if (f) {
      if (f.runLength > 0)
        return {
          start: a.tileDataOffset + f.offset,
          end: a.tileDataOffset + f.offset + f.length - 1
        };
      l = a.leafDirectoryOffset + f.offset, c = f.length;
    } else
      return;
  }
}
async function C0(e, t, i, n, r, s) {
  const a = new URL(e);
  if (a.searchParams.delete("jwt"), !await t.getZxy(r, i, n)) return;
  const c = await ff(t, i, n, r, s);
  await Ce.set("layers", `${a.href}/${c.start}/${c.end}`, e, { headers: { Range: `bytes=${c.start}-${c.end}` } });
}
async function E0(e, t, i) {
  const n = new URL(e);
  n.searchParams.delete("jwt"), await Ce.set("layers", `${n.href}/0/16383`, e, { headers: { Range: "bytes=0-16383" } }), i = Array.from(i);
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    await Ce.set("layers", `${n.href}/${s.replace("-", "/")}`, e, { headers: { Range: `bytes=${s}` } });
  }
}
async function hf(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || o.get(e, "leaflet.maxDataZoom"), s = t.nbConcurrentRequests || 10, a = o.get(e, "leaflet.url"), l = new Ec(a), c = /* @__PURE__ */ new Set(), u = Pc(e.leaflet);
  let d = [];
  for (let f = n; f <= r; f++) {
    let g = new rs().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], f, o.get(e, "leaflet.tms"));
    for (let v = g.minY; v <= g.maxY; v++)
      for (let x = g.minX; x <= g.maxX; x++)
        for (const [w, M] of u) {
          const p = M.dataTileForDisplayTile({ x, y: v, z: f });
          d.push(C0(a, l, p.dataTile.x, p.dataTile.y, p.dataTile.z, c)), d.length === s && (await Promise.all(d), d = []);
        }
  }
  await E0(a, l, c), await Promise.all(d);
}
async function va(e, t) {
  ys(e) && (e.type === "BaseLayer" ? await T0(e, t) : e.service ? await P0(e, t) : o.get(e, "leaflet.type") === "geoJson" ? await k0(e) : o.get(e, "leaflet.type") === "pmtiles" && await D0(e, t));
}
async function Hs(e, t, i, n) {
  const r = e.replace("{z}", n).replace("{x}", t).replace("{y}", i), s = new URL(r);
  s.searchParams.delete("jwt"), await Ce.unset("layers", s.href);
}
async function T0(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || o.get(e, "leaflet.maxNativeZoom"), s = o.get(e, "leaflet.source");
  for (let a = n; a <= r; a++) {
    let c = new rs().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], a, o.get(e, "leaflet.tms"));
    for (let u = c.minY; u <= c.maxY; u++)
      for (let d = c.minX; d <= c.maxX; d++)
        await Hs(s, d, u, a);
  }
  await Hs(s, 0, 0, 0), e.iconUrl && await Hs(e.iconUrl);
}
async function P0(e, t) {
  const n = (await Ce.getItem("services") || {})[e.service];
  n && await q.getOfflineService(e.service, n.context).remove(null, {
    query: {
      south: t.bounds[0][0],
      north: t.bounds[1][0],
      west: t.bounds[0][1],
      east: t.bounds[1][1]
    }
  });
}
async function k0(e) {
  const t = o.get(e, "leaflet.source");
  let i = new URL(t);
  i.searchParams.delete("jwt"), await Ce.unset("layers", i.href);
}
async function M0(e, t, i, n, r, s) {
  const a = new URL(e);
  if (a.searchParams.delete("jwt"), !await t.getZxy(r, i, n)) return;
  const c = await ff(t, i, n, r, s);
  await Ce.unset("layers", `${a.href}/${c.start}/${c.end}`);
}
async function F0(e, t, i) {
  const n = new URL(e);
  n.searchParams.delete("jwt"), await Ce.unset("layers", `${n.href}/0/16383`), i = Array.from(i);
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    await Ce.unset("layers", `${n.href}/${s.replace("-", "/")}`);
  }
}
async function D0(e, t) {
  const i = t.bounds, n = t.minZoom || 3, r = t.maxZoom || o.get(e, "leaflet.maxDataZoom"), s = o.get(e, "leaflet.url"), a = new Ec(s), l = /* @__PURE__ */ new Set(), c = Pc(e.leaflet);
  for (let u = n; u <= r; u++) {
    let f = new rs().xyz([i[0][1], i[0][0], i[1][1], i[1][0]], u, o.get(e, "leaflet.tms"));
    for (let h = f.minY; h <= f.maxY; h++)
      for (let g = f.minX; g <= f.maxX; g++)
        for (const [v, x] of c) {
          const w = x.dataTileForDisplayTile({ x: g, y: h, z: u });
          await M0(s, a, w.dataTile.x, w.dataTile.y, w.dataTile.z, l);
        }
  }
  await F0(s, a, l);
}
function mf(e) {
  return o.get(e, "isRemovable", fi(e));
}
function gf(e) {
  return o.get(e, "isStyleEditable", fi(e));
}
function pf(e) {
  return o.get(e, "isDataEditable", fi(e) && on(e));
}
function yf(e) {
  return o.get(e, "isFilterEditable", fi(e) && on(e));
}
function wi(e) {
  if (e.type === "TerrainLayer") return !0;
  const t = e.cesium || e;
  return t.type === "Cesium" || t.type === "Ellipsoid";
}
function vf(e) {
  return e.variables && e.service;
}
async function bf(e) {
  const t = o.get(e, "filters", []);
  if (!t.length) return [];
  const i = q.getService("styles"), n = [];
  for (const r of t)
    r.style && n.push({
      conditions: ca(r.active),
      values: o.isObject(r.style) ? r.style : await i.get(r.style)
    });
  return n;
}
async function wf(e, t) {
  const i = await bf(e);
  if (!i.length) return;
  const n = la(t, i);
  return Object.assign(
    {},
    o.mapKeys(n, (s, a) => `leaflet.${a}`),
    o.mapKeys(n, (s, a) => `cesium.${a}`)
  );
}
async function _f(e, t, i = !1) {
  if (t = o.pick(t, ["point", "line", "polygon"]), e._id) {
    const n = await wf(e, t);
    if (n)
      Object.assign(n, await kn(Object.assign({}, e, n))), i && (n.ignoreFeatureStyle = !0), await q.getService("catalog").patch(e._id, n);
    else {
      const r = await kn(Object.assign({}, e, { "cesium.style": t, "leaflet.style": t })), s = Object.assign({}, { "cesium.style": t, "leaflet.style": t }, r);
      i && (s.ignoreFeatureStyle = !0), await q.getService("catalog").patch(e._id, s);
    }
  } else
    o.set(e, "cesium.style", t), o.set(e, "leaflet.style", t), Object.assign(e, await kn(e)), i && (e.ignoreFeatureStyle = !0);
  return e;
}
async function A0(e) {
  if (!e._id) return;
  const t = ps(o.get(e, "leaflet.style", {})), i = await wf(e, t);
  i && await q.getService("catalog").patch(e._id, i);
}
async function O0(e, t, i, n, r = !1) {
  if (!e._id) return;
  const s = ps(o.get(e, "leaflet.style", {})), a = await bf(e), l = ca(t.active);
  o.forEach(a, (f) => {
    o.isEqual(f.conditions, l) && (f.values = n);
  });
  const c = la(o.merge({}, oa, i, s), a), u = o.cloneDeep(o.get(e, "filters", []));
  o.forEach(u, (f) => {
    o.isEqual(f.label, t.label) && o.isEqual(f.active, t.active) && (f.style = n._id);
  });
  const d = Object.assign(
    {},
    o.mapKeys(c, (f, h) => `leaflet.${h}`),
    o.mapKeys(c, (f, h) => `cesium.${h}`),
    { filters: u }
  );
  r && (d.ignoreFeatureStyle = !0), Object.assign(d, await kn(Object.assign({}, e, { filters: u }))), await q.getService("catalog").patch(e._id, d);
}
async function B0(e) {
  const t = o.get(e, "filters", []);
  if (!t.length) return [];
  const i = q.getService("styles"), n = [];
  for (const r of t) {
    const s = o.cloneDeep(r);
    r.style && (s.linkedStyle = o.isObject(r.style) ? r.style : await i.get(r.style)), n.push(s);
  }
  return n;
}
async function kn(e) {
  const t = (n, r) => {
    if (o.has(n, "legend"))
      o.isArray(o.get(n, "legend")) ? o.forEach(n.legend, (s) => {
        i(s, r);
      }) : i(n.legend, r);
    else {
      const s = [{ shape: "circle", type: "point" }, { shape: "polyline", type: "line" }, { shape: "rect", type: "polygon" }];
      n.legend = {
        type: "symbols",
        label: o.get(e, "label", o.get(e, "name")),
        content: {
          symbols: o.map(s, (a) => ({
            symbol: { "media/KShape": { options: o.merge({ shape: a.shape }, o.omit(o.get(r, a.type), ["size"])) } },
            label: o.get(n, "label", o.get(n, "name"))
          }))
        }
      };
    }
  }, i = (n, r) => {
    n.type === "symbols" && n.content && n.content.symbols && o.forEach(n.content.symbols, (s) => {
      if (s.symbol && s.symbol["media/KShape"] && s.symbol["media/KShape"].options)
        switch (s.symbol["media/KShape"].options.shape) {
          case "rect":
            s.symbol["media/KShape"].options = o.omit(o.merge({ shape: "rect" }, o.get(r, "polygon")), ["size"]);
            break;
          case "polyline":
            s.symbol["media/KShape"].options = o.omit(o.merge({ shape: "polyline" }, o.get(r, "line")), ["size"]);
            break;
          default:
            s.symbol["media/KShape"].options = o.omit(o.merge({ shape: "circle" }, o.get(r, "point")), ["size"]);
            break;
        }
    });
  };
  if (o.has(e, "filters") && !o.isEmpty(e.filters)) {
    const n = await B0(e);
    let r = !1;
    o.forEach(n, (a) => {
      o.has(a, "linkedStyle") && (r = !0, t(a, a.linkedStyle));
    });
    const s = { filters: o.map(n, (a) => o.omit(a, "linkedStyle")) };
    return r && Object.assign(s, { $unset: { legend: "" } }), s;
  } else {
    const n = ps(o.get(e, "leaflet.style", {}));
    return t(e, n), { legend: e.legend };
  }
}
function ba(e, t) {
  if (t.type !== "FeatureCollection" && t.type !== "Feature") {
    z.error("invalid geoJson content");
    return;
  }
  const i = {
    type: "geoJson",
    isVisible: !0,
    realtime: !0
  }, n = {
    type: "OverlayLayer",
    scope: "user",
    isDataEditable: !0,
    leaflet: i,
    // Avoid sharing reference to the same object although options are similar
    // otherwise updating one will automatically update the other one
    cesium: Object.assign({}, i)
  };
  if (o.defaults(e, n), !e.schema) {
    const r = $f(t, e.name);
    e.schema = { name: e.name, content: r };
  }
  if (e.featureId || (t.type === "FeatureCollection" ? o.forEach(t.features, (r) => {
    r._id = Gt().toString();
  }) : t._id = Gt().toString()), t.type === "FeatureCollection" && (o.defaultsDeep(e, o.omit(t, ["type", "properties", "features"])), !o.has(e, "leaflet.panes"))) {
    const r = [];
    o.forEach(t.features, (s) => {
      const a = o.get(s, "style.pane");
      a && r.push({
        name: a
      });
    }), o.isEmpty(r) || o.set(e, "leaflet.panes", r);
  }
  return !0;
}
async function Lf(e, t, i = 5e3) {
  const n = _a(t);
  if (n.kinks.length > 0) {
    const l = await qo({
      title: Y.t("utils.layers.INVALID_FEATURES_DIALOG_TITLE", { total: n.kinks.length }),
      message: Y.t("utils.layers.INVALID_FEATURES_DIALOG_MESSAGE", { total: n.kinks.length }),
      options: {
        type: "toggle",
        model: [],
        items: [
          { label: Y.t("utils.layers.DOWNLOAD_INVALID_FEATURES_LABEL"), value: "download" }
        ]
      },
      html: !0,
      ok: {
        label: Y.t("OK"),
        flat: !0
      },
      cancel: {
        label: Y.t("CANCEL"),
        flat: !0
      }
    });
    if (!l.ok) return;
    o.get(l, "data", []).includes("download") && ud(
      JSON.stringify({ type: "FeatureCollection", features: n.kinks }),
      Y.t("utils.layers.INVALID_FEATURES_FILE"),
      "application/json;charset=utf-8;"
    );
  }
  o.set(e, "service", "features"), o.has(e, "leaflet") && o.set(e, "leaflet.source", "/api/features"), o.has(e, "cesium") && o.set(e, "cesium.source", "/api/features");
  const r = Ie(t);
  let s = 0;
  r.forEach((l) => {
    s += Md(l).features.length;
  }), s > 5e3 && (o.set(e, "leaflet.tiled", !0), o.set(e, "leaflet.minZoom", 15)), Re.show({ message: Y.t("utils.layers.SAVING_LABEL", { processed: 0, total: r.length }), html: !0 });
  let a;
  try {
    a = await q.getService("catalog").create(o.omit(e, tf));
    let l = 0;
    await La(t, a, i, (c, u) => {
      l += u.length, Re.show({
        message: Y.t("utils.layers.SAVING_LABEL", { processed: l, total: r.length }),
        html: !0
      });
    }), a = await q.getService("catalog").patch(a._id, { baseQuery: { layer: a._id } }), o.get(e, "leaflet.tiled") && Xe.create({ type: "positive", message: Y.t("utils.layers.SAVE_DIALOG_MESSAGE"), timeout: 1e4, html: !0 });
  } catch (l) {
    z.error(`[KDK] ${l}`);
  }
  return Re.hide(), a;
}
async function xf(e) {
  return e = await q.getService("catalog").create(o.omit(e, tf)), e;
}
async function Sf(e) {
  if (!(await qo({
    title: Y.t("utils.layers.REMOVE_DIALOG_TITLE", { layer: e.label || e.name }),
    message: Y.t("utils.layers.REMOVE_DIALOG_MESSAGE", { layer: e.label || e.name }),
    html: !0,
    ok: {
      label: Y.t("OK"),
      flat: !0
    },
    cancel: {
      label: Y.t("CANCEL"),
      flat: !0
    }
  })).ok) return !1;
  Re.show({ message: Y.t("utils.layers.REMOVING_LABEL"), html: !0 });
  try {
    e._id && (on(e) && await xa(null, e), await q.getService("catalog").remove(e._id));
  } catch (i) {
    z.error(`[KDK] ${i}`);
  }
  return Re.hide(), !0;
}
function Jn(e, t) {
  const i = Ie(e);
  if (typeof t == "function")
    i.forEach((n) => t(n));
  else if (typeof t == "string") {
    const n = o.template(t);
    i.forEach((r) => n({ feature: r, properties: r.properties }));
  }
}
function vs(e, t) {
  Ie(e).forEach((n) => {
    const r = o.get(t, "scale"), s = o.get(t, "rotate"), a = o.get(t, "translate");
    r && a0(
      n,
      r.factor,
      Object.assign(o.omit(r, ["factor"]), { mutate: !0 })
    ), s && s0(
      n,
      s.angle,
      Object.assign(o.omit(s, ["angle"]), { mutate: !0 })
    ), a && (a.point && (a.distance = Xo(a.pivot || [0, 0], a.point), a.direction = Yo(a.pivot || [0, 0], a.point), delete a.pivot, delete a.point), c0(
      n,
      a.distance,
      a.direction,
      Object.assign(o.omit(a, ["direction", "distance"]), { mutate: !0 })
    ));
  });
}
async function Cf(e, t) {
  const i = t.build.variable;
  if (!e || e.type !== "FeatureCollection") {
    console.error("Invalid GeoJSON, a FeatureCollection is required to build a gradient path");
    return;
  }
  if (!i.chromajs.colors) {
    console.error(`Invalid chromajs on variable ${i.name}, missing colors.`);
    return;
  }
  let n;
  if (i.chromajs.domain ? n = Pt.scale(i.chromajs.colors).domain(i.chromajs.domain) : i.chromajs.classes && (n = Pt.scale(i.chromajs.colors).classes(i.chromajs.classes)), !n) {
    console.error(`Invalid chromajs on variable ${i.name}, missing domain or classes.`);
    return;
  }
  e.features = e.features.map((r) => {
    const s = r.geometry.geometries.map((c) => c.coordinates), l = r.properties[i.name].map((c) => n(c).hex());
    return s.length < 2 ? {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: [s[0], s[0]]
      },
      properties: Object.assign({ gradient: [l[0], l[0]] }, o.omit(r.properties, i.name), i.gradientPath.properties)
    } : {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: s
      },
      properties: Object.assign({ gradient: l }, o.omit(r.properties, i.name), i.gradientPath.properties)
    };
  }), e.total = e.features.length;
}
async function R0(e) {
  const t = ["gradientPath"];
  if (e.variables)
    for (const i of t) {
      const n = o.find(e.variables, (r) => o.has(r, i));
      if (n)
        return { instruct: i, variable: n };
    }
}
async function bs(e) {
  const t = {};
  if (e.baseQuery)
    if (typeof e.baseQuery == "function") {
      const i = await e.baseQuery();
      if (i) Object.assign(t, i);
      else return;
    } else
      Object.assign(t, e.baseQuery);
  return t;
}
async function ws(e) {
  const t = {};
  if (e.filterQuery)
    if (typeof e.filterQuery == "function") {
      const n = await e.filterQuery();
      Object.assign(t, n);
    } else
      Object.assign(t, e.filterQuery);
  const i = o.get(e, "filters", []);
  if (!o.isEmpty(i)) {
    const n = o.get(e, "filterOperators", { active: "$or", inactive: "$and" }), r = i.filter((a) => a.isActive).map((a) => a.active).filter((a) => !o.isEmpty(a));
    o.isEmpty(r) || (t[n.active] = r);
    const s = i.filter((a) => !a.isActive).map((a) => a.inactive).filter((a) => !o.isEmpty(a));
    o.isEmpty(s) || (t[n.inactive] = s);
  }
  return t;
}
async function _s(e) {
  const t = {};
  if (e.sortQuery)
    if (typeof e.sortQuery == "function") {
      const i = await e.sortQuery();
      Object.assign(t, i);
    } else
      Object.assign(t, e.sortQuery);
  return { $sort: t };
}
function Ls(e) {
  const t = o.get(e, "every");
  return t ? fe.duration(t) : null;
}
function xs(e) {
  const t = Ls(e);
  let i = o.get(e, "queryFrom");
  return !i && t && (i = fe.duration(-2 * t.asMilliseconds())), i ? fe.duration(i) : null;
}
function Ef(e, t, i) {
  if (i || (i = Ls(t)), !i) return !0;
  const n = pe.getCurrentTime(), r = fe.duration(n.diff(e));
  return Math.abs(r.asMilliseconds()) < i.asMilliseconds();
}
async function Tf(e) {
  const t = await bs(e), i = await ws(e), n = await _s(e);
  Object.assign(t, i, n);
  const s = await (typeof e.getPlanetApi == "function" ? e.getPlanetApi() : q).getService(e.probeService).find(Object.assign({ query: t }, e.baseParams));
  return e.processor && Jn(s, e.processor), e.transform && vs(s, e.transform), s;
}
async function wa(e, t, i) {
  t || (t = xs(e));
  let n = await bs(e);
  const r = await R0(e);
  if (e.build = r, t) {
    r ? n = Object.assign({
      $groupBy: e.featureId,
      $aggregate: ["geometry", r.variable.name]
    }, n) : e.variables ? n = Object.assign({
      $groupBy: e.featureId,
      // Take care we might have multiple variables targetting the same value name
      // but that differentiate using others properties (compound feature ID)
      $aggregate: o.uniq(e.variables.map((c) => c.name))
    }, n) : e.featureId && (n = Object.assign({
      $groupBy: e.featureId,
      $aggregate: ["geometry"]
    }, n));
    const l = pe.getCurrentTime();
    if (fe.isDuration(t)) {
      const c = t.asMilliseconds() > 0 ? l.clone().subtract(t) : l.clone().add(t), u = l;
      Object.assign(n, {
        $sort: { time: -1, runTime: -1 },
        time: {
          $gte: c.toISOString(),
          $lte: u.toISOString()
        }
      }), e.featureId && !r && (n.$limit = 1);
    } else typeof t == "object" ? n.time = t : (Object.assign(n, {
      $sort: { time: -1, runTime: -1 },
      time: { $lte: l.toISOString() }
    }), e.featureId && !r && (n.$limit = 1));
  }
  o.isNil(i) || (n.level = i);
  const s = await ws(e), a = await _s(e);
  return o.merge(n, s, a), n;
}
function Pf(e, t) {
  if (!e.time) return !0;
  const i = xs(t);
  if (!fe.isDuration(i)) return !0;
  const n = pe.getCurrentTime(), r = fe.utc(e.time), s = i.asMilliseconds() > 0 ? n.clone().subtract(i) : n.clone().add(i), a = n;
  return pe.isRealtime() && a.add(pe.get().interval, "s"), r.isSameOrAfter(s) && r.isSameOrBefore(a);
}
async function Hr(e, t) {
  const n = await (typeof e.getPlanetApi == "function" ? e.getPlanetApi() : q).getService(e.service).find(Object.assign({ query: t }, e.baseParams));
  if (e.processor && Jn(n, e.processor), e.transform && vs(n, e.transform), e.build) {
    switch (e.build.instruct) {
      case "gradientPath":
        await Cf(n, e);
        break;
    }
    delete e.build;
  }
  return n;
}
function Wr(e, t) {
  let i = e.chronicleId || e.featureId;
  i = Array.isArray(i) ? i : [i];
  const n = i.reduce(
    (r, s) => Object.assign(r, { ["properties." + s]: o.get(t, "properties." + s) }),
    {}
  );
  return n.$groupBy = i, n;
}
async function kf(e, t, i, n, r) {
  return await wa(o.merge({
    baseQuery: Wr(e, t)
  }, e), {
    $gte: i.toISOString(),
    $lte: n.toISOString()
  }, r);
}
async function Zr(e, t, i) {
  const n = await Hr(e, i);
  return o.get(n, "features[0]");
}
async function Mf(e, t, i, n, r) {
  let s;
  try {
    const a = await kf(e, t, i, n, r);
    s = await Zr(e, t, a);
  } catch (a) {
    z.error(a);
  }
  return s;
}
function _a(e, t = {
  kinks: !0,
  redundantCoordinates: !0
}) {
  const i = Ie(e);
  t.redundantCoordinates && i.forEach((r) => t0(r, { mutate: !0 }));
  let n;
  return t.kinks && (n = o.remove(i, (r) => {
    const s = Si(r);
    if (s === "MultiPolygon" || s === "Polygon") {
      const a = Xb(r);
      return o.get(a, "features", []).length > 0;
    } else
      return !1;
  })), { kinks: n };
}
async function La(e, t, i = 5e3, n) {
  if (!t) return;
  const r = Ie(e);
  if (r.forEach((s) => {
    delete s._id, s.layer = t._id;
  }), r.length === 1)
    return await q.getService(t.service).create(r[0]);
  {
    const s = [];
    let a = 0, l = [];
    r.forEach((c) => {
      const d = Md(c).features.length;
      a + d <= i ? (a += d, l.push(c)) : (l.length > 0 && s.push(l), l = [c], a = d);
    }), l.length > 0 && s.push(l);
    for (let c = 0; c < s.length; c++)
      await q.getService(t.service).create(s[c]), typeof n == "function" && await n(c, s[c]);
  }
}
async function Ff(e, t) {
  const i = Ie(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (s._id) {
      const a = await q.getService(t.service).patch(s._id, o.pick(s, ["geometry"]));
      n.push(a);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function Df(e, t) {
  const i = Ie(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (s._id) {
      const a = await q.getService(t.service).patch(s._id, o.pick(s, ["properties"]));
      n.push(a);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function Af(e, t) {
  const i = Ie(e), n = [];
  for (let r = 0; r < i.length; r++) {
    const s = i[r];
    if (t._id) {
      const a = await q.getService(t.service).patch(s._id, o.pick(s, ["style"]));
      n.push(a);
    }
  }
  return e.type === "FeatureCollection" ? Object.assign(e, { features: n }) : n;
}
async function xa(e, t) {
  if (!e)
    await q.getService(t.service).remove(null, { query: { layer: t._id } });
  else {
    const i = Ie(e);
    for (let n = 0; n < i.length; n++) {
      const r = i[n];
      r._id && await q.getService(t.service).remove(r._id);
    }
  }
}
async function si(e, t = {}) {
  const i = await fetch(e);
  if (i.status !== 200)
    throw new Error(`Impossible to fetch ${e}: ` + i.status);
  const n = await i.json();
  return t.processor && Jn(n, t.processor), t.transform && vs(n, t.transform), n;
}
function an(e) {
  const t = o.get(e, "geometry.type");
  if (!t) {
    z.warn("[KDK] feature has undefined geometry");
    return;
  }
  if (["Point", "MultiPoint"].includes(t)) return "point";
  if (["LineString", "MultiLineString"].includes(t)) return "line";
  if (["Polygon", "MultiPolygon"].includes(t)) return "polygon";
  z.warn(`[KDK] unsupported geometry of type of ${t}`);
}
function Qn(e, {
  context: t = null,
  created: i = null,
  updated: n = null,
  patched: r = null,
  removed: s = null,
  all: a = null
} = {}, l) {
  if (!e.service || At(e) || !on(e) && !e.serviceEvents) return;
  ln(e, l);
  const c = (u, d) => u ? (f, h) => {
    !Si(f) || !ri(f) || (f.layer ? f.layer === d._id && u(f, d, h) : u(f, d, h));
  } : null;
  return Ht(e.service, {
    context: t,
    created: c(i, e),
    updated: c(n, e),
    patched: c(r, e),
    removed: c(s, e),
    all: c(a, e)
  });
}
function ln(e, t) {
  Rt(t);
}
function Of(e) {
  let t, i;
  const n = /(-?\d+(?:\.\d+)?)°\s*([NSEW])\s+(-?\d+(?:\.\d+)?)°\s*([NSEW])/;
  let r = e.match(n);
  if (r)
    return r[2] === "N" || r[2] === "S" ? (i = parseFloat(r[1]), r[2] === "S" && (i = -i), t = parseFloat(r[3]), r[4] === "W" && (t = -t), { longitude: t, latitude: i }) : (t = parseFloat(r[1]), r[2] === "W" && (t = -t), i = parseFloat(r[3]), r[4] === "S" && (i = -i), { longitude: t, latitude: i });
  const s = /(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/;
  if (r = e.match(s), r)
    return t = parseFloat(r[1]), i = parseFloat(r[2]), { longitude: t, latitude: i };
}
function Ss(e, t, i, n) {
  if (i === "aeronautical") {
    const r = Xs(e, t), s = r.latValues.degreesInt.toString().padStart(2, "0"), a = Math.floor(r.latValues.secondsTotal / 6).toString().padStart(3, "0"), l = r.north ? "N" : "S", c = r.lonValues.degreesInt.toString().padStart(3, "0"), u = Math.floor(r.lonValues.secondsTotal / 6).toString().padStart(3, "0"), d = r.east ? "E" : "W";
    return `${s}${a}${l} ${c}${u}${d}`;
  }
  return Xs(e, t).format(i, n);
}
function Bf(e) {
  const t = e.properties;
  if (!t) {
    z.warn("[KDK] invalid geocoding result: missing 'properties' property");
    return;
  }
  let i = t.formattedAddress || "";
  if (i || (t.streetNumber && (i += t.streetNumber + ", "), t.streetName && (i += t.streetName + " "), t.city && (i += t.city + " "), t.zipcode && (i += " (" + t.zipcode + ")")), !i) {
    if (!o.has(e, "geokoder.matchProp")) {
      z.warn("[KDK] invalid geocoding result: missing 'geokoder.matchProp' property");
      return;
    }
    i = o.get(e, e.geokoder.matchProp, "");
  }
  return i;
}
function Rf(e, t) {
  return e.filter((i) => {
    const n = i.value || i;
    if (t && n.includes("kano:")) {
      const r = o.replace(n, /^(.*:)?kano:/g, "");
      let s = o.find(t.layers, { service: r });
      return s || (s = o.find(t.layers, { probeService: r })), s;
    }
    return !0;
  });
}
async function $0() {
  const e = await Ce.getItem("services");
  if (e) {
    const t = Object.keys(e);
    for (let i = 0; i < t.length; i++) {
      const n = t[i], r = e[n];
      r.features ? await q.createOfflineFeaturesService(n, { snapshot: !1, ...r }) : await q.createOfflineService(n, { snapshot: !1, ...r });
    }
  }
}
async function I0(e, t, i = {}) {
  const n = await Ce.getItem("views");
  n ? (n[e._id] = i, await Ce.setItem("views", n)) : await Ce.setItem("views", { [e._id]: i });
  const r = [{ type: { $nin: ["Context", "Service", "Category"] } }, { type: { $in: ["Context", "Service", "Category"] } }];
  await q.createOfflineService("catalog", {
    baseQueries: r
  }), i.contextId && await q.createOfflineService("catalog", {
    baseQueries: r,
    context: i.contextId
  });
  const s = { populate: !0 };
  await q.createOfflineService("projects", {
    baseQuery: s
  }), await q.createOfflineFeaturesService("features", {
    context: i.contextId
  });
  for (let a = 0; a < t.length; a++) {
    const l = t[a];
    await ya(l, Object.assign({ bounds: [[e.south, e.west], [e.north, e.east]] }, i));
  }
}
async function z0(e, t, i = {}) {
  const n = await Ce.getItem("views") || {};
  if (n[e._id]) {
    Object.assign(i, n[e._id] || {});
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      await va(s, Object.assign({ bounds: [[e.south, e.west], [e.north, e.east]] }, i));
    }
    if (delete n[e._id], o.isEmpty(n)) {
      await Ce.removeItem("views");
      const r = await Ce.getItem("services") || {}, s = Object.keys(r);
      for (let a = 0; a < s.length; a++) {
        const l = s[a], c = r[l];
        await q.getOfflineService(l, c.context).remove(null, { query: {} }), q.removeService(l, c.context);
      }
      await Ce.removeItem("services");
    } else
      await Ce.setItem("views", n);
  }
}
function Vn(e) {
  const t = { _id: { $in: o.map(o.filter(e.layers, "_id"), "_id") } }, i = { name: { $in: o.map(o.filter(e.layers, "name"), "name") } };
  return { $or: [t, i] };
}
function $f(e, t) {
  const i = {
    $id: `http://www.kalisio.xyz/schemas/${o.kebabCase(t)}#`,
    title: t,
    $schema: "http://json-schema.org/draft-07/schema#",
    type: "object",
    properties: {}
  };
  return Ie(e).forEach((r) => {
    const s = r.properties ? sn(r.properties) : {};
    o.forOwn(s, (a, l) => {
      if (i.properties["{key}"]) {
        const c = i.properties[`${l}`];
        o.isNil(c) && (i.properties[`${l}`] = a);
      } else
        i.properties[`${l}`] = a;
    });
  }), o.forOwn(i.properties, (r, s) => {
    let a = typeof r;
    (a === "object" || a === "undefined") && (a = "string"), i.properties[`${s}`] = {
      type: a,
      nullable: !0,
      field: {
        component: a === "number" ? "form/KNumberField" : a === "boolean" ? "form/KToggleField" : "form/KTextField",
        label: s
      }
    };
  }), i;
}
async function uo({ longitude: e, latitude: t, startTime: i, endTime: n, forecastModel: r, forecastLevel: s, weacastApi: a }) {
  if (!r) return;
  const l = {
    type: "Point",
    coordinates: [e, t]
  }, c = {
    forecastTime: {
      $gte: i.format(),
      $lte: n.format()
    },
    geometry: {
      $geoIntersects: {
        $geometry: l
      }
    }
  };
  let u;
  try {
    let d = r.elements.map((h) => h.name);
    s ? d = d.filter((h) => h.endsWith(s.toString())) : d = d.filter((h) => {
      const g = h.split("-");
      return g.length === 0 || !o.isFinite(o.toNumber(g[g.length - 1]));
    });
    const f = await a.getService("probes").create({
      forecast: r.name,
      elements: d
    }, { query: c });
    if (f.features.length > 0)
      u = f.features[0];
    else throw new Error("Cannot find valid forecast at location");
  } catch (d) {
    z.error(d);
  }
  return u;
}
async function If({ name: e, forecastModel: t, weacastApi: i }) {
  const n = await i.getService("probes").find({
    query: {
      name: e,
      forecast: t.name,
      $paginate: !1,
      $select: ["elements", "forecast", "featureId"]
    }
  });
  return n.length > 0 ? n[0] : null;
}
async function zf({ probe: e, featureId: t, startTime: i, endTime: n, forecastModel: r, forecastLevel: s, weacastApi: a }) {
  let l;
  try {
    let c = r.elements.map((h) => h.name);
    s ? c = c.filter((h) => h.endsWith(s.toString())) : c = c.filter((h) => {
      const g = h.split("-");
      return g.length === 0 || !o.isFinite(o.toNumber(g[g.length - 1]));
    });
    const u = s ? `windDirection-${s}` : "windDirection", d = s ? `windSpeed-${s}` : "windSpeed";
    c = c.concat([u, d]);
    const f = await a.getService("probe-results").find({
      query: {
        probeId: e._id,
        forecastTime: {
          $gte: i.format(),
          $lte: n.format()
        },
        [e.featureId]: t,
        $groupBy: e.featureId,
        $aggregate: c
      }
    });
    if (f.length > 0)
      l = f[0];
    else throw new Error("Cannot find valid forecast for feature");
  } catch (c) {
    z.error(c);
  }
  return l;
}
async function Jr(e, t, i, n) {
  e = await e;
  const r = o.get(e, "time", o.get(e, "forecastTime", {})), s = o.get(e, "runTime", {}), a = o.get(e, "properties", {}), l = i ? `${t.name}-${i}` : t.name;
  let c = [];
  return a[l] && Array.isArray(a[l]) && (c = a[l].map((u, d) => (u = be.convert(u, t.unit, t.targetUnit), { time: fe.utc(r[l][d]).valueOf(), [l]: u })), t.runTimes && n && !o.isEmpty(o.get(s, l)) ? c = c.filter((u, d) => s[l][d] === n.toISOString()) : c = o.uniqBy(c, "time")), c;
}
async function Zl({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  forecastModel: s,
  forecastLevel: a,
  weacastApi: l
}) {
  const { start: c, end: u } = pe.getRange();
  n || (n = c), r || (r = u);
  let d;
  if (!e)
    d = await uo({ longitude: t.lng, latitude: t.lat, startTime: n, endTime: r, forecastModel: s, forecastLevel: a, weacastApi: l });
  else if (i.probe) {
    const f = await If({ name: i.probe, forecastModel: s, weacastApi: l });
    f && (d = await zf({ probe: f, featureId: o.get(e, f.featureId), startTime: n, endTime: r, forecastModel: s, forecastLevel: a, weacastApi: l }));
  } else {
    const f = xi(e), h = o.get(f, "geometry.coordinates[0]"), g = o.get(f, "geometry.coordinates[1]");
    d = await uo({ longitude: h, latitude: g, startTime: n, endTime: r, forecastModel: s, forecastLevel: a, weacastApi: l });
  }
  return d;
}
async function Jl({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  level: s,
  probeFunction: a
}) {
  const { start: l, end: c } = pe.getRange();
  n || (n = l), r || (r = c);
  let u;
  return a ? u = await a({ feature: e, location: t, layer: i, level: s, startTime: n, endTime: r }) : vf(i) && (u = await Mf(i, e, n, r, s)), u;
}
function N0({
  feature: e,
  location: t,
  layer: i,
  startTime: n,
  endTime: r,
  runTime: s,
  forecastLayers: a,
  forecastModel: l,
  forecastLevel: c,
  weacastApi: u,
  fetchDelay: d
}) {
  let f = [];
  if (a && a.length > 0 && a.forEach((w) => {
    f = f.concat(o.get(w, "variables", []));
  }), f = o.uniqBy(f, "name"), f.length === 0) return [];
  const h = o.get(e, "properties", {}), g = Zl({
    feature: e,
    location: t,
    layer: i,
    startTime: n,
    endTime: r,
    forecastModel: l,
    forecastLevel: c,
    weacastApi: u
  }), v = o.debounce(() => Zl({
    feature: e,
    location: t,
    layer: i,
    startTime: n,
    endTime: r,
    forecastModel: l,
    forecastLevel: c,
    weacastApi: u
  }), d || 250, { leading: !0, trailing: !1 });
  return f.map((w) => {
    const M = o.get(h, "unit", w.unit), p = be.getUnit(M), y = be.getTargetUnit(M), S = {
      probedLocationData: g,
      data: Jr(g, w, c, s),
      variable: {
        name: w.name,
        label: `${Y.tie(w.label)} (${be.getTargetUnitSymbol(M)})`,
        unit: p,
        targetUnit: y,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: c ? `${w.name}-${c}` : w.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, o.cloneDeep(w.chartjs))
      }
    };
    return S.fetch = () => (S.probedLocationData = v(), S.data = Jr(S.probedLocationData, w, c, s), S.data), S;
  });
}
function j0({
  feature: e,
  location: t,
  layer: i,
  layers: n,
  startTime: r,
  endTime: s,
  runTime: a,
  level: l,
  probeFunction: c,
  fetchDelay: u
}) {
  let d = o.get(i, "variables", []);
  if (n && n.length > 0 && n.forEach((x) => {
    d = d.concat(o.get(x, "variables", []));
  }), d = o.uniqBy(d, "name"), d.length === 0) return [];
  const f = o.get(e, "properties", {}), h = Jl({
    feature: e,
    location: t,
    layer: i,
    startTime: r,
    endTime: s,
    level: l,
    probeFunction: c
  }), g = o.debounce(() => Jl({
    feature: e,
    location: t,
    layer: i,
    startTime: r,
    endTime: s,
    level: l,
    probeFunction: c
  }), u || 250, { leading: !0, trailing: !1 });
  return d.map((x) => {
    const w = o.get(f, "unit", x.unit), M = be.getUnit(w), p = be.getTargetUnit(w), y = {
      probedLocationData: h,
      data: Jr(h, x),
      variable: {
        name: x.name,
        label: `${Y.tie(x.label)} (${be.getTargetUnitSymbol(w)})`,
        unit: M,
        targetUnit: p,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: x.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, o.cloneDeep(x.chartjs))
      }
    };
    return y.fetch = () => (y.probedLocationData = g(), y.data = Jr(y.probedLocationData, x), y.data), y;
  });
}
function Nf(e, t = {}) {
  let i = {};
  const n = Ko(e, t), { get: r, has: s, set: a } = Ot(`selections.${e}`);
  t = r("options", Object.assign({
    // Specific selection item comparator
    matches: (j) => (ie) => {
      const le = o.get(j, "layer.name"), ye = o.get(ie, "layer.name");
      if (le && ye) {
        if (le !== ye) return !1;
        if (j.feature && ie.feature) {
          const ge = st(j.feature, j.layer), ve = st(ie.feature, ie.layer);
          return ge === ve;
        } else
          return !1;
      } else {
        if (le || ye) return !1;
        const ge = o.get(j, "location"), ve = o.get(ie, "location");
        return ge.lat === ve.lat && ge.lon === ve.lon;
      }
    },
    // Multiple selection key
    multiple: "ctrlKey",
    // Buffer selection width (10px)
    buffer: 10,
    showBuffer: !1,
    showBufferDelay: 250,
    boxSelection: !0,
    clusterSelection: !1
  }, t)), s("options") || a("options", t);
  const { kActivity: l } = di();
  let c = Wi(l);
  function u(j) {
    c !== j && (c && c.$engineEvents && (R(), n.setSelectionEnabled(), n.clearSelection(), c.$engineEvents.off("click", X), t.boxSelection && c.$engineEvents.off("boxselectionend", te), t.clusterSelection && c.$engineEvents.off("spiderfied", H), c.$engineEvents.off("layer-added", he), c.$engineEvents.off("layer-removed", ce), c.$engineEvents.off("layer-hidden", oe)), c = j, c && c.$engineEvents && (de(), c.$engineEvents.on("click", X), t.boxSelection && c.$engineEvents.on("boxselectionend", te), t.clusterSelection && c.$engineEvents.on("spiderfied", H), c.$engineEvents.on("layer-added", he), c.$engineEvents.on("layer-removed", ce), c.$engineEvents.on("layer-hidden", oe)));
  }
  function d(j) {
    t.boxSelection !== j && (t.boxSelection = j, c && (j ? (c.$engineEvents.on("boxselectionend", te), c.map.boxSelection.enable()) : (c.$engineEvents.off("boxselectionend", te), c.map.boxSelection.disable())));
  }
  function f(j) {
    t.clusterSelection !== j && (t.clusterSelection = j, c && (j ? c.$engineEvents.on("spiderfied", H) : c.$engineEvents.off("spiderfied", H)));
  }
  function h(j) {
    t.buffer = j;
  }
  function g() {
    return n.hasSelectedItem() && n.getSelectedItem().feature;
  }
  function v() {
    return n.getSelectedItem().feature;
  }
  function x() {
    return n.getSelectedItems().filter((j) => j.feature).map((j) => j.feature);
  }
  function w() {
    return { type: "FeatureCollection", features: n.getSelectedItems().filter((j) => j.feature).map((j) => j.feature) };
  }
  function M() {
    const j = {};
    return n.getSelectedItems().filter((le) => le.feature && le.layer).forEach((le) => {
      const ye = le.layer._id || le.layer.name;
      j[ye] || (j[ye] = { layer: le.layer, features: [] }), j[ye].features.push(le.feature);
    }), o.values(j);
  }
  function p() {
    return n.hasSelectedItem() && n.getSelectedItem().layer;
  }
  function y() {
    return n.getSelectedItem().layer;
  }
  function S() {
    return n.getSelectedItem().filter((j) => j.layer).map((j) => j.layer);
  }
  function C() {
    return n.hasSelectedItem() && n.getSelectedItem().location;
  }
  function T() {
    return n.getSelectedItem().location;
  }
  function k(j, ie) {
    const le = n.getSelectedItems();
    for (let ye = 0; ye < le.length; ye++) {
      const ge = le[ye];
      if (ge.feature && ge.layer && ge.layer.name === ie.name) {
        const ve = st(ge.feature, ge.layer);
        if (st(j, ie) === ve) return ge;
      }
    }
    return null;
  }
  function I(j, ie) {
    return k(j, ie) !== null;
  }
  function A() {
    let j;
    if (p()) {
      const ie = y();
      j = o.get(ie, "widget"), j ? typeof j != "string" && (j = o.get(j, "type", "information-box")) : o.has(ie, "probe") || // Static probe on pre-defined sites
      o.has(ie, "variables") ? j = "time-series" : o.get(ie, "leaflet.type") === "mapillary" ? j = "mapillary-viewer" : j = "information-box";
    }
    return j;
  }
  function P() {
    g() ? c.center(...o.get(xi(v()), "geometry.coordinates")) : C() && c.center(T().lng, T().lat);
  }
  function D(j, ie) {
    Array.isArray(j) || (j = [j]);
    const le = [], ye = [];
    j.forEach((ge) => {
      const { location: ve, feature: at, layer: et } = ge;
      at && et ? I(at, et) ? ye.push(ge) : le.push(ge) : ve && et && le.push(ge);
    }), (ie || o.isEmpty(le) && o.isEmpty(ye)) && n.clearSelection(), ye.forEach((ge) => n.unselectItem(ge)), le.forEach((ge) => n.selectItem(ge));
  }
  function F(j) {
    const ie = [];
    return o.values(c.layers).filter(Pe({
      scope: { $ne: "system" },
      "leaflet.type": "geoJson",
      isVisible: !0
    })).forEach((ye) => {
      if (!c.isLayerSelectable(ye)) return;
      const ge = c.toGeoJson(ye.name);
      ki(ge, (ve) => {
        if (Cd(ve, j)) {
          const at = xi(ve), et = o.get(at, "geometry.coordinates[0]"), ht = o.get(at, "geometry.coordinates[1]");
          ie.push({ feature: ve, layer: ye, location: { lng: et, lat: ht } });
        }
      });
    }), ie;
  }
  let O, $;
  function X(j, ie) {
    if (!n.isSelectionEnabled()) return;
    const le = o.get(ie, "containerPoint");
    if (O && le.equals(O)) {
      O = null;
      return;
    }
    if ($ && le.equals($)) {
      $ = null;
      return;
    }
    O = le;
    const ye = t.multiple ? o.get(ie, `originalEvent.${t.multiple}`) : !1;
    let ge;
    const ve = o.get(ie, "latlng");
    if (n.getSelectionMode() === "buffer") {
      if (c.is2D() && t.showBuffer) {
        const er = o.get(me, `engines.${c.engine}.style.selection.polygon`, {}), fn = B.circleMarker(ve, Object.assign({ radius: t.buffer }, fa(er))).addTo(c.map);
        setTimeout(() => fn.removeFrom(c.map), t.showBufferDelay);
      }
      const et = c.getCenter(), ht = 40075016686e-3 * Math.abs(Math.cos(ve.lat * Math.PI / 180)) / Math.pow(2, et.zoomLevel + 8);
      ge = F(Lb([ve.lng, ve.lat], t.buffer * ht, { steps: 100, units: "meters" }));
    } else {
      let et;
      j && j.name ? (j = c.getLayerByName(j.name), j && c.isLayerSelectable(j) ? et = o.get(ie, "target.feature") : j = void 0) : j = void 0, ge = [{ location: ve, feature: et, layer: j }];
    }
    const at = n.isSingleSelectionMode() || !ye;
    t.handler ? t.handler(ge, at) : D(ge, at);
  }
  function te(j, ie) {
    if (!n.isSelectionEnabled()) return;
    $ = o.get(ie, "containerPoint");
    const { bounds: le } = ie;
    let ye = F(Ld([
      le.getWest(),
      le.getSouth(),
      le.getEast(),
      le.getNorth()
    ]));
    !o.isEmpty(ye) && n.isSingleSelectionMode() && (ye = o.last(ye)), t.handler ? t.handler(ye, !0) : D(ye, !0);
  }
  function H(j, ie) {
    if (!n.isSelectionEnabled() || n.isSingleSelectionMode()) return;
    const le = o.get(ie, "markers", []).map((ye) => {
      const ge = ye.feature, ve = xi(ge), at = o.get(ve, "geometry.coordinates[0]"), et = o.get(ve, "geometry.coordinates[1]");
      return { feature: ge, layer: j, location: { lng: at, lat: et } };
    });
    t.handler ? t.handler(le, !0) : D(le, !0);
  }
  function oe(j) {
    n.getSelectedItems().filter((le) => j.name === o.get(le, "layer.name")).forEach((le) => n.unselectItem(le));
  }
  function he(j) {
    const ie = Qn(j, {
      all: Q,
      removed: _e
    }, i[j._id]);
    ie && (i[j._id] = ie);
  }
  function ce(j) {
    ln(j, i[j._id]), delete i[j._id];
  }
  function de() {
    i = {}, o.forEach(c.getLayers(), he);
  }
  function R() {
    o.forOwn(i, ce), i = {};
  }
  function Q(j, ie) {
    if (!ie && j.layer && (ie = c.getLayerById(j.layer)), !ie) return;
    const le = k(j, ie);
    le && Object.assign(le.feature, j);
  }
  function _e(j, ie) {
    if (!ie && j.layer && (ie = c.getLayerById(j.layer)), !ie) return;
    const le = k(j, ie);
    le && n.unselectItem(le);
  }
  return {
    ...n,
    getSelectionOptions: () => r("options"),
    setCurrentActivity: u,
    hasSelectedFeature: g,
    getSelectedFeature: v,
    getSelectedFeatures: x,
    getSelectedFeatureCollection: w,
    getSelectedFeaturesByLayer: M,
    hasSelectedLayer: p,
    getSelectedLayer: y,
    getSelectedLayers: S,
    hasSelectedLocation: C,
    getSelectedLocation: T,
    getWidgetForSelection: A,
    centerOnSelection: P,
    setBoxSelectionEnabled: d,
    setClusterSelectionEnabled: f,
    setBufferWidth: h
  };
}
function jf(e, t = {}) {
  const { kActivity: i } = di();
  let n = Wi(i);
  const { store: r, set: s, get: a, has: l } = Ot(`probes.${e}`);
  function c(T) {
    n !== T && (n && n.$engineEvents && n.$engineEvents.off("click", S), n = T, T && T.$engineEvents && T.$engineEvents.on("click", S));
  }
  function u() {
    s("item", null);
  }
  function d(T) {
    s("item", T);
  }
  function f() {
    return n && n.isCursor("probe-cursor");
  }
  function h() {
    return a("item") && a("item").layer;
  }
  function g() {
    return a("item").layer;
  }
  function v() {
    return a("item") && a("item").location;
  }
  function x() {
    return a("item").location;
  }
  function w() {
    let T;
    return v() && (T = "time-series"), T;
  }
  function M() {
    v() && n.center(x().lng, x().lat);
  }
  function p(T) {
    d(T);
  }
  let y;
  function S(T, k) {
    if (!f()) {
      a("item") && (o.get(k, "target.feature") || u());
      return;
    }
    const I = o.get(k, "containerPoint");
    if (y && I.equals(y)) {
      y = null;
      return;
    }
    y = I;
    const A = o.get(k, "latlng");
    let P;
    T && T.name ? (T = n.getLayerByName(T.name), T && n.isLayerProbable(T) ? P = o.get(k, "target.feature") : T = void 0) : T = void 0, t.handler ? t.handler({ location: A, feature: P, layer: T }) : p({ location: A, feature: P, layer: T });
  }
  function C() {
    n.setCursor("probe-cursor"), n.$engineEvents.once("click", () => {
      setTimeout(() => {
        n.unsetCursor("probe-cursor");
      }, t.timeout || 500);
    });
  }
  return l("item") || u(), {
    setCurrentActivity: c,
    probe: r,
    clearProbe: u,
    setProbe: d,
    hasProbedLayer: h,
    getProbedLayer: g,
    hasProbedLocation: v,
    getProbedLocation: x,
    probeAtLocation: C,
    getWidgetForProbe: w,
    centerOnProbe: M
  };
}
const gi = Gt(), Vf = 999, Sr = 8;
function Uf(e, t = {}) {
  let i = "highlightable-layers", n = {};
  t = Object.assign({ updateDelay: 250 }, t);
  const { kActivity: r } = di();
  let s = Wi(r);
  const { store: a, clear: l, set: c, get: u, unset: d, has: f } = Ot(`highlights.${e}`), { forOwn: h } = Ot("highlights");
  function g(R) {
    s !== R && (s && (O(), s.$engineEvents.off("layer-added", te), s.$engineEvents.off("layer-removed", H), s.$engineEvents.off("layer-added", P), s.$engineEvents.off("layer-disabled", $), s.$engineEvents.off("layer-enabled", X)), s = R, s && (s.$engineEvents.on("layer-added", te), s.$engineEvents.on("layer-removed", H), s.$engineEvents.on("layer-added", P), s.$engineEvents.on("layer-disabled", $), s.$engineEvents.on("layer-enabled", X)));
  }
  function v(R, Q) {
    let _e = `${e}`;
    if (Q && (_e += `-${o.kebabCase(Q.name)}`), R) {
      const j = st(R, Q);
      j && (_e += `-${j}`);
    }
    return _e;
  }
  function x(R, Q, _e) {
    return _e ? R.includes(`-${st(_e, Q)}`) : R.includes(`-${o.kebabCase(Q.name)}`);
  }
  function w(R, Q) {
    return f(v(R, Q));
  }
  function M(R, Q) {
    return u(v(R, Q));
  }
  function p(R, Q) {
    Object.assign(
      Q,
      R.geometry ? { geometry: R.geometry } : { geometry: { type: "Point", coordinates: [o.get(R, "lng", 0), o.get(R, "lat", 0)] } }
    ), t.asBbox && Q.geometry.type !== "Point" && Object.assign(Q, Ld(Fi(Q))), F();
  }
  function y(R = "highlightable-layers") {
    i = R;
  }
  function S(R, Q, _e = !0) {
    if (Q && i === "highlightable-layers" && !sf(Q)) return;
    const j = v(R, Q), ie = {
      highlightId: j,
      type: "Feature",
      properties: Object.assign({
        zOrder: 0
      }, t)
    };
    if (p(R, ie), _e) {
      const le = `engines.${s.engine}.style.selection.${an(ie)}`;
      let ye = o.cloneDeep(o.get(me, le, {}));
      if (s.is2D()) {
        let ge = o.get(R, "style.radius"), ve = o.get(R, "style.size");
        ve && !Array.isArray(ve) && (ve = [ve, ve]), !ve && !ge && (ve = o.get(Q, `${s.engine}.style.point.size`), ge = o.get(Q, `${s.engine}.style.point.radius`), ve && !Array.isArray(ve) && (ve = [ve, ve])), ge ? Object.assign(ye, { radius: ge + 0.5 * Sr }) : ve && Object.assign(ye, { size: [ve[0] + Sr, ve[1] + Sr] }), Object.assign(ie, { style: ye });
      } else
        Object.assign(ie, { style: o.defaults({}, ye, R.style) });
    } else
      Object.assign(ie, { style: R.style });
    return o.merge(ie, o.omit(R, ["geometry", "style"])), c(j, ie), T(R, Q, Q ? !Q.isDisabled : !0), ie;
  }
  function C(R, Q) {
    const _e = v(R, Q);
    d(_e), F();
  }
  function T(R, Q, _e = !0) {
    const j = M(R, Q);
    o.set(j, "style.visibility", _e), F();
  }
  function k(R, Q = !0) {
    A(R).forEach((_e) => T(_e, R, Q));
  }
  function I() {
    l(), F();
  }
  function A(R, Q) {
    let _e = [];
    return h((j) => {
      o.forOwn(j, (ie, le) => {
        (!R || R && x(le, R, Q)) && _e.push(ie);
      });
    }), _e;
  }
  async function P() {
    s.getLayerByName(gi) || await s.addLayer({
      name: gi,
      type: "OverlayLayer",
      scope: "system",
      isSelectable: !1,
      featureId: "highlightId",
      leaflet: {
        type: "geoJson",
        isVisible: !0,
        realtime: !0,
        interactive: !1,
        cluster: !1,
        removeMissing: !0,
        popup: { pick: [] },
        zIndex: Vf,
        interactive: !1
      },
      cesium: {
        type: "geoJson",
        isVisible: !0,
        realtime: !0,
        cluster: !1,
        removeMissing: !0,
        popup: { pick: [] }
      }
    }), s.isLayerVisible(gi) || await s.showLayer(gi);
  }
  function D() {
    let R = A();
    R = R.filter((Q) => !Q.isDisabled), R = o.sortBy(R, (Q) => o.get(Q, "properties.zOrder")), s && s.updateLayer(gi, {
      type: "FeatureCollection",
      features: R
    }, { replace: !0 });
  }
  const F = o.debounce(D, t.updateDelay);
  function O() {
    s && s.removeLayer(gi);
  }
  function $(R) {
    A(R).forEach((Q) => {
      T(Q, R, !1);
    });
  }
  function X(R) {
    A(R).forEach((Q) => {
      T(Q, R, !0);
    });
  }
  function te(R) {
    const Q = Qn(R, {
      all: ce,
      removed: de
    }, n[R._id]);
    Q && (n[R._id] = Q);
  }
  function H(R) {
    ln(R, n[R._id]), delete n[R._id];
  }
  function oe() {
    n = {}, o.forEach(s.getLayers(), te);
  }
  function he() {
    o.forOwn(n, H), n = {};
  }
  function ce(R, Q) {
    !Q && R.layer && (Q = s.getLayerById(R.layer)), Q && w(R, Q) && p(R, M(R, Q));
  }
  function de(R, Q) {
    !Q && R.layer && (Q = s.getLayerById(R.layer)), Q && w(R, Q) && C(R, Q);
  }
  return qn(() => {
    oe();
  }), Ue(() => {
    he(), I();
  }), {
    setCurrentActivity: g,
    highlights: a,
    setHighlightMode: y,
    hasHighlight: w,
    getHighlight: M,
    getHighlights: A,
    highlight: S,
    unhighlight: C,
    setHighlightEnabled: T,
    setHighlightsEnabled: k,
    clearHighlights: I
  };
}
const qf = {};
function V0(e, t = {}) {
  o.defaults(t, { selection: !0, probe: !0, highlight: !0 });
  const i = gd(e, t), { CurrentActivityContext: n } = i;
  let r, s, a;
  function l(u) {
    i.setCurrentActivity(u), r && r.setCurrentActivity(u), s && s.setCurrentActivity(u), a && a.setCurrentActivity(u);
  }
  const c = {
    ...i
  };
  return t.selection && (r = Nf(e, o.get(n, "config.selection")), Object.assign(c, {
    ...r
  })), t.probe && (s = jf(e, o.get(n, "config.probe")), Object.assign(c, {
    ...s
  })), t.highlight && (a = Uf(e, o.get(n, "config.highlight")), Object.assign(c, {
    ...a
  })), Object.assign(c, {
    setCurrentActivity: l
  }), o.set(qf, e, c), c;
}
const Ql = xc(null);
function Sa(e = {}) {
  o.defaults(e, { selection: !0, probe: !0 });
  const t = di(), { CurrentActivityContext: i } = t;
  function n(a) {
    Ql.value = Wi(a);
  }
  function r() {
    return Ql.value;
  }
  const s = {
    ...t,
    setActivityProject: n,
    getActivityProject: r
  };
  return i.name && Object.assign(s, o.get(qf, i.name)), s;
}
class Gf extends zc {
}
const U0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KGeolocationError: Gf
}, Symbol.toStringTag, { value: "Module" }));
function q0(e, t, i) {
  t("service", "geocoder"), t("create", "geocoder"), t("service", "catalog"), t("read", "catalog"), t("service", "projects"), t("read", "projects"), t("service", "alerts"), t("read", "alerts"), t("service", "styles"), t("read", "styles");
}
const G0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defineUserAbilities: q0
}, Symbol.toStringTag, { value: "Module" })), Ke = {
  ASCENDING: 0,
  DESCENDING: 1
}, Yt = {}, cn = {}, Yl = function() {
  const e = new Float32Array(1), t = new Int32Array(e.buffer);
  return function(n) {
    e[0] = n;
    const r = t[0];
    let s = r >> 16 & 32768, a = r >> 12 & 2047;
    const l = r >> 23 & 255;
    return l < 103 ? s : l > 142 ? (s |= 31744, s |= (l === 255 ? 0 : 1) && r & 8388607, s) : l < 113 ? (a |= 2048, s |= (a >> 114 - l) + (a >> 113 - l & 1), s) : (s |= l - 112 << 10 | a >> 1, s += a & 1, s);
  };
}();
class un {
  constructor(t, i, n, r) {
    if (this.sourceKey = t, this.bbox = i, this.dimensions = n, this.resolution = [(i[2] - i[0]) / (n[0] - 1), (i[3] - i[1]) / (n[1] - 1)], this.nodata = r, this.bbox[0] >= this.bbox[2] || this.bbox[1] >= this.bbox[3])
      throw new Error("Grid bbox seems weird");
    if (this.dimensions[0] <= 0 || this.dimensions[1] <= 0)
      throw new Error("Grid dimension is < 0, something's wrong");
    if (this.resolution[0] <= 0 || this.resolution[1] <= 0)
      throw new Error("Grid resolution is < 0, something's wrong");
  }
  getDimensions() {
    return this.dimensions;
  }
  getResolution() {
    return this.resolution;
  }
  getBBox() {
    return this.bbox;
  }
  hasData() {
    for (let t = 0; t < this.dimensions[0]; ++t)
      for (let i = 0; i < this.dimensions[1]; ++i)
        if (this.getValue(t, i) !== this.nodata)
          return !0;
    return !1;
  }
  getDataBounds() {
    if (this.dataBounds)
      return this.dataBounds;
    let t = 0, i = 0, n, r;
    for (; t < this.dimensions[0] && r === void 0; ++t)
      for (; i < this.dimensions[1] && r === void 0; ++i) {
        const s = this.getValue(t, i);
        s !== this.nodata && (n = r = s);
      }
    for (; t < this.dimensions[0]; ++t)
      for (; i < this.dimensions[1]; ++i) {
        const s = this.getValue(t, i);
        s !== this.nodata && (n = Math.min(n, s), r = Math.max(r, s));
      }
    return this.dataBounds = [n, r], this.dataBounds;
  }
  getLat(t) {
    return this.bbox[0] + t * this.resolution[0];
  }
  getLon(t) {
    return this.bbox[1] + t * this.resolution[1];
  }
  getValue(t, i) {
    throw new Error("Not implemented");
  }
  getIndices(t, i) {
    if (t < this.bbox[0] || t > this.bbox[2] || i < this.bbox[1] || i > this.bbox[2])
      return null;
    const n = (t - this.bbox[0]) / this.resolution[0], r = (i - this.bbox[1]) / this.resolution[1];
    return [Math.floor(n), Math.floor(r)];
  }
  getBestFit(t) {
    let i = -1;
    for (let a = 0; a < this.dimensions[0] - 1 && i === -1; ++a)
      this.getLat(a + 1) > t[0] && (i = a);
    let n = -1;
    for (let a = this.dimensions[0] - 1; a > 0 && n === -1; --a)
      this.getLat(a - 1) < t[2] && (n = a);
    let r = -1;
    for (let a = 0; a < this.dimensions[1] - 1 && r === -1; ++a)
      this.getLon(a + 1) > t[1] && (r = a);
    let s = -1;
    for (let a = this.dimensions[1] - 1; a > 0 && s === -1; --a)
      this.getLon(a - 1) < t[3] && (s = a);
    return [i, r, n, s];
  }
  genCoordsBuffer() {
    const t = this.dimensions[0] * this.dimensions[1], i = new Uint16Array(2 * t), n = this.getLat(0), r = this.getLat(this.dimensions[0] - 1), s = this.getLon(0), a = this.getLon(this.dimensions[1] - 1), l = r - n, c = a - s;
    let u = 0;
    for (let d = 0; d < this.dimensions[1]; ++d) {
      const f = this.getLon(d);
      for (let h = 0; h < this.dimensions[0]; ++h) {
        const g = this.getLat(h);
        i[u * 2] = Yl((g - n) / l), i[u * 2 + 1] = Yl((f - s) / c), ++u;
      }
    }
    return { coords: i, minLat: n, maxLat: r, minLon: s, maxLon: a, deltaLat: l, deltaLon: c };
  }
  genValuesBuffer() {
    const t = this.dimensions[0] * this.dimensions[1], i = new Float32Array(t);
    let n = 0;
    for (let r = 0; r < this.dimensions[1]; ++r)
      for (let s = 0; s < this.dimensions[0]; ++s)
        i[n] = this.getValue(s, r), ++n;
    return i;
  }
  genMeshIndexBuffer() {
    let t = 0;
    const i = this.dimensions[0] * this.dimensions[1] - 1, n = (this.dimensions[1] - 1) * (this.dimensions[0] * 2 + 1) - 1, r = i > 65534 ? 4294967295 : 65535, s = i > 65534 ? new Uint32Array(n) : new Uint16Array(n);
    for (let a = 0; a < this.dimensions[1] - 1; ++a) {
      for (let l = 0; l < this.dimensions[0]; ++l)
        s[t++] = l + a * this.dimensions[0], s[t++] = l + (a + 1) * this.dimensions[0];
      a !== this.dimensions[1] - 2 && (s[t++] = r);
    }
    return s;
  }
  genWireframeIndexBuffer() {
    const t = this.dimensions[0] * this.dimensions[1] - 1, i = this.dimensions[1] * (this.dimensions[0] + 1) + (this.dimensions[0] * (this.dimensions[1] + 1) - 1), n = t > 65534 ? 4294967295 : 65535, r = t > 65534 ? new Uint32Array(i) : new Uint16Array(i);
    let s = 0;
    for (let a = 0; a < this.dimensions[1]; ++a) {
      for (let l = 0; l < this.dimensions[0]; ++l)
        r[s++] = l + a * this.dimensions[0];
      r[s++] = n;
    }
    for (let a = 0; a < this.dimensions[0]; ++a) {
      for (let l = 0; l < this.dimensions[1]; ++l)
        r[s++] = a + l * this.dimensions[0];
      a !== this.dimensions[0] - 1 && (r[s++] = n);
    }
    return r;
  }
}
class dn {
  constructor(t) {
    this.events = {}, this.sourceKey = 0;
  }
  getBBox() {
    return null;
  }
  getDataBounds() {
    throw new Error("Not implemented");
  }
  supportsNoData() {
    return this.nodata !== void 0;
  }
  /**
     * @returns {Number} Returns a new longitude with the value wrapped so it's always in the same range than the given bounding box (e.g. between -180 and +180 degrees).
     */
  wrapLongitude(t, i) {
    return i[0] < 0 ? t > 180 ? t - 360 : t : i[2] > 180 && t < 0 ? t + 360 : t;
  }
  async setup(t) {
    throw new Error("Not implemented");
  }
  async fetch(t, i, n) {
    throw new Error("Not implemented");
  }
  on(t, i) {
    const n = o.get(this.events, t, []);
    n.push(i), n.length === 1 && (this.events[t] = n);
  }
  off(t, i) {
    o.get(this.events, t, []).splice(0, 0, i);
  }
  emit(t) {
    const i = o.get(this.events, t, []), n = { source: this, event: t };
    for (const r of i)
      r(n);
  }
  dataChanged() {
    this.emit("data-changed");
  }
}
function en(e, t = null) {
  const i = o.get(Yt, e, null);
  return i ? i(t) : null;
}
function Yn(e) {
  for (const t of Object.keys(e))
    if (o.get(Yt, t, null))
      return [t, e[t]];
  return [null, null];
}
const K0 = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i * n + t];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(r - (i + 1)) * n + t];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i * n + (n - (t + 1))];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(r - (i + 1)) * n + (n - (t + 1))];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[t * r + i];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[t * r + (r - (i + 1))];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[(n - (t + 1)) * r + i];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[(n - (t + 1)) * r + (r - (i + 1))];
  }
];
class Un extends un {
  constructor(t, i, n, r, s, a, l, c = void 0, u = null) {
    super(t, i, n, c), this.data = r;
    const d = l + a * 2 + (s ? 1 : 0) * 4;
    if (this.getByIndex = K0[d], u)
      for (let f = 0; f < r.length; ++f)
        r[f] = u(r[f]);
  }
  getValue(t, i) {
    return this.getByIndex(this.data, t, i, this.dimensions[0], this.dimensions[1]);
  }
}
const H0 = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i][t];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[r - (i + 1)][t];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[i][n - (t + 1)];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[r - (i + 1)][n - (t + 1)];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[t][i];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[t][r - (i + 1)];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(e, t, i, n, r) {
    return e[n - (t + 1)][i];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(e, t, i, n, r) {
    return e[n - (t + 1)][r - (i + 1)];
  }
];
class Kf extends un {
  constructor(t, i, n, r, s, a, l, c = void 0, u = null) {
    super(t, i, n, c), this.data = r;
    const d = l + a * 2 + (s ? 1 : 0) * 4;
    if (this.getByIndex = H0[d], u)
      for (let f = 0; f < r.length; ++f) {
        const h = r[f];
        for (let g = 0; g < h.length; ++g)
          h[g] = u(h[g]);
      }
  }
  getValue(t, i) {
    return this.getByIndex(this.data, t, i, this.dimensions[0], this.dimensions[1]);
  }
}
class fo extends un {
  constructor(t, i, n = void 0) {
    const r = i[0].getBBox(), s = i[0].getDimensions(), a = i[0].getResolution();
    super(t, r, s, n), this.dimensions = [0, 0], this.bbox = [r[0], r[1], r[2], r[3]], this.resolution = [a[0], a[1]];
    for (const l of i) {
      const c = l.getResolution();
      if (c[0] !== a[0] || c[1] !== a[1])
        throw new Error("Resolution does not match between tiles");
      const u = l.getBBox();
      this.bbox[0] = Math.min(this.bbox[0], u[0]), this.bbox[1] = Math.min(this.bbox[1], u[1]), this.bbox[2] = Math.max(this.bbox[2], u[2]), this.bbox[3] = Math.max(this.bbox[3], u[3]);
    }
    this.dimensions[0] = 1 + Math.trunc((this.bbox[2] - this.bbox[0]) / this.resolution[0]), this.dimensions[1] = 1 + Math.trunc((this.bbox[3] - this.bbox[1]) / this.resolution[1]), this.tiles = [];
    for (const l of i) {
      const c = l.getBBox(), u = {
        tile: l,
        iLatMin: Math.floor((c[0] - this.bbox[0]) / this.resolution[0]),
        iLatMax: Math.floor((c[2] - this.bbox[0]) / this.resolution[0]),
        iLonMin: Math.floor((c[1] - this.bbox[1]) / this.resolution[1]),
        iLonMax: Math.floor((c[3] - this.bbox[1]) / this.resolution[1])
      };
      this.tiles.push(u);
    }
  }
  getValue(t, i) {
    let n = null;
    for (const r of this.tiles)
      if (!(t < r.iLatMin || t > r.iLatMax || i < r.iLonMin || i > r.iLonMax)) {
        n = r;
        break;
      }
    return n ? n.tile.getValue(t - n.iLatMin, i - n.iLonMin) : 0;
  }
}
class Hf extends un {
  constructor(t, i, n) {
    const [r, s, a, l] = i.getBestFit(n), c = [1 + a - r, 1 + l - s], u = [i.getLat(r), i.getLon(s), i.getLat(a), i.getLon(l)];
    super(t, u, c, i.nodata), this.latOffset = r, this.lonOffset = s, this.implGrid = i;
  }
  getValue(t, i) {
    return this.implGrid.getValue(t + this.latOffset, i + this.lonOffset);
  }
}
const W0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseGrid: un,
  Grid1D: Un,
  Grid2D: Kf,
  GridSource: dn,
  SortOrder: Ke,
  SubGrid: Hf,
  TiledGrid: fo,
  extractGridSourceConfig: Yn,
  gridSourceFactories: Yt,
  makeGridSource: en,
  unitConverters: cn
}, Symbol.toStringTag, { value: "Module" })), Wf = /* @__PURE__ */ new Set(["Float32", "Float64"]);
async function Zf(e) {
  const t = e.indexOf("?"), i = t === -1 ? `${e}.dds` : `${e.substring(0, t)}.dds${e.substring(t)}`, n = t === -1 ? `${e}.das` : `${e.substring(0, t)}.das${e.substring(t)}`, r = fetch(i).then((d) => d.text()), s = fetch(n).then((d) => d.text()), [a, l] = await Promise.all([r, s]), c = new eo.ddsParser(a).parse();
  return new eo.dasParser(l, c).parse();
}
async function Cr(e, t = null) {
  const i = t ? { signal: t } : {};
  let n = null, r = null, s = 0;
  for (; !r; ) {
    ++s;
    try {
      const l = await fetch(e, i).then((f) => f.arrayBuffer()), c = new DataView(l);
      let u = "", d = 0;
      for (; d < c.byteLength; ) {
        const f = c.getUint8(d);
        if ((f === `
` || f === 10) && String.fromCodePoint(
          c.getUint8(d + 1),
          c.getUint8(d + 2),
          c.getUint8(d + 3),
          c.getUint8(d + 4),
          c.getUint8(d + 5),
          c.getUint8(d + 6)
        ) === `Data:
`)
          break;
        u += String.fromCodePoint(f), ++d;
      }
      n = new eo.ddsParser(u).parse(), r = new Sm.dapUnpacker(l.slice(d + 7), n).getValue();
    } catch (l) {
      if (s >= 2) throw l;
    }
  }
  const a = {};
  if (n && r) {
    let l = 0;
    for (const c in n)
      n[c].type && (a[c] = r[l], l += 1);
  }
  return a;
}
function Jf(e, t) {
  const i = e[t];
  return i === void 0 ? !1 : i.type === "Grid";
}
function ho(e, t) {
  const i = e[t];
  return i === void 0 || i.shape === void 0 ? !1 : i.shape.length === 1 && Wf.has(i.type);
}
function Z0(e, t) {
  return e[t].shape[0];
}
function mo(e, t, i) {
  return e[t].array.shape[i];
}
function Qf(e, t, i) {
  const n = e[t], r = [];
  for (let s = 0; s < n.array.dimensions.length; ++s) {
    const a = i[n.array.dimensions[s]];
    if (a === void 0)
      return [];
    r.push(a);
  }
  return r;
}
function Er(e, t) {
  let i;
  Array.isArray(t) ? i = t : i = o.keys(t).map((s) => `${s}[${t[s]}]`);
  const n = e.indexOf("?"), r = (n === -1 ? `${e}.dods?` : `${e.substring(0, n)}.dods${e.substring(n)}&`) + i.join(",");
  return encodeURI(r);
}
function go(e, t, i) {
  const n = e[t];
  return n === void 0 ? -1 : n.array.dimensions.indexOf(i);
}
function Yf(e) {
  return e.reduce((i, n) => (i[0] = Math.min(i[0], n), i[1] = Math.max(i[1], n), i), [e[0], e[0]]);
}
function Qr(e, t) {
  let i = 0, n = e;
  for (; i < t.length - 1; ++i)
    n = n[t[i]];
  return n[t[i]];
}
function J0(e, t) {
  let i = 0, n = e;
  for (; i < t - 1; ++i)
    n = n[0];
  return n[0];
}
function Xf(e, t) {
  if (t > 1) {
    const i = J0(e, t);
    return e.reduce((n, r) => {
      const s = Xf(r, t - 1);
      return [Math.min(n[0], s[0]), Math.max(n[1], s[1])];
    }, [i, i]);
  } else
    return Yf(e);
}
const Q0 = [
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.ASCENDING
  function(e, t, i, n, r, s, a) {
    const l = [...e];
    return l.fill(0), l[t] = n, l[i] = r, l;
  },
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.DESCENDING
  function(e, t, i, n, r, s, a) {
    const l = [...e];
    return l.fill(0), l[t] = n, l[i] = a - (r + 1), l;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.ASCENDING
  function(e, t, i, n, r, s, a) {
    const l = [...e];
    return l.fill(0), l[t] = s - (n + 1), l[i] = r, l;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.DESCENDING
  function(e, t, i, n, r, s, a) {
    const l = [...e];
    return l.fill(0), l[t] = s - (n + 1), l[i] = a - (r + 1), l;
  }
];
class eh extends un {
  constructor(t, i, n, r, s, a, l, c, u, d = void 0, f = null) {
    super(t, i, n, d), this.data = r, this.indices = s, this.latIndex = a, this.lonIndex = l;
    const h = u + c * 2;
    if (this.makeIndices = Q0[h], f) {
      const g = [...s];
      g.fill(0);
      for (let v = 0; v < n[0]; ++v) {
        g[a] = v;
        for (let x = 0; x < n[1]; ++x) {
          g[l] = x;
          const w = Qr(r, g.slice(0, g.length - 1));
          w[g[g.length - 1]] = f(w[g[g.length - 1]]);
        }
      }
    }
  }
  getValue(t, i) {
    const n = this.makeIndices(this.indices, this.latIndex, this.lonIndex, t, i, this.dimensions[0], this.dimensions[1]);
    return Qr(this.data, n);
  }
}
const Y0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OpenDAPGrid: eh,
  fetchData: Cr,
  fetchDescriptor: Zf,
  getArrayVariableLength: Z0,
  getGridDimensionIndex: go,
  getGridDimensionLength: mo,
  getGridValue: Qr,
  getMinMaxArray: Yf,
  getMinMaxGrid: Xf,
  makeGridIndices: Qf,
  makeQuery: Er,
  opendapTypes: Wf,
  variableIsArray: ho,
  variableIsGrid: Jf
}, Symbol.toStringTag, { value: "Module" }));
class Xl extends dn {
  static getKey() {
    return "opendap";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.descriptor = null, this.indices = null, this.latCount = 0, this.latIndex = 0, this.lonCount = 0, this.lonIndex = 0, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.latStep = 0, this.lonStep = 0, this.latSortOrder = Ke.ASCENDING, this.lonSortOrder = Ke.ASCENDING, this.canUseGrid2D = !1, this.config = t, this.converter = cn[this.config.converter];
    try {
      this.descriptor = await Zf(this.config.url);
    } catch {
      this.descriptor = null, console.log(`Failed fetching opendap descriptor from ${this.config.url}`);
    }
    if (this.descriptor) {
      const i = Jf(this.descriptor, this.config.variable), n = ho(this.descriptor, this.config.latitude), r = ho(this.descriptor, this.config.longitude);
      if (i && n && r) {
        this.latIndex = go(this.descriptor, this.config.variable, this.config.latitude), this.latCount = mo(this.descriptor, this.config.variable, this.latIndex), this.lonIndex = go(this.descriptor, this.config.variable, this.config.longitude), this.lonCount = mo(this.descriptor, this.config.variable, this.lonIndex);
        const s = await this.getDimensionsAsIndices();
        if (s[this.config.latitude] = `0:${this.latCount - 1}`, s[this.config.longitude] = `0:${this.lonCount - 1}`, this.indices = Qf(this.descriptor, this.config.variable, s), this.indices.length !== 0) {
          const a = this.indices.length - 1;
          (this.latIndex === a && this.lonIndex === a - 1 || this.latIndex === a - 1 && this.lonIndex === a) && (this.canUseGrid2D = !0), await this.computeMetaDataFromData(), this.usable = !0;
        } else
          console.log("Couldn't create index array for grid");
      } else
        i || console.log(`${this.config.variable} is not a grid variable!`), n || console.log(`${this.config.latitude} is expected to be an array variable!`), r || console.log(`${this.config.longitude} is expected to be an array variable!`);
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.makeQuery(i, n);
    if (!r)
      return null;
    const s = this.sourceKey, l = (await Cr(r, t))[this.config.variable], c = l[0], u = l[this.latIndex + 1], d = l[this.lonIndex + 1], f = u[0], h = u[u.length - 1];
    let g = d[0], v = d[d.length - 1];
    g > 180 && (g -= 360), v > 180 && (v -= 360);
    const x = [Math.min(f, h), Math.min(g, v), Math.max(f, h), Math.max(g, v)];
    if (this.canUseGrid2D) {
      const w = this.indices.slice(0, this.indices.length - 2);
      w.fill(0);
      const M = Qr(c, w);
      return new Kf(
        s,
        x,
        [u.length, d.length],
        M,
        this.latIndex < this.lonIndex,
        this.latSortOrder,
        this.lonSortOrder,
        this.nodata,
        this.converter
      );
    }
    return new eh(
      s,
      x,
      [u.length, d.length],
      c,
      this.indices,
      this.latIndex,
      this.lonIndex,
      this.latSortOrder,
      this.lonSortOrder,
      this.nodata,
      this.converter
    );
  }
  makeQuery(t, i) {
    const n = t[0], r = t[1], s = t[2], a = t[3];
    let l = Math.floor((n - this.minMaxLat[0]) / this.latStep), c = Math.floor((r - this.minMaxLon[0]) / this.lonStep), u = Math.ceil((s - this.minMaxLat[0]) / this.latStep), d = Math.ceil((a - this.minMaxLon[0]) / this.lonStep);
    if (l = Math.min(Math.max(l, 0), this.latCount - 1), c = Math.min(Math.max(c, 0), this.lonCount - 1), u = Math.min(Math.max(u, 0), this.latCount - 1), d = Math.min(Math.max(d, 0), this.lonCount - 1), this.latSortOrder === Ke.DESCENDING) {
      const x = l;
      l = this.latCount - 1 - u, u = this.latCount - 1 - x;
    }
    if (this.lonSortOrder === Ke.DESCENDING) {
      const x = c;
      c = this.lonCount - 1 - d, d = this.lonCount - 1 - x;
    }
    const f = Math.max(1, Math.floor(i[0] / this.latStep)), h = Math.max(1, Math.floor(i[1] / this.lonStep));
    f > 1 && (u = Math.min(this.latCount - 1, u + f)), h > 1 && (d = Math.min(this.lonCount - 1, d + h));
    const g = [...this.indices];
    g[this.latIndex] = `${l}:${f}:${u}`, g[this.lonIndex] = `${c}:${h}:${d}`;
    const v = {};
    return v[this.config.variable] = g.join("]["), Er(this.config.url, v);
  }
  async computeMetaDataFromData() {
    const t = {};
    t[this.config.latitude] = `0:${this.latCount - 1}:${this.latCount - 1}`, t[this.config.longitude] = `0:${this.lonCount - 1}:${this.lonCount - 1}`;
    const i = Er(this.config.url, t), n = await Cr(i), r = n[this.config.latitude], s = n[this.config.longitude], a = r[0], l = r[r.length - 1];
    this.minMaxLat = [Math.min(a, l), Math.max(a, l)];
    const c = s[0] > 180 ? s[0] - 360 : s[0], u = s[s.length - 1] > 180 ? s[s.length - 1] - 360 : s[s.length - 1];
    this.minMaxLon = [Math.min(c, u), Math.max(c, u)], this.latStep = (this.minMaxLat[1] - this.minMaxLat[0]) / (this.latCount - 1), this.lonStep = (this.minMaxLon[1] - this.minMaxLon[0]) / (this.lonCount - 1), this.latSortOrder = a < l ? Ke.ASCENDING : Ke.DESCENDING, this.lonSortOrder = c < u ? Ke.ASCENDING : Ke.DESCENDING;
  }
  async getDimensionsAsIndices() {
    const t = {};
    if (this.config.dimensionsAsIndices && Object.assign(t, this.config.dimensionsAsIndices), this.config.dimensionsAsValues) {
      const i = o.keys(this.config.dimensionsAsValues), n = Er(this.config.url, i), r = await Cr(n, null);
      for (let s = 0; s < i.length; ++s) {
        const a = r[i[s]], l = this.config.dimensionsAsValues[i[s]];
        let c = -1;
        for (let u = 0; u < a.length && c === -1; ++u)
          a[u] === l && (c = u);
        if (c === -1)
          throw new Error(`Failed looking up value '${l}' for dimension named '${i[s]}'`);
        t[i[s]] = c;
      }
    }
    return t;
  }
}
function X0(e, t = {}) {
  return fetch(e, { redirect: "follow", headers: t }).then((i) => i.text()).then((i) => Mr.parseStringPromise(i, { tagNameProcessors: [Mr.processors.stripPrefix] }));
}
async function ew(e, t, i, n = {}, r = {}) {
  const s = Gn(e, Object.assign({
    SERVICE: "WCS",
    VERSION: t,
    REQUEST: "DescribeCoverage",
    COVERAGE: i
  }, n));
  return X0(s, r);
}
async function tw(e, t, i, n, r, s, a, l, c = {}, u = {}) {
  const d = Gn(t, Object.assign({
    SERVICE: "WCS",
    VERSION: i,
    REQUEST: "GetCoverage",
    COVERAGE: n,
    CRS: "EPSG:4326",
    BBOX: `${s.join(",")}`,
    WIDTH: a,
    HEIGHT: l,
    FORMAT: r
  }, c));
  return fetch(d, { method: "get", signal: e, headers: u }).then((f) => f.arrayBuffer());
}
function iw(e) {
  const t = o.get(e, "CoverageDescription.CoverageOffering[0].lonLatEnvelope[0].pos", null);
  if (!t)
    return null;
  const i = [], n = [];
  for (const a of t) {
    const l = a.split(" ");
    n.push(parseFloat(l[0])), i.push(parseFloat(l[1]));
  }
  const r = [Math.min(...i), Math.min(...n)], s = [Math.max(...i), Math.max(...n)];
  return [r[0], r[1], s[0], s[1]];
}
function nw(e) {
  const t = o.get(e, "CoverageDescription.CoverageOffering[0].supportedFormats[0]", null);
  return o.get(t, "formats");
}
class ec extends dn {
  static getKey() {
    return "wcs";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.queryFormat = null, this.config = t, this.converter = cn[t.converter];
    try {
      const i = await ew(this.config.url, this.config.version, this.config.coverage, this.config.searchParams, this.config.headers), n = iw(i), r = nw(i);
      this.queryFormat = r[0], this.minMaxLat = [n[0], n[2]], this.minMaxLon = [n[1], n[3]], this.usable = !0;
    } catch {
      console.log(`Failed fetching wcs from ${this.config.url}`);
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.sourceKey, s = i[0], a = i[1], l = i[2], c = i[3], u = 1 + Math.trunc((i[3] - i[1]) / n[1]), d = 1 + Math.trunc((i[2] - i[0]) / n[0]), f = [a, s, c, l], h = await tw(t, this.config.url, this.config.version, this.config.coverage, this.queryFormat, f, u, d, this.config.searchParams, this.config.headers).then((M) => Rc.fromArrayBuffer(M)).then((M) => M.getImage()), g = h.readRasters(), v = h.getBoundingBox(), x = [v[1], v[0], v[3], v[2]], w = [h.getHeight(), h.getWidth()];
    return new Un(
      r,
      x,
      w,
      (await g)[0],
      !0,
      Ke.DESCENDING,
      Ke.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function th(e, t, i) {
  return e | t << 8 | i << 16 | 62 << 24;
}
function rw(e) {
  const t = new Uint32Array(1), i = new Float32Array(t.buffer);
  return t[0] = e, i[0];
}
function sw(e) {
  const t = 8 * (e.BYTES_PER_ELEMENT - 1), i = new Float32Array(e.length / 3), n = new Uint32Array(i.buffer);
  for (let r = 0; r < i.length; r++)
    n[r] = th(e[r * 3] >> t, e[r * 3 + 1] >> t, e[r * 3 + 2] >> t);
  return i;
}
class tc extends dn {
  static getKey() {
    return "geotiff";
  }
  constructor(t) {
    super(t), this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    this.usable = !1, ++this.sourceKey, this.minMaxLat = null, this.minMaxLon = null, this.minMaxVal = null, this.nodata = t.nodata, this.converter = cn[t.converter], this.rgb = t.rgb;
    try {
      this.geotiff = await Rc.fromUrl(t.url);
    } catch {
      this.geotiff = null, console.error(`Failed fetching geotiff from ${t.url}`);
    }
    if (this.geotiff) {
      if (this.imageCount = await this.geotiff.getImageCount(), this.refImage = await this.geotiff.getImage(), this.nodata === void 0) {
        const n = this.refImage.getFileDirectory(), r = parseFloat(n.GDAL_NODATA);
        r && !isNaN(r) && (this.nodata = r);
      }
      this.rgb === void 0 && (this.rgb = this.refImage.getSamplesPerPixel() > 1), this.rgb && this.nodata && this.nodata.length === 3 && (this.nodata = rw(th(this.nodata[0], this.nodata[1], this.nodata[2])));
      const i = this.refImage.getBoundingBox();
      this.minMaxLat = [i[1], i[3]], this.minMaxLon = [i[0], i[2]], this.usable = !0;
    }
    this.dataChanged();
  }
  async fetch(t, i, n) {
    if (!this.usable)
      return null;
    const r = this.sourceKey;
    let s = await this.geotiff.getImage(0);
    for (let S = 1; S < this.imageCount; ++S) {
      const C = await this.geotiff.getImage(S), [T, k] = C.getResolution(this.refImage);
      if (Math.abs(T) > n[1] || Math.abs(k) > n[0]) break;
      s = C;
    }
    const [a, l] = s.getResolution(this.refImage), [c, u] = this.refImage.getOrigin(), [d, f] = [s.getWidth(), s.getHeight()];
    let h = (i[1] - c) / a, g = (i[3] - c) / a, v = (i[0] - u) / l, x = (i[2] - u) / l;
    a < 0 && ([h, g] = [g, h]), l < 0 && ([v, x] = [x, v]), h = Math.min(d - 1, Math.max(0, Math.floor(h))), g = Math.min(d - 1, Math.max(0, Math.ceil(g))), v = Math.min(f - 1, Math.max(0, Math.floor(v))), x = Math.min(f - 1, Math.max(0, Math.ceil(x)));
    const w = [h, v, g + 1, x + 1], M = this.rgb ? await s.readRGB({ window: w }) : await s.readRasters({ window: w, fillValue: this.nodata }), p = this.rgb ? sw(M) : M[0];
    a < 0 && ([h, g] = [g, h]), l < 0 && ([v, x] = [x, v]);
    const y = [
      u + v * l,
      c + h * a,
      u + x * l,
      c + g * a
    ];
    return new Un(
      r,
      y,
      [M.height, M.width],
      p,
      !0,
      Ke.DESCENDING,
      Ke.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function ic(e, t, i, n) {
  const r = i - t, s = Math.ceil(r / n) - 1;
  return Math.max(0, s);
}
function ow(e, t) {
  const i = ic(e[0], e[1], e[3], t), n = ic(e[2], e[1], e[3], t), r = e[3] - e[1], s = [];
  for (let a = 0; a < i + 2; ++a) {
    const l = e[1] + a / (i + 1) * r;
    s.push([l, e[0]]);
  }
  for (let a = 0; a < n + 2; ++a) {
    const l = e[3] - a / (n + 1) * r;
    s.push([l, e[2]]);
  }
  return s.push([e[1], e[0]]), s;
}
function pr(e, t) {
  return e * 4294967296 + t;
}
function aw(e) {
  const t = Math.floor(e / 4294967296);
  return [t, e - t * 4294967296];
}
class nc extends dn {
  static getKey() {
    return "weacast";
  }
  constructor(t) {
    super(t), this.api = t.weacastApi, this.usable = !1;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(t) {
    if (this.usable = !1, ++this.sourceKey, !this.api) return;
    const i = this.api.models.find((a) => a.name === t.model);
    if (!i) return;
    this.converter = cn[t.converter], this.time = fe(t.forecastTime).utc().format(), this.service = t.model + "/" + t.element, this.lonResolution = i.tileResolution[0], this.useCache = o.get(t, "useCache", !0), this.maxCacheSize = o.get(t, "maxCacheSize", 0), this.useCache ? (this.tileCache = /* @__PURE__ */ new Map(), this.tileCounter = 0, this.tileOrigin = [i.origin[1], i.origin[0]], this.tileSize = [i.tileResolution[1], i.tileResolution[0]], this.wrapLon = i.bounds[2] > 180, this.maxTileX = (i.bounds[2] - i.bounds[0]) / i.tileResolution[0] - 1, this.maxTileY = (i.bounds[3] - i.bounds[1]) / i.tileResolution[1] - 1) : this.tileCache = null, this.minMaxLat = [i.bounds[1], i.bounds[3]];
    const n = i.bounds[2] === 360;
    this.minMaxLon = [n ? -180 : i.bounds[0], n ? 180 : i.bounds[2]], this.minMaxVal = null;
    const r = {
      time: this.time,
      $select: ["forecastTime", "minValue", "maxValue"],
      $paginate: !1
    }, s = await this.api.getService(this.service).find({ query: r });
    s.length > 0 && (this.minMaxVal = [s[0].minValue, s[0].maxValue]), this.usable = !0, this.dataChanged();
  }
  fetch(t, i, n) {
    return this.usable ? this.useCache ? this.fetchWithCache(t, i, n) : this.fetchWithoutCache(t, i, n) : null;
  }
  async fetchWithCache(t, i, n) {
    const r = this.wrapLon && i[1] < 0 ? i[1] + 360 : i[1], s = this.wrapLon && i[3] < 0 ? i[3] + 360 : i[3], a = Math.min(Math.max(Math.floor((s - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX), l = Math.min(Math.max(Math.floor((r - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX), c = Math.min(Math.max(Math.floor((this.tileOrigin[0] - i[2]) / this.tileSize[0]), 0), this.maxTileY), u = Math.min(Math.max(Math.floor((this.tileOrigin[0] - i[0]) / this.tileSize[0]), 0), this.maxTileY), d = [];
    for (let y = c; y <= u; ++y)
      if (l > a) {
        for (let S = 0; S <= a; ++S) d.push(pr(S, y));
        for (let S = l; S <= this.maxTileX; ++S) d.push(pr(S, y));
      } else
        for (let S = l; S <= a; ++S) d.push(pr(S, y));
    const f = [], h = [], g = [], v = d.map((y) => this.tileCache.get(y));
    for (let y = 0; y < d.length; ++y)
      v[y] ? v[y].grid ? h.push(v[y].grid) : f.push(v[y].request) : g.push(d[y]);
    const x = this.sourceKey;
    if (g.length) {
      const y = [], S = [this.tileSize[1] * 0.5, this.tileSize[0] * 0.5];
      for (let k = 0; k < g.length; ++k) {
        const [I, A] = aw(g[k]);
        let P = this.tileOrigin[1] + this.tileSize[1] * I;
        const D = this.tileOrigin[0] - this.tileSize[0] * A;
        P >= 180 && (P -= 360), y.push([P + S[0], D - S[1]]);
      }
      const C = {
        time: this.time,
        $select: ["forecastTime", "data", "geometry", "size", "x", "y"],
        $paginate: !1,
        geometry: {
          $geoIntersects: {
            $geometry: {
              type: "MultiPoint",
              coordinates: y
            }
          }
        }
      }, T = new Promise((k, I) => {
        this.api.getService(this.service).find({ query: C }).then((A) => {
          const P = [];
          if (x === this.sourceKey)
            for (const D of A) {
              const F = D.geometry.coordinates[0], O = [F[0][1], F[0][0], F[2][1], F[2][0]];
              O[1] > O[3] && (O[1] -= 360);
              const $ = pr(D.x, D.y), X = this.tileCache.get($);
              if (X.grid = new Un(
                x,
                O,
                D.size,
                D.data,
                !0,
                Ke.DESCENDING,
                Ke.ASCENDING,
                this.nodata,
                this.converter
              ), X.request = null, this.maxCacheSize !== void 0 && (X.tileCounter = this.tileCounter, ++this.tileCounter, this.tileCounter > this.maxCacheSize)) {
                let te = $, H = X.tileCounter;
                for (const [oe, he] of this.tileCache)
                  he.tileCounter !== void 0 && he.tileCounter < H && (H = he.tileCounter, te = oe);
                this.tileCache.delete(te);
              }
              P.push(X.grid);
            }
          k(P);
        });
      });
      for (let k = 0; k < g.length; ++k)
        this.tileCache.set(g[k], { request: T });
      f.push(T);
    }
    const w = await Promise.all(f), M = h.concat(w.flat());
    if (M.length === 0) return null;
    const p = M.length > 1 ? new fo(x, M) : M[0];
    return new Hf(x, p, i);
  }
  async fetchWithoutCache(t, i, n) {
    const r = {
      time: this.time,
      $select: ["forecastTime", "data", "geometry", "size"],
      $paginate: !1,
      // build a polygon with points longitudaly spaced every lonResolution degrees
      // otherwise mongodb will connect points using shortest path on sphere
      // which is not going to be a square lat/lon box
      geometry: {
        $geoIntersects: {
          $geometry: {
            type: "Polygon",
            coordinates: [ow(i, this.lonResolution)]
          }
        }
      }
    }, s = this.sourceKey, a = await this.api.getService(this.service).find({ query: r });
    if (a.length === 0) return null;
    const l = [];
    for (const c of a) {
      const u = c.geometry.coordinates[0], d = [u[0][1], u[0][0], u[2][1], u[2][0]];
      d[1] > d[3] && (d[1] -= 360);
      const f = new Un(
        s,
        d,
        c.size,
        c.data,
        !0,
        Ke.DESCENDING,
        Ke.ASCENDING,
        this.nodata,
        this.converter
      );
      l.push(f);
    }
    return l.length > 1 ? new fo(s, l) : l[0];
  }
}
function ih(e, t) {
  return Math.floor(e / t) * t;
}
function lw(e, t) {
  const i = ih(e.hours(), t / 3600);
  return e.clone().hours(i).minutes(0).seconds(0).milliseconds(0);
}
function cw(e, t) {
  const i = e.clone().add({ seconds: 0.5 * t }), n = ih(i.hours(), t / 3600);
  return i.clone().hours(n).minutes(0).seconds(0).milliseconds(0);
}
class nh extends dn {
  constructor(t) {
    super(t), this.source = null, this.updateId = null, this.updateCtx = {}, this.buildCtx = {}, this.onDataChanged = this.dataChanged.bind(this);
  }
  getBBox() {
    return this.source ? this.source.getBBox() : null;
  }
  getDataBounds() {
    return this.source ? this.source.getDataBounds() : null;
  }
  supportsNoData() {
    return this.source ? this.source.supportsNoData() : !1;
  }
  async fetch(t, i, n) {
    return this.source ? this.source.fetch(t, i, n) : null;
  }
  invalidate() {
    this.forceUpdate = !0;
  }
  queueUpdate() {
    this.updateId || (this.updateId = setTimeout(() => {
      this.update(this.updateCtx), this.updateId = null;
    }, 50));
  }
  update(t) {
    const i = this.makeBuildContext(t), n = this.forceUpdate ? !1 : this.shouldSkipUpdate(i, this.buildCtx);
    if (this.forceUpdate = !1, n) return;
    this.buildCtx = i;
    const [r, s] = this.buildSourceAndConfig(i);
    this.source && this.source.off("data-changed", this.onDataChanged), this.source = r, this.source ? (this.source.on("data-changed", this.onDataChanged), this.source.setup(s), this.sourceKey = this.source.sourceKey) : this.dataChanged();
  }
  makeBuildContext(t) {
    return Object.assign({}, t);
  }
  shouldSkipUpdate(t, i) {
    return !1;
  }
  buildSourceAndConfig(t) {
    throw new Error("Not implemented");
  }
  deriveConfig(t, i, n) {
    const r = Object.assign({}, i);
    for (const s of o.keys(n)) {
      const a = n[s](t);
      if (a != null) {
        let l = r;
        const c = s.split("$");
        for (let u = 0; u < c.length - 1; ++u)
          l[c[u]] === void 0 && (l[c[u]] = {}), l = l[c[u]];
        l[c[c.length - 1]] = a;
      }
    }
    return r;
  }
  dynpropGenerator(t) {
    if (t.strTemplate)
      return o.template(t.strTemplate);
    if (t.intTemplate) {
      const i = o.template(t.intTemplate);
      return function(n) {
        const r = i(n);
        return parseInt(r);
      };
    }
    if (t.floatTemplate) {
      const i = o.template(t.floatTemplate);
      return function(n) {
        const r = i(n);
        return parseFloat(r);
      };
    }
    return null;
  }
}
function Yr(e) {
  let t = null;
  return typeof e == "string" ? (e.charAt(0) === "P" ? t = fe.duration(e) : t = fe.utc(e), t = t.isValid() ? t : null) : e || (t = fe.duration(0)), t;
}
function Xr(e, t) {
  return fe.isDuration(e) ? t.clone().add(e) : e;
}
class rc extends nh {
  static getKey() {
    return "meteo_model";
  }
  constructor(t) {
    super(t), this.options = t, this.updateCtx.level = void 0;
  }
  setModel(t) {
    this.updateCtx.model = t, this.queueUpdate();
  }
  setTime(t) {
    this.updateCtx.time = t.clone(), this.updateCtx.time.utc(), this.updateCtx.runOffset = 0, this.queueUpdate();
  }
  setLevel(t) {
    t !== null ? this.updateCtx.level = t : this.updateCtx.level && delete this.updateCtx.level, this.queueUpdate();
  }
  async setup(t) {
    this.candidates = [];
    for (const i of t.sources) {
      const n = Object.assign(Object.assign({}, t.default), i), [r, s] = Yn(n), a = {
        key: r,
        staticProps: s,
        dynamicProps: {},
        from: n.from ? Yr(n.from) : null,
        to: n.to ? Yr(n.to) : null,
        model: n.model
      }, l = o.has(n.dynprops, a.key) ? n.dynprops[a.key] : n.dynprops;
      for (const c of o.keys(l)) {
        const u = l[c], d = this.dynpropGenerator(u);
        d && (a.dynamicProps[c] = d);
      }
      this.candidates.push(a);
    }
  }
  makeBuildContext(t) {
    const i = Object.assign({}, t);
    return i.candidate = this.selectCandidate(t.time, t.model.name), i.candidate && (i.runTime = lw(t.time, t.model.runInterval), i.runTime.subtract(i.runOffset * t.model.runInterval, "seconds"), i.forecastTime = cw(t.time, t.model.interval), i.forecastOffset = fe.duration(i.forecastTime.diff(i.runTime)), i.time.utc(), i.runTime.utc(), i.forecastTime.utc()), i;
  }
  shouldSkipUpdate(t, i) {
    return !(i.candidate !== t.candidate || i.runTime && t.runTime && !i.runTime.isSame(t.runTime) || i.forecastTime && t.forecastTime && !i.forecastTime.isSame(t.forecastTime) || i.level !== t.level);
  }
  buildSourceAndConfig(t) {
    let i = null, n = null;
    return t.candidate && (n = this.deriveConfig(t, t.candidate.staticProps, t.candidate.dynamicProps), n && (i = en(t.candidate.key, this.options))), [i, n];
  }
  selectCandidate(t, i) {
    const n = fe();
    let r = null;
    for (const s of this.candidates) {
      if (s.model !== i) continue;
      const a = s.from ? Xr(s.from, n) : null, l = s.to ? Xr(s.to, n) : null;
      if (a && l ? r = t.isBetween(a, l) ? s : null : a ? r = t.isSameOrAfter(a) ? s : null : l && (r = t.isSameOrBefore(l) ? s : null), r) break;
    }
    return r;
  }
  dataChanged() {
    if (this.source && !this.source.usable && this.updateCtx.runOffset === 0) {
      this.updateCtx.runOffset = 1, this.queueUpdate();
      return;
    }
    super.dataChanged();
  }
}
class sc extends nh {
  static getKey() {
    return "time_based";
  }
  constructor(t) {
    super(t), this.options = t;
  }
  setTime(t) {
    this.updateCtx.time = t.clone(), this.updateCtx.time.utc(), this.queueUpdate();
  }
  async setup(t) {
    this.candidates = [];
    for (const i of t.sources) {
      const n = Object.assign(Object.assign({}, t.default), i), [r, s] = Yn(n), a = {
        key: r,
        staticProps: s,
        dynamicProps: {},
        from: n.from ? Yr(n.from) : null,
        to: n.to ? Yr(n.to) : null,
        every: fe.duration(n.every)
      }, l = o.has(n.dynprops, a.key) ? n.dynprops[a.key] : n.dynprops;
      for (const c of o.keys(l)) {
        const u = l[c], d = this.dynpropGenerator(u);
        d && (a.dynamicProps[c] = d);
      }
      this.candidates.push(a);
    }
  }
  makeBuildContext(t) {
    const i = Object.assign({}, t);
    return i.candidate = this.selectCandidate(i.time), i.candidate && (i.stepTime = fe(Math.trunc(i.time / i.candidate.every) * i.candidate.every), i.time.utc(), i.stepTime.utc()), i;
  }
  shouldSkipUpdate(t, i) {
    return !(i.candidate !== t.candidate || i.stepTime && t.stepTime && !i.stepTime.isSame(t.stepTime));
  }
  buildSourceAndConfig(t) {
    let i = null, n = null;
    return t.candidate && (n = this.deriveConfig(t, t.candidate.staticProps, t.candidate.dynamicProps), n && (i = en(t.candidate.key, this.options))), [i, n];
  }
  selectCandidate(t) {
    const i = fe();
    let n = null;
    for (const r of this.candidates) {
      const s = r.from ? Xr(r.from, i) : null, a = r.to ? Xr(r.to, i) : null;
      if (s && a ? n = t.isBetween(s, a) ? r : null : s ? n = t.isSameOrAfter(s) ? r : null : a && (n = t.isSameOrBefore(a) ? r : null), n) break;
    }
    return n;
  }
}
Yt[Xl.getKey()] = function(e) {
  return new Xl(e);
};
Yt[ec.getKey()] = function(e) {
  return new ec(e);
};
Yt[tc.getKey()] = function(e) {
  return new tc(e);
};
Yt[nc.getKey()] = function(e) {
  return new nc(e);
};
Yt[rc.getKey()] = function(e) {
  return new rc(e);
};
Yt[sc.getKey()] = function(e) {
  return new sc(e);
};
cn.kelvin2celsius = function(e) {
  return e - 273.15;
};
const ot = {
  initialize() {
    V.set("geolocation", { location: null, error: void 0 });
  },
  hasLocation() {
    return V.get("geolocation.location");
  },
  get() {
    return V.get("geolocation");
  },
  getLongitude() {
    return V.get("geolocation.location.geometry.coordinates[0]", 0);
  },
  get longitude() {
    return this.getLongitude();
  },
  getLatitude() {
    return V.get("geolocation.location.geometry.coordinates[1]", 0);
  },
  get latitude() {
    return this.getLatitude();
  },
  getAltitude() {
    return V.get("geolocation.location.geometry.coordinates[2]", 0);
  },
  get altitude() {
    return this.getAltitude();
  },
  getGeometry() {
    return V.get("geolocation.location.geometry");
  },
  get geometry() {
    return this.getGeometry();
  },
  getAccuracy() {
    return V.get("geolocation.location.properties.accuracy");
  },
  get accuracy() {
    return this.getAccuracy();
  },
  getAltitudeAccuracy() {
    return V.get("geolocation.location.properties.altitudeAccuracy");
  },
  get altitudeAccuracy() {
    return this.getAltitudeAccuracy();
  },
  async update() {
    let e = null;
    try {
      e = await this.refresh(), V.patch("geolocation", { location: e, error: void 0 }), z.debug("[KDK] Geolocation updated:", e);
    } catch (t) {
      const i = t.code, n = new Gf();
      i === t.PERMISSION_DENIED ? n.code = "GEOLOCATION_PERMISSION_DENIED" : i === t.POSITION_UNAVAILABLE ? n.code = "GEOLOCATION_POSITION_UNAVAILABLE" : i === t.TIMEOUT ? n.code = "GEOLOCATION_POSITION_TIMEOUT" : n.code = "GEOLOCATION_ERROR", V.patch("geolocation", { location: null, error: n }), ne.emit("error", Object.assign(n, {
        // By default we only show geolocation errors, nothing if disabled by user
        ignore: i === t.PERMISSION_DENIED,
        retryHandler: () => this.refresh()
      })), z.debug("[KDK] geolocation failed: ", t);
    }
    return e;
  },
  async refresh() {
    return this.positionPromise = ds(new Promise((e, t) => {
      if (!window.navigator.geolocation) {
        ne.emit("error", {
          message: "errors.GEOLOCATION_NOT_SUPPORTED",
          // By default we only show geolocation errors, nothing if unsupported
          ignore: !0
        });
        return;
      }
      window.navigator.geolocation.getCurrentPosition(
        (i) => {
          const n = i.coords.longitude, r = i.coords.latitude, s = i.coords.altitude;
          e({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: s ? [n, r, s] : [n, r]
            },
            properties: {
              name: Ss(r, n, V.get("locationFormat", "FFf")),
              accuracy: i.coords.accuracy,
              altitudeAccuracy: i.coords.altitudeAccuracy
            }
          });
        },
        (i) => t(i),
        { timeout: 3e4, enableHighAccuracy: !0 }
      );
    })), this.positionPromise;
  }
}, rh = {
  initialize() {
    this.availableApps = {
      waze: "https://waze.com/ul?q=<%= lat %>,<%= lon %>",
      "google-maps": "https://www.google.com/maps/dir/?api=1&destination=<%= lat %>,<%= lon %>",
      "apple-plan": "https://maps.apple.com/place?ll=<%= lat %>,<%= lon %>"
    };
    const e = nt.get("settings");
    if (o.isNil(e)) {
      let t = "google-maps";
      Vt.ios && (t = "apple-plan"), V.set("navigator", t), z.debug("[KDK] Navigator initialized to:", this.get());
    } else
      z.debug("[KDK] Navigator initialized to:", e.navigator);
  },
  get() {
    return V.get("navigator");
  },
  navigateTo(e, t) {
    const i = this.get();
    if (o.isEmpty(i)) {
      z.debug("[KDK] Default navigator is undefined");
      return;
    }
    const r = o.template(this.availableApps[i])({ lat: e, lon: t });
    window.open(r);
  }
}, uw = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`reading GeoJSON file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let a = s.result;
        try {
          a = JSON.parse(a);
        } catch (l) {
          r(new Error(Y.t("errors.INVALID_JSON_FILE", { file: i.name }), { errors: l }));
          return;
        }
        if (a.crs) {
          const l = o.get(a.crs, "properties.name");
          if (l) {
            const c = l.toLowerCase(), u = ["epsg:4326", "urn:ogc:def:crs:OGC:1.3:CRS84", "urn:ogc:def:crs:EPSG::4326"];
            if (!o.some(u, (f) => f.toLowerCase() === c)) {
              r(new Error(Y.t("errors.INVALID_GEOJSON_CRS", { file: i.name }), { errors: `Invalid CRS ${l}` }));
              return;
            }
            delete a.crs;
          }
        }
        n(a);
      }, s.onerror = (a) => {
        z.debug(a), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: a }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, dw = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`reading KML file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let a = s.result;
        try {
          a = sh(new DOMParser().parseFromString(a, "text/xml"));
        } catch (l) {
          z.debug(l), r(new Error(Y.t("errors.INVALID_KML_FILE", { file: i.name }), { errors: l }));
          return;
        }
        n(a);
      }, s.onerror = (a) => {
        z.debug(a), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: a }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
function fw(e) {
  const t = {}, i = ["extrude", "altitudeMode"], n = e.getElementsByTagName("Placemark");
  return o.forEach(n, (r) => {
    const s = r.getElementsByTagName("name");
    if (!s.length) return;
    const a = s[0].textContent;
    o.forEach(i, (l) => {
      const c = r.getElementsByTagName(l);
      if (!c.length) return;
      let u = c[0].textContent;
      ["0", "1"].includes(u) && (u = u === "1"), o.set(t, [a, l].join("."), u);
    });
  }), t;
}
function sh(e) {
  const t = fw(e), i = Mc(e);
  return o.forEach(o.get(i, "features", []), (n) => {
    const r = o.get(n, "properties.name", !1), s = o.merge(li(n.properties), ci(n.properties), ui(n.properties));
    r && o.has(t, r) && o.merge(s, t[r]), o.set(n, "style", s);
    const a = o.mapValues(o.get(n, "properties", {}), (l) => typeof l == "string" ? l.trim() : l);
    o.set(n, "properties", a), o.get(n, "geometry.type") === "Point" && o.has(n, "properties.name") && (o.set(n, "properties.icon-text", n.properties.name), o.set(n, "properties.entityStyle.label", {
      heightReference: "Cesium.HeightReference.RELATIVE_TO_GROUND"
    }));
  }), i;
}
const hw = {
  read(e, t) {
    if (e.length !== 1) {
      z.debug("invalid 'files' arguments");
      return;
    }
    const i = e[0];
    return z.debug(`reading GPX file ${i.name}`), new Promise((n, r) => {
      const s = new FileReader();
      s.onloadend = () => {
        let a = s.result;
        try {
          a = im(new DOMParser().parseFromString(a, "text/xml"));
        } catch (l) {
          z.debug(l), r(new Error(Y.t("errors.INVALID_GPX_FILE", { file: i.name }), { errors: l }));
          return;
        }
        n(a);
      }, s.onerror = (a) => {
        z.debug(a), r(new Error(Y.t("errors.CANNOT_READ_FILE", { file: i.name }), { errors: a }));
      }, s.readAsText(i);
    });
  },
  getAdditionalFiles() {
    return [];
  }
}, mw = {
  async read(e, t) {
    if (e.length < 1 || e.length > this.getAdditionalFiles().length + 1) {
      z.info("invalid 'files' arguments");
      return;
    }
    const i = [], n = e[0];
    i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (h) => {
        z.debug(h), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: n.name }), { errors: h }));
      }, f.readAsArrayBuffer(n);
    }));
    const r = o.find(e, (u) => qt.extname(u.name) === ".prj");
    r && i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (h) => {
        z.debug(h), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: r.name }), { errors: h }));
      }, f.readAsText(r);
    }));
    const s = o.find(e, (u) => qt.extname(u.name) === ".dbf");
    s && i.push(new Promise((u, d) => {
      const f = new FileReader();
      f.onloadend = () => {
        u(f.result);
      }, f.onerror = (h) => {
        z.debug(h), d(new Error(Y.t("errors.CANNOT_READ_FILE", { file: s.name }), { errors: h }));
      }, f.readAsArrayBuffer(s);
    }));
    const a = await Promise.all(i);
    if (s)
      return r ? ti.combine([ti.parseShp(a[0], a[1]), ti.parseDbf(a[2])]) : ti.combine([ti.parseShp(a[0]), ti.parseDbf(a[1])]);
    let l;
    r && (l = ti.parseShp(a[0], a[1])), l = ti.parseShp(a[0]);
    const c = {
      type: "FeatureCollection",
      features: []
    };
    return o.forEach(l, (u) => {
      c.features.push({
        type: "Feature",
        properties: {},
        geometry: u
      });
    }), c;
  },
  getAdditionalFiles() {
    return [".dbf", ".prj", ".shx", ".cpg"];
  }
}, gw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GEOJSONReader: uw,
  GPXReader: hw,
  KMLReader: dw,
  SHPReader: mw,
  convertToGeoJsonWithStyle: sh
}, Symbol.toStringTag, { value: "Module" }));
function pw(e) {
  const t = ["geoJson"];
  return o.omit(e, ...t);
}
function oh(e) {
  const t = this;
  return t.setForecastTime = (i) => {
    t.forecastTime = i, t.emit("forecast-time-changed", i);
  }, t.getForecastTime = () => t.forecastTime, t.createOfflineFeaturesService = async function(i, n = {}) {
    return n = Object.assign(o.omit(n, ["hooks", "dataPath"]), {
      // Set required default hooks and data path for snapshot as the service responds in GeoJson format
      hooks: o.defaultsDeep(o.get(n, "hooks"), {
        before: {
          all: [Fo, ko, Od],
          create: [Mo, Bd],
          remove: Rd
        },
        after: {
          find: [$d, Id]
        }
      }),
      dataPath: "features",
      // Here are service options used to manage offline features services
      features: !0
    }), await t.createOfflineService(i, n);
  }, t;
}
async function ah() {
  const e = this;
  z.debug("[KDK] Initializing Map module..."), e.registerMatcher(pw), e.createService("features-edition", {
    service: Cm({
      id: "_id",
      paginate: { default: 10 },
      matcher: e.matcher
    })
  }), ot.initialize(), Ca.initialize(), po.initialize(), rh.initialize(), V.set("timeFormat", Nt({
    time: Nt({
      short: "H[h]",
      long: "HH:mm"
    }),
    date: Nt({
      short: "DD/MM",
      long: "dddd D"
    }),
    year: Nt({
      short: "YY",
      long: "YYYY"
    }),
    utc: !1,
    locale: Bt()
  })), V.set("locationFormat", "f"), V.set("restore", Nt({
    view: !0,
    layers: !1
  })), V.set("timeseries", Nt({
    span: 1440,
    // 24H
    groupBy: "feature"
  })), o.forEach(o.get(me, "readers.map", []), (t) => {
    z.debug(`[KDK] Registering mime types [${t.mimeTypes}] to reader ${t.reader}`), Pi.register(t.mimeTypes, gw[t.reader]);
  }), Xi.polyline = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M1 44L17 6L33 44L49 6" />',
    clipPath: !1
  }, Xi.polygon = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M10 40L1 24L5 10L20 1L40 10L49 24L40 40L32 49Z" />'
  }, V.set("kdk.map.initialized", !0), z.debug("[KDK] Map module initialized");
}
const Ca = {
  initialize() {
    this.planets = {};
  },
  async connect(e, t = {}) {
    o.defaults(t, {
      origin: window.location.origin,
      apiPath: me.apiPath,
      apiJwt: `${e}-jwt`,
      gatewayJwt: `${e}-gateway-jwt`,
      apiTimeout: me.apiTimeout,
      transport: me.transport,
      appName: `${e}`,
      renewJwt: !1
    });
    const i = await Do(t);
    oh.bind(i)(t), i.on("authenticated", (r) => {
      r.gatewayToken && i.get("storage").setItem(t.gatewayJwt, r.gatewayToken);
    }), i.on("logout", (r) => {
      i.get("storage").removeItem(t.gatewayJwt);
    });
    const n = await i.get("storage").getItem(t.apiJwt);
    if (!n) {
      z.error(new Error(`You must set planet ${e} token first`));
      return;
    }
    return await i.authenticate({
      strategy: "jwt",
      accessToken: n
    }), this.planets[e] = i, i;
  },
  async disconnect(e) {
    await this.planets[e].logout(), delete this.planets[e];
  },
  isConnected(e) {
    return !o.isNil(this.planets[e]);
  },
  get(e) {
    if (!this.planets[e]) z.error(new Error(`You must connect to planet ${e} first`));
    else return this.planets[e];
  },
  // Register an existing planet
  set(e, t) {
    this.planets[e] = t;
  }
}, po = {
  initialize() {
    V.set("geocoder", o.defaultsDeep(me.geocoder, {
      planet: void 0,
      path: "geocoder"
    })), z.debug("[KDK] Geocoder initialized with configuration:", V.get("geocoder"));
  },
  getApiConfig() {
    const e = V.get("geocoder.planet");
    return e ? Ca.get(e).getConfig() : q.getConfig();
  },
  getApiPath() {
    return V.get("geocoder.path");
  },
  async query(e, t = "") {
    const i = this.getApiConfig();
    if (!o.has(i, "gateway")) {
      z.error("[KDK] Invalid Geocoder configuration: missing 'gateway' property");
      return;
    }
    if (!o.has(i, "gatewayJwt")) {
      z.error("[KDK] Invalid Geocoder configuration: missing 'gatewayJwt' property");
      return;
    }
    const n = `${i.gateway}/${this.getApiPath()}`, r = await q.get("storage").getItem(i.gatewayJwt);
    let s = `${n}/${e}`;
    return t && (s += `?${t}`), (await fetch(s, { headers: { Authorization: `Bearer ${r}` } })).json();
  },
  async getForwardCapabilities() {
    let e;
    try {
      e = await this.query("capabilities/forward"), e.i18n && Y.registerTranslation(e.i18n);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return o.get(e, "geocoders", []);
  },
  async getReverseCapabilities() {
    let e;
    try {
      e = await this.query("capabilities/reverse"), e.i18n && Y.registerTranslation(e.i18n);
    } catch {
      ne.emit("error", { message: Y.t("errors.NETWORK_ERROR") });
    }
    return o.get(e, "geocoders", []);
  },
  async queryForward(e, t = {}) {
    const i = [], n = Of(e);
    if (n)
      i.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [n.longitude, n.latitude]
        },
        properties: {
          name: Ss(n.latitude, n.longitude, V.get("locationFormat", "FFf"))
        }
      });
    else {
      let r = "";
      o.isEmpty(t.geocoders) || (r += "&sources=*(" + t.geocoders.join("|") + ")"), o.isEmpty(t.viewbox) || (r += "&viewbox=" + t.viewbox.join(",")), r += "&limit=" + (t.limit || 20), (await this.query("forward", `q=${e}${r}`)).forEach((a) => {
        i.push(
          Object.assign(
            o.pick(a, ["type", "geometry"]),
            { properties: { name: Bf(a), source: a.geokoder.source } }
          )
        );
      });
    }
    return i;
  }
};
function yw() {
  const { getActivityProject: e } = Sa({ selection: !1, probe: !1 }), t = ue([]), i = ue([]), n = ue([]);
  async function r(c) {
    if (o.isNull(c))
      t.value = [], i.value = [];
    else {
      let u = await po.getForwardCapabilities();
      u = Rf(u, e()), o.isEmpty(c) ? (t.value = o.map(u, (d) => ({ value: d, label: Y.tie(`Geocoders.${d}`) })), i.value = u) : (t.value = o.reduce(c, (d, f) => {
        const h = o.replace(f.source, /^services:.*\//g, `services:${ct.getId()}/`), g = o.replace(f.source, /^services:.*\//g, "services:*/");
        return u.includes(h) && d.push({ value: h, label: Y.tie(`Geocoders.${g}`), selected: f.selected }), d;
      }, []), i.value = o.reduce(t.value, (d, f) => (f.selected && d.push(f.value), d), []));
    }
  }
  async function s(c) {
    o.isNull(c) ? n.value = [] : n.value = c;
  }
  async function a() {
    if (await ot.update(), !V.get("geolocation.error"))
      return V.get("geolocation.location");
  }
  async function l(c, u = 25) {
    return po.queryForward(c, {
      geocoders: i.value,
      viewbox: n.value,
      limit: u
    });
  }
  return {
    availableGeocoders: t,
    selectedGeocoders: i,
    setGeocoders: r,
    setViewbox: s,
    geolocate: a,
    search: l
  };
}
function vw() {
  function e(i, n) {
    if (Array.isArray(i) && Array.isArray(n)) {
      const r = hs(pe.getCurrentTime(), i.map((s) => fe.utc(s)));
      return r.index >= 0 ? n[r.index] : null;
    } else
      return n;
  }
  function t(i) {
    const n = o.cloneDeep(i);
    return o.forOwn(n.properties, (r, s) => {
      if (Array.isArray(r)) {
        const a = o.get(n, "time." + s);
        a && (o.set(n, "properties." + s, e(a, r)), o.set(n, "time." + s, e(a, a)));
      }
    }), n;
  }
  return {
    getMeasureValueAtCurrentTime: e,
    getProbedLocationMeasureAtCurrentTime: t
  };
}
function bw(e = {}) {
  const { kActivity: t } = di();
  let i = Wi(t);
  Le(t, (h) => {
    h = Wi(h), i !== h && h && (i = h);
  });
  function n(h) {
    const g = {
      // Only wind/temperature can be available at different levels now
      windDirection: {
        property: i.forecastLevel ? `properties.windDirection-${i.forecastLevel}` : "properties.windDirection"
      },
      windSpeed: {
        property: i.forecastLevel ? `properties.windSpeed-${i.forecastLevel}` : "properties.windSpeed"
      },
      temperature: {
        property: i.forecastLevel ? `properties.temperature-${i.forecastLevel}` : "properties.temperature"
      },
      gust: {
        property: "properties.gust",
        label: "max"
      },
      precipitations: {
        property: "properties.precipitations"
      },
      humidity: {
        property: "properties.humidity"
      },
      time: {
        property: "forecastTime"
      },
      name: {
        property: "properties.name"
      }
    };
    return h && h.length > 0 && o.forOwn(g, (v, x) => {
      const w = o.find(h, { name: `${v.property.replace("properties.", "")}` });
      w && (v.label = w.label);
    }), g;
  }
  function r(h) {
    const { windDirection: g, windSpeed: v } = n();
    return o.has(h, g.property) && o.has(h, v.property);
  }
  function s(h, g = {}) {
    const v = n(), x = o.get(g, "windDirection.label", v.windDirection.label), w = o.get(g, "windSpeed.label", v.windSpeed.label), M = o.get(g, "gust.label", v.gust.label), p = o.get(g, "temperature.label", v.temperature.label), y = o.get(g, "precipitations.label", v.precipitations.label), S = o.get(g, "humidity.label", v.humidity.label), C = o.get(g, "windDirection.property", v.windDirection.property), T = o.get(g, "windSpeed.property", v.windSpeed.property), k = o.get(g, "gust.property", v.gust.property), I = o.get(g, "temperature.property", v.temperature.property), A = o.get(g, "precipitations.property", v.precipitations.property), P = o.get(g, "humidity.property", v.humidity.property), D = o.get(g, "time.property", v.time.property), F = o.get(g, "name.property", v.name.property), O = o.get(h, `${C}`), $ = o.get(h, `${T}`), X = o.get(h, `${k}`), te = o.get(h, `${I}`), H = o.get(h, `${A}`), oe = o.get(h, `${P}`);
    let he = o.get(h, `${D}`), ce = !0;
    if (typeof he == "object") {
      const Q = o.uniq(o.values(he));
      Q.length > 1 ? ce = !1 : he = Q[0];
    }
    const de = (Q) => !o.isNil(Q) && (Q = fe.utc(Q), Q.isValid()) ? ` (${pe.format(Q, "date.short")} - ${pe.format(Q, "time.long")})` : "";
    let R = "";
    if (!o.isNil($) && o.isFinite($) && (w && (R += `${Y.tie(w)}: `), R += be.format($, "m/s"), ce || (R += de(o.get(he, T.replace("properties.", "")))), R += "</br>"), !o.isNil(X) && o.isFinite(X) && (M && (R += `${Y.tie(M)}: `), R += be.format(X, "m/s"), ce || (R += de(o.get(he, k.replace("properties.", "")))), R += "</br>"), !o.isNil(O) && o.isFinite(O) && (x && (R += `${Y.tie(x)}: `), R += be.format(O, "deg"), ce || (R += de(o.get(he, C.replace("properties.", "")))), R += "</br>"), !o.isNil(H) && o.isFinite(H) && (y && (R += `${Y.tie(y)}: `), R += be.format(H, "mm/h"), ce || (R += de(o.get(he, A.replace("properties.", "")))), R += "</br>"), !o.isNil(oe) && o.isFinite(oe) && (S && (R += `${Y.tie(S)}: `), R += `${oe.toFixed(0)} %`, ce || (R += de(o.get(he, P.replace("properties.", "")))), R += "</br>"), !o.isNil(te) && o.isFinite(te) && (p && (R += `${Y.tie(p)}: `), R += be.format(te, "degC"), ce || (R += de(o.get(he, I.replace("properties.", "")))), R += "</br>"), R) {
      const Q = o.get(h, `${F}`);
      o.isNil(Q) || (R = `<b><u>${Q}</u></b></br>` + R), ce && (R += de(he).trim().replace("(", "").replace(")", ""));
    }
    return R;
  }
  function a(h, g) {
    if (Array.isArray(h) && Array.isArray(g)) {
      const v = hs(pe.getCurrentTime(), h.map((x) => fe.utc(x)));
      return v.difference / 1e3 > 0.5 * i.forecastModel.interval ? null : g[v.index];
    } else
      return g;
  }
  function l(h) {
    const g = o.cloneDeep(h);
    return o.forOwn(g.properties, (v, x) => {
      if (Array.isArray(v)) {
        const w = o.get(g, "forecastTime." + x);
        w && (o.set(g, "properties." + x, a(w, v)), o.set(g, "forecastTime." + x, a(w, w)));
      }
    }), g;
  }
  function c(h, g = {}) {
    const v = n();
    let x = o.get(g, "windDirection.property", v.windDirection.property), w = o.get(g, "windSpeed.property", v.windSpeed.property);
    return x = o.get(h, `${x}`), w = o.get(h, `${w}`), o.isNil(x) || !o.isFinite(x) || o.isNil(w) || !o.isFinite(w) ? null : {
      deg: x,
      speed: w,
      // Expressed as m/s
      pointRadius: 10,
      pointColor: "#2196f3",
      pointStroke: "#888888",
      strokeWidth: 2,
      strokeColor: "#888888",
      strokeLength: 12,
      fillColor: "#2196f3",
      barbSpaceing: 4,
      barbHeight: 10,
      forceDir: !0
    };
  }
  function u(h, g = {}) {
    const v = c(h, g);
    return v ? new B.WindBarb.Icon(v) : null;
  }
  function d(h, g, v, x = {}) {
    const w = s(h, x);
    return w ? B.tooltip({ permanent: !1 }, g).setContent(`<b>${w}</b>`) : null;
  }
  function f(h, g, v, x = {}) {
    const w = u(h, x);
    return w ? B.marker(g, { icon: w }) : null;
  }
  return {
    getProbedLocationForecastFields: n,
    isWeatherProbe: r,
    getForecastAsHtml: s,
    getWindBarbOptions: c,
    createWindBarbIcon: u,
    getProbedLocationForecastAtCurrentTime: l,
    getProbedLocationForecastTooltip: d,
    getProbedLocationForecastMarker: f
  };
}
function ww(e = {}) {
  o.defaults(e, {
    // Default filter queries
    layers: {},
    categories: {},
    sublegends: {},
    views: {},
    // Default to contextual or global catalog depending on store
    context: "",
    // Default to app API
    planetApi: q
  });
  const t = ue([]), i = ue([]), n = ue([]), r = ue([]), s = W(() => Td(t.value, i.value)), a = W(() => Pd(t.value, s.value));
  async function l(f = {}) {
    const h = Object.assign(
      {},
      e.project ? Object.assign(Vn(e.project), e.layers) : e.layers,
      f
    );
    return t.value = await Ur({
      query: h,
      context: e.context,
      planetApi: e.planetApi
    }), t.value;
  }
  async function c() {
    return i.value = await qr({
      query: e.categories,
      context: e.context,
      planetApi: e.planetApi
    }), i.value;
  }
  async function u() {
    return n.value = await Gr({
      query: e.sublegends,
      context: e.context,
      planetApi: e.planetApi
    }), n.value;
  }
  async function d() {
    return r.value = await kd({
      query: e.project ? Object.assign(Vn(e.project), e.views) : e.views,
      context: e.context,
      planetApi: e.planetApi
    }), r.value;
  }
  return {
    layers: t,
    categories: i,
    sublegends: n,
    layersByCategory: s,
    orphanLayers: a,
    views: r,
    getLayers: l,
    getCategories: c,
    getSublegends: u,
    getViews: d
  };
}
function _w(e = {}) {
  const { setActivityProject: t } = Sa({ selection: !1, probe: !1 });
  o.defaults(e, {
    // Set if project should be extracted from route
    // otherwise it should be loaded manually
    route: !0,
    // Default to contextual or global service depending on store
    context: "",
    // Default to target activity
    updateActivity: !0,
    // Default to app API
    planetApi: q
  });
  const i = So(), n = xo(), r = ue(null), s = ue(null);
  let a;
  const l = W(() => o.isEmpty(r.value) ? {} : { project: r.value }), c = W(() => o.isEmpty(s.value) ? {} : Vn(s.value));
  function u() {
    return r.value;
  }
  function d() {
    return s.value;
  }
  async function f(x) {
    v();
    const w = x ? o.cloneDeep(x) : {};
    if (o.defaults(w, { populate: !0 }), r.value)
      s.value = await e.planetApi.getService("projects", e.context).get(r.value, { query: w });
    else if (s.value = null, x) {
      const M = await e.planetApi.getService("projects", e.context).find({ query: w });
      s.value = o.get(M, "data[0]"), s.value && (r.value = s.value._id);
    }
    e.updateActivity && t(s.value), s.value && (s.value.getPlanetApi = () => e.planetApi);
  }
  function h(x) {
    s.value && x._id === s.value._id && (s.value = x, e.updateActivity && t(x));
  }
  function g(x) {
    s.value && x._id === s.value._id && (s.value = null, r.value = null, e.route && n.push({
      name: i.name,
      query: o.omit(i.query, ["project"]),
      params: i.params
    }));
  }
  function v() {
    if (!e.route) return;
    const x = o.get(i, "query.project", null);
    r.value !== x && (r.value = x);
  }
  return e.route && Le(() => i.query.project, v), qn(() => {
    v(), a = Ht(e.planetApi.getService("projects", e.context), {
      patched: h,
      updated: h,
      removed: g
    });
  }), Ue(() => {
    Rt(a);
  }), {
    project: s,
    projectId: r,
    hasProject: u,
    isProjectLoaded: d,
    loadProject: f,
    projectQuery: l,
    catalogProjectQuery: c
  };
}
const Lw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HighlightMargin: Sr,
  HighlightsLayerName: gi,
  HighlightsZIndex: Vf,
  useActivity: V0,
  useCatalog: ww,
  useCurrentActivity: Sa,
  useHighlight: Uf,
  useLocation: yw,
  useMeasure: vw,
  useProbe: jf,
  useProject: _w,
  useSelection: Nf,
  useWeather: bw
}, Symbol.toStringTag, { value: "Module" })), xw = {
  emits: [
    "layer-filter-toggled"
  ],
  data() {
    return {
      layerCategories: [],
      variables: [],
      engine: "leaflet",
      engineReady: !1,
      engineContainerWidth: null,
      engineContainerHeight: null
    };
  },
  computed: {
    viewStyle() {
      return "width: 100%; height: 100%; fontWeight: normal; zIndex: 0; position: absolute;";
    },
    variablesForCurrentLevel() {
      return this.variables.map((e) => Object.assign({ name: `${e.name}-${this.selectedLevel}` }, o.omit(e, ["name"])));
    },
    currentVariables() {
      return this.forecastLevel ? this.variablesForCurrentLevel : this.variables;
    }
  },
  methods: {
    is2D() {
      return this.engine === "leaflet";
    },
    is3D() {
      return this.engine === "cesium";
    },
    // This method should be overriden in activities
    getFeatureActions(e, t) {
      return [];
    },
    async getCatalogLayers() {
      const e = {};
      this.project ? Object.assign(e, this.catalogProjectQuery ? this.catalogProjectQuery : Vn(this.project)) : this.project = null;
      let t = await Ur({ query: e });
      const i = V.get("context");
      return i && (t = t.concat(await Ur({ query: e, context: i }))), t;
    },
    async addCatalogLayer(e) {
      if (e[this.engine]) {
        if (o.get(e, `${this.engine}.type`, "").startsWith("weacast.") && (!this.getWeacastApi() || !this.forecastModel)) return;
        await this.addLayer(e);
      }
      e.variables && (this.variables = o.uniqBy(this.variables.concat(e.variables), (t) => t.name));
    },
    async removeCatalogLayer(e) {
      e[this.engine] && await this.removeLayer(e.name);
    },
    async getCatalogCategories() {
      let e = await qr();
      const t = V.get("context");
      return t && (e = e.concat(await qr({ context: t }))), e;
    },
    async getCatalogSublegends() {
      let e = await Gr();
      const t = V.get("context");
      return t && (e = e.concat(await Gr({ context: t }))), e;
    },
    async addCatalogCategory(e) {
      this.layerCategories.push(e);
    },
    async refreshLayerCategories() {
      this.layerCategories.splice(0, this.layerCategories.length);
      const e = await this.getCatalogCategories();
      for (let t = 0; t < e.length; t++)
        this.addCatalogCategory(e[t]);
      await this.refreshOrphanLayers();
    },
    async updateCategoriesOrder(e, t) {
      this.reorganizeLayers();
    },
    async updateLayersOrder(e, t) {
      this.reorganizeLayers();
    },
    async updateOrphanLayersOrder(e) {
      this.reorganizeLayers();
    },
    async refreshLayers() {
      this.clearLayers(), this.variables = [];
      const e = await this.getCatalogLayers();
      for (let i = 0; i < e.length; i++)
        await this.addCatalogLayer(e[i]);
      if (!e.find((i) => i.type === "BaseLayer" && i.isVisible)) {
        const i = e.find((n) => n.type === "BaseLayer");
        i && await this.showLayer(i.name);
      }
    },
    async refreshOrphanLayers() {
      typeof this.reorganizeLayers == "function" && this.reorganizeLayers();
    },
    isInMemoryLayer: At,
    isUserLayer: fi,
    isFeatureLayer: on,
    hasFeatureSchema: nf,
    isLayerSelectable(e) {
      return typeof this.isLayerEdited == "function" && this.isLayerEdited(e) ? !1 : rf(e);
    },
    isLayerProbable: of,
    isLayerStorable: af,
    isLayerCached: cf,
    isLayerCachable: ys,
    setLayerCached: ya,
    setLayerUncached: va,
    isLayerEditable: lf,
    isLayerFilterEditable: yf,
    isLayerRemovable: mf,
    isLayerStyleEditable: gf,
    isLayerDataEditable: pf,
    canCreateLayer() {
      return q.can("create", "catalog");
    },
    canUpdateLayer(e) {
      return At(e) || q.can("update", "catalog");
    },
    canRemoveLayer(e) {
      return At(e) || q.can("remove", "catalog");
    },
    async resetLayer(e) {
      if (this.isLayerVisible(e.name)) {
        let i;
        At(e) && typeof this.toGeoJson == "function" && (i = await this.toGeoJson(e.name)), await this.hideLayer(e.name), await this.showLayer(e.name), i && this.updateLayer(e.name, i), typeof this.updateLayerDisabled == "function" && this.updateLayerDisabled(e);
      }
    },
    configureLayerActions(e) {
      let t = o.get(this, "activityOptions.layers.actions", []);
      return t = Ki(t, o.get(this, "activityOptions.layers.filter", {})), t = Wn(o.cloneDeep(t), this, ["dialog"]), t.push({ id: "toggle", handler: () => this.onTriggerLayer(e) }), t.push({ id: "toggle-filter", handler: (i) => this.onTriggerLayerFilter(e, i) }), e.actions = t, t;
    },
    async onTriggerLayer(e) {
      this.isLayerVisible(e.name) ? await this.hideLayer(e.name) : await this.showLayer(e.name), typeof this.storeContext == "function" && this.storeContext("layers");
    },
    async onTriggerLayerFilter(e, t) {
      typeof this.updateLayer == "function" && await this.updateLayer(e.name, null, { removeMissing: !0 }), this.$emit("layer-filter-toggled", e, t), this.$engineEvents.emit("layer-filter-toggled", e, t);
    },
    onZoomIn() {
      const e = this.getCenter();
      this.center(e.longitude, e.latitude, e.zoomLevel ? e.zoomLevel + 1 : e.altitude * 0.5);
    },
    onZoomOut() {
      const e = this.getCenter();
      this.center(e.longitude, e.latitude, e.zoomLevel ? e.zoomLevel - 1 : e.altitude * 2);
    },
    onZoomToLayer(e) {
      this.zoomToLayer(e.name);
    },
    onBringLayerToFront(e) {
      typeof this.bringLayerToFront == "function" && this.bringLayerToFront(e.name);
    },
    onBringLayerToBack(e) {
      typeof this.bringLayerToBack == "function" && this.bringLayerToBack(e.name);
    },
    async onSaveLayer(e) {
      typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("accept");
      let t;
      if (!o.has(e, "wfs") && o.get(e, `${this.engine}.type`) === "geoJson") {
        const i = this.toGeoJson(e.name);
        t = await Lf(e, i, o.get(this, "activityOptions.featuresChunkSize", 5e3));
      } else
        t = await xf(e);
      this.project && this.project.getPlanetApi() === q && (this.project.layers.push({ _id: t._id }), await q.getService("projects").patch(this.project._id, {
        layers: this.project.layers
      })), t && (e._id = t._id, await this.resetLayer(t));
    },
    editLayerByName(e, t = {}) {
      const i = this.getLayerByName(e);
      i && this.startEditLayer(i, t);
    },
    async onEditLayerData(e) {
      this.isLayerEdited(e) ? await this.stopEditLayer("accept") : await this.startEditLayer(e, { editMode: "edit-properties" });
    },
    async onEndLayerEdition(e = "accept") {
      await this.stopEditLayer(e);
    },
    async onResetLayerStyle(e) {
      await _f(e, {}), e._id || await this.resetLayer(e);
    },
    async onRemoveLayer(e) {
      typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("reject"), await Sf(e) && this.removeLayer(e.name), await this.refreshOrphanLayers();
    },
    onEngineReady(e) {
      this.engine = e, this.engineReady = !0;
    },
    onToggleFullscreen() {
      this.$q.fullscreen.isActive ? this.$q.fullscreen.exit() : this.$q.fullscreen.request();
    },
    listenToCatalogServiceEvents() {
      const e = q.getService("catalog", "global"), t = q.getService("catalog");
      this.globalCatalogListeners = Ht("catalog", {
        context: "global",
        all: this.onCatalogUpdated,
        removed: (i) => this.onCatalogUpdated(i, "removed")
      }, this.globalCatalogListeners), t && t !== e && (this.catalogListeners = Ht("catalog", {
        all: this.onCatalogUpdated,
        removed: (i) => this.onCatalogUpdated(i, "removed")
      }, this.catalogListeners));
    },
    unlistenToCatalogServiceEvents() {
      this.globalCatalogListeners && Rt(this.globalCatalogListeners), this.catalogListeners && Rt(this.catalogListeners), this.globalCatalogListeners = null, this.catalogListeners = null;
    },
    resetCatalogServiceEventsListeners() {
      this.listenToCatalogServiceEvents();
    },
    async initialize() {
      const e = typeof this.restoreContext == "function", t = o.get(me, "weacast.enabled", !0);
      if (t && this.setupWeacast)
        try {
          await this.setupWeacast();
        } catch (n) {
          z.error("[KDK]", n);
        }
      else
        t ? z.warn("[KDK] Weacast setup function is missing") : z.debug("[KDK] disabling Weacast");
      try {
        await this.refreshLayerCategories(), await this.refreshLayers(), e && await this.restoreContext("layers");
      } catch (n) {
        z.error("[KDK]", n);
      }
      e && await this.restoreContext("time"), !(e ? await this.restoreContext("view") : !1) && o.get(this, "activityOptions.restore.geolocation", !0) && (await ot.update(), ot.hasLocation() && this.center(ot.getLongitude(), ot.getLatitude())), this.listenToCatalogServiceEvents();
    },
    finalize() {
      this.unlistenToCatalogServiceEvents();
    },
    async refreshLayer(e, t) {
      let i;
      e && typeof e.getPlanetApi == "function" && (i = e.getPlanetApi()), e && (typeof this.isLayerEdited == "function" && this.isLayerEdited(e) && await this.stopEditLayer("reject"), await this.removeCatalogLayer(e)), t !== "removed" && (i && Object.assign(e, { getPlanetApi: () => i }), await Qo([e], i), await this.addCatalogLayer(e));
    },
    requestRefreshLayer(e, t) {
      this.pendingLayerRefresh || (this.pendingLayerRefresh = {}), this.pendingLayerRefresh[e] && clearTimeout(this.pendingLayerRefresh[e]), this.pendingLayerRefresh[e] = setTimeout(() => {
        delete this.pendingLayerRefresh[e], this.refreshLayer(e, t);
      }, 500);
    },
    async onCatalogUpdated(e, t) {
      switch (e.type) {
        case "Category":
          await this.requestRefreshLayerCategories();
          break;
        case "Context":
        case "Service":
          break;
        default: {
          await this.requestRefreshLayer(e, t);
          break;
        }
      }
    }
  },
  // Need to be in the first lifecycle hook as others mixins might use activity options
  created() {
    const e = o.get(me, `engines.${this.engine}`);
    e && (z.debug(`[KDK] Configuring '${this.engine}' engine with options:`, e), this.activityOptions.engine = o.defaultsDeep(o.get(this.activityOptions, "engine", {}), e)), this.$engineEvents.on("map-ready", this.onEngineReady), this.$engineEvents.on("globe-ready", this.onEngineReady), this.$engineEvents.on("layer-added", this.configureLayerActions);
  },
  mounted() {
    this.requestRefreshLayerCategories = o.debounce(this.refreshLayerCategories, 200), ne.on("navigator-disconnected", this.resetCatalogServiceEventsListeners), ne.on("navigator-reconnected", this.resetCatalogServiceEventsListeners), ne.on("websocket-disconnected", this.resetCatalogServiceEventsListeners), ne.on("websocket-reconnected", this.resetCatalogServiceEventsListeners);
  },
  beforeUnmount() {
    this.$engineEvents.off("map-ready", this.onEngineReady), this.$engineEvents.off("globe-ready", this.onEngineReady), this.$engineEvents.off("layer-added", this.configureLayerActions), ne.off("navigator-disconnected", this.resetCatalogServiceEventsListeners), ne.off("navigator-reconnected", this.resetCatalogServiceEventsListeners), ne.off("websocket-disconnected", this.resetCatalogServiceEventsListeners), ne.off("websocket-reconnected", this.resetCatalogServiceEventsListeners), this.finalize();
  }
}, Sw = {
  methods: {
    getContextKey(e) {
      return `${this.activityName}-${e}`;
    },
    shouldRestoreContext(e) {
      return o.has(this, `activityOptions.restore.${e}`) && !o.get(this, `activityOptions.restore.${e}`) ? !1 : V.get(`restore.${e}`);
    },
    getRouteContext(e) {
      switch (e) {
        case "layers":
          if (o.get(this.$route, "query.layers"))
            return o.pick(this.$route.query, ["layers"]);
          break;
        case "time":
          if (o.get(this.$route, "query.time"))
            return o.pick(this.$route.query, ["time"]);
          break;
        case "view":
        default:
          if (o.get(this.$route, "params.south") && o.get(this.$route, "params.west") && o.get(this.$route, "params.north") && o.get(this.$route, "params.east")) {
            const t = o.pick(this.$route.params, ["south", "west", "north", "east"]);
            return o.mapValues(t, (i) => o.toNumber(i));
          }
          break;
      }
      return {};
    },
    contextAsQuery(e) {
      switch (e) {
        case "layers":
          return !0;
        case "time":
          return !0;
        case "view":
        default:
          return !1;
      }
    },
    getContextParameters(e) {
      let t;
      switch (e) {
        case "layers":
          t = {
            layers: o.values(this.layers).filter(Pe({ isVisible: !0, scope: { $nin: ["system"] }, _id: { $exists: !0 } })).map((i) => i.name)
          };
          break;
        case "time": {
          t = {
            time: pe.getCurrentTime()
          };
          break;
        }
        case "view":
        default: {
          const i = this.getBounds(), n = i[0][0], r = i[0][1], s = i[1][0], a = i[1][1];
          t = { south: n, west: r, north: s, east: a };
        }
      }
      return t;
    },
    updateRouteContext(e, t) {
      const i = this.contextAsQuery(e), n = {
        query: Object.assign({}, o.get(this.$route, "query", {})),
        params: Object.assign({}, o.get(this.$route, "params", {}))
      };
      switch (e) {
        case "layers": {
          t = o.pick(t, ["layers"]);
          break;
        }
        case "time": {
          t = o.pick(t, ["time"]);
          break;
        }
        case "view":
        default:
          t = o.pick(t, ["south", "west", "north", "east"]);
      }
      Object.assign(i ? n.query : n.params, t), this.$router && this.$router.replace(n).catch((r) => {
      });
    },
    async setContextParameters(e, t) {
      switch (e) {
        case "layers": {
          if (!o.has(t, "layers")) return;
          const i = o.values(this.layers).filter(Pe({ isVisible: !0, scope: { $nin: ["system"] }, _id: { $exists: !0 } })).map((c) => c.name);
          let n = o.isArray(t.layers) ? t.layers : [t.layers];
          if (n = n.map((c) => (this.hasLayer(c) || o.startsWith(c, "Layers.") || (o.startsWith(c, "layers-") || (c = "layers-" + c), c = o.replace(o.replace(o.upperCase(c), / /g, "_"), "LAYERS_", "Layers.")), c)), n = n.filter((c) => this.hasLayer(c)), o.isEmpty(n)) return;
          const r = o.difference(n, i), s = o.difference(i, n), a = o.find(s, (c) => this.hasLayer(c) && wi(this.getLayerByName(c))), l = o.find(r, (c) => this.hasLayer(c) && wi(this.getLayerByName(c)));
          a && !l && o.pull(s, a), await Promise.all(r.map((c) => this.showLayer(c))), await Promise.all(s.map((c) => this.hideLayer(c)));
          break;
        }
        case "time": {
          if (!o.has(t, "time")) return;
          V.set("time.currentTime", fe(t.time).utc());
          break;
        }
        case "view":
        default:
          if (!o.has(t, "south") || !o.has(t, "west") || !o.has(t, "north") || !o.has(t, "east")) return;
          this.zoomToBounds([
            [t.south, t.west],
            [t.north, t.east]
          ]);
          break;
      }
    },
    storeContext(e) {
      const t = this.getContextParameters(e);
      this.shouldRestoreContext(e) && (o.isEqual(this.getRouteContext(e), t) || this.updateRouteContext(e, t), nt.set(this.getContextKey(e), t));
    },
    async restoreContext(e) {
      let t = this.getRouteContext(e);
      if (o.isEmpty(t)) {
        const i = nt.get(this.getContextKey(e));
        if (this.shouldRestoreContext(e))
          if (!o.isEmpty(i))
            t = i, Array.isArray(t) && (t = {
              south: t[0][0],
              west: t[0][1],
              north: t[1][0],
              east: t[1][1]
            });
          else {
            if (o.isUndefined(this.homeContext)) {
              const n = await q.getService("catalog").find({ query: { type: "Context", isDefault: !0 } });
              this.homeContext = n.data.length > 0 ? n.data[0] : null;
            }
            this.homeContext && (t = this.homeContext);
          }
      }
      return o.isEmpty(t) || (this.shouldRestoreContext(e) && !o.isEqual(this.getRouteContext(e), t) && this.updateRouteContext(e, t), this.setContextParameters(e, t)), t;
    },
    clearContext(e) {
      let t;
      switch (e) {
        case "layers":
          t = { layers: void 0 };
          break;
        case "time":
          t = { time: void 0 };
          break;
        case "view":
        default:
          t = { south: void 0, west: void 0, north: void 0, east: void 0 };
          break;
      }
      this.updateRouteContext(e, t), window.localStorage.removeItem(this.getContextKey(e));
    },
    async saveContext(e) {
      e = Object.assign({}, e);
      const t = e.layers;
      return delete e.layers, e.type = "Context", Object.assign(e, this.getContextParameters("view")), t && Object.assign(e, this.getContextParameters("layers")), e = await q.getService("catalog").create(e), e;
    },
    async loadContext(e) {
      if (typeof e == "string")
        if (fd(e))
          e = await q.getService("catalog").get(e);
        else {
          const t = await q.getService("catalog").find({ query: { type: "Context", name: e } });
          e = t.data.length > 0 ? t.data[0] : null;
        }
      if (!e) throw new Error("Cannot find or invalid context");
      return this.setContextParameters("view", e), this.setContextParameters("layers", e), e;
    },
    updateViewSettings(e) {
      e || this.clearContext("view");
    },
    updateLayersSettings(e) {
      e || this.clearContext("layers");
    }
  },
  mounted() {
    ne.on("restore-view-changed", this.updateViewSettings), ne.on("restore-layers-changed", this.updateLayersSettings);
  },
  beforeUnmount() {
    ne.off("restore-view-changed", this.updateViewSettings), ne.off("restore-layers-changed", this.updateLayersSettings);
  }
}, Cw = {
  watch: {
    "selection.items": {
      handler() {
        this.updateHighlights(), this.handleWidget(this.getWidgetForSelection());
      }
    },
    "probe.item": {
      handler() {
        this.updateHighlights(), this.handleWidget(this.getWidgetForProbe());
      }
    }
  },
  methods: {
    updateHighlights() {
      this.clearHighlights(), this.getSelectedItems().forEach((e) => {
        this.highlight(e.feature || e.location, e.layer);
      }), this.hasProbedLocation() && this.highlight(this.getProbedLocation(), this.getProbedLayer());
    },
    handleWidget(e) {
      e && e !== "none" && !this.isWidgetWindowVisible(e) && this.openWidget(e);
    }
  }
}, Ew = {
  methods: {
    getBaseQueryForFeatures: bs,
    getFilterQueryForFeatures: ws,
    getSortQueryForFeatures: _s,
    getFeaturesUpdateInterval: Ls,
    getFeaturesQueryInterval: xs,
    shouldSkipFeaturesUpdate: Ef,
    getFeaturesLevel(e) {
      return this.selectableLevelsLayer && this.selectableLevelsLayer.name === e.name ? this.selectedLevel : null;
    },
    getProbeFeatures: Tf,
    async getProbeFeaturesFromLayer(e) {
      const t = this.getLayerByName(e);
      if (t)
        return this.getProbeFeatures(t);
    },
    async getFeaturesQuery(e, t, i) {
      return i || (i = this.getFeaturesLevel(e)), wa(e, t, i);
    },
    getFeaturesFromQuery: Hr,
    async getFeatures(e, t, i) {
      const n = await this.getFeaturesQuery(e, t, i);
      return await Hr(e, n);
    },
    async getFeaturesFromLayer(e, t) {
      const i = this.getLayerByName(e);
      if (i)
        return this.getFeatures(i, t);
    },
    getMeasureForFeatureBaseQuery: Wr,
    async getMeasureForFeatureQuery(e, t, i, n) {
      return await this.getFeaturesQuery(o.merge({
        baseQuery: Wr(e, t)
      }, e), {
        $gte: i.toISOString(),
        $lte: n.toISOString()
      });
    },
    getMeasureForFeatureFromQuery: Zr,
    async getMeasureForFeature(e, t, i, n) {
      let r;
      this.setCursor("processing-cursor");
      try {
        const s = await this.getMeasureForFeatureQuery(e, t, i, n);
        r = await Zr(e, t, s);
      } catch (s) {
        z.error(s);
      }
      return this.unsetCursor("processing-cursor"), r;
    },
    checkFeatures: _a,
    createFeatures: La,
    editFeaturesGeometry: Ff,
    editFeaturesProperties: Df,
    editFeaturesStyle: Af,
    removeFeatures: xa,
    onFeatureUpdated(e, t) {
      !t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerVisible(t.name)) && (typeof this.isLayerEdited == "function" && this.isLayerEdited(t) || Pf(e, t) && typeof this.updateLayer == "function" && [e].filter(Pe(o.omit(t.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"]))).length > 0 && this.updateLayer(t.name, e, { removeMissing: !1 }));
    },
    onFeatureRemoved(e, t) {
      !t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerVisible(t.name)) && (typeof this.isLayerEdited == "function" && this.isLayerEdited(t) || typeof this.updateLayer == "function" && [e].filter(Pe(o.omit(t.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"]))).length > 0 && this.updateLayer(t.name, e, { remove: !0 }));
    },
    listenToFeaturesServiceEventsForLayer(e) {
      const t = Qn(e, {
        created: this.onFeatureUpdated,
        updated: this.onFeatureUpdated,
        patched: this.onFeatureUpdated,
        removed: this.onFeatureRemoved
      }, this.layerServiceEventListeners[e._id]);
      t && (this.layerServiceEventListeners[e._id] = t);
    },
    unlistenToFeaturesServiceEventsForLayer(e) {
      ln(e, this.layerServiceEventListeners[e._id]), delete this.layerServiceEventListeners[e._id];
    },
    listenToFeaturesServiceEventsForLayers() {
      this.layerServiceEventListeners = {}, o.forEach(this.getLayers(), this.listenToFeaturesServiceEventsForLayer);
    },
    unlistenToFeaturesServiceEventsForLayers() {
      o.forOwn(this.layerServiceEventListeners, this.unlistenToFeaturesServiceEventsForLayer), this.layerServiceEventListeners = {};
    }
  },
  created() {
    q.getService("features").timeout = 3600 * 1e3;
  },
  mounted() {
    this.listenToFeaturesServiceEventsForLayers(), this.$engineEvents.on("layer-added", this.listenToFeaturesServiceEventsForLayer), this.$engineEvents.on("layer-removed", this.unlistenToFeaturesServiceEventsForLayer), ne.on("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.on("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  },
  beforeUnmount() {
    this.unlistenToFeaturesServiceEventsForLayers(), this.$engineEvents.off("layer-added", this.listenToFeaturesServiceEventsForLayer), this.$engineEvents.off("layer-removed", this.unlistenToFeaturesServiceEventsForLayer), ne.off("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers), ne.off("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  }
}, Tw = {
  methods: {
    getDefaultInfoBox(e, t) {
      let i = e.properties;
      if (i) {
        const n = o.get(t, this.engine, t);
        if (o.has(n, "infobox") && !o.get(n, "infobox")) return [];
        if (o.has(i, "infobox") && !o.get(i, "infobox")) return [];
        const r = Object.assign(
          {},
          o.get(this, "activityOptions.engine.infobox"),
          n.infobox,
          i.infobox
        );
        r.pick ? i = o.pick(i, r.pick) : r.omit && (i = o.omit(i, r.omit));
      }
      return i;
    }
  },
  created() {
    this.registerStyle("infobox", this.getDefaultInfoBox);
  }
}, Pw = {
  emits: [
    "selected-level-changed"
  ],
  data() {
    return {
      selectedLevel: null,
      selectableLevels: {},
      selectableLevelsLayer: null
    };
  },
  computed: {
    hasSelectableLevels() {
      return o.get(this.selectableLevels, "values", []).length > 0;
    }
  },
  methods: {
    setSelectableLevels(e, t, i) {
      this.selectableLevels = t, this.selectableLevelsLayer = e, o.isNil(i) && (i = o.get(t, "values[0]", o.get(t, "range.min"))), this.setSelectedLevel(i);
    },
    clearSelectableLevels(e) {
      this.selectableLevelsLayer && (this.selectableLevels = {}, this.selectableLevelsLayer = null, this.setSelectedLevel(null));
    },
    setSelectedLevel(e) {
      this.selectedLevel !== e && (this.selectedLevel = e, this.onSelectedLevelChanged(e));
    },
    onSelectedLevelChanged(e) {
      this.$emit("selected-level-changed", e), this.$engineEvents.emit("selected-level-changed", e);
    },
    onShowSelectableLevelsLayer(e) {
      const t = o.get(e, "levels");
      t && this.setSelectableLevels(e, t);
    },
    onHideSelectableLevelsLayer(e) {
      o.get(e, "levels") && this.clearSelectableLevels(e);
    }
  },
  created() {
    this.$engineEvents.on("layer-shown", this.onShowSelectableLevelsLayer), this.$engineEvents.on("layer-hidden", this.onHideSelectableLevelsLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-shown", this.onShowSelectableLevelsLayer), this.$engineEvents.off("layer-hidden", this.onHideSelectableLevelsLayer);
  }
}, kw = {
  methods: {
    registerStyle(e, t) {
      this[e + "Factory"] || (this[e + "Factory"] = []), this[e + "Factory"].push(t);
    },
    unregisterStyle(e, t) {
      o.pull(this[e + "Factory"], t);
    },
    generateStyle() {
      const e = Array.from(arguments), t = e[0];
      if (!this[t + "Factory"]) return;
      e.shift();
      let i;
      for (let n = this[t + "Factory"].length - 1; n >= 0; n--) {
        const r = this[t + "Factory"][n];
        if (i = r(...e), i) break;
      }
      return i;
    }
  }
}, Mw = {
  emits: [
    "forecast-model-changed",
    "forecast-level-changed"
  ],
  data() {
    return {
      forecastModel: null,
      forecastModels: []
    };
  },
  methods: {
    getWeacastApi() {
      return q;
    },
    async setupWeacast() {
      try {
        await this.setupForecastModels();
      } catch (e) {
        z.error("Cannot retrieve available Weacast forecast models", e);
      }
    },
    async setupForecastModels() {
      if (!this.getWeacastApi() || this.getWeacastApi().isDisconnected || this.getWeacastApi().useLocalFirst) return;
      const e = await this.getWeacastApi().getService("forecasts").find();
      this.forecastModels.splice(0, this.forecastModels.length, ...e.data), this.getWeacastApi().models = this.forecastModels, this.forecastModels.forEach((i) => {
        i.actions = [{ id: "toggle", handler: () => this.setForecastModel(i) }];
      });
      let t = this.forecastModels.find((i) => i.isDefault);
      t || (t = this.forecastModels.length > 0 ? this.forecastModels[0] : null), this.setForecastModel(t);
    },
    setForecastModel(e) {
      this.forecastModel !== e && (this.forecastModel = e, this.onForecastModelChanged(e));
    },
    onForecastModelChanged(e) {
      this.$emit("forecast-model-changed", e), this.$engineEvents.emit("forecast-model-changed", e);
    },
    setForecastLevel(e) {
      this.forecastLevel !== e && (this.forecastLevel = e, this.onForecastLevelChanged(e));
    },
    onForecastLevelChanged(e) {
      this.$emit("forecast-level-changed", e), this.$engineEvents.emit("forecast-level-changed", e);
    },
    async getForecastForLocation(e, t, i, n) {
      if (!this.forecastModel) return;
      this.setCursor("processing-cursor");
      const r = await uo({
        startTime: i,
        endTime: n,
        forecastModel: this.forecastModel,
        forecastLevel: this.forecastLevel,
        weacastApi: this.getWeacastApi()
      });
      return this.unsetCursor("processing-cursor"), r;
    },
    async getForecastProbe(e) {
      if (this.forecastModel)
        return this.probe && this.probe.name === e && this.probe.forecast === this.forecastModel.name ? this.probe : (this.probe = await If({ name: e, forecastModel: this.forecastModel, weacastApi: this.getWeacastApi() }), this.probe);
    },
    async getForecastForFeature(e, t, i) {
      if (!this.forecastModel || !this.probe) return;
      this.setCursor("processing-cursor");
      const n = await zf({ probe: this.probe, featureId: e, startTime: t, endTime: i, forecastModel: this.forecastModel, forecastLevel: this.forecastLevel, weacastApi: this.getWeacastApi() });
      return this.unsetCursor("processing-cursor"), n;
    },
    onCurrentForecastTimeChanged(e) {
      this.getWeacastApi() && this.getWeacastApi().setForecastTime(e);
    },
    onWeacastSelectedLevelChanged(e) {
      if (o.isNil(e)) {
        this.setForecastLevel(null);
        return;
      }
      const t = this.selectableLevelsLayer;
      if (t) {
        const i = o.get(t, `${this.engine}.type`), r = o.get(t, "meteo_model.sources", []).find((s) => o.has(s, "weacast"));
        (i.startsWith("weacast") || r) && this.setForecastLevel(e);
      }
    }
  },
  created() {
    ne.on("time-current-time-changed", this.onCurrentForecastTimeChanged), this.$engineEvents.on("selected-level-changed", this.onWeacastSelectedLevelChanged);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentForecastTimeChanged), this.$engineEvents.off("selected-level-changed", this.onWeacastSelectedLevelChanged);
  }
}, Fw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: xw,
  context: Sw,
  featureSelection: Cw,
  featureService: Ew,
  infobox: Tw,
  levels: Pw,
  style: kw,
  weacast: Mw
}, Symbol.toStringTag, { value: "Module" }));
(function() {
  function e(m, b, E) {
    try {
      return window.URL.createObjectURL(new Blob([Uint8Array.from(m.split("").map(function(N) {
        return N.charCodeAt(0);
      }))], { type: b }));
    } catch {
      return "data:" + b + "," + m;
    }
  }
  (function(m) {
    if (m.fetch)
      return;
    var b = {
      searchParams: "URLSearchParams" in m,
      iterable: "Symbol" in m && "iterator" in Symbol,
      blob: "FileReader" in m && "Blob" in m && function() {
        try {
          return new Blob(), !0;
        } catch {
          return !1;
        }
      }(),
      formData: "FormData" in m,
      arrayBuffer: "ArrayBuffer" in m
    };
    if (b.arrayBuffer)
      var E = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ], N = function(G) {
        return G && DataView.prototype.isPrototypeOf(G);
      }, U = ArrayBuffer.isView || function(G) {
        return G && E.indexOf(Object.prototype.toString.call(G)) > -1;
      };
    function J(G) {
      if (typeof G != "string" && (G = String(G)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(G))
        throw new TypeError("Invalid character in header field name");
      return G.toLowerCase();
    }
    function Z(G) {
      return typeof G != "string" && (G = String(G)), G;
    }
    function ae(G) {
      var se = {
        next: function() {
          var we = G.shift();
          return { done: we === void 0, value: we };
        }
      };
      return b.iterable && (se[Symbol.iterator] = function() {
        return se;
      }), se;
    }
    function re(G) {
      this.map = {}, G instanceof re ? G.forEach(function(se, we) {
        this.append(we, se);
      }, this) : Array.isArray(G) ? G.forEach(function(se) {
        this.append(se[0], se[1]);
      }, this) : G && Object.getOwnPropertyNames(G).forEach(function(se) {
        this.append(se, G[se]);
      }, this);
    }
    re.prototype.append = function(G, se) {
      G = J(G), se = Z(se);
      var we = this.map[G];
      this.map[G] = we ? we + "," + se : se;
    }, re.prototype.delete = function(G) {
      delete this.map[J(G)];
    }, re.prototype.get = function(G) {
      return G = J(G), this.has(G) ? this.map[G] : null;
    }, re.prototype.has = function(G) {
      return this.map.hasOwnProperty(J(G));
    }, re.prototype.set = function(G, se) {
      this.map[J(G)] = Z(se);
    }, re.prototype.forEach = function(G, se) {
      var we = this;
      for (var qe in this.map)
        we.map.hasOwnProperty(qe) && G.call(se, we.map[qe], qe, we);
    }, re.prototype.keys = function() {
      var G = [];
      return this.forEach(function(se, we) {
        G.push(we);
      }), ae(G);
    }, re.prototype.values = function() {
      var G = [];
      return this.forEach(function(se) {
        G.push(se);
      }), ae(G);
    }, re.prototype.entries = function() {
      var G = [];
      return this.forEach(function(se, we) {
        G.push([we, se]);
      }), ae(G);
    }, b.iterable && (re.prototype[Symbol.iterator] = re.prototype.entries);
    function xe(G) {
      if (G.bodyUsed)
        return Promise.reject(new TypeError("Already read"));
      G.bodyUsed = !0;
    }
    function Se(G) {
      return new Promise(function(se, we) {
        G.onload = function() {
          se(G.result);
        }, G.onerror = function() {
          we(G.error);
        };
      });
    }
    function De(G) {
      var se = new FileReader(), we = Se(se);
      return se.readAsArrayBuffer(G), we;
    }
    function Qe(G) {
      var se = new FileReader(), we = Se(se);
      return se.readAsText(G), we;
    }
    function Ae(G) {
      for (var se = new Uint8Array(G), we = new Array(se.length), qe = 0; qe < se.length; qe++)
        we[qe] = String.fromCharCode(se[qe]);
      return we.join("");
    }
    function Ye(G) {
      if (G.slice)
        return G.slice(0);
      var se = new Uint8Array(G.byteLength);
      return se.set(new Uint8Array(G)), se.buffer;
    }
    function $e() {
      return this.bodyUsed = !1, this._initBody = function(G) {
        if (this._bodyInit = G, !G)
          this._bodyText = "";
        else if (typeof G == "string")
          this._bodyText = G;
        else if (b.blob && Blob.prototype.isPrototypeOf(G))
          this._bodyBlob = G;
        else if (b.formData && FormData.prototype.isPrototypeOf(G))
          this._bodyFormData = G;
        else if (b.searchParams && URLSearchParams.prototype.isPrototypeOf(G))
          this._bodyText = G.toString();
        else if (b.arrayBuffer && b.blob && N(G))
          this._bodyArrayBuffer = Ye(G.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer]);
        else if (b.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(G) || U(G)))
          this._bodyArrayBuffer = Ye(G);
        else
          throw new Error("unsupported BodyInit type");
        this.headers.get("content-type") || (typeof G == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : b.searchParams && URLSearchParams.prototype.isPrototypeOf(G) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
      }, b.blob && (this.blob = function() {
        var G = xe(this);
        if (G)
          return G;
        if (this._bodyBlob)
          return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]));
      }, this.arrayBuffer = function() {
        return this._bodyArrayBuffer ? xe(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(De);
      }), this.text = function() {
        var G = xe(this);
        if (G)
          return G;
        if (this._bodyBlob)
          return Qe(this._bodyBlob);
        if (this._bodyArrayBuffer)
          return Promise.resolve(Ae(this._bodyArrayBuffer));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText);
      }, b.formData && (this.formData = function() {
        return this.text().then(Cs);
      }), this.json = function() {
        return this.text().then(JSON.parse);
      }, this;
    }
    var Xt = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
    function Bi(G) {
      var se = G.toUpperCase();
      return Xt.indexOf(se) > -1 ? se : G;
    }
    function kt(G, se) {
      se = se || {};
      var we = se.body;
      if (G instanceof kt) {
        if (G.bodyUsed)
          throw new TypeError("Already read");
        this.url = G.url, this.credentials = G.credentials, se.headers || (this.headers = new re(G.headers)), this.method = G.method, this.mode = G.mode, !we && G._bodyInit != null && (we = G._bodyInit, G.bodyUsed = !0);
      } else
        this.url = String(G);
      if (this.credentials = se.credentials || this.credentials || "omit", (se.headers || !this.headers) && (this.headers = new re(se.headers)), this.method = Bi(se.method || this.method || "GET"), this.mode = se.mode || this.mode || null, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && we)
        throw new TypeError("Body not allowed for GET or HEAD requests");
      this._initBody(we);
    }
    kt.prototype.clone = function() {
      return new kt(this, { body: this._bodyInit });
    };
    function Cs(G) {
      var se = new FormData();
      return G.trim().split("&").forEach(function(we) {
        if (we) {
          var qe = we.split("="), wt = qe.shift().replace(/\+/g, " "), Me = qe.join("=").replace(/\+/g, " ");
          se.append(decodeURIComponent(wt), decodeURIComponent(Me));
        }
      }), se;
    }
    function Mh(G) {
      var se = new re();
      return G.split(/\r?\n/).forEach(function(we) {
        var qe = we.split(":"), wt = qe.shift().trim();
        if (wt) {
          var Me = qe.join(":").trim();
          se.append(wt, Me);
        }
      }), se;
    }
    $e.call(kt.prototype);
    function It(G, se) {
      se || (se = {}), this.type = "default", this.status = "status" in se ? se.status : 200, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in se ? se.statusText : "OK", this.headers = new re(se.headers), this.url = se.url || "", this._initBody(G);
    }
    $e.call(It.prototype), It.prototype.clone = function() {
      return new It(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new re(this.headers),
        url: this.url
      });
    }, It.error = function() {
      var G = new It(null, { status: 0, statusText: "" });
      return G.type = "error", G;
    };
    var Fh = [301, 302, 303, 307, 308];
    It.redirect = function(G, se) {
      if (Fh.indexOf(se) === -1)
        throw new RangeError("Invalid status code");
      return new It(null, { status: se, headers: { location: G } });
    }, m.Headers = re, m.Request = kt, m.Response = It, m.fetch = function(G, se) {
      return new Promise(function(we, qe) {
        var wt = new kt(G, se), Me = new XMLHttpRequest();
        Me.onload = function() {
          var hn = {
            status: Me.status,
            statusText: Me.statusText,
            headers: Mh(Me.getAllResponseHeaders() || "")
          };
          hn.url = "responseURL" in Me ? Me.responseURL : hn.headers.get("X-Request-URL");
          var Es = "response" in Me ? Me.response : Me.responseText;
          we(new It(Es, hn));
        }, Me.onerror = function() {
          qe(new TypeError("Network request failed"));
        }, Me.ontimeout = function() {
          qe(new TypeError("Network request failed"));
        }, Me.open(wt.method, wt.url, !0), wt.credentials === "include" && (Me.withCredentials = !0), "responseType" in Me && b.blob && (Me.responseType = "blob"), wt.headers.forEach(function(hn, Es) {
          Me.setRequestHeader(Es, hn);
        }), Me.send(typeof wt._bodyInit > "u" ? null : wt._bodyInit);
      });
    }, m.fetch.polyfill = !0;
  })(typeof self < "u" ? self : void 0);
  var t = function(m, b, E, N, U) {
    var J, Z, ae = U * 8 - N - 1, re = (1 << ae) - 1, xe = re >> 1, Se = -7, De = E ? U - 1 : 0, Qe = E ? -1 : 1, Ae = m[b + De];
    for (De += Qe, J = Ae & (1 << -Se) - 1, Ae >>= -Se, Se += ae; Se > 0; J = J * 256 + m[b + De], De += Qe, Se -= 8)
      ;
    for (Z = J & (1 << -Se) - 1, J >>= -Se, Se += N; Se > 0; Z = Z * 256 + m[b + De], De += Qe, Se -= 8)
      ;
    if (J === 0)
      J = 1 - xe;
    else {
      if (J === re)
        return Z ? NaN : (Ae ? -1 : 1) * (1 / 0);
      Z = Z + Math.pow(2, N), J = J - xe;
    }
    return (Ae ? -1 : 1) * Z * Math.pow(2, J - N);
  }, i = function(m, b, E, N, U, J) {
    var Z, ae, re, xe = J * 8 - U - 1, Se = (1 << xe) - 1, De = Se >> 1, Qe = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ae = N ? 0 : J - 1, Ye = N ? 1 : -1, $e = b < 0 || b === 0 && 1 / b < 0 ? 1 : 0;
    for (b = Math.abs(b), isNaN(b) || b === 1 / 0 ? (ae = isNaN(b) ? 1 : 0, Z = Se) : (Z = Math.floor(Math.log(b) / Math.LN2), b * (re = Math.pow(2, -Z)) < 1 && (Z--, re *= 2), Z + De >= 1 ? b += Qe / re : b += Qe * Math.pow(2, 1 - De), b * re >= 2 && (Z++, re /= 2), Z + De >= Se ? (ae = 0, Z = Se) : Z + De >= 1 ? (ae = (b * re - 1) * Math.pow(2, U), Z = Z + De) : (ae = b * Math.pow(2, De - 1) * Math.pow(2, U), Z = 0)); U >= 8; m[E + Ae] = ae & 255, Ae += Ye, ae /= 256, U -= 8)
      ;
    for (Z = Z << U | ae, xe += U; xe > 0; m[E + Ae] = Z & 255, Ae += Ye, Z /= 256, xe -= 8)
      ;
    m[E + Ae - Ye] |= $e * 128;
  }, n = {
    read: t,
    write: i
  }, r = a, s = n;
  function a(m) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(m) ? m : new Uint8Array(m || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  a.Varint = 0, a.Fixed64 = 1, a.Bytes = 2, a.Fixed32 = 5;
  var l = 65536 * 65536, c = 1 / l;
  a.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(m, b, E) {
      var N = this;
      for (E = E || this.length; this.pos < E; ) {
        var U = N.readVarint(), J = U >> 3, Z = N.pos;
        N.type = U & 7, m(J, b, N), N.pos === Z && N.skip(U);
      }
      return b;
    },
    readMessage: function(m, b) {
      return this.readFields(m, b, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var m = A(this.buf, this.pos);
      return this.pos += 4, m;
    },
    readSFixed32: function() {
      var m = D(this.buf, this.pos);
      return this.pos += 4, m;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var m = A(this.buf, this.pos) + A(this.buf, this.pos + 4) * l;
      return this.pos += 8, m;
    },
    readSFixed64: function() {
      var m = A(this.buf, this.pos) + D(this.buf, this.pos + 4) * l;
      return this.pos += 8, m;
    },
    readFloat: function() {
      var m = s.read(this.buf, this.pos, !0, 23, 4);
      return this.pos += 4, m;
    },
    readDouble: function() {
      var m = s.read(this.buf, this.pos, !0, 52, 8);
      return this.pos += 8, m;
    },
    readVarint: function(m) {
      var b = this.buf, E, N;
      return N = b[this.pos++], E = N & 127, N < 128 || (N = b[this.pos++], E |= (N & 127) << 7, N < 128) || (N = b[this.pos++], E |= (N & 127) << 14, N < 128) || (N = b[this.pos++], E |= (N & 127) << 21, N < 128) ? E : (N = b[this.pos], E |= (N & 15) << 28, u(E, m, this));
    },
    readVarint64: function() {
      return this.readVarint(!0);
    },
    readSVarint: function() {
      var m = this.readVarint();
      return m % 2 === 1 ? (m + 1) / -2 : m / 2;
    },
    readBoolean: function() {
      return !!this.readVarint();
    },
    readString: function() {
      var m = this.readVarint() + this.pos, b = F(this.buf, this.pos, m);
      return this.pos = m, b;
    },
    readBytes: function() {
      var m = this.readVarint() + this.pos, b = this.buf.subarray(this.pos, m);
      return this.pos = m, b;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(m, b) {
      var E = this, N = d(this);
      for (m = m || []; this.pos < N; )
        m.push(E.readVarint(b));
      return m;
    },
    readPackedSVarint: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readSVarint());
      return m;
    },
    readPackedBoolean: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readBoolean());
      return m;
    },
    readPackedFloat: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readFloat());
      return m;
    },
    readPackedDouble: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readDouble());
      return m;
    },
    readPackedFixed32: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readFixed32());
      return m;
    },
    readPackedSFixed32: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readSFixed32());
      return m;
    },
    readPackedFixed64: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readFixed64());
      return m;
    },
    readPackedSFixed64: function(m) {
      var b = this, E = d(this);
      for (m = m || []; this.pos < E; )
        m.push(b.readSFixed64());
      return m;
    },
    skip: function(m) {
      var b = m & 7;
      if (b === a.Varint)
        for (; this.buf[this.pos++] > 127; )
          ;
      else if (b === a.Bytes)
        this.pos = this.readVarint() + this.pos;
      else if (b === a.Fixed32)
        this.pos += 4;
      else if (b === a.Fixed64)
        this.pos += 8;
      else
        throw new Error("Unimplemented type: " + b);
    },
    // === WRITING =================================================================
    writeTag: function(m, b) {
      this.writeVarint(m << 3 | b);
    },
    realloc: function(m) {
      for (var b = this.length || 16; b < this.pos + m; )
        b *= 2;
      if (b !== this.length) {
        var E = new Uint8Array(b);
        E.set(this.buf), this.buf = E, this.length = b;
      }
    },
    finish: function() {
      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
    },
    writeFixed32: function(m) {
      this.realloc(4), P(this.buf, m, this.pos), this.pos += 4;
    },
    writeSFixed32: function(m) {
      this.realloc(4), P(this.buf, m, this.pos), this.pos += 4;
    },
    writeFixed64: function(m) {
      this.realloc(8), P(this.buf, m & -1, this.pos), P(this.buf, Math.floor(m * c), this.pos + 4), this.pos += 8;
    },
    writeSFixed64: function(m) {
      this.realloc(8), P(this.buf, m & -1, this.pos), P(this.buf, Math.floor(m * c), this.pos + 4), this.pos += 8;
    },
    writeVarint: function(m) {
      if (m = +m || 0, m > 268435455 || m < 0) {
        h(m, this);
        return;
      }
      this.realloc(4), this.buf[this.pos++] = m & 127 | (m > 127 ? 128 : 0), !(m <= 127) && (this.buf[this.pos++] = (m >>>= 7) & 127 | (m > 127 ? 128 : 0), !(m <= 127) && (this.buf[this.pos++] = (m >>>= 7) & 127 | (m > 127 ? 128 : 0), !(m <= 127) && (this.buf[this.pos++] = m >>> 7 & 127)));
    },
    writeSVarint: function(m) {
      this.writeVarint(m < 0 ? -m * 2 - 1 : m * 2);
    },
    writeBoolean: function(m) {
      this.writeVarint(!!m);
    },
    writeString: function(m) {
      m = String(m), this.realloc(m.length * 4), this.pos++;
      var b = this.pos;
      this.pos = O(this.buf, m, this.pos);
      var E = this.pos - b;
      E >= 128 && x(b, E, this), this.pos = b - 1, this.writeVarint(E), this.pos += E;
    },
    writeFloat: function(m) {
      this.realloc(4), s.write(this.buf, m, this.pos, !0, 23, 4), this.pos += 4;
    },
    writeDouble: function(m) {
      this.realloc(8), s.write(this.buf, m, this.pos, !0, 52, 8), this.pos += 8;
    },
    writeBytes: function(m) {
      var b = this, E = m.length;
      this.writeVarint(E), this.realloc(E);
      for (var N = 0; N < E; N++)
        b.buf[b.pos++] = m[N];
    },
    writeRawMessage: function(m, b) {
      this.pos++;
      var E = this.pos;
      m(b, this);
      var N = this.pos - E;
      N >= 128 && x(E, N, this), this.pos = E - 1, this.writeVarint(N), this.pos += N;
    },
    writeMessage: function(m, b, E) {
      this.writeTag(m, a.Bytes), this.writeRawMessage(b, E);
    },
    writePackedVarint: function(m, b) {
      this.writeMessage(m, w, b);
    },
    writePackedSVarint: function(m, b) {
      this.writeMessage(m, M, b);
    },
    writePackedBoolean: function(m, b) {
      this.writeMessage(m, S, b);
    },
    writePackedFloat: function(m, b) {
      this.writeMessage(m, p, b);
    },
    writePackedDouble: function(m, b) {
      this.writeMessage(m, y, b);
    },
    writePackedFixed32: function(m, b) {
      this.writeMessage(m, C, b);
    },
    writePackedSFixed32: function(m, b) {
      this.writeMessage(m, T, b);
    },
    writePackedFixed64: function(m, b) {
      this.writeMessage(m, k, b);
    },
    writePackedSFixed64: function(m, b) {
      this.writeMessage(m, I, b);
    },
    writeBytesField: function(m, b) {
      this.writeTag(m, a.Bytes), this.writeBytes(b);
    },
    writeFixed32Field: function(m, b) {
      this.writeTag(m, a.Fixed32), this.writeFixed32(b);
    },
    writeSFixed32Field: function(m, b) {
      this.writeTag(m, a.Fixed32), this.writeSFixed32(b);
    },
    writeFixed64Field: function(m, b) {
      this.writeTag(m, a.Fixed64), this.writeFixed64(b);
    },
    writeSFixed64Field: function(m, b) {
      this.writeTag(m, a.Fixed64), this.writeSFixed64(b);
    },
    writeVarintField: function(m, b) {
      this.writeTag(m, a.Varint), this.writeVarint(b);
    },
    writeSVarintField: function(m, b) {
      this.writeTag(m, a.Varint), this.writeSVarint(b);
    },
    writeStringField: function(m, b) {
      this.writeTag(m, a.Bytes), this.writeString(b);
    },
    writeFloatField: function(m, b) {
      this.writeTag(m, a.Fixed32), this.writeFloat(b);
    },
    writeDoubleField: function(m, b) {
      this.writeTag(m, a.Fixed64), this.writeDouble(b);
    },
    writeBooleanField: function(m, b) {
      this.writeVarintField(m, !!b);
    }
  };
  function u(m, b, E) {
    var N = E.buf, U, J;
    if (J = N[E.pos++], U = (J & 112) >> 4, J < 128 || (J = N[E.pos++], U |= (J & 127) << 3, J < 128) || (J = N[E.pos++], U |= (J & 127) << 10, J < 128) || (J = N[E.pos++], U |= (J & 127) << 17, J < 128) || (J = N[E.pos++], U |= (J & 127) << 24, J < 128) || (J = N[E.pos++], U |= (J & 1) << 31, J < 128))
      return f(m, U, b);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function d(m) {
    return m.type === a.Bytes ? m.readVarint() + m.pos : m.pos + 1;
  }
  function f(m, b, E) {
    return E ? b * 4294967296 + (m >>> 0) : (b >>> 0) * 4294967296 + (m >>> 0);
  }
  function h(m, b) {
    var E, N;
    if (m >= 0 ? (E = m % 4294967296 | 0, N = m / 4294967296 | 0) : (E = ~(-m % 4294967296), N = ~(-m / 4294967296), E ^ 4294967295 ? E = E + 1 | 0 : (E = 0, N = N + 1 | 0)), m >= 18446744073709552e3 || m < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    b.realloc(10), g(E, N, b), v(N, b);
  }
  function g(m, b, E) {
    E.buf[E.pos++] = m & 127 | 128, m >>>= 7, E.buf[E.pos++] = m & 127 | 128, m >>>= 7, E.buf[E.pos++] = m & 127 | 128, m >>>= 7, E.buf[E.pos++] = m & 127 | 128, m >>>= 7, E.buf[E.pos] = m & 127;
  }
  function v(m, b) {
    var E = (m & 7) << 4;
    b.buf[b.pos++] |= E | ((m >>>= 3) ? 128 : 0), m && (b.buf[b.pos++] = m & 127 | ((m >>>= 7) ? 128 : 0), m && (b.buf[b.pos++] = m & 127 | ((m >>>= 7) ? 128 : 0), m && (b.buf[b.pos++] = m & 127 | ((m >>>= 7) ? 128 : 0), m && (b.buf[b.pos++] = m & 127 | ((m >>>= 7) ? 128 : 0), m && (b.buf[b.pos++] = m & 127)))));
  }
  function x(m, b, E) {
    var N = b <= 16383 ? 1 : b <= 2097151 ? 2 : b <= 268435455 ? 3 : Math.ceil(Math.log(b) / (Math.LN2 * 7));
    E.realloc(N);
    for (var U = E.pos - 1; U >= m; U--)
      E.buf[U + N] = E.buf[U];
  }
  function w(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeVarint(m[E]);
  }
  function M(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeSVarint(m[E]);
  }
  function p(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeFloat(m[E]);
  }
  function y(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeDouble(m[E]);
  }
  function S(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeBoolean(m[E]);
  }
  function C(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeFixed32(m[E]);
  }
  function T(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeSFixed32(m[E]);
  }
  function k(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeFixed64(m[E]);
  }
  function I(m, b) {
    for (var E = 0; E < m.length; E++)
      b.writeSFixed64(m[E]);
  }
  function A(m, b) {
    return (m[b] | m[b + 1] << 8 | m[b + 2] << 16) + m[b + 3] * 16777216;
  }
  function P(m, b, E) {
    m[E] = b, m[E + 1] = b >>> 8, m[E + 2] = b >>> 16, m[E + 3] = b >>> 24;
  }
  function D(m, b) {
    return (m[b] | m[b + 1] << 8 | m[b + 2] << 16) + (m[b + 3] << 24);
  }
  function F(m, b, E) {
    for (var N = "", U = b; U < E; ) {
      var J = m[U], Z = null, ae = J > 239 ? 4 : J > 223 ? 3 : J > 191 ? 2 : 1;
      if (U + ae > E)
        break;
      var re, xe, Se;
      ae === 1 ? J < 128 && (Z = J) : ae === 2 ? (re = m[U + 1], (re & 192) === 128 && (Z = (J & 31) << 6 | re & 63, Z <= 127 && (Z = null))) : ae === 3 ? (re = m[U + 1], xe = m[U + 2], (re & 192) === 128 && (xe & 192) === 128 && (Z = (J & 15) << 12 | (re & 63) << 6 | xe & 63, (Z <= 2047 || Z >= 55296 && Z <= 57343) && (Z = null))) : ae === 4 && (re = m[U + 1], xe = m[U + 2], Se = m[U + 3], (re & 192) === 128 && (xe & 192) === 128 && (Se & 192) === 128 && (Z = (J & 15) << 18 | (re & 63) << 12 | (xe & 63) << 6 | Se & 63, (Z <= 65535 || Z >= 1114112) && (Z = null))), Z === null ? (Z = 65533, ae = 1) : Z > 65535 && (Z -= 65536, N += String.fromCharCode(Z >>> 10 & 1023 | 55296), Z = 56320 | Z & 1023), N += String.fromCharCode(Z), U += ae;
    }
    return N;
  }
  function O(m, b, E) {
    for (var N = 0, U, J; N < b.length; N++) {
      if (U = b.charCodeAt(N), U > 55295 && U < 57344)
        if (J)
          if (U < 56320) {
            m[E++] = 239, m[E++] = 191, m[E++] = 189, J = U;
            continue;
          } else
            U = J - 55296 << 10 | U - 56320 | 65536, J = null;
        else {
          U > 56319 || N + 1 === b.length ? (m[E++] = 239, m[E++] = 191, m[E++] = 189) : J = U;
          continue;
        }
      else J && (m[E++] = 239, m[E++] = 191, m[E++] = 189, J = null);
      U < 128 ? m[E++] = U : (U < 2048 ? m[E++] = U >> 6 | 192 : (U < 65536 ? m[E++] = U >> 12 | 224 : (m[E++] = U >> 18 | 240, m[E++] = U >> 12 & 63 | 128), m[E++] = U >> 6 & 63 | 128), m[E++] = U & 63 | 128);
    }
    return E;
  }
  var $ = X;
  function X(m, b) {
    this.x = m, this.y = b;
  }
  X.prototype = {
    clone: function() {
      return new X(this.x, this.y);
    },
    add: function(m) {
      return this.clone()._add(m);
    },
    sub: function(m) {
      return this.clone()._sub(m);
    },
    mult: function(m) {
      return this.clone()._mult(m);
    },
    div: function(m) {
      return this.clone()._div(m);
    },
    rotate: function(m) {
      return this.clone()._rotate(m);
    },
    matMult: function(m) {
      return this.clone()._matMult(m);
    },
    unit: function() {
      return this.clone()._unit();
    },
    perp: function() {
      return this.clone()._perp();
    },
    round: function() {
      return this.clone()._round();
    },
    mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    equals: function(m) {
      return this.x === m.x && this.y === m.y;
    },
    dist: function(m) {
      return Math.sqrt(this.distSqr(m));
    },
    distSqr: function(m) {
      var b = m.x - this.x, E = m.y - this.y;
      return b * b + E * E;
    },
    angle: function() {
      return Math.atan2(this.y, this.x);
    },
    angleTo: function(m) {
      return Math.atan2(this.y - m.y, this.x - m.x);
    },
    angleWith: function(m) {
      return this.angleWithSep(m.x, m.y);
    },
    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(m, b) {
      return Math.atan2(
        this.x * b - this.y * m,
        this.x * m + this.y * b
      );
    },
    _matMult: function(m) {
      var b = m[0] * this.x + m[1] * this.y, E = m[2] * this.x + m[3] * this.y;
      return this.x = b, this.y = E, this;
    },
    _add: function(m) {
      return this.x += m.x, this.y += m.y, this;
    },
    _sub: function(m) {
      return this.x -= m.x, this.y -= m.y, this;
    },
    _mult: function(m) {
      return this.x *= m, this.y *= m, this;
    },
    _div: function(m) {
      return this.x /= m, this.y /= m, this;
    },
    _unit: function() {
      return this._div(this.mag()), this;
    },
    _perp: function() {
      var m = this.y;
      return this.y = this.x, this.x = -m, this;
    },
    _rotate: function(m) {
      var b = Math.cos(m), E = Math.sin(m), N = b * this.x - E * this.y, U = E * this.x + b * this.y;
      return this.x = N, this.y = U, this;
    },
    _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
  }, X.convert = function(m) {
    return m instanceof X ? m : Array.isArray(m) ? new X(m[0], m[1]) : m;
  };
  var te = $, H = oe;
  function oe(m, b, E, N, U) {
    this.properties = {}, this.extent = E, this.type = 0, this._pbf = m, this._geometry = -1, this._keys = N, this._values = U, m.readFields(he, this, b);
  }
  function he(m, b, E) {
    m == 1 ? b.id = E.readVarint() : m == 2 ? ce(E, b) : m == 3 ? b.type = E.readVarint() : m == 4 && (b._geometry = E.pos);
  }
  function ce(m, b) {
    for (var E = m.readVarint() + m.pos; m.pos < E; ) {
      var N = b._keys[m.readVarint()], U = b._values[m.readVarint()];
      b.properties[N] = U;
    }
  }
  oe.types = ["Unknown", "Point", "LineString", "Polygon"], oe.prototype.loadGeometry = function() {
    var m = this._pbf;
    m.pos = this._geometry;
    for (var b = m.readVarint() + m.pos, E = 1, N = 0, U = 0, J = 0, Z = [], ae; m.pos < b; ) {
      if (!N) {
        var re = m.readVarint();
        E = re & 7, N = re >> 3;
      }
      if (N--, E === 1 || E === 2)
        U += m.readSVarint(), J += m.readSVarint(), E === 1 && (ae && Z.push(ae), ae = []), ae.push(new te(U, J));
      else if (E === 7)
        ae && ae.push(ae[0].clone());
      else
        throw new Error("unknown command " + E);
    }
    return ae && Z.push(ae), Z;
  }, oe.prototype.bbox = function() {
    var m = this._pbf;
    m.pos = this._geometry;
    for (var b = m.readVarint() + m.pos, E = 1, N = 0, U = 0, J = 0, Z = 1 / 0, ae = -1 / 0, re = 1 / 0, xe = -1 / 0; m.pos < b; ) {
      if (!N) {
        var Se = m.readVarint();
        E = Se & 7, N = Se >> 3;
      }
      if (N--, E === 1 || E === 2)
        U += m.readSVarint(), J += m.readSVarint(), U < Z && (Z = U), U > ae && (ae = U), J < re && (re = J), J > xe && (xe = J);
      else if (E !== 7)
        throw new Error("unknown command " + E);
    }
    return [Z, re, ae, xe];
  }, oe.prototype.toGeoJSON = function(m, b, E) {
    var N = this.extent * Math.pow(2, E), U = this.extent * m, J = this.extent * b, Z = this.loadGeometry(), ae = oe.types[this.type], re, xe;
    function Se(Ae) {
      for (var Ye = 0; Ye < Ae.length; Ye++) {
        var $e = Ae[Ye], Xt = 180 - ($e.y + J) * 360 / N;
        Ae[Ye] = [
          ($e.x + U) * 360 / N - 180,
          360 / Math.PI * Math.atan(Math.exp(Xt * Math.PI / 180)) - 90
        ];
      }
    }
    switch (this.type) {
      case 1:
        var De = [];
        for (re = 0; re < Z.length; re++)
          De[re] = Z[re][0];
        Z = De, Se(Z);
        break;
      case 2:
        for (re = 0; re < Z.length; re++)
          Se(Z[re]);
        break;
      case 3:
        for (Z = de(Z), re = 0; re < Z.length; re++)
          for (xe = 0; xe < Z[re].length; xe++)
            Se(Z[re][xe]);
        break;
    }
    Z.length === 1 ? Z = Z[0] : ae = "Multi" + ae;
    var Qe = {
      type: "Feature",
      geometry: {
        type: ae,
        coordinates: Z
      },
      properties: this.properties
    };
    return "id" in this && (Qe.id = this.id), Qe;
  };
  function de(m) {
    var b = m.length;
    if (b <= 1)
      return [m];
    for (var E = [], N, U, J = 0; J < b; J++) {
      var Z = R(m[J]);
      Z !== 0 && (U === void 0 && (U = Z < 0), U === Z < 0 ? (N && E.push(N), N = [m[J]]) : N.push(m[J]));
    }
    return N && E.push(N), E;
  }
  function R(m) {
    for (var b = 0, E = 0, N = m.length, U = N - 1, J, Z; E < N; U = E++)
      J = m[E], Z = m[U], b += (Z.x - J.x) * (J.y + Z.y);
    return b;
  }
  var Q = H, _e = j;
  function j(m, b) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = m, this._keys = [], this._values = [], this._features = [], m.readFields(ie, this, b), this.length = this._features.length;
  }
  function ie(m, b, E) {
    m === 15 ? b.version = E.readVarint() : m === 1 ? b.name = E.readString() : m === 5 ? b.extent = E.readVarint() : m === 2 ? b._features.push(E.pos) : m === 3 ? b._keys.push(E.readString()) : m === 4 && b._values.push(le(E));
  }
  function le(m) {
    for (var b = null, E = m.readVarint() + m.pos; m.pos < E; ) {
      var N = m.readVarint() >> 3;
      b = N === 1 ? m.readString() : N === 2 ? m.readFloat() : N === 3 ? m.readDouble() : N === 4 ? m.readVarint64() : N === 5 ? m.readVarint() : N === 6 ? m.readSVarint() : N === 7 ? m.readBoolean() : null;
    }
    return b;
  }
  j.prototype.feature = function(m) {
    if (m < 0 || m >= this._features.length)
      throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[m];
    var b = this._pbf.readVarint() + this._pbf.pos;
    return new Q(this._pbf, b, this.extent, this._keys, this._values);
  };
  var ye = _e, ge = ve;
  function ve(m, b) {
    this.layers = m.readFields(at, {}, b);
  }
  function at(m, b, E) {
    if (m === 3) {
      var N = new ye(E, E.readVarint() + E.pos);
      N.length && (b[N.name] = N);
    }
  }
  var et = ge;
  L.SVG.Tile = L.SVG.extend({
    initialize: function(m, b, E) {
      L.SVG.prototype.initialize.call(this, E), this._tileCoord = m, this._size = b, this._initContainer(), this._container.setAttribute("width", this._size.x), this._container.setAttribute("height", this._size.y), this._container.setAttribute("viewBox", [0, 0, this._size.x, this._size.y].join(" ")), this._layers = {};
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    onAdd: L.Util.falseFn,
    addTo: function(m) {
      if (this._map = m, this.options.interactive)
        for (var b in this._layers) {
          var E = this._layers[b];
          E._path.style.pointerEvents = "auto", this._map._targets[L.stamp(E._path)] = E;
        }
    },
    removeFrom: function(m) {
      if (this.options.interactive)
        for (var b in this._layers) {
          var E = this._layers[b];
          delete this._map._targets[L.stamp(E._path)];
        }
      delete this._map;
    },
    _initContainer: function() {
      L.SVG.prototype._initContainer.call(this), L.SVG.create("rect");
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _addPath: function(m) {
      this._rootGroup.appendChild(m._path), this._layers[L.stamp(m)] = m;
    },
    _updateIcon: function(m) {
      var b = m._path = L.SVG.create("image"), E = m.options.icon, N = E.options, U = L.point(N.iconSize), J = N.iconAnchor || U && U.divideBy(2, !0), Z = m._point.subtract(J);
      b.setAttribute("x", Z.x), b.setAttribute("y", Z.y), b.setAttribute("width", U.x + "px"), b.setAttribute("height", U.y + "px"), b.setAttribute("href", N.iconUrl);
    }
  }), L.svg.tile = function(m, b, E) {
    return new L.SVG.Tile(m, b, E);
  };
  var ht = L.Class.extend({
    // 🍂method initialize(feature: GeoJSON, pxPerExtent: Number)
    // Initializes a new Line Symbolizer given a GeoJSON feature and the
    // pixel-to-coordinate-units ratio. Internal use only.
    // 🍂method render(renderer, style)
    // Renders this symbolizer in the given tiled renderer, with the given
    // `L.Path` options.  Internal use only.
    render: function(m, b) {
      this._renderer = m, this.options = b, m._initPath(this), m._updateStyle(this);
    },
    // 🍂method render(renderer, style)
    // Updates the `L.Path` options used to style this symbolizer, and re-renders it.
    // Internal use only.
    updateStyle: function(m, b) {
      this.options = b, m._updateStyle(this);
    },
    _getPixelBounds: function() {
      for (var m = this._parts, b = L.bounds([]), E = 0; E < m.length; E++)
        for (var N = m[E], U = 0; U < N.length; U++)
          b.extend(N[U]);
      var J = this._clickTolerance(), Z = new L.Point(J, J);
      return b.min._subtract(Z), b.max._add(Z), b;
    },
    _clickTolerance: L.Path.prototype._clickTolerance
  }), er = {
    _makeFeatureParts: function(m, b) {
      var E = m.geometry, N;
      this._parts = [];
      for (var U = 0; U < E.length; U++) {
        for (var J = E[U], Z = [], ae = 0; ae < J.length; ae++)
          N = J[ae], Z.push(L.point(N).scaleBy(b));
        this._parts.push(Z);
      }
    },
    makeInteractive: function() {
      this._pxBounds = this._getPixelBounds();
    }
  }, fn = L.CircleMarker.extend({
    includes: ht.prototype,
    statics: {
      iconCache: {}
    },
    initialize: function(m, b) {
      this.properties = m.properties, this._makeFeatureParts(m, b);
    },
    render: function(m, b) {
      ht.prototype.render.call(this, m, b), this._radius = b.radius || L.CircleMarker.prototype.options.radius, this._updatePath();
    },
    _makeFeatureParts: function(m, b) {
      var E = m.geometry[0];
      typeof E[0] == "object" && "x" in E[0] ? (this._point = L.point(E[0]).scaleBy(b), this._empty = L.Util.falseFn) : (this._point = L.point(E).scaleBy(b), this._empty = L.Util.falseFn);
    },
    makeInteractive: function() {
      this._updateBounds();
    },
    updateStyle: function(m, b) {
      return this._radius = b.radius || this._radius, this._updateBounds(), ht.prototype.updateStyle.call(this, m, b);
    },
    _updateBounds: function() {
      var m = this.options.icon;
      if (m) {
        var b = L.point(m.options.iconSize), E = m.options.iconAnchor || b && b.divideBy(2, !0), N = this._point.subtract(E);
        this._pxBounds = new L.Bounds(N, N.add(m.options.iconSize));
      } else
        L.CircleMarker.prototype._updateBounds.call(this);
    },
    _updatePath: function() {
      this.options.icon ? this._renderer._updateIcon(this) : L.CircleMarker.prototype._updatePath.call(this);
    },
    _getImage: function() {
      if (this.options.icon) {
        var m = this.options.icon.options.iconUrl, b = fn.iconCache[m];
        if (!b) {
          var E = this.options.icon;
          b = fn.iconCache[m] = E.createIcon();
        }
        return b;
      } else
        return null;
    },
    _containsPoint: function(m) {
      var b = this.options.icon;
      return b ? this._pxBounds.contains(m) : L.CircleMarker.prototype._containsPoint.call(this, m);
    }
  }), Th = L.Polyline.extend({
    includes: [ht.prototype, er],
    initialize: function(m, b) {
      this.properties = m.properties, this._makeFeatureParts(m, b);
    },
    render: function(m, b) {
      b.fill = !1, ht.prototype.render.call(this, m, b), this._updatePath();
    },
    updateStyle: function(m, b) {
      b.fill = !1, ht.prototype.updateStyle.call(this, m, b);
    }
  }), Ph = L.Polygon.extend({
    includes: [ht.prototype, er],
    initialize: function(m, b) {
      this.properties = m.properties, this._makeFeatureParts(m, b);
    },
    render: function(m, b) {
      ht.prototype.render.call(this, m, b), this._updatePath();
    }
  });
  L.VectorGrid = L.GridLayer.extend({
    options: {
      // 🍂option rendererFactory = L.svg.tile
      // A factory method which will be used to instantiate the per-tile renderers.
      rendererFactory: L.svg.tile,
      // 🍂option vectorTileLayerStyles: Object = {}
      // A data structure holding initial symbolizer definitions for the vector features.
      vectorTileLayerStyles: {},
      // 🍂option interactive: Boolean = false
      // Whether this `VectorGrid` fires `Interactive Layer` events.
      interactive: !1
      // 🍂option getFeatureId: Function = undefined
      // A function that, given a vector feature, returns an unique identifier for it, e.g.
      // `function(feat) { return feat.properties.uniqueIdField; }`.
      // Must be defined for `setFeatureStyle` to work.
    },
    initialize: function(m) {
      L.setOptions(this, m), L.GridLayer.prototype.initialize.apply(this, arguments), this.options.getFeatureId && (this._vectorTiles = {}, this._overriddenStyles = {}, this.on("tileunload", function(b) {
        var E = this._tileCoordsToKey(b.coords), N = this._vectorTiles[E];
        N && this._map && N.removeFrom(this._map), delete this._vectorTiles[E];
      }, this)), this._dataLayerNames = {};
    },
    createTile: function(m, b) {
      var E = this.options.getFeatureId, N = this.getTileSize(), U = this.options.rendererFactory(m, N, this.options), J = this._getVectorTilePromise(m);
      return E && (this._vectorTiles[this._tileCoordsToKey(m)] = U, U._features = {}), J.then((function(ae) {
        for (var re in ae.layers) {
          this._dataLayerNames[re] = !0;
          for (var xe = ae.layers[re], Se = this.getTileSize().divideBy(xe.extent), De = this.options.vectorTileLayerStyles[re] || L.Path.prototype.options, Qe = 0; Qe < xe.features.length; Qe++) {
            var Ae = xe.features[Qe], Ye, $e = De;
            if (E) {
              Ye = this.options.getFeatureId(Ae);
              var Xt = this._overriddenStyles[Ye];
              Xt && (Xt[re] ? $e = Xt[re] : $e = Xt);
            }
            if ($e instanceof Function && ($e = $e(Ae.properties, m.z)), $e instanceof Array || ($e = [$e]), !!$e.length) {
              for (var Bi = this._createLayer(Ae, Se), kt = 0; kt < $e.length; kt++) {
                var Cs = L.extend({}, L.Path.prototype.options, $e[kt]);
                Bi.render(U, Cs), U._addPath(Bi);
              }
              this.options.interactive && Bi.makeInteractive(), E && (U._features[Ye] = {
                layerName: re,
                feature: Bi
              });
            }
          }
        }
        this._map != null && U.addTo(this._map), L.Util.requestAnimFrame(b.bind(m, null, null));
      }).bind(this)), U.getContainer();
    },
    // 🍂method setFeatureStyle(id: Number, layerStyle: L.Path Options): this
    // Given the unique ID for a vector features (as per the `getFeatureId` option),
    // re-symbolizes that feature across all tiles it appears in.
    setFeatureStyle: function(m, b) {
      this._overriddenStyles[m] = b;
      for (var E in this._vectorTiles) {
        var N = this._vectorTiles[E], U = N._features, J = U[m];
        if (J) {
          var Z = J.feature, ae = b;
          b[J.layerName] && (ae = b[J.layerName]), this._updateStyles(Z, N, ae);
        }
      }
      return this;
    },
    // 🍂method setFeatureStyle(id: Number): this
    // Reverts the effects of a previous `setFeatureStyle` call.
    resetFeatureStyle: function(m) {
      delete this._overriddenStyles[m];
      for (var b in this._vectorTiles) {
        var E = this._vectorTiles[b], N = E._features, U = N[m];
        if (U) {
          var J = U.feature, Z = this.options.vectorTileLayerStyles[U.layerName] || L.Path.prototype.options;
          this._updateStyles(J, E, Z);
        }
      }
      return this;
    },
    // 🍂method getDataLayerNames(): Array
    // Returns an array of strings, with all the known names of data layers in
    // the vector tiles displayed. Useful for introspection.
    getDataLayerNames: function() {
      return Object.keys(this._dataLayerNames);
    },
    _updateStyles: function(m, b, E) {
      E = E instanceof Function ? E(m.properties, b.getCoord().z) : E, E instanceof Array || (E = [E]);
      for (var N = 0; N < E.length; N++) {
        var U = L.extend({}, L.Path.prototype.options, E[N]);
        m.updateStyle(b, U);
      }
    },
    _createLayer: function(m, b, E) {
      var N;
      switch (m.type) {
        case 1:
          N = new fn(m, b);
          break;
        case 2:
          N = new Th(m, b);
          break;
        case 3:
          N = new Ph(m, b);
          break;
      }
      return this.options.interactive && N.addEventParent(this), N;
    }
  }), L.vectorGrid = function(m) {
    return new L.VectorGrid(m);
  }, L.VectorGrid.Protobuf = L.VectorGrid.extend({
    options: {
      // 🍂section
      // As with `L.TileLayer`, the URL template might contain a reference to
      // any option (see the example above and note the `{key}` or `token` in the URL
      // template, and the corresponding option).
      //
      // 🍂option subdomains: String = 'abc'
      // Akin to the `subdomains` option for `L.TileLayer`.
      subdomains: "abc",
      // Like L.TileLayer
      //
      // 🍂option fetchOptions: Object = {}
      // options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
      fetchOptions: {}
    },
    initialize: function(m, b) {
      this._url = m, L.VectorGrid.prototype.initialize.call(this, b);
    },
    // 🍂method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    setUrl: function(m, b) {
      return this._url = m, b || this.redraw(), this;
    },
    _getSubdomain: L.TileLayer.prototype._getSubdomain,
    _getVectorTilePromise: function(m) {
      var b = {
        s: this._getSubdomain(m),
        x: m.x,
        y: m.y,
        z: m.z
        // 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
      };
      if (this._map && !this._map.options.crs.infinite) {
        var E = this._globalTileRange.max.y - m.y;
        this.options.tms && (b.y = E), b["-y"] = E;
      }
      var N = L.Util.template(this._url, L.extend(b, this.options));
      return fetch(N, this.options.fetchOptions).then(function(U) {
        return U.ok ? U.blob().then(function(J) {
          var Z = new FileReader();
          return new Promise(function(ae) {
            Z.addEventListener("loadend", function() {
              var re = new r(Z.result);
              return ae(new et(re));
            }), Z.readAsArrayBuffer(J);
          });
        }) : { layers: [] };
      }).then(function(U) {
        for (var J in U.layers) {
          for (var Z = [], ae = 0; ae < U.layers[J].length; ae++) {
            var re = U.layers[J].feature(ae);
            re.geometry = re.loadGeometry(), Z.push(re);
          }
          U.layers[J].features = Z;
        }
        return U;
      });
    }
  }), L.vectorGrid.protobuf = function(m, b) {
    return new L.VectorGrid.Protobuf(m, b);
  };
  var kh = e(`'use strict';

var simplify_1 = simplify$1;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify$1(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

var convert_1 = convert$1;

var simplify = simplify_1;

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert$1(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    if (feature.geometry === null) {
        // ignore features with null geometry
        return;
    }

    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings, projectedRing;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            projectedRing = project(coords[i], tolerance);
            if (type === 'Polygon') { projectedRing.outer = (i === 0); }
            rings.push(projectedRing);
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                projectedRing = project(coords[i][j], tolerance);
                projectedRing.outer = (j === 0);
                rings.push(projectedRing);
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < 0 ? 0 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) { calcRingBBox(min, max, geometry); }
    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

var tile = transformTile;
var point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) { return tile; }

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

var transform$1 = {
	tile: tile,
	point: point
};

var clip_1 = clip$1;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   ____|____/
 *     |        |
 */

function clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept
    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) { continue; } // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) { slice.push(a); }
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            outer = points.outer,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) { slice.push(a); }

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }

        // add the final slice
        newSlice(slices, slice, area, dist, outer);
    }

    return slices;
}

function newSlice(slices, slice, area, dist, outer) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;
        if (outer !== undefined) { slice.outer = outer; }

        slices.push(slice);
    }
    return [];
}

var clip$2 = clip_1;

var wrap_1 = wrap$1;

function wrap$1(features, buffer, intersectX) {
    var merged = features,
        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center
        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

var tile$1 = createTile$1;

function createTile$1(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }
        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }
        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }
        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            if (type === 3) { rewind(simplifiedRing, ring.outer); }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

function rewind(ring, clockwise) {
    var area = signedArea(ring);
    if (area < 0 === clockwise) { ring.reverse(); }
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
}

var index = geojsonvt;

var convert = convert_1;
var transform = transform$1;
var clip = clip_1;
var wrap = wrap_1;
var createTile = tile$1;     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) { console.time('preprocess data'); }

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) { this.splitTile(features, 0, 0, 0); }

    if (debug) {
        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {
    var this$1 = this;


    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this$1.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) { console.time('creation'); }

            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this$1.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this$1.stats[key] = (this$1.stats[key] || 0) + 1;
                this$1.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) { continue; }

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) { solid = z; } // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) { console.time('clipping'); }

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) { console.timeEnd('clipping'); }

        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }
        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }
        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }
        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var this$1 = this;

    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }

    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this$1.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) { return null; }

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }

    if (debug > 1) { console.time('drilling down'); }
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) { console.timeEnd('drilling down'); }

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) { dest[i] = src[i]; }
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) { return false; }

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }

    var len = feature.geometry[0].length;
    if (len !== 5) { return false; }

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }
    }

    return true;
}

var identity = function(x) {
  return x;
};

var transform$3 = function(topology) {
  if ((transform = topology.transform) == null) { return identity; }
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) { x0 = y0 = 0; }
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
    return point;
  };
};

var bbox = function(topology) {
  var bbox = topology.bbox;

  function bboxPoint(p0) {
    p1[0] = p0[0], p1[1] = p0[1], t(p1);
    if (p1[0] < x0) { x0 = p1[0]; }
    if (p1[0] > x1) { x1 = p1[0]; }
    if (p1[1] < y0) { y0 = p1[1]; }
    if (p1[1] > y1) { y1 = p1[1]; }
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  if (!bbox) {
    var t = transform$3(topology), p0, p1 = new Array(2), name,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length;
      while (++i < n) {
        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);
        if (p1[0] < x0) { x0 = p1[0]; }
        if (p1[0] > x1) { x1 = p1[0]; }
        if (p1[1] < y0) { y0 = p1[1]; }
        if (p1[1] > y1) { y1 = p1[1]; }
      }
    });

    for (name in topology.objects) {
      bboxGeometry(topology.objects[name]);
    }

    bbox = topology.bbox = [x0, y0, x1, y1];
  }

  return bbox;
};

var reverse = function(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }
};

var feature = function(topology, o) {
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
      : feature$1(topology, o);
};

function feature$1(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = transform$3(topology),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) { points.pop(); }
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k].slice(), k));
    }
    if (i < 0) { reverse(points, n); }
  }

  function point(p) {
    return transformPoint(p.slice());
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }
    if (points.length < 2) { points.push(points[0].slice()); }
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) { points.push(points[0].slice()); }
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}

var stitch = function(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }
    else { p1 = arc[arc.length - 1]; }
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });

  return fragments;
};

function extractArcs(topology, object$$1, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object$$1);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });

  return arcs;
}

function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }
  return Math.abs(area); // Note: doubled area!
}

var bisect = function(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
};

var slicers = {};
var options;

onmessage = function (e) {
	if (e.data[0] === 'slice') {
		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.
		var geojson = e.data[1];
		options     = e.data[2];

		if (geojson.type && geojson.type === 'Topology') {
			for (var layerName in geojson.objects) {
				slicers[layerName] = index(
					feature(geojson, geojson.objects[layerName])
				, options);
			}
		} else {
			slicers[options.vectorTileLayerName] = index(geojson, options);
		}

	} else if (e.data[0] === 'get') {
		// Gets the vector tile for the given coordinates, sends it back as a message
		var coords = e.data[1];

		var tileLayers = {};
		for (var layerName in slicers) {
			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);

			if (slicedTileLayer) {
				var vectorTileLayer = {
					features: [],
					extent: options.extent,
					name: options.vectorTileLayerName,
					length: slicedTileLayer.features.length
				};

				for (var i in slicedTileLayer.features) {
					var feat = {
						geometry: slicedTileLayer.features[i].geometry,
						properties: slicedTileLayer.features[i].tags,
						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon
					};
					vectorTileLayer.features.push(feat);
				}
				tileLayers[layerName] = vectorTileLayer;
			}
		}
		postMessage({ layers: tileLayers, coords: coords });
	}
};
//# sourceMappingURL=slicerWebWorker.js.worker.map
`, "text/plain; charset=us-ascii");
  L.VectorGrid.Slicer = L.VectorGrid.extend({
    options: {
      // 🍂section
      // Additionally to these options, `VectorGrid.Slicer` can take in any
      // of the [`geojson-vt` options](https://github.com/mapbox/geojson-vt#options).
      // 🍂option vectorTileLayerName: String = 'sliced'
      // Vector tiles contain a set of *data layers*, and those data layers
      // contain features. Thus, the slicer creates one data layer, with
      // the name given in this option. This is important for symbolizing the data.
      vectorTileLayerName: "sliced",
      extent: 4096,
      // Default for geojson-vt
      maxZoom: 14
      // Default for geojson-vt
    },
    initialize: function(m, E) {
      L.VectorGrid.prototype.initialize.call(this, E);
      var E = {};
      for (var N in this.options)
        N !== "rendererFactory" && N !== "vectorTileLayerStyles" && typeof this.options[N] != "function" && (E[N] = this.options[N]);
      this._worker = new Worker(kh), this._worker.postMessage(["slice", m, E]);
    },
    _getVectorTilePromise: function(m) {
      var b = this, E = new Promise(function(U) {
        b._worker.addEventListener("message", function J(Z) {
          Z.data.coords && Z.data.coords.x === m.x && Z.data.coords.y === m.y && Z.data.coords.z === m.z && (U(Z.data), b._worker.removeEventListener("message", J));
        });
      });
      return this._worker.postMessage(["get", m]), E;
    }
  }), L.vectorGrid.slicer = function(m, b) {
    return new L.VectorGrid.Slicer(m, b);
  }, L.Canvas.Tile = L.Canvas.extend({
    initialize: function(m, b, E) {
      L.Canvas.prototype.initialize.call(this, E), this._tileCoord = m, this._size = b, this._initContainer(), this._container.setAttribute("width", this._size.x), this._container.setAttribute("height", this._size.y), this._layers = {}, this._drawnLayers = {}, this._drawing = !0, E.interactive && (this._container.style.pointerEvents = "auto");
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    getOffset: function() {
      return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
    },
    onAdd: L.Util.falseFn,
    addTo: function(m) {
      this._map = m;
    },
    removeFrom: function(m) {
      delete this._map;
    },
    _onClick: function(m) {
      var b = this._map.mouseEventToLayerPoint(m).subtract(this.getOffset()), E, N;
      for (var U in this._layers)
        E = this._layers[U], E.options.interactive && E._containsPoint(b) && !this._map._draggableMoved(E) && (N = E);
      N && (L.DomEvent.fakeStop(m), this._fireEvent([N], m));
    },
    _onMouseMove: function(m) {
      if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
        var b = this._map.mouseEventToLayerPoint(m).subtract(this.getOffset());
        this._handleMouseHover(m, b);
      }
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _updateIcon: function(m) {
      if (this._drawing) {
        var b = m.options.icon, E = b.options, N = L.point(E.iconSize), U = E.iconAnchor || N && N.divideBy(2, !0), J = m._point.subtract(U), Z = this._ctx, ae = m._getImage();
        ae.complete ? Z.drawImage(ae, J.x, J.y, N.x, N.y) : L.DomEvent.on(ae, "load", function() {
          Z.drawImage(ae, J.x, J.y, N.x, N.y);
        }), this._drawnLayers[m._leaflet_id] = m;
      }
    }
  }), L.canvas.tile = function(m, b, E) {
    return new L.Canvas.Tile(m, b, E);
  };
})();
var Ws = { exports: {} }, oc;
function Dw() {
  return oc || (oc = 1, function(e, t) {
    (function(i, n) {
      e.exports = i(B, kc);
    })(function(i, n) {
      if (typeof r > "u")
        var r = { iso8601: n };
      return i.TimeDimension = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        initialize: function(s) {
          i.setOptions(this, s), this._availableTimes = this._generateAvailableTimes(), this._currentTimeIndex = -1, this._loadingTimeIndex = -1, this._loadingTimeout = this.options.loadingTimeout || 3e3, this._syncedLayers = [], this._availableTimes.length > 0 && this.setCurrentTime(this.options.currentTime || this._getDefaultCurrentTime()), this.options.lowerLimitTime && this.setLowerLimit(this.options.lowerLimitTime), this.options.upperLimitTime && this.setUpperLimit(this.options.upperLimitTime);
        },
        getAvailableTimes: function() {
          return this._availableTimes;
        },
        getCurrentTimeIndex: function() {
          return this._currentTimeIndex === -1 ? this._availableTimes.length - 1 : this._currentTimeIndex;
        },
        getCurrentTime: function() {
          var s = -1;
          return this._loadingTimeIndex !== -1 ? s = this._loadingTimeIndex : s = this.getCurrentTimeIndex(), s >= 0 ? this._availableTimes[s] : null;
        },
        isLoading: function() {
          return this._loadingTimeIndex !== -1;
        },
        setCurrentTimeIndex: function(s) {
          var a = this._upperLimit || this._availableTimes.length - 1, l = this._lowerLimit || 0;
          if (s = Math.min(Math.max(l, s), a), !(s < 0)) {
            this._loadingTimeIndex = s;
            var c = this._availableTimes[s];
            this._checkSyncedLayersReady(this._availableTimes[this._loadingTimeIndex]) ? this._newTimeIndexLoaded() : (this.fire("timeloading", {
              time: c
            }), setTimeout((function(u) {
              u == this._loadingTimeIndex && this._newTimeIndexLoaded();
            }).bind(this, s), this._loadingTimeout));
          }
        },
        _newTimeIndexLoaded: function() {
          if (this._loadingTimeIndex !== -1) {
            var s = this._availableTimes[this._loadingTimeIndex];
            this._currentTimeIndex = this._loadingTimeIndex, this.fire("timeload", {
              time: s
            }), this._loadingTimeIndex = -1;
          }
        },
        _checkSyncedLayersReady: function(s) {
          for (var a = 0, l = this._syncedLayers.length; a < l; a++)
            if (this._syncedLayers[a].isReady && !this._syncedLayers[a].isReady(s))
              return !1;
          return !0;
        },
        setCurrentTime: function(s) {
          var a = this._seekNearestTimeIndex(s);
          this.setCurrentTimeIndex(a);
        },
        seekNearestTime: function(s) {
          var a = this._seekNearestTimeIndex(s);
          return this._availableTimes[a];
        },
        nextTime: function(s, a) {
          s || (s = 1);
          var l = this._currentTimeIndex, c = this._upperLimit || this._availableTimes.length - 1, u = this._lowerLimit || 0;
          this._loadingTimeIndex > -1 && (l = this._loadingTimeIndex), l = l + s, l > c && (a ? l = u : l = c), l < u && (a ? l = c : l = u), this.setCurrentTimeIndex(l);
        },
        prepareNextTimes: function(s, a, l) {
          s || (s = 1);
          var c = this._currentTimeIndex, u = c;
          this._loadingTimeIndex > -1 && (c = this._loadingTimeIndex);
          for (var d = 0, f = this._syncedLayers.length; d < f; d++)
            this._syncedLayers[d].setMinimumForwardCache && this._syncedLayers[d].setMinimumForwardCache(a);
          for (var h = a, g = this._upperLimit || this._availableTimes.length - 1, v = this._lowerLimit || 0; h > 0; ) {
            if (c = c + s, c > g)
              if (l)
                c = v;
              else
                break;
            if (c < v)
              if (l)
                c = g;
              else
                break;
            if (u === c)
              break;
            this.fire("timeloading", {
              time: this._availableTimes[c]
            }), h--;
          }
        },
        getNumberNextTimesReady: function(s, a, l) {
          s || (s = 1);
          var c = this._currentTimeIndex;
          this._loadingTimeIndex > -1 && (c = this._loadingTimeIndex);
          for (var u = a, d = 0, f = this._upperLimit || this._availableTimes.length - 1, h = this._lowerLimit || 0; u > 0; ) {
            if (c = c + s, c > f)
              if (l)
                c = h;
              else {
                u = 0, d = a;
                break;
              }
            if (c < h)
              if (l)
                c = f;
              else {
                u = 0, d = a;
                break;
              }
            var g = this._availableTimes[c];
            this._checkSyncedLayersReady(g) && d++, u--;
          }
          return d;
        },
        previousTime: function(s, a) {
          this.nextTime(s * -1, a);
        },
        registerSyncedLayer: function(s) {
          this._syncedLayers.push(s), s.on("timeload", this._onSyncedLayerLoaded, this);
        },
        unregisterSyncedLayer: function(s) {
          var a = this._syncedLayers.indexOf(s);
          a != -1 && this._syncedLayers.splice(a, 1), s.off("timeload", this._onSyncedLayerLoaded, this);
        },
        _onSyncedLayerLoaded: function(s) {
          s.time == this._availableTimes[this._loadingTimeIndex] && this._checkSyncedLayersReady(s.time) && this._newTimeIndexLoaded();
        },
        _generateAvailableTimes: function() {
          if (this.options.times)
            return i.TimeDimension.Util.parseTimesExpression(this.options.times);
          if (this.options.timeInterval) {
            var s = i.TimeDimension.Util.parseTimeInterval(this.options.timeInterval), a = this.options.period || "P1D", l = this.options.validTimeRange || void 0;
            return i.TimeDimension.Util.explodeTimeRange(s[0], s[1], a, l);
          } else
            return [];
        },
        _getDefaultCurrentTime: function() {
          var s = this._seekNearestTimeIndex((/* @__PURE__ */ new Date()).getTime());
          return this._availableTimes[s];
        },
        _seekNearestTimeIndex: function(s) {
          for (var a = 0, l = this._availableTimes.length; a < l && !(s < this._availableTimes[a]); a++)
            ;
          return a > 0 && a--, a;
        },
        setAvailableTimes: function(s, a) {
          var l = this.getCurrentTime(), c = this.getLowerLimit(), u = this.getUpperLimit();
          if (a == "extremes") {
            var d = this.options.period || "P1D";
            this._availableTimes = i.TimeDimension.Util.explodeTimeRange(new Date(s[0]), new Date(s[s.length - 1]), d);
          } else {
            var f = i.TimeDimension.Util.parseTimesExpression(s);
            if (this._availableTimes.length === 0)
              this._availableTimes = f;
            else if (a == "intersect")
              this._availableTimes = i.TimeDimension.Util.intersect_arrays(f, this._availableTimes);
            else if (a == "union")
              this._availableTimes = i.TimeDimension.Util.union_arrays(f, this._availableTimes);
            else if (a == "replace")
              this._availableTimes = f;
            else
              throw "Merge available times mode not implemented: " + a;
          }
          c && this.setLowerLimit(c), u && this.setUpperLimit(u), this.setCurrentTime(l), this.fire("availabletimeschanged", {
            availableTimes: this._availableTimes,
            currentTime: l
          });
        },
        getLowerLimit: function() {
          return this._availableTimes[this.getLowerLimitIndex()];
        },
        getUpperLimit: function() {
          return this._availableTimes[this.getUpperLimitIndex()];
        },
        setLowerLimit: function(s) {
          var a = this._seekNearestTimeIndex(s);
          this.setLowerLimitIndex(a);
        },
        setUpperLimit: function(s) {
          var a = this._seekNearestTimeIndex(s);
          this.setUpperLimitIndex(a);
        },
        setLowerLimitIndex: function(s) {
          this._lowerLimit = Math.min(Math.max(s || 0, 0), this._upperLimit || this._availableTimes.length - 1), this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        setUpperLimitIndex: function(s) {
          this._upperLimit = Math.max(Math.min(s, this._availableTimes.length - 1), this._lowerLimit || 0), this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        getLowerLimitIndex: function() {
          return this._lowerLimit;
        },
        getUpperLimitIndex: function() {
          return this._upperLimit;
        }
      }), i.Map.addInitHook(function() {
        this.options.timeDimension && (this.timeDimension = i.timeDimension(this.options.timeDimensionOptions || {}));
      }), i.timeDimension = function(s) {
        return new i.TimeDimension(s);
      }, i.TimeDimension.Util = {
        getTimeDuration: function(s) {
          if (typeof r > "u")
            throw "iso8601-js-period library is required for Leatlet.TimeDimension: https://github.com/nezasa/iso8601-js-period";
          return r.iso8601.Period.parse(s, !0);
        },
        addTimeDuration: function(s, a, l) {
          typeof l > "u" && (l = !0), (typeof a == "string" || a instanceof String) && (a = this.getTimeDuration(a));
          var c = a.length, u = l ? "getUTC" : "get", d = l ? "setUTC" : "set";
          c > 0 && a[0] != 0 && s[d + "FullYear"](s[u + "FullYear"]() + a[0]), c > 1 && a[1] != 0 && s[d + "Month"](s[u + "Month"]() + a[1]), c > 2 && a[2] != 0 && s[d + "Date"](s[u + "Date"]() + a[2] * 7), c > 3 && a[3] != 0 && s[d + "Date"](s[u + "Date"]() + a[3]), c > 4 && a[4] != 0 && s[d + "Hours"](s[u + "Hours"]() + a[4]), c > 5 && a[5] != 0 && s[d + "Minutes"](s[u + "Minutes"]() + a[5]), c > 6 && a[6] != 0 && s[d + "Seconds"](s[u + "Seconds"]() + a[6]);
        },
        subtractTimeDuration: function(s, a, l) {
          (typeof a == "string" || a instanceof String) && (a = this.getTimeDuration(a));
          for (var c = [], u = 0, d = a.length; u < d; u++)
            c.push(-a[u]);
          this.addTimeDuration(s, c, l);
        },
        parseAndExplodeTimeRange: function(s, a) {
          var l = s.split("/"), c = new Date(Date.parse(l[0])), u = new Date(Date.parse(l[1])), d = l.length > 2 && l[2].length ? l[2] : "P1D";
          return a != null && (d = a), this.explodeTimeRange(c, u, d);
        },
        explodeTimeRange: function(s, a, l, c) {
          var u = this.getTimeDuration(l), d = [], f = new Date(s.getTime()), h = null, g = null, v = null, x = null;
          if (c !== void 0) {
            var w = c.split("/");
            h = w[0].split(":")[0], g = w[0].split(":")[1], v = w[1].split(":")[0], x = w[1].split(":")[1];
          }
          for (; f < a; )
            (c === void 0 || f.getUTCHours() >= h && f.getUTCHours() <= v) && (f.getUTCHours() != h || f.getUTCMinutes() >= g) && (f.getUTCHours() != v || f.getUTCMinutes() <= x) && d.push(f.getTime()), this.addTimeDuration(f, u);
          return f >= a && d.push(a.getTime()), d;
        },
        parseTimeInterval: function(s) {
          var a = s.split("/");
          if (a.length != 2)
            throw "Incorrect ISO9601 TimeInterval: " + s;
          var l = Date.parse(a[0]), c = null, u = null;
          return isNaN(l) ? (u = this.getTimeDuration(a[0]), c = Date.parse(a[1]), l = new Date(c), this.subtractTimeDuration(l, u, !0), c = new Date(c)) : (c = Date.parse(a[1]), isNaN(c) ? (u = this.getTimeDuration(a[1]), c = new Date(l), this.addTimeDuration(c, u, !0)) : c = new Date(c), l = new Date(l)), [l, c];
        },
        parseTimesExpression: function(s, a) {
          var l = [];
          if (!s)
            return l;
          if (typeof s == "string" || s instanceof String)
            for (var c = s.split(","), u, d, f = 0, h = c.length; f < h; f++)
              u = c[f], u.split("/").length == 3 ? l = l.concat(this.parseAndExplodeTimeRange(u, a)) : (d = Date.parse(u), isNaN(d) || l.push(d));
          else
            l = s;
          return l.sort(function(g, v) {
            return g - v;
          });
        },
        intersect_arrays: function(s, a) {
          for (var l = s.slice(0), c = a.slice(0), u = []; l.length > 0 && c.length > 0; )
            l[0] < c[0] ? l.shift() : (l[0] > c[0] || u.push(l.shift()), c.shift());
          return u;
        },
        union_arrays: function(s, a) {
          for (var l = s.slice(0), c = a.slice(0), u = []; l.length > 0 && c.length > 0; )
            l[0] < c[0] ? u.push(l.shift()) : l[0] > c[0] ? u.push(c.shift()) : (u.push(l.shift()), c.shift());
          return l.length > 0 ? u = u.concat(l) : c.length > 0 && (u = u.concat(c)), u;
        },
        sort_and_deduplicate: function(s) {
          s = s.slice(0).sort();
          for (var a = [], l = null, c = 0, u = s.length; c < u; c++)
            s[c] !== l && (a.push(s[c]), l = s[c]);
          return a;
        }
      }, i.TimeDimension.Layer = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        options: {
          opacity: 1,
          zIndex: 1
        },
        initialize: function(s, a) {
          i.setOptions(this, a || {}), this._map = null, this._baseLayer = s, this._currentLayer = null, this._timeDimension = this.options.timeDimension || null;
        },
        addTo: function(s) {
          return s.addLayer(this), this;
        },
        onAdd: function(s) {
          this._map = s, !this._timeDimension && s.timeDimension && (this._timeDimension = s.timeDimension), this._timeDimension.on("timeloading", this._onNewTimeLoading, this), this._timeDimension.on("timeload", this._update, this), this._timeDimension.registerSyncedLayer(this), this._update();
        },
        onRemove: function(s) {
          this._timeDimension.unregisterSyncedLayer(this), this._timeDimension.off("timeloading", this._onNewTimeLoading, this), this._timeDimension.off("timeload", this._update, this), this.eachLayer(s.removeLayer, s), this._map = null;
        },
        eachLayer: function(s, a) {
          return s.call(a, this._baseLayer), this;
        },
        setZIndex: function(s) {
          return this.options.zIndex = s, this._baseLayer.setZIndex && this._baseLayer.setZIndex(s), this._currentLayer && this._currentLayer.setZIndex && this._currentLayer.setZIndex(s), this;
        },
        setOpacity: function(s) {
          return this.options.opacity = s, this._baseLayer.setOpacity && this._baseLayer.setOpacity(s), this._currentLayer && this._currentLayer.setOpacity && this._currentLayer.setOpacity(s), this;
        },
        bringToBack: function() {
          if (this._currentLayer)
            return this._currentLayer.bringToBack(), this;
        },
        bringToFront: function() {
          if (this._currentLayer)
            return this._currentLayer.bringToFront(), this;
        },
        _onNewTimeLoading: function(s) {
          this.fire("timeload", {
            time: s.time
          });
        },
        isReady: function(s) {
          return !0;
        },
        _update: function() {
          return !0;
        },
        getBaseLayer: function() {
          return this._baseLayer;
        },
        getBounds: function() {
          var s = new i.LatLngBounds();
          return this._currentLayer && s.extend(this._currentLayer.getBounds ? this._currentLayer.getBounds() : this._currentLayer.getLatLng()), s;
        }
      }), i.timeDimension.layer = function(s, a) {
        return new i.TimeDimension.Layer(s, a);
      }, i.TimeDimension.Layer.WMS = i.TimeDimension.Layer.extend({
        initialize: function(s, a) {
          i.TimeDimension.Layer.prototype.initialize.call(this, s, a), this._timeCacheBackward = this.options.cacheBackward || this.options.cache || 0, this._timeCacheForward = this.options.cacheForward || this.options.cache || 0, this._wmsVersion = this.options.wmsVersion || this.options.version || s.options.version || "1.1.1", this._getCapabilitiesParams = this.options.getCapabilitiesParams || {}, this._getCapabilitiesAlternateUrl = this.options.getCapabilitiesUrl || null, this._getCapabilitiesAlternateLayerName = this.options.getCapabilitiesLayerName || null, this._proxy = this.options.proxy || null, this._updateTimeDimension = this.options.updateTimeDimension || !1, this._setDefaultTime = this.options.setDefaultTime || !1, this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "intersect", this._period = this.options.period || null, this._layers = {}, this._defaultTime = 0, this._availableTimes = [], this._capabilitiesRequested = !1, (this._updateTimeDimension || this.options.requestTimeFromCapabilities) && this._requestTimeDimensionFromCapabilities(), this._baseLayer.on("load", (function() {
            this._baseLayer.setLoaded(!0), this.fire("timeload", {
              time: this._defaultTime
            });
          }).bind(this));
        },
        getEvents: function() {
          var s = i.bind(this._unvalidateCache, this);
          return {
            moveend: s,
            zoomend: s
          };
        },
        eachLayer: function(s, a) {
          for (var l in this._layers)
            this._layers.hasOwnProperty(l) && s.call(a, this._layers[l]);
          return i.TimeDimension.Layer.prototype.eachLayer.call(this, s, a);
        },
        _onNewTimeLoading: function(s) {
          var a = this._getLayerForTime(s.time);
          this._map.hasLayer(a) || this._map.addLayer(a);
        },
        isReady: function(s) {
          var a = this._getLayerForTime(s);
          return this.options.bounds && this._map && !this._map.getBounds().contains(this.options.bounds) ? !0 : a.isLoaded();
        },
        onAdd: function(s) {
          i.TimeDimension.Layer.prototype.onAdd.call(this, s), this._availableTimes.length == 0 ? this._requestTimeDimensionFromCapabilities() : this._updateTimeDimensionAvailableTimes();
        },
        _update: function() {
          if (this._map) {
            var s = this._timeDimension.getCurrentTime(), a = this._getLayerForTime(s);
            this._currentLayer == null && (this._currentLayer = a), this._map.hasLayer(a) ? this._showLayer(a, s) : this._map.addLayer(a);
          }
        },
        setOpacity: function(s) {
          i.TimeDimension.Layer.prototype.setOpacity.apply(this, arguments);
          for (var a in this._layers)
            this._layers.hasOwnProperty(a) && this._layers[a].setOpacity && this._layers[a].setOpacity(s);
        },
        setZIndex: function(s) {
          i.TimeDimension.Layer.prototype.setZIndex.apply(this, arguments);
          for (var a in this._layers)
            this._layers.hasOwnProperty(a) && this._layers[a].setZIndex && this._layers[a].setZIndex(s);
        },
        setParams: function(s, a) {
          i.extend(this._baseLayer.options, s), this._baseLayer.setParams && this._baseLayer.setParams(s, a);
          for (var l in this._layers)
            this._layers.hasOwnProperty(l) && this._layers[l].setParams && (this._layers[l].setLoaded(!1), this._layers[l].setParams(s, a));
          return this;
        },
        _unvalidateCache: function() {
          var s = this._timeDimension.getCurrentTime();
          for (var a in this._layers)
            s != a && this._layers.hasOwnProperty(a) && (this._layers[a].setLoaded(!1), this._layers[a].redraw());
        },
        _evictCachedTimes: function(s, a) {
          var l = this._getLoadedTimes(), c = String(this._currentTime), u = l.indexOf(c), d = [];
          if (a > -1) {
            var f = u - a;
            f > 0 && (d = l.splice(0, f), this._removeLayers(d));
          }
          if (s > -1) {
            u = l.indexOf(c);
            var f = l.length - u - s - 1;
            f > 0 && (d = l.splice(u + s + 1, f), this._removeLayers(d));
          }
        },
        _showLayer: function(s, a) {
          this._currentLayer && this._currentLayer !== s && this._currentLayer.hide(), s.show(), !(this._currentLayer && this._currentLayer === s) && (this._currentLayer = s, this._currentTime = a, this._evictCachedTimes(this._timeCacheForward, this._timeCacheBackward));
        },
        _getLayerForTime: function(s) {
          if (s == 0 || s == this._defaultTime || s == null)
            return this._baseLayer;
          if (this._layers.hasOwnProperty(s))
            return this._layers[s];
          var a = this._getNearestTime(s);
          if (this._layers.hasOwnProperty(a))
            return this._layers[a];
          var l = this._createLayerForTime(a);
          return this._layers[s] = l, l.on("load", (function(c, u) {
            c.setLoaded(!0), this._layers[u] || (this._layers[u] = c), this._timeDimension && u == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading() && this._showLayer(c, u), this.fire("timeload", {
              time: u
            });
          }).bind(this, l, s)), l.onAdd = (function(c) {
            Object.getPrototypeOf(this).onAdd.call(this, c), this.hide();
          }).bind(l), l;
        },
        _createLayerForTime: function(s) {
          var a = this._baseLayer.options;
          return a.time = new Date(s).toISOString(), new this._baseLayer.constructor(this._baseLayer.getURL(), a);
        },
        _getLoadedTimes: function() {
          var s = [];
          for (var a in this._layers)
            this._layers.hasOwnProperty(a) && s.push(a);
          return s.sort(function(l, c) {
            return l - c;
          });
        },
        _removeLayers: function(s) {
          for (var a = 0, l = s.length; a < l; a++)
            this._map && this._map.removeLayer(this._layers[s[a]]), delete this._layers[s[a]];
        },
        setMinimumForwardCache: function(s) {
          s > this._timeCacheForward && (this._timeCacheForward = s);
        },
        _requestTimeDimensionFromCapabilities: function() {
          if (!this._capabilitiesRequested) {
            this._capabilitiesRequested = !0;
            var s = this._getCapabilitiesUrl();
            this._proxy && (s = this._proxy + "?url=" + encodeURIComponent(s));
            var a = new XMLHttpRequest();
            a.addEventListener("load", (function(l) {
              var c = l.currentTarget.responseXML;
              c !== null && (this._defaultTime = Date.parse(this._getDefaultTimeFromCapabilities(c)), this._setDefaultTime = this._setDefaultTime || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0, this.setAvailableTimes(this._parseTimeDimensionFromCapabilities(c)), this._setDefaultTime && this._timeDimension && this._timeDimension.setCurrentTime(this._defaultTime));
            }).bind(this)), a.overrideMimeType("application/xml"), a.open("GET", s), a.send();
          }
        },
        _getCapabilitiesUrl: function() {
          var s = this._baseLayer.getURL();
          this._getCapabilitiesAlternateUrl && (s = this._getCapabilitiesAlternateUrl);
          var a = i.extend({}, this._getCapabilitiesParams, {
            request: "GetCapabilities",
            service: "WMS",
            version: this._wmsVersion
          });
          return s = s + i.Util.getParamString(a, s, a.uppercase), s;
        },
        _parseTimeDimensionFromCapabilities: function(s) {
          var a = s.querySelectorAll('Layer[queryable="1"]'), l = this._baseLayer.wmsParams.layers, c = null, u = null;
          return a.forEach(function(d) {
            d.querySelector("Name").innerHTML === l && (c = d);
          }), c && (u = this._getTimesFromLayerCapabilities(c), u || (u = this._getTimesFromLayerCapabilities(c.parentNode))), u;
        },
        _getTimesFromLayerCapabilities: function(s) {
          for (var a = null, l = s.children, c = 0, u = l.length; c < u; c++)
            if (!(l[c].nodeName !== "Extent" && l[c].nodeName !== "Dimension") && l[c].getAttribute("name") === "time" && l[c].textContent.length) {
              a = l[c].textContent.trim();
              break;
            }
          return a;
        },
        _getDefaultTimeFromCapabilities: function(s) {
          var a = s.querySelectorAll('Layer[queryable="1"]'), l = this._baseLayer.wmsParams.layers, c = null;
          a.forEach(function(d) {
            d.querySelector("Name").innerHTML === l && (c = d);
          });
          var u = 0;
          return c && (u = this._getDefaultTimeFromLayerCapabilities(c), u == 0 && (u = this._getDefaultTimeFromLayerCapabilities(c.parentNode))), u;
        },
        _getDefaultTimeFromLayerCapabilities: function(s) {
          for (var a = 0, l = s.children, c = 0, u = l.length; c < u; c++)
            if (!(l[c].nodeName !== "Extent" && l[c].nodeName !== "Dimension") && l[c].getAttribute("name") === "time" && l[c].attributes.default && l[c].attributes.default.textContent.length) {
              a = l[c].attributes.default.textContent.trim();
              break;
            }
          return a;
        },
        setAvailableTimes: function(s) {
          this._availableTimes = i.TimeDimension.Util.parseTimesExpression(s, this._period), this._updateTimeDimensionAvailableTimes();
        },
        _updateTimeDimensionAvailableTimes: function() {
          (this._timeDimension && this._updateTimeDimension || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0) && (this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode), this._setDefaultTime && this._defaultTime > 0 && this._timeDimension.setCurrentTime(this._defaultTime));
        },
        _getNearestTime: function(s) {
          if (this._layers.hasOwnProperty(s) || this._availableTimes.length == 0)
            return s;
          for (var a = 0, l = this._availableTimes.length; a < l && !(s < this._availableTimes[a]); a++)
            ;
          return a > 0 && a--, s != this._availableTimes[a], this._availableTimes[a];
        }
      }), i.NonTiledLayer || (i.NonTiledLayer = (i.Layer || i.Class).extend({})), i.NonTiledLayer.include({
        _visible: !0,
        _loaded: !1,
        _originalUpdate: i.NonTiledLayer.prototype._update,
        _originalOnRemove: i.NonTiledLayer.prototype.onRemove,
        _update: function() {
          !this._visible && this._loaded || this._originalUpdate();
        },
        onRemove: function(s) {
          this._loaded = !1, this._originalOnRemove(s);
        },
        setLoaded: function(s) {
          this._loaded = s;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = !1, this._div.style.display = "none";
        },
        show: function() {
          this._visible = !0, this._div.style.display = "block";
        },
        getURL: function() {
          return this._wmsUrl;
        }
      }), i.TileLayer.include({
        _visible: !0,
        _loaded: !1,
        _originalUpdate: i.TileLayer.prototype._update,
        _update: function() {
          !this._visible && this._loaded || this._originalUpdate();
        },
        setLoaded: function(s) {
          this._loaded = s;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = !1, this._container && (this._container.style.display = "none");
        },
        show: function() {
          this._visible = !0, this._container && (this._container.style.display = "block");
        },
        getURL: function() {
          return this._url;
        }
      }), i.timeDimension.layer.wms = function(s, a) {
        return new i.TimeDimension.Layer.WMS(s, a);
      }, i.TimeDimension.Layer.GeoJson = i.TimeDimension.Layer.extend({
        initialize: function(s, a) {
          i.TimeDimension.Layer.prototype.initialize.call(this, s, a), this._updateTimeDimension = this.options.updateTimeDimension || !1, this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "extremes", this._duration = this.options.duration || null, this._addlastPoint = this.options.addlastPoint || !1, this._waitForReady = this.options.waitForReady || !1, this._defaultTime = 0, this._availableTimes = [], this._loaded = !1, this._baseLayer.getLayers().length == 0 ? this._waitForReady ? this._baseLayer.on("ready", this._onReadyBaseLayer, this) : this._loaded = !0 : (this._loaded = !0, this._setAvailableTimes()), this._baseLayer.on("layeradd", (function() {
            this._loaded && this._setAvailableTimes();
          }).bind(this));
        },
        onAdd: function(s) {
          i.TimeDimension.Layer.prototype.onAdd.call(this, s), this._loaded && this._setAvailableTimes();
        },
        eachLayer: function(s, a) {
          return this._currentLayer && s.call(a, this._currentLayer), i.TimeDimension.Layer.prototype.eachLayer.call(this, s, a);
        },
        isReady: function(s) {
          return this._loaded;
        },
        _update: function() {
          if (this._map && this._loaded) {
            this._timeDimension.getCurrentTime();
            var s = this._timeDimension.getCurrentTime(), a = 0;
            if (this._duration) {
              var l = new Date(s);
              i.TimeDimension.Util.subtractTimeDuration(l, this._duration, !0), a = l.getTime();
            }
            for (var c = i.geoJson(null, this._baseLayer.options), u = this._baseLayer.getLayers(), d = 0, f = u.length; d < f; d++) {
              var h = this._getFeatureBetweenDates(u[d].feature, a, s);
              if (h && (c.addData(h), this._addlastPoint && h.geometry.type == "LineString" && h.geometry.coordinates.length > 0)) {
                var g = h.properties;
                g.last = !0, c.addData({
                  type: "Feature",
                  properties: g,
                  geometry: {
                    type: "Point",
                    coordinates: h.geometry.coordinates[h.geometry.coordinates.length - 1]
                  }
                });
              }
            }
            this._currentLayer && this._map.removeLayer(this._currentLayer), c.getLayers().length && (c.addTo(this._map), this._currentLayer = c);
          }
        },
        _setAvailableTimes: function() {
          for (var s = [], a = this._baseLayer.getLayers(), l = 0, c = a.length; l < c; l++)
            if (a[l].feature)
              for (var u = this._getFeatureTimes(a[l].feature), d = 0, f = u.length; d < f; d++)
                s.push(u[d]);
          this._availableTimes = i.TimeDimension.Util.sort_and_deduplicate(s), this._timeDimension && (this._updateTimeDimension || this._timeDimension.getAvailableTimes().length == 0) && this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode);
        },
        _getFeatureTimes: function(s) {
          if (!s.featureTimes) {
            s.properties ? s.properties.hasOwnProperty("coordTimes") ? s.featureTimes = s.properties.coordTimes : s.properties.hasOwnProperty("times") ? s.featureTimes = s.properties.times : s.properties.hasOwnProperty("linestringTimestamps") ? s.featureTimes = s.properties.linestringTimestamps : s.properties.hasOwnProperty("time") ? s.featureTimes = [s.properties.time] : s.featureTimes = [] : s.featureTimes = [];
            for (var a = 0, l = s.featureTimes.length; a < l; a++) {
              var c = s.featureTimes[a];
              (typeof c == "string" || c instanceof String) && (c = Date.parse(c.trim()), s.featureTimes[a] = c);
            }
          }
          return s.featureTimes;
        },
        _getFeatureBetweenDates: function(s, a, l) {
          var c = this._getFeatureTimes(s);
          if (c.length == 0)
            return s;
          var u = null, d = null, f = c.length;
          if (c[0] > l || c[f - 1] < a)
            return null;
          if (c[f - 1] > a) {
            for (var h = 0; h < f; h++)
              if (u === null && c[h] > a && (u = h), c[h] > l) {
                d = h;
                break;
              }
          }
          u === null && (u = 0), d === null && (d = f);
          var g = [];
          return s.geometry.coordinates[0].length ? g = s.geometry.coordinates.slice(u, d) : g = s.geometry.coordinates, {
            type: "Feature",
            properties: s.properties,
            geometry: {
              type: s.geometry.type,
              coordinates: g
            }
          };
        },
        _onReadyBaseLayer: function() {
          this._loaded = !0, this._setAvailableTimes(), this._update();
        }
      }), i.timeDimension.layer.geoJson = function(s, a) {
        return new i.TimeDimension.Layer.GeoJson(s, a);
      }, i.TimeDimension.Player = (i.Layer || i.Class).extend({
        includes: i.Evented || i.Mixin.Events,
        initialize: function(s, a) {
          i.setOptions(this, s), this._timeDimension = a, this._paused = !1, this._buffer = this.options.buffer || 5, this._minBufferReady = this.options.minBufferReady || 1, this._waitingForBuffer = !1, this._loop = this.options.loop || !1, this._steps = 1, this._timeDimension.on("timeload", (function(l) {
            this.release(), this._waitingForBuffer = !1;
          }).bind(this)), this.setTransitionTime(this.options.transitionTime || 1e3), this._timeDimension.on("limitschanged availabletimeschanged timeload", (function(l) {
            this._timeDimension.prepareNextTimes(this._steps, this._minBufferReady, this._loop);
          }).bind(this));
        },
        _tick: function() {
          var s = this._getMaxIndex(), a = this._timeDimension.getCurrentTimeIndex() >= s && this._steps > 0, l = this._timeDimension.getCurrentTimeIndex() == 0 && this._steps < 0;
          if ((a || l) && !this._loop) {
            this.pause(), this.stop(), this.fire("animationfinished");
            return;
          }
          if (!this._paused) {
            var c = 0, u = this._bufferSize;
            if (this._minBufferReady > 0) {
              if (c = this._timeDimension.getNumberNextTimesReady(this._steps, u, this._loop), this._waitingForBuffer)
                if (c < u) {
                  this.fire("waiting", {
                    buffer: u,
                    available: c
                  });
                  return;
                } else
                  this.fire("running"), this._waitingForBuffer = !1;
              else if (c < this._minBufferReady) {
                this._waitingForBuffer = !0, this._timeDimension.prepareNextTimes(this._steps, u, this._loop), this.fire("waiting", {
                  buffer: u,
                  available: c
                });
                return;
              }
            }
            this.pause(), this._timeDimension.nextTime(this._steps, this._loop), u > 0 && this._timeDimension.prepareNextTimes(this._steps, u, this._loop);
          }
        },
        _getMaxIndex: function() {
          return Math.min(
            this._timeDimension.getAvailableTimes().length - 1,
            this._timeDimension.getUpperLimitIndex() || 1 / 0
          );
        },
        start: function(s) {
          this._intervalID || (this._steps = s || 1, this._waitingForBuffer = !1, this.options.startOver && this._timeDimension.getCurrentTimeIndex() === this._getMaxIndex() && this._timeDimension.setCurrentTimeIndex(this._timeDimension.getLowerLimitIndex() || 0), this.release(), this._intervalID = window.setInterval(
            i.bind(this._tick, this),
            this._transitionTime
          ), this._tick(), this.fire("play"), this.fire("running"));
        },
        stop: function() {
          this._intervalID && (clearInterval(this._intervalID), this._intervalID = null, this._waitingForBuffer = !1, this.fire("stop"));
        },
        pause: function() {
          this._paused = !0;
        },
        release: function() {
          this._paused = !1;
        },
        getTransitionTime: function() {
          return this._transitionTime;
        },
        isPlaying: function() {
          return !!this._intervalID;
        },
        isWaiting: function() {
          return this._waitingForBuffer;
        },
        isLooped: function() {
          return this._loop;
        },
        setLooped: function(s) {
          this._loop = s, this.fire("loopchange", {
            loop: s
          });
        },
        setTransitionTime: function(s) {
          this._transitionTime = s, typeof this._buffer == "function" ? this._bufferSize = this._buffer.call(this, this._transitionTime, this._minBufferReady, this._loop) : this._bufferSize = this._buffer, this._intervalID && (this.stop(), this.start(this._steps)), this.fire("speedchange", {
            transitionTime: s,
            buffer: this._bufferSize
          });
        },
        getSteps: function() {
          return this._steps;
        }
      }), i.UI = i.ui = i.UI || {}, i.UI.Knob = i.Draggable.extend({
        options: {
          className: "knob",
          step: 1,
          rangeMin: 0,
          rangeMax: 10
          //minValue : null,
          //maxValue : null
        },
        initialize: function(s, a) {
          i.setOptions(this, a), this._element = i.DomUtil.create("div", this.options.className || "knob", s), i.Draggable.prototype.initialize.call(this, this._element, this._element), this._container = s, this.on("predrag", function() {
            this._newPos.y = 0, this._newPos.x = this._adjustX(this._newPos.x);
          }, this), this.on("dragstart", function() {
            i.DomUtil.addClass(s, "dragging");
          }), this.on("dragend", function() {
            i.DomUtil.removeClass(s, "dragging");
          }), i.DomEvent.on(this._element, "dblclick", function(l) {
            this.fire("dblclick", l);
          }, this), i.DomEvent.disableClickPropagation(this._element), this.enable();
        },
        _getProjectionCoef: function() {
          return (this.options.rangeMax - this.options.rangeMin) / (this._container.offsetWidth || this._container.style.width);
        },
        _update: function() {
          this.setPosition(i.DomUtil.getPosition(this._element).x);
        },
        _adjustX: function(s) {
          var a = this._toValue(s) || this.getMinValue();
          return this._toX(this._adjustValue(a));
        },
        _adjustValue: function(s) {
          return s = Math.max(this.getMinValue(), Math.min(this.getMaxValue(), s)), s = s - this.options.rangeMin, s = Math.round(s / this.options.step) * this.options.step, s = s + this.options.rangeMin, s = Math.round(s * 100) / 100, s;
        },
        _toX: function(s) {
          var a = (s - this.options.rangeMin) / this._getProjectionCoef();
          return a;
        },
        _toValue: function(s) {
          var a = s * this._getProjectionCoef() + this.options.rangeMin;
          return a;
        },
        getMinValue: function() {
          return this.options.minValue || this.options.rangeMin;
        },
        getMaxValue: function() {
          return this.options.maxValue || this.options.rangeMax;
        },
        setStep: function(s) {
          this.options.step = s, this._update();
        },
        setPosition: function(s) {
          i.DomUtil.setPosition(
            this._element,
            i.point(this._adjustX(s), 0)
          ), this.fire("positionchanged");
        },
        getPosition: function() {
          return i.DomUtil.getPosition(this._element).x;
        },
        setValue: function(s) {
          this.setPosition(this._toX(s));
        },
        getValue: function() {
          return this._adjustValue(this._toValue(this.getPosition()));
        }
      }), i.Control.TimeDimension = i.Control.extend({
        options: {
          styleNS: "leaflet-control-timecontrol",
          position: "bottomleft",
          title: "Time Control",
          backwardButton: !0,
          forwardButton: !0,
          playButton: !0,
          playReverseButton: !1,
          loopButton: !1,
          displayDate: !0,
          timeSlider: !0,
          timeSliderDragUpdate: !1,
          limitSliders: !1,
          limitMinimumRange: 5,
          speedSlider: !0,
          minSpeed: 0.1,
          maxSpeed: 10,
          speedStep: 0.1,
          timeSteps: 1,
          autoPlay: !1,
          playerOptions: {
            transitionTime: 1e3
          },
          timeZones: ["UTC", "Local"]
        },
        initialize: function(s) {
          i.setOptions(s), i.Control.prototype.initialize.call(this, s), this._timeZoneIndex = 0, this._timeDimension = this.options.timeDimension || null;
        },
        onAdd: function(s) {
          var a;
          return this._map = s, !this._timeDimension && s.timeDimension && (this._timeDimension = s.timeDimension), this._initPlayer(), a = i.DomUtil.create("div", "leaflet-bar leaflet-bar-horizontal leaflet-bar-timecontrol"), this.options.backwardButton && (this._buttonBackward = this._createButton("Backward", a)), this.options.playReverseButton && (this._buttonPlayReversePause = this._createButton("Play Reverse", a)), this.options.playButton && (this._buttonPlayPause = this._createButton("Play", a)), this.options.forwardButton && (this._buttonForward = this._createButton("Forward", a)), this.options.loopButton && (this._buttonLoop = this._createButton("Loop", a)), this.options.displayDate && (this._displayDate = this._createButton("Date", a)), this.options.timeSlider && (this._sliderTime = this._createSliderTime(this.options.styleNS + " timecontrol-slider timecontrol-dateslider", a)), this.options.speedSlider && (this._sliderSpeed = this._createSliderSpeed(this.options.styleNS + " timecontrol-slider timecontrol-speed", a)), this._steps = this.options.timeSteps || 1, this._timeDimension.on("timeload", this._update, this), this._timeDimension.on("timeload", this._onPlayerStateChange, this), this._timeDimension.on("timeloading", this._onTimeLoading, this), this._timeDimension.on("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this), i.DomEvent.disableClickPropagation(a), a;
        },
        addTo: function() {
          return i.Control.prototype.addTo.apply(this, arguments), this._onPlayerStateChange(), this._onTimeLimitsChanged(), this._update(), this;
        },
        onRemove: function() {
          this._player.off("play stop running loopchange speedchange", this._onPlayerStateChange, this), this._player.off("waiting", this._onPlayerWaiting, this), this._timeDimension.off("timeload", this._update, this), this._timeDimension.off("timeload", this._onPlayerStateChange, this), this._timeDimension.off("timeloading", this._onTimeLoading, this), this._timeDimension.off("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this);
        },
        _initPlayer: function() {
          this._player || (this.options.player ? this._player = this.options.player : this._player = new i.TimeDimension.Player(this.options.playerOptions, this._timeDimension)), this.options.autoPlay && this._player.start(this._steps), this._player.on("play stop running loopchange speedchange", this._onPlayerStateChange, this), this._player.on("waiting", this._onPlayerWaiting, this), this._onPlayerStateChange();
        },
        _onTimeLoading: function(s) {
          s.time == this._timeDimension.getCurrentTime() && this._displayDate && i.DomUtil.addClass(this._displayDate, "loading");
        },
        _onTimeLimitsChanged: function() {
          var s = this._timeDimension.getLowerLimitIndex(), a = this._timeDimension.getUpperLimitIndex(), l = this._timeDimension.getAvailableTimes().length - 1;
          this._limitKnobs && (this._limitKnobs[0].options.rangeMax = l, this._limitKnobs[1].options.rangeMax = l, this._limitKnobs[0].setValue(s || 0), this._limitKnobs[1].setValue(a || l)), this._sliderTime && (this._sliderTime.options.rangeMax = l, this._sliderTime._update());
        },
        _onPlayerWaiting: function(s) {
          this._buttonPlayPause && this._player.getSteps() > 0 && (i.DomUtil.addClass(this._buttonPlayPause, "loading"), this._buttonPlayPause.innerHTML = this._getDisplayLoadingText(s.available, s.buffer)), this._buttonPlayReversePause && this._player.getSteps() < 0 && (i.DomUtil.addClass(this._buttonPlayReversePause, "loading"), this._buttonPlayReversePause.innerHTML = this._getDisplayLoadingText(s.available, s.buffer));
        },
        _onPlayerStateChange: function() {
          if (this._buttonPlayPause && (this._player.isPlaying() && this._player.getSteps() > 0 ? (i.DomUtil.addClass(this._buttonPlayPause, "pause"), i.DomUtil.removeClass(this._buttonPlayPause, "play")) : (i.DomUtil.removeClass(this._buttonPlayPause, "pause"), i.DomUtil.addClass(this._buttonPlayPause, "play")), this._player.isWaiting() && this._player.getSteps() > 0 ? i.DomUtil.addClass(this._buttonPlayPause, "loading") : (this._buttonPlayPause.innerHTML = "", i.DomUtil.removeClass(this._buttonPlayPause, "loading"))), this._buttonPlayReversePause && (this._player.isPlaying() && this._player.getSteps() < 0 ? i.DomUtil.addClass(this._buttonPlayReversePause, "pause") : i.DomUtil.removeClass(this._buttonPlayReversePause, "pause"), this._player.isWaiting() && this._player.getSteps() < 0 ? i.DomUtil.addClass(this._buttonPlayReversePause, "loading") : (this._buttonPlayReversePause.innerHTML = "", i.DomUtil.removeClass(this._buttonPlayReversePause, "loading"))), this._buttonLoop && (this._player.isLooped() ? i.DomUtil.addClass(this._buttonLoop, "looped") : i.DomUtil.removeClass(this._buttonLoop, "looped")), this._sliderSpeed && !this._draggingSpeed) {
            var s = this._player.getTransitionTime() || 1e3;
            s = Math.round(1e4 / s) / 10, this._sliderSpeed.setValue(s);
          }
        },
        _update: function() {
          if (this._timeDimension)
            if (this._timeDimension.getCurrentTimeIndex() >= 0) {
              var s = new Date(this._timeDimension.getCurrentTime());
              this._displayDate && (i.DomUtil.removeClass(this._displayDate, "loading"), this._displayDate.innerHTML = this._getDisplayDateFormat(s)), this._sliderTime && !this._slidingTimeSlider && this._sliderTime.setValue(this._timeDimension.getCurrentTimeIndex());
            } else
              this._displayDate && (this._displayDate.innerHTML = this._getDisplayNoTimeError());
        },
        _createButton: function(s, a) {
          var l = i.DomUtil.create("a", this.options.styleNS + " timecontrol-" + s.toLowerCase(), a);
          return l.href = "#", l.title = s, i.DomEvent.addListener(l, "click", i.DomEvent.stopPropagation).addListener(l, "click", i.DomEvent.preventDefault).addListener(l, "click", this["_button" + s.replace(/ /i, "") + "Clicked"], this), l;
        },
        _createSliderTime: function(s, a) {
          var l, c, u, d, f;
          return l = i.DomUtil.create("div", s, a), c = i.DomUtil.create("div", "slider", l), u = this._timeDimension.getAvailableTimes().length - 1, this.options.limitSliders && (f = this._limitKnobs = this._createLimitKnobs(c)), d = new i.UI.Knob(c, {
            className: "knob main",
            rangeMin: 0,
            rangeMax: u
          }), d.on("dragend", function(h) {
            var g = h.target.getValue();
            this._sliderTimeValueChanged(g), this._slidingTimeSlider = !1;
          }, this), d.on("drag", function(h) {
            this._slidingTimeSlider = !0;
            var g = this._timeDimension.getAvailableTimes()[h.target.getValue()];
            if (g) {
              var v = new Date(g);
              this._displayDate && (this._displayDate.innerHTML = this._getDisplayDateFormat(v)), this.options.timeSliderDragUpdate && this._sliderTimeValueChanged(h.target.getValue());
            }
          }, this), d.on("predrag", function() {
            var h, g;
            f && (h = f[0].getPosition(), g = f[1].getPosition(), this._newPos.x < h && (this._newPos.x = h), this._newPos.x > g && (this._newPos.x = g));
          }, d), i.DomEvent.on(c, "click", function(h) {
            if (!i.DomUtil.hasClass(h.target, "knob")) {
              var g = h.touches && h.touches.length === 1 ? h.touches[0] : h, v = i.DomEvent.getMousePosition(g, c).x;
              f ? f[0].getPosition() <= v && v <= f[1].getPosition() && (d.setPosition(v), this._sliderTimeValueChanged(d.getValue())) : (d.setPosition(v), this._sliderTimeValueChanged(d.getValue()));
            }
          }, this), d.setPosition(0), d;
        },
        _createLimitKnobs: function(s) {
          i.DomUtil.addClass(s, "has-limits");
          var a = this._timeDimension.getAvailableTimes().length - 1, l = i.DomUtil.create("div", "range", s), c = new i.UI.Knob(s, {
            className: "knob lower",
            rangeMin: 0,
            rangeMax: a
          }), u = new i.UI.Knob(s, {
            className: "knob upper",
            rangeMin: 0,
            rangeMax: a
          });
          return i.DomUtil.setPosition(l, 0), c.setPosition(0), u.setPosition(a), c.on("dragend", function(d) {
            var f = d.target.getValue();
            this._sliderLimitsValueChanged(f, u.getValue());
          }, this), u.on("dragend", function(d) {
            var f = d.target.getValue();
            this._sliderLimitsValueChanged(c.getValue(), f);
          }, this), c.on("drag positionchanged", function() {
            i.DomUtil.setPosition(l, i.point(c.getPosition(), 0)), l.style.width = u.getPosition() - c.getPosition() + "px";
          }, this), u.on("drag positionchanged", function() {
            l.style.width = u.getPosition() - c.getPosition() + "px";
          }, this), u.on("predrag", function() {
            var d = c._toX(c.getValue() + this.options.limitMinimumRange);
            u._newPos.x <= d && (u._newPos.x = d);
          }, this), c.on("predrag", function() {
            var d = u._toX(u.getValue() - this.options.limitMinimumRange);
            c._newPos.x >= d && (c._newPos.x = d);
          }, this), c.on("dblclick", function() {
            this._timeDimension.setLowerLimitIndex(0);
          }, this), u.on("dblclick", function() {
            this._timeDimension.setUpperLimitIndex(this._timeDimension.getAvailableTimes().length - 1);
          }, this), [c, u];
        },
        _createSliderSpeed: function(s, a) {
          var l = i.DomUtil.create("div", s, a), c = i.DomUtil.create("span", "speed", l), u = i.DomUtil.create("div", "slider", l), d = Math.round(1e4 / (this._player.getTransitionTime() || 1e3)) / 10;
          c.innerHTML = this._getDisplaySpeed(d);
          var f = new i.UI.Knob(u, {
            step: this.options.speedStep,
            rangeMin: this.options.minSpeed,
            rangeMax: this.options.maxSpeed
          });
          return f.on("dragend", function(h) {
            var g = h.target.getValue();
            this._draggingSpeed = !1, c.innerHTML = this._getDisplaySpeed(g), this._sliderSpeedValueChanged(g);
          }, this), f.on("drag", function(h) {
            this._draggingSpeed = !0, c.innerHTML = this._getDisplaySpeed(h.target.getValue());
          }, this), f.on("positionchanged", function(h) {
            c.innerHTML = this._getDisplaySpeed(h.target.getValue());
          }, this), i.DomEvent.on(u, "click", function(h) {
            if (h.target !== f._element) {
              var g = h.touches && h.touches.length === 1 ? h.touches[0] : h, v = i.DomEvent.getMousePosition(g, u).x;
              f.setPosition(v), c.innerHTML = this._getDisplaySpeed(f.getValue()), this._sliderSpeedValueChanged(f.getValue());
            }
          }, this), f;
        },
        _buttonBackwardClicked: function() {
          this._timeDimension.previousTime(this._steps);
        },
        _buttonForwardClicked: function() {
          this._timeDimension.nextTime(this._steps);
        },
        _buttonLoopClicked: function() {
          this._player.setLooped(!this._player.isLooped());
        },
        _buttonPlayClicked: function() {
          this._player.isPlaying() ? this._player.stop() : this._player.start(this._steps);
        },
        _buttonPlayReverseClicked: function() {
          this._player.isPlaying() ? this._player.stop() : this._player.start(this._steps * -1);
        },
        _buttonDateClicked: function() {
          this._switchTimeZone();
        },
        _sliderTimeValueChanged: function(s) {
          this._timeDimension.setCurrentTimeIndex(s);
        },
        _sliderLimitsValueChanged: function(s, a) {
          this._timeDimension.setLowerLimitIndex(s), this._timeDimension.setUpperLimitIndex(a);
        },
        _sliderSpeedValueChanged: function(s) {
          this._player.setTransitionTime(1e3 / s);
        },
        _getCurrentTimeZone: function() {
          return this.options.timeZones[this._timeZoneIndex];
        },
        _switchTimeZone: function() {
          this._getCurrentTimeZone().toLowerCase() == "utc" && i.DomUtil.removeClass(this._displayDate, "utc"), this._timeZoneIndex = (this._timeZoneIndex + 1) % this.options.timeZones.length;
          var s = this._getCurrentTimeZone();
          s.toLowerCase() == "utc" ? (i.DomUtil.addClass(this._displayDate, "utc"), this._displayDate.title = "UTC Time") : s.toLowerCase() == "local" ? this._displayDate.title = "Local Time" : this._displayDate.title = s, this._update();
        },
        _getDisplayDateFormat: function(s) {
          var a = this._getCurrentTimeZone();
          return a.toLowerCase() == "utc" ? s.toISOString() : a.toLowerCase() == "local" ? s.toLocaleString() : s.toLocaleString([], { timeZone: a, timeZoneName: "short" });
        },
        _getDisplaySpeed: function(s) {
          return s + "fps";
        },
        _getDisplayLoadingText: function(s, a) {
          return "<span>" + Math.floor(s / a * 100) + "%</span>";
        },
        _getDisplayNoTimeError: function() {
          return "Time not available";
        }
      }), i.Map.addInitHook(function() {
        this.options.timeDimensionControl && (this.timeDimensionControl = i.control.timeDimension(this.options.timeDimensionControlOptions || {}), this.addControl(this.timeDimensionControl));
      }), i.control.timeDimension = function(s) {
        return new i.Control.TimeDimension(s);
      }, i.TimeDimension;
    });
  }(Ws)), Ws.exports;
}
Dw();
(function(e) {
  typeof define == "function" && define.amd ? define(e) : e();
})(function() {
  const e = L.extend({}, L.DomUtil);
  L.extend(L.DomUtil, {
    /**
     * Resets the 3D CSS transform of `el` so it is
     * translated by `offset` pixels and optionally
     * scaled by `scale`. Does not have an effect if
     * the browser doesn't support 3D CSS transforms.
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} offset 
     * @param {Number} scale
     * @param {Number} bearing 
     * @param {L.Point} pivot 
     */
    setTransform: function(d, f, h, g, v) {
      var x = f || new L.Point(0, 0);
      if (!g)
        return f = x._round(), e.setTransform.apply(this, arguments);
      x = x.rotateFrom(g, v), d.style[L.DomUtil.TRANSFORM] = "translate3d(" + x.x + "px," + x.y + "px,0)" + (h ? " scale(" + h + ")" : "") + " rotate(" + g + "rad)";
    },
    /**
     * Sets the position of `el` to coordinates specified by
     * `position`, using CSS translate or top/left positioning
     * depending on the browser (used by Leaflet internally
     * to position its layers).
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} point 
     * @param {Number} bearing
     * @param {L.Point} pivot 
     * @param {Number} scale 
     */
    setPosition: function(d, f, h, g, v) {
      if (!h)
        return e.setPosition.apply(this, arguments);
      d._leaflet_pos = f, L.Browser.any3d ? L.DomUtil.setTransform(d, f, v, h, g) : (d.style.left = f.x + "px", d.style.top = f.y + "px");
    },
    /**
     * @constant radians = degrees × π/180°
     */
    DEG_TO_RAD: Math.PI / 180,
    /**
     * @constant degrees = radians × 180°/π
     */
    RAD_TO_DEG: 180 / Math.PI
  }), L.Draggable.include({
    /** @TODO */
    // updateMapBearing: function(mapBearing) {
    //     this._mapBearing = mapBearing;
    // },
  }), L.extend(L.Point.prototype, {
    /**
     * Rotate around (0,0) by applying the 2D rotation matrix:
     * 
     * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤
     * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦
     * 
     * @param theta must be given in radians.
     */
    rotate: function(d) {
      return this.rotateFrom(d, new L.Point(0, 0));
    },
    /**
     * Rotate around (pivot.x, pivot.y) by:
     * 
     * 1. subtract (pivot.x, pivot.y)
     * 2. rotate around (0, 0)
     * 3. add (pivot.x, pivot.y) back
     * 
     * same as `this.subtract(pivot).rotate(theta).add(pivot)`
     * 
     * @param {Number} theta 
     * @param {L.Point} pivot 
     * 
     * @returns {L.Point}
     */
    rotateFrom: function(d, f) {
      if (!d)
        return this;
      var h = Math.sin(d), g = Math.cos(d), v = f.x, x = f.y, w = this.x - v, M = this.y - x;
      return new L.Point(
        w * g - M * h + v,
        w * h + M * g + x
      );
    }
  });
  const t = L.extend({}, L.DivOverlay.prototype);
  L.DivOverlay.include({
    /**
     * Update L.Popup and L.Tooltip anchor positions after
     * the map is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(t.getEvents.apply(this, arguments), { rotate: this._updatePosition });
    },
    /**
     * 0. update element anchor point (divOverlayProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _updatePosition: function() {
      if (this._map && (t._updatePosition.apply(this, arguments), this._map && this._map._rotate && this._zoomAnimated)) {
        var d = this._getAnchor(), f = L.DomUtil.getPosition(this._container).subtract(d);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(f).add(d));
      }
    }
  });
  const i = L.extend({}, L.Popup.prototype);
  L.Popup.include({
    /**
     * 0. update element anchor point (popupProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _animateZoom: function(d) {
      if (i._animateZoom.apply(this, arguments), this._map && this._map._rotate) {
        var f = this._getAnchor(), h = L.DomUtil.getPosition(this._container).subtract(f);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(h).add(f));
      }
    },
    /**
     * Fix for L.popup({ keepInView = true })
     * 
     * @see https://github.com/fnicollet/Leaflet/pull/21
     */
    _adjustPan: function() {
      if (!(!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress)) {
        if (this._autopanning) {
          this._autopanning = !1;
          return;
        }
        var d = this._map, f = parseInt(L.DomUtil.getStyle(this._container, "marginBottom"), 10) || 0, h = this._container.offsetHeight + f, g = this._containerWidth, v = new L.Point(this._containerLeft, -h - this._containerBottom);
        v._add(L.DomUtil.getPosition(this._container));
        var x = v._add(this._map._getMapPanePos()), w = L.point(this.options.autoPanPadding), M = L.point(this.options.autoPanPaddingTopLeft || w), p = L.point(this.options.autoPanPaddingBottomRight || w), y = d.getSize(), S = 0, C = 0;
        x.x + g + p.x > y.x && (S = x.x + g - y.x + p.x), x.x - S - M.x < 0 && (S = x.x - M.x), x.y + h + p.y > y.y && (C = x.y + h - y.y + p.y), x.y - C - M.y < 0 && (C = x.y - M.y), (S || C) && (this.options.keepInView && (this._autopanning = !0), d.fire("autopanstart").panBy([S, C]));
      }
    }
  });
  const n = L.extend({}, L.Tooltip.prototype);
  L.Tooltip.include({
    _animateZoom: function(d) {
      if (!this._map._rotate)
        return n._animateZoom.apply(this, arguments);
      var f = this._map._latLngToNewLayerPoint(this._latlng, d.zoom, d.center);
      f = this._map.rotatedPointToMapPanePoint(f), this._setPosition(f);
    },
    _updatePosition: function() {
      if (!this._map._rotate)
        return n._updatePosition.apply(this, arguments);
      var d = this._map.latLngToLayerPoint(this._latlng);
      d = this._map.rotatedPointToMapPanePoint(d), this._setPosition(d);
    }
  }), L.extend({}, L.Icon.prototype), L.Icon.include({
    _setIconStyles: function(d, f) {
      var h = this.options, g = h[f + "Size"];
      typeof g == "number" && (g = [g, g]);
      var v = L.point(g), x = L.point(f === "shadow" && h.shadowAnchor || h.iconAnchor || v && v.divideBy(2, !0));
      d.className = "leaflet-marker-" + f + " " + (h.className || ""), x && (d.style.marginLeft = -x.x + "px", d.style.marginTop = -x.y + "px", d.style[L.DomUtil.TRANSFORM + "Origin"] = x.x + "px " + x.y + "px 0px"), v && (d.style.width = v.x + "px", d.style.height = v.y + "px");
    }
  });
  const r = L.extend({}, L.Marker.prototype);
  L.Marker.mergeOptions({
    /**
     * Rotation of this marker in rad
     * 
     * @type {Number}
     */
    rotation: 0,
    /**
     * Rotate this marker when map rotates
     * 
     * @type {Boolean}
     */
    rotateWithView: !1,
    /**
     * Scale of the marker icon
     * 
     * @type {Number}
     */
    scale: void 0
  });
  var s, a = {
    // _onDragStart: function() {
    //     if (!this._marker._map._rotate) {
    //         return markerDragProto._onDragStart.apply(this, arguments);
    //     }
    //     this._draggable.updateMapBearing(this._marker._map._bearing);
    // },
    _onDrag: function(d) {
      var f = this._marker, h = f.options.rotation || f.options.rotateWithView, g = f._shadow, v = L.DomUtil.getPosition(f._icon);
      !h && g && L.DomUtil.setPosition(g, v), f._map._rotate && (v = f._map.mapPanePointToRotatedPoint(v));
      var x = f._map.layerPointToLatLng(v);
      f._latlng = x, d.latlng = x, d.oldLatLng = this._oldLatLng, h ? f.setLatLng(x) : f.fire("move", d), f.fire("drag", d);
    },
    _onDragEnd: function(d) {
      this._marker._map._rotate && this._marker.update(), s._onDragEnd.apply(this, arguments);
    }
  };
  L.Marker.include({
    /**
     * Update L.Marker anchor position after the map
     * is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(r.getEvents.apply(this, arguments), { rotate: this.update });
    },
    _initInteraction: function() {
      var d = r._initInteraction.apply(this, arguments);
      return this.dragging && this.dragging.enabled() && this._map && this._map._rotate && (s = s || Object.getPrototypeOf(this.dragging), this.dragging.disable(), Object.assign(this.dragging, {
        // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),
        _onDrag: a._onDrag.bind(this.dragging),
        _onDragEnd: a._onDragEnd.bind(this.dragging)
      }), this.dragging.enable()), d;
    },
    _setPos: function(d) {
      this._map._rotate && (d = this._map.rotatedPointToMapPanePoint(d));
      var f = this.options.rotation || 0;
      this.options.rotateWithView && (f += this._map._bearing), this._icon && L.DomUtil.setPosition(this._icon, d, f, d, this.options.scale), this._shadow && L.DomUtil.setPosition(this._shadow, d, f, d, this.options.scale), this._zIndex = d.y + this.options.zIndexOffset, this._resetZIndex();
    },
    // _updateZIndex: function(offset) {
    //     if (!this._map._rotate) {
    //         return markerProto._updateZIndex.apply(this, arguments);
    //     }
    //     this._icon.style.zIndex = Math.round(this._zIndex + offset);
    // },
    setRotation: function(d) {
      this.options.rotation = d, this.update();
    }
  });
  const l = L.extend({}, L.GridLayer.prototype);
  L.GridLayer.include({
    /**
     * Redraw L.TileLayer bounds after the map is
     * moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      var d = l.getEvents.apply(this, arguments);
      return this._map._rotate && !this.options.updateWhenIdle && (this._onRotate || (this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this)), d.rotate = this._onRotate), d;
    },
    _getTiledPixelBounds: function(d) {
      return this._map._rotate ? this._map._getNewPixelBounds(d, this._tileZoom) : l._getTiledPixelBounds.apply(this, arguments);
    }
  });
  const c = L.extend({}, L.Renderer.prototype);
  L.Renderer.include({
    /**
     * Redraw L.Canvas and L.SVG renderer bounds after the
     * map is moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(c.getEvents.apply(this, arguments), { rotate: this._update });
    },
    /**
     * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     */
    onAdd: function() {
      c.onAdd.apply(this, arguments), L.version <= "1.9.3" && this._container.classList.add("leaflet-zoom-animated");
    },
    /**
     * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)
     * 
     * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`
     * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`
     * 
     * @example
     *   map.setZoom(2);
     *   path._renderer._update();
     *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     * @see https://github.com/Leaflet/Leaflet/pull/8103
     * @see https://github.com/Leaflet/Leaflet/issues/7466
     * 
     * @TODO rechek this changes from leaflet@v1.9.3
     * 
     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3
     */
    _updateTransform: function(d, f) {
      if (!this._map._rotate)
        return c._updateTransform.apply(this, arguments);
      var h = this._map.getZoomScale(f, this._zoom), g = this._map._latLngToNewLayerPoint(this._topLeft, f, d);
      L.DomUtil.setTransform(this._container, g, h);
    },
    // getEvents() {
    //     const events = {
    //         viewreset: this._reset,
    //         zoom: this._onZoom,
    //         moveend: this._update,
    //         zoomend: this._onZoomEnd
    //     };
    //     if (this._zoomAnimated) {
    //         events.zoomanim = this._onAnimZoom;
    //     }
    //     return events;
    // },
    // _onAnimZoom(ev) {
    //     this._updateTransform(ev.center, ev.zoom);
    // },
    // _onZoom() {
    //     this._updateTransform(this._map.getCenter(), this._map.getZoom());
    // },
    // _onZoomEnd() {
    //     for (const id in this._layers) {
    //         this._layers[id]._project();
    //     }
    // },
    // _reset() {
    //     this._update();
    //     this._updateTransform(this._center, this._zoom);
    //     for (const id in this._layers) {
    //         this._layers[id]._reset();
    //     }
    // },
    // _updatePaths() {
    //     for (const id in this._layers) {
    //         this._layers[id]._update();
    //     }
    // },
    _update: function() {
      if (!this._map._rotate)
        return c._update.apply(this, arguments);
      this._bounds = this._map._getPaddedPixelBounds(this.options.padding), this._topLeft = this._map.layerPointToLatLng(this._bounds.min), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
    }
  });
  const u = L.extend({}, L.Map.prototype);
  L.Map.mergeOptions({ rotate: !1, bearing: 0 }), L.Map.prototype._animateZoomNoDelay = function(d, f, h) {
    this._mapPane && (h && (this._animatingZoom = !0, this._animateToCenter = d, this._animateToZoom = f, this._mapPane.classList.add("leaflet-zoom-anim")), this._onZoomTransitionEnd());
  }, L.Map.include({
    /**
     * @param {(HTMLElement|String)} id html selector
     * @param {Object} [options={}] leaflet map options
     */
    initialize: function(d, f) {
      f.rotate && (this._rotate = !0, this._bearing = 0), u.initialize.apply(this, arguments), this.options.rotate && this.setBearing(this.options.bearing);
    },
    /**
     * Given a pixel coordinate relative to the map container,
     * returns the corresponding pixel coordinate relative to
     * the [origin pixel](#map-getpixelorigin).
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    containerPointToLayerPoint: function(d) {
      return this._rotate ? L.point(d).subtract(this._getMapPanePos()).rotateFrom(-this._bearing, this._getRotatePanePos()).subtract(this._getRotatePanePos()) : u.containerPointToLayerPoint.apply(this, arguments);
    },
    /**
     * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
     * returns the corresponding pixel coordinate relative to the map container.
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    layerPointToContainerPoint: function(d) {
      return this._rotate ? L.point(d).add(this._getRotatePanePos()).rotateFrom(this._bearing, this._getRotatePanePos()).add(this._getMapPanePos()) : u.layerPointToContainerPoint.apply(this, arguments);
    },
    /**
     * Converts a coordinate from the rotated pane reference system
     * to the reference system of the not rotated map pane.
     * 
     * (rotatePane) --> (mapPane)
     * (rotatePane) --> (norotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point}
     * 
     * @since leaflet-rotate (v0.1)
     */
    rotatedPointToMapPanePoint: function(d) {
      return L.point(d).rotate(this._bearing)._add(this._getRotatePanePos());
    },
    /**
     * Converts a coordinate from the not rotated map pane reference system
     * to the reference system of the rotated pane.
     * 
     * (mapPane) --> (rotatePane)
     * (norotatePane) --> (rotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * 
     * @since leaflet-rotate (v0.1)
     */
    mapPanePointToRotatedPoint: function(d) {
      return L.point(d)._subtract(this._getRotatePanePos()).rotate(-this._bearing);
    },
    // latLngToLayerPoint: function (latlng) {
    //     var projectedPoint = this.project(L.latLng(latlng))._round();
    //     return projectedPoint._subtract(this.getPixelOrigin());
    // },
    // latLngToContainerPoint: function (latlng) {
    // 	return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    // },
    /**
     * Given latlng bounds, returns the bounds in projected pixel
     * relative to the map container.
     * 
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135
     * 
     * @param {L.LatLngBounds} bounds 
     * @returns {L.Bounds}
     * 
     * @since leaflet-rotate (v0.2)
     */
    mapBoundsToContainerBounds: function(d) {
      if (!this._rotate && u.mapBoundsToContainerBounds)
        return u.mapBoundsToContainerBounds.apply(this, arguments);
      const f = this.getPixelOrigin(), h = this.layerPointToContainerPoint(this.project(d.getNorthWest())._subtract(f)), g = this.layerPointToContainerPoint(this.project(d.getNorthEast())._subtract(f)), v = this.layerPointToContainerPoint(this.project(d.getSouthWest())._subtract(f)), x = this.layerPointToContainerPoint(this.project(d.getSouthEast())._subtract(f));
      return L.bounds([
        L.point(Math.min(h.x, g.x, x.x, v.x), Math.min(h.y, g.y, x.y, v.y)),
        // [ minX, minY ]
        L.point(Math.max(h.x, g.x, x.x, v.x), Math.max(h.y, g.y, x.y, v.y))
        // [ maxX, maxY ]
      ]);
    },
    /**
     * Returns geographical bounds visible in the current map view
     * 
     * @TODO find out  if map bounds calculated by `L.Map::getBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     * 
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.LatLngBounds}
     */
    getBounds: function() {
      if (!this._rotate)
        return u.getBounds.apply(this, arguments);
      var d = this.getSize();
      return new L.LatLngBounds([
        this.containerPointToLatLng([0, 0]),
        // topleft
        this.containerPointToLatLng([d.x, 0]),
        // topright 
        this.containerPointToLatLng([d.x, d.y]),
        // bottomright
        this.containerPointToLatLng([0, d.y])
        // bottomleft
      ]);
    },
    /**
     * Returns the bounds of the current map view in projected pixel
     * coordinates (sometimes useful in layer and overlay implementations).
     * 
     * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.Bounds}
     */
    // getPixelBounds(center, zoom) {
    //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());
    //     const topLeftPoint = this._getTopLeftPoint(center, zoom);
    //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    // },
    /**
     * Change map rotation
     * 
     * @param {number} theta map degrees
     * @param {L.Point} rotation center offset in screen pixels to apply
     * 
     * @since leaflet-rotate (v0.1)
     */
    setBearing: function(d, f = L.point(0, 0)) {
      if (!(!L.Browser.any3d || !this._rotate)) {
        var h = L.Util.wrapNum(d, [0, 360]) * L.DomUtil.DEG_TO_RAD, g = this._getPixelCenter().add(L.point(f)), v = this._getRotatePanePos().rotateFrom(-this._bearing, g), x = v.rotateFrom(h, g);
        L.DomUtil.setPosition(this._rotatePane, v, h, g), this._pivot = g, this._bearing = h, this._rotatePanePos = x, this.fire("rotate");
      }
    },
    /**
     * Get current map rotation
     * 
     * @returns {number} theta map degrees
     * 
     * @since leaflet-rotate (v0.1)
     */
    getBearing: function() {
      return this._bearing * L.DomUtil.RAD_TO_DEG;
    },
    /**
     * Creates a new [map pane](#map-pane) with the given name if it doesn't
     * exist already, then returns it. The pane is created as a child of
     * `container`, or as a child of the main map pane if not set.
     * 
     * @param {String} name leaflet pane
     * @param {HTMLElement} [container] parent element
     * @returns {HTMLElement} pane container
     */
    // createPane: function(name, container) {
    //     if (!this._rotate || name == 'mapPane') {
    //         return mapProto.createPane.apply(this, arguments);
    //     }
    //     // init "rotatePane"
    //     if (!this._rotatePane) {
    //         // this._pivot = this.getSize().divideBy(2);
    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);
    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);
    //     }
    //     return mapProto.createPane.call(this, name, container || this._rotatePane);
    // },
    /**
     * Panes are DOM elements used to control the ordering of layers on
     * the map. You can access panes with [`map.getPane`](#map-getpane)
     * or [`map.getPanes`](#map-getpanes) methods. New panes can be created
     * with the [`map.createPane`](#map-createpane) method.
     * 
     * Every map has the following default panes that differ only in zIndex:
     * 
     * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes
     * - tilePane    [HTMLElement = 2]      - Pane for tile layers
     * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons
     * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)
     * - markerPane  [HTMLElement = 6]      - Pane for marker icons
     * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.
     * - popupPane   [HTMLElement = 700]    - Pane for popups.
     */
    _initPanes: function() {
      var d = this._panes = {};
      this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0)), this._rotate ? (this._rotatePane = this.createPane("rotatePane", this._mapPane), this._norotatePane = this.createPane("norotatePane", this._mapPane), this.createPane("tilePane", this._rotatePane), this.createPane("overlayPane", this._rotatePane), this.createPane("shadowPane", this._norotatePane), this.createPane("markerPane", this._norotatePane), this.createPane("tooltipPane", this._norotatePane), this.createPane("popupPane", this._norotatePane)) : (this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane")), this.options.markerZoomAnimation || (L.DomUtil.addClass(d.markerPane, "leaflet-zoom-hide"), L.DomUtil.addClass(d.shadowPane, "leaflet-zoom-hide"));
    },
    /**
     * Pans the map the minimum amount to make the `latlng` visible. Use
     * padding options to fit the display to more restricted bounds.
     * If `latlng` is already within the (optionally padded) display bounds,
     * the map will not be panned.
     * 
     * @see https://github.com/Raruto/leaflet-rotate/issues/18
     * 
     * @param {L.LatLng} latlng coordinates
     * @param {Object} [options={}] padding options
     * 
     * @returns {L.Map} current map instance
     */
    panInside(d, f) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1)
        return u.panInside.apply(this, arguments);
      f = f || {};
      const h = L.point(f.paddingTopLeft || f.padding || [0, 0]), g = L.point(f.paddingBottomRight || f.padding || [0, 0]), v = this._container.getBoundingClientRect(), x = this.latLngToContainerPoint(d), w = L.bounds([L.point(v), L.point(v).add(this.getSize())]), M = w.getCenter(), p = L.bounds([w.min.add(h), w.max.subtract(g)]), y = p.getSize();
      if (!p.contains(x)) {
        this._enforcingBounds = !0;
        const S = x.subtract(p.getCenter()), C = p.extend(x).getSize().subtract(y);
        M.x += S.x < 0 ? -C.x : C.x, M.y += S.y < 0 ? -C.y : C.y, this.panTo(this.containerPointToLatLng(M), f), this._enforcingBounds = !1;
      }
      return this;
    },
    /**
     * Pans the map to the closest view that would lie inside the given bounds
     * (if it's not already), controlling the animation using the options specific,
     * if any.
     * 
     * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @param {L.LatLngBounds} bounds coordinates
     * @param {Object} [options] pan options
     * @returns {L.Map} current map instance
     */
    // panInsideBounds: function (bounds, options) {
    //     this._enforcingBounds = true;
    //     var center = this.getCenter(),
    //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));
    //
    //     if (!center.equals(newCenter)) {
    //         this.panTo(newCenter, options);
    //     }
    //
    //     this._enforcingBounds = false;
    //     return this;
    // },
    // adjust center for view to get inside bounds
    // _limitCenter(center, zoom, bounds) {
    //
    //     if (!bounds) { return center; }
    //
    //     const centerPoint = this.project(center, zoom),
    //         viewHalf = this.getSize().divideBy(2),
    //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
    //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);
    //
    //     // If offset is less than a pixel, ignore.
    //     // This prevents unstable projections from getting into
    //     // an infinite loop of tiny offsets.
    //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
    //             return center;
    //     }
    //
    //     return this.unproject(centerPoint.add(offset), zoom);
    // },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    // flyToBounds(bounds, options) {
    //     const target = this._getBoundsCenterZoom(bounds, options);
    //     return this.flyTo(target.center, target.zoom, options);
    // },
    // _getBoundsCenterZoom(bounds, options) {
    //
    //     options = options || {};
    //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
    //
    //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
    //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);
    //
    //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
    //
    //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;
    //
    //     if (zoom === Infinity) {
    //         return { center: bounds.getCenter(), zoom };
    //     }
    //
    //     return { center, zoom };
    //
    // },
    /**
     * Returns the maximum zoom level on which the given bounds fit to the map
     * view in its entirety. If `inside` (optional) is set to `true`, the method
     * instead returns the minimum zoom level on which the map view fits into
     * the given bounds in its entirety.
     * 
     * @param {L.LatLngBounds} bounds
     * @param {Boolean} [inside=false]
     * @param {L.Point} [padding=[0,0]]
     * 
     * @returns {Number} zoom level
     */
    getBoundsZoom(d, f, h) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1)
        return u.getBoundsZoom.apply(this, arguments);
      d = L.latLngBounds(d), h = L.point(h || [0, 0]);
      let g = this.getZoom() || 0;
      const v = this.getMinZoom(), x = this.getMaxZoom(), w = this.getSize().subtract(h), M = this.mapBoundsToContainerBounds(d).getSize(), p = this.options.zoomSnap, y = w.x / M.x, S = w.y / M.y, C = f ? Math.max(y, S) : Math.min(y, S);
      return g = this.getScaleZoom(C, g), p && (g = Math.round(g / (p / 100)) * (p / 100), g = f ? Math.ceil(g / p) * p : Math.floor(g / p) * p), Math.max(v, Math.min(x, g));
    },
    /**
     * Layer point of the current center
     * 
     * @returns {L.Point} layer center
     */
    // _getCenterLayerPoint: function () {
    //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    // },
    /**
     * Offset of the specified place to the current center in pixels
     * 
     * @param {L.LatLng} latlng map coordinates
     */
    _getCenterOffset: function(d) {
      var f = u._getCenterOffset.apply(this, arguments);
      return this._rotate && (f = f.rotate(this._bearing)), f;
    },
    /**
     * @since leaflet-rotate (v0.1)
     */
    _getRotatePanePos: function() {
      return this._rotatePanePos || new L.Point(0, 0);
    },
    // _latLngToNewLayerPoint(latlng, zoom, center) {
    //    const topLeft = this._getNewPixelOrigin(center, zoom);
    //    return this.project(latlng, zoom)._subtract(topLeft);
    //},
    _getNewPixelOrigin: function(d, f) {
      if (!this._rotate)
        return u._getNewPixelOrigin.apply(this, arguments);
      var h = this.getSize()._divideBy(2);
      return this.project(d, f).rotate(this._bearing)._subtract(h)._add(this._getMapPanePos())._add(this._getRotatePanePos()).rotate(-this._bearing)._round();
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\tile\GridLayer::_getTiledPixelBounds()
     */
    _getNewPixelBounds: function(d, f) {
      if (d = d || this.getCenter(), f = f || this.getZoom(), !this._rotate && u._getNewPixelBounds)
        return u._getNewPixelBounds.apply(this, arguments);
      var h = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(), g = this.getZoomScale(h, f), v = this.project(d, f).floor(), x = this.getSize(), w = new L.Bounds([
        this.containerPointToLayerPoint([0, 0]).floor(),
        this.containerPointToLayerPoint([x.x, 0]).floor(),
        this.containerPointToLayerPoint([0, x.y]).floor(),
        this.containerPointToLayerPoint([x.x, x.y]).floor()
      ]).getSize().divideBy(g * 2);
      return new L.Bounds(v.subtract(w), v.add(w));
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @return {L.Point} map pivot point (center)
     */
    _getPixelCenter: function() {
      return !this._rotate && u._getPixelCenter ? u._getPixelCenter.apply(this, arguments) : this.getSize()._divideBy(2)._subtract(this._getMapPanePos());
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\vector\Renderer::_update()
     */
    _getPaddedPixelBounds: function(d) {
      if (!this._rotate && u._getPaddedPixelBounds)
        return u._getPaddedPixelBounds.apply(this, arguments);
      var f = d, h = this.getSize(), g = h.multiplyBy(-f), v = h.multiplyBy(1 + f);
      return new L.Bounds([
        this.containerPointToLayerPoint([g.x, g.y]).floor(),
        this.containerPointToLayerPoint([g.x, v.y]).floor(),
        this.containerPointToLayerPoint([v.x, g.y]).floor(),
        this.containerPointToLayerPoint([v.x, v.y]).floor()
      ]);
    },
    _handleGeolocationResponse: function(d) {
      if (this._container._leaflet_id) {
        var f = d.coords.latitude, h = d.coords.longitude, g = d.coords.heading, v = new L.LatLng(f, h), x = v.toBounds(d.coords.accuracy), w = this._locateOptions;
        if (w.setView) {
          var M = this.getBoundsZoom(x);
          this.setView(v, w.maxZoom ? Math.min(M, w.maxZoom) : M);
        }
        var p = {
          latlng: v,
          bounds: x,
          timestamp: d.timestamp,
          /** @TODO use mapProto._handleGeolocationResponse */
          heading: g
        };
        for (var y in d.coords)
          typeof d.coords[y] == "number" && (p[y] = d.coords[y]);
        this.fire("locationfound", p);
      }
    }
    /**
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264
     * 
     * @param {L.Bounds} points 
     * @returns {L.Bounds}
     */
    // toCircumscribedBounds(points) {
    //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),
    //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),
    //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),
    //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);
    //
    //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));
    // },
  }), L.Map.CompassBearing = L.Handler.extend({
    initialize: function(d) {
      this._map = d, "ondeviceorientationabsolute" in window ? this.__deviceOrientationEvent = "deviceorientationabsolute" : "ondeviceorientation" in window && (this.__deviceOrientationEvent = "deviceorientation"), this._throttled = L.Util.throttle(this._onDeviceOrientation, 100, this);
    },
    addHooks: function() {
      this._map._rotate && this.__deviceOrientationEvent ? L.DomEvent.on(window, this.__deviceOrientationEvent, this._throttled, this) : this.disable();
    },
    removeHooks: function() {
      this._map._rotate && this.__deviceOrientationEvent && L.DomEvent.off(window, this.__deviceOrientationEvent, this._throttled, this);
    },
    /**
     * `DeviceOrientationEvent.absolute` - Indicates whether the device is providing absolute
     *                                     orientation values (relatives to Magnetic North) or
     *                                     using some arbitrary frame determined by the device.
     * 
     * `DeviceOrientationEvent.alpha`    - Returns the rotation of the device around the Z axis;
     *                                     that is, the number of degrees by which the device is
     *                                     being twisted around the center of the screen.
     * 
     * `window.orientation`              - Returns the screen orientation in degrees (in 90-degree increments)
     *                                     of the viewport relative to the device's natural orientation.
     *                                     Its only possible values are -90, 0, 90, and 180. Positive
     *                                     values are counterclockwise; negative values are clockwise.
     * 
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/alpha
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation
     */
    _onDeviceOrientation: function(d) {
      var f = d.webkitCompassHeading || d.alpha, h = 0;
      !d.absolute && d.webkitCompassHeading && (f = 360 - f), !d.absolute && typeof window.orientation < "u" && (h = window.orientation), this._map.setBearing(f - h);
    }
  }), L.Map.addInitHook("addHandler", "compassBearing", L.Map.CompassBearing), L.Map.mergeOptions({
    /**
     * Whether the map uses mutation observers to
     * detect changes in its container and trigger
     * `invalidateSize`. Disabled by default due to
     * support not being available in all web browsers.
     *
     * @type {Boolean}
     * 
     * @see https://developer.mozilla.org/docs/Web/API/MutationObserver
     */
    trackContainerMutation: !1
  }), L.Map.ContainerMutation = L.Handler.extend({
    addHooks: function() {
      this._observer || (this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map))), this._observer.observe(this._map.getContainer(), {
        childList: !1,
        attributes: !0,
        characterData: !1,
        subtree: !1,
        attributeFilter: ["style"]
      });
    },
    removeHooks: function() {
      this._observer.disconnect();
    }
  }), L.Map.addInitHook("addHandler", "trackContainerMutation", L.Map.ContainerMutation), L.Map.mergeOptions({
    /**
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: !0,
    /**
     * Set a minimum bearing value (rotate threshold) to
     * prevent map from rotating when user just wants to
     * zoom.  
     * 
     * @type { number | undefined }
     */
    touchRotateIntertia: 0
  }), L.Map.TouchGestures = L.Handler.extend({
    initialize: function(d) {
      this._map = d, this.rotate = !!this._map.options.touchRotate, this.zoom = !!this._map.options.touchZoom;
    },
    addHooks: function() {
      L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
    },
    _onTouchStart: function(d) {
      var f = this._map;
      if (!(!d.touches || d.touches.length !== 2 || f._animatingZoom || this._zooming || this._rotating)) {
        var h = f.mouseEventToContainerPoint(d.touches[0]), g = f.mouseEventToContainerPoint(d.touches[1]), v = h.subtract(g);
        this._centerPoint = f.getSize()._divideBy(2), this._startLatLng = f.containerPointToLatLng(this._centerPoint), this._center = this._startLatLng, this.zoom ? (f.options.touchZoom !== "center" && (this._pinchStartLatLng = f.containerPointToLatLng(h.add(g)._divideBy(2))), this._startDist = h.distanceTo(g), this._startZoom = f.getZoom(), this._zooming = !0) : this._zooming = !1, this.rotate ? (this._startTheta = Math.atan(v.x / v.y), this._startBearing = f.getBearing(), v.y < 0 && (this._startBearing += 180), this._rotating = !0) : this._rotating = !1, this._moved = !1, f._stop(), L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend touchcancel", this._onTouchEnd, this), L.DomEvent.preventDefault(d);
      }
    },
    _onTouchMove: function(d) {
      if (!(!d.touches || d.touches.length !== 2 || !(this._zooming || this._rotating))) {
        var f = this._map, h = f.mouseEventToContainerPoint(d.touches[0]), g = f.mouseEventToContainerPoint(d.touches[1]), v = h.subtract(g), x = h.distanceTo(g) / this._startDist, w, M;
        if (this._rotating) {
          var p = Math.atan(v.x / v.y), y = (p - this._startTheta) * L.DomUtil.RAD_TO_DEG;
          v.y < 0 && (y += 180), Math.abs(y) > this._map.options.touchRotateInertia && f.setBearing(this._startBearing - y);
        }
        if (this._zooming) {
          if (this._zoom = f.getScaleZoom(x, this._startZoom), !f.options.bounceAtZoomLimits && (this._zoom < f.getMinZoom() && x < 1 || this._zoom > f.getMaxZoom() && x > 1) && (this._zoom = f._limitZoom(this._zoom)), f.options.touchZoom === "center") {
            if (this._center = this._startLatLng, x === 1)
              return;
          } else {
            if (w = h._add(g)._divideBy(2)._subtract(this._centerPoint), x === 1 && w.x === 0 && w.y === 0)
              return;
            var S = -f.getBearing() * L.DomUtil.DEG_TO_RAD;
            this._center = f.unproject(f.project(this._pinchStartLatLng).subtract(w.rotate(S)));
          }
          M = !0;
        }
        this._moved || (f._moveStart(!0, !1), this._moved = !0), L.Util.cancelAnimFrame(this._animRequest), this._animZoomRequest && L.Util.cancelAnimFrame(this._animZoomRequest);
        var C = f._move.bind(f, this._center, this._zoom, { pinch: !0, round: !1 });
        if (this._animRequest = L.Util.requestAnimFrame(C, this, !0), M) {
          var T = f._animateZoomNoDelay.bind(f, this._center, this._map._limitZoom(this._zoom), !0);
          this._animZoomRequest = L.Util.requestAnimFrame(T, this, !0);
        } else
          this._animZoomRequest = null;
        L.DomEvent.preventDefault(d);
      }
    },
    _onTouchEnd: function() {
      if (!this._moved || !(this._zooming || this._rotating)) {
        this._zooming = !1;
        return;
      }
      this._zooming = !1, this._rotating = !1, L.Util.cancelAnimFrame(this._animRequest), L.Util.cancelAnimFrame(this._animZoomRequest), L.DomEvent.off(document, "touchmove", this._onTouchMove, this).off(document, "touchend touchcancel", this._onTouchEnd, this), this.zoom && (this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._animateZoomNoDelay(this._center, this._map._limitZoom(this._zoom), !0));
    }
  }), L.Map.addInitHook("addHandler", "touchGestures", L.Map.TouchGestures), L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with a two-finger rotation gesture
     * 
     * @type {Boolean}
     */
    touchRotate: !1
  }), L.Map.TouchRotate = L.Handler.extend({
    addHooks: function() {
      this._map.touchGestures.enable(), this._map.touchGestures.rotate = !0;
    },
    removeHooks: function() {
      this._map.touchGestures.rotate = !1;
    }
  }), L.Map.addInitHook("addHandler", "touchRotate", L.Map.TouchRotate), L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with shift + wheel scroll
     * @type {Boolean}
     */
    shiftKeyRotate: !0
  }), L.Map.ShiftKeyRotate = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, "wheel", this._handleShiftScroll, this), this._map.shiftKeyRotate.rotate = !0;
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "wheel", this._handleShiftScroll, this), this._map.shiftKeyRotate.rotate = !1;
    },
    _handleShiftScroll: function(d) {
      d.shiftKey ? (d.preventDefault(), this._map.scrollWheelZoom.disable(), this._map.setBearing(this._map._bearing * L.DomUtil.RAD_TO_DEG + Math.sign(d.deltaY) * 5)) : this._map.scrollWheelZoom.enable();
    }
  }), L.Map.addInitHook("addHandler", "shiftKeyRotate", L.Map.ShiftKeyRotate), L.Map.addInitHook(function() {
    this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled() && (this.scrollWheelZoom.disable(), this.scrollWheelZoom.enable());
  }), L.Map.mergeOptions({
    /**
     * Whether the map can be zoomed by touch-dragging
     * with two fingers. If passed `'center'`, it will
     * zoom to the center of the view regardless of
     * where the touch events (fingers) were. Enabled
     * for touch-capable web browsers.
     * 
     * @type {(Boolean|String)}
     */
    touchZoom: L.Browser.touch,
    /**
     * @TODO check if this is a duplicate of `L.Map.TouchGestures::bounceAtZoomLimits`
     * 
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: !1
  }), L.Map.TouchZoom = L.Handler.extend({
    addHooks: function() {
      this._map._handlers.forEach((d) => {
        typeof d._onTouchMove == "function" && d.disable();
      }), L.DomUtil.addClass(this._map._container, "leaflet-touch-zoom"), this._map.touchGestures.enable(), this._map.touchGestures.zoom = !0;
    },
    removeHooks: function() {
      L.DomUtil.removeClass(this._map._container, "leaflet-touch-zoom"), this._map.touchGestures.zoom = !1;
    }
  }), L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom), L.Control.Rotate = L.Control.extend({
    options: {
      position: "topleft",
      closeOnZeroBearing: !0
    },
    onAdd: function(d) {
      var f = this._container = L.DomUtil.create("div", "leaflet-control-rotate leaflet-bar"), h = this._arrow = L.DomUtil.create("span", "leaflet-control-rotate-arrow");
      h.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")`, h.style.cursor = "grab", h.style.display = "block", h.style.width = "100%", h.style.height = "100%", h.style.backgroundRepeat = "no-repeat", h.style.backgroundPosition = "50%";
      var g = this._link = L.DomUtil.create("a", "leaflet-control-rotate-toggle", f);
      return g.appendChild(h), g.href = "#", g.title = "Rotate map", L.DomEvent.on(g, "dblclick", L.DomEvent.stopPropagation).on(g, "mousedown", this._handleMouseDown, this).on(g, "click", L.DomEvent.stop).on(g, "click", this._cycleState, this).on(g, "click", this._refocusOnMap, this), L.Browser.any3d || L.DomUtil.addClass(g, "leaflet-disabled"), this._restyle(), d.on("rotate", this._restyle, this), this._follow = !1, this._canFollow = !1, this.options.closeOnZeroBearing && d.getBearing() === 0 && (f.style.display = "none"), f;
    },
    onRemove: function(d) {
      d.off("rotate", this._restyle, this);
    },
    _handleMouseDown: function(d) {
      L.DomEvent.stop(d), this.dragging = !0, this.dragstartX = d.pageX, this.dragstartY = d.pageY, L.DomEvent.on(document, "mousemove", this._handleMouseDrag, this).on(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseUp: function(d) {
      L.DomEvent.stop(d), this.dragging = !1, L.DomEvent.off(document, "mousemove", this._handleMouseDrag, this).off(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseDrag: function(d) {
      if (this.dragging) {
        var f = d.clientX - this.dragstartX;
        this._map.setBearing(f);
      }
    },
    _cycleState: function(d) {
      if (this._map) {
        var f = this._map;
        !f.touchRotate.enabled() && !f.compassBearing.enabled() ? f.touchRotate.enable() : f.compassBearing.enabled() ? (f.compassBearing.disable(), f.setBearing(0), this.options.closeOnZeroBearing && f.touchRotate.enable()) : (f.touchRotate.disable(), (DeviceOrientationEvent && DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission() : Promise.resolve("granted")).then((h) => h === "granted" && f.compassBearing.enable())), this._restyle();
      }
    },
    _restyle: function() {
      if (!this._map.options.rotate)
        L.DomUtil.addClass(this._link, "leaflet-disabled");
      else {
        var d = this._map, f = d.getBearing();
        this._arrow.style.transform = "rotate(" + f + "deg)", f && this.options.closeOnZeroBearing && (this._container.style.display = "block"), d.compassBearing.enabled() ? this._link.style.backgroundColor = "orange" : d.touchRotate.enabled() ? this._link.style.backgroundColor = null : (this._link.style.backgroundColor = "grey", f === 0 && this.options.closeOnZeroBearing && (this._container.style.display = "none"));
      }
    }
  }), L.control.rotate = function(d) {
    return new L.Control.Rotate(d);
  }, L.Map.mergeOptions({
    rotateControl: !0
  }), L.Map.addInitHook(function() {
    if (this.options.rotateControl) {
      var d = typeof this.options.rotateControl == "object" ? this.options.rotateControl : {};
      this.rotateControl = L.control.rotate(d), this.addControl(this.rotateControl);
    }
  });
});
B.Map.mergeOptions({
  // Deactivate by default
  boxSelection: !1,
  // If active deactivate default box zoom as it will conflict
  // boxZoom: false,
  boxSelectionKey: "shiftKey"
});
const Aw = B.Handler.extend({
  initialize: function(e) {
    this._map = e, this._boxSelectionKey = e.options.boxSelectionKey, this._container = e._container, this._pane = e._panes.overlayPane, this._resetStateTimeout = 0, e.on("unload", this._destroy, this);
  },
  addHooks: function() {
    B.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
  },
  removeHooks: function() {
    B.DomEvent.off(this._container, "mousedown", this._onMouseDown, this);
  },
  moved: function() {
    return this._moved;
  },
  _destroy: function() {
    B.DomUtil.remove(this._pane), delete this._pane;
  },
  _resetState: function() {
    this._resetStateTimeout = 0, this._moved = !1;
  },
  _clearDeferredResetState: function() {
    this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
  },
  _onMouseDown: function(e) {
    if (!e[this._boxSelectionKey] || e.which !== 1 && e.button !== 1)
      return !1;
    this._clearDeferredResetState(), this._resetState(), B.DomUtil.disableTextSelection(), B.DomUtil.disableImageDrag(), this._startPoint = this._map.mouseEventToContainerPoint(e), B.DomEvent.on(document, {
      contextmenu: B.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseMove: function(e) {
    this._moved || (this._moved = !0, this._box = B.DomUtil.create("div", "leaflet-zoom-box", this._container), B.DomUtil.addClass(this._container, "leaflet-crosshair"), this._map.fire("boxselectionstart", Object.assign(e, { containerPoint: this._startPoint }))), this._point = this._map.mouseEventToContainerPoint(e);
    const t = new B.Bounds(this._point, this._startPoint), i = t.getSize();
    B.DomUtil.setPosition(this._box, t.min), this._box.style.width = i.x + "px", this._box.style.height = i.y + "px";
  },
  _finish: function() {
    this._moved && (B.DomUtil.remove(this._box), B.DomUtil.removeClass(this._container, "leaflet-crosshair")), B.DomUtil.enableTextSelection(), B.DomUtil.enableImageDrag(), B.DomEvent.off(document, {
      contextmenu: B.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseUp: function(e) {
    if (e.which !== 1 && e.button !== 1 || (this._finish(), !this._moved))
      return;
    this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(B.Util.bind(this._resetState, this), 0);
    const t = new B.LatLngBounds(
      this._map.containerPointToLatLng(this._startPoint),
      this._map.containerPointToLatLng(this._point)
    );
    this._map.fire("boxselectionend", Object.assign(e, { bounds: t, containerPoint: this._map.mouseEventToContainerPoint(e) }));
  },
  _onKeyDown: function(e) {
    e.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
  }
});
B.Map.addInitHook("addHandler", "boxSelection", Aw);
const Ow = B.Icon.extend({
  options: {
    fillColor: "#2B85C7",
    pointRadius: 8,
    pointStroke: "#010101",
    strokeColor: "#010101",
    strokeWidth: 2,
    strokeLength: 15,
    barbSpaceing: 5,
    barbHeight: 15,
    forceDir: !1
  },
  initialize: function(e) {
    e = B.Util.setOptions(this, e);
  },
  createIcon: function() {
    const e = document.createElement("div"), t = this._createPoint();
    return e.appendChild(t), this._setIconStyles(e), e;
  },
  _createPoint: function() {
    const e = this.options.pointStroke, t = this.options.strokeWidth, i = this.options.pointRadius, n = this.options.fillColor, r = 2 * t + 2 * i, s = r, a = "http://www.w3.org/2000/svg", l = document.createElementNS(a, "svg");
    l.setAttributeNS(null, "width", r), l.setAttributeNS(null, "height", s);
    const c = document.createElementNS(a, "circle");
    return c.setAttributeNS(null, "stroke", e), c.setAttributeNS(null, "stroke-width", t), c.setAttributeNS(null, "fill", n), c.setAttributeNS(null, "cx", r / 2), c.setAttributeNS(null, "cy", s / 2), c.setAttributeNS(null, "r", i), l.appendChild(c), l;
  },
  _createBarbs: function(e) {
    let t = e / 0.514;
    const i = { 5: 0, 10: 0, 50: 0 }, n = this.options.barbSpaceing, r = this.options.barbHeight, s = this.options.pointRadius, a = this.options.strokeColor, l = this.options.strokeWidth, c = this.options.strokeLength, u = this.options.forceDir, d = "http://www.w3.org/2000/svg", f = document.createElementNS(d, "svg"), h = document.createElementNS(d, "g");
    t = t % 5 >= 2.5 ? parseInt(t / 5) * 5 + 5 : parseInt(t / 5) * 5;
    for (let D = t; D > 0; )
      if (D - 50 >= 0)
        i[50] += 1, D -= 50;
      else if (D - 10 >= 0)
        i[10] += 1, D -= 10;
      else if (D - 5 >= 0)
        i[5] += 1, D -= 5;
      else
        break;
    const g = i[5] + i[10] + i[50];
    let v;
    g === 0 ? v = 0 : (v = g * n, (i[5] === 1 && i[10] > 0 || i[5] === 1 && i[50] > 0) && (v -= n), i[50] > 0 && (v += 3 * i[50] * n));
    const x = Math.round(Math.sqrt(r * r + v * v)) + 2, w = s * 2 + l * 2 + 2 * (v + c) + 2 * x, M = w, p = w / 2, y = M / 2;
    f.setAttributeNS(null, "width", w), f.setAttributeNS(null, "height", M), f.appendChild(h);
    let S, C, T, k, I, A, P;
    if (u === !0 && (S = p - s - l * 0.5, C = y, k = S + "," + C, I = S - c, T = I - 2 * n, P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " H " + I), h.appendChild(P), S = I), g !== 0) {
      if (u !== !0 && (S = p - s - l * 0.5, C = y, k = S + "," + C, I = S - c, T = I - 2 * n, P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " H " + I), h.appendChild(P), S = I), i[5] === 1) {
        const D = Math.sqrt(2 * n * (2 * n) + r * r), F = Math.atan(r / (2 * n)), O = D / 2;
        k = S + "," + C, A = S - O * Math.cos(F) + "," + (y - r * 0.5), P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " L " + A), h.appendChild(P), i[10] === 0 && i[50] === 0 && (S -= n, I = S, P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " H " + I), h.appendChild(P));
      }
      for (let D = 0; D < i[10]; D++)
        k = S + "," + C, S -= n, I = S, P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " H " + I), h.appendChild(P), k = I + "," + y, T -= n, A = T + "," + (y - r), P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " L " + A), h.appendChild(P);
      if (i[50] > 0) {
        k = S + "," + C, S -= n, I = S, P = document.createElementNS(d, "path"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "stroke-linecap", "butt"), P.setAttributeNS(null, "d", "M " + k + " H " + I), h.appendChild(P);
        for (let D = 0; D < i[50]; D++) {
          T -= n;
          const F = S + "," + y, O = T + "," + (y - r), $ = T + "," + y;
          P = document.createElementNS(d, "polygon"), P.setAttributeNS(null, "stroke", a), P.setAttributeNS(null, "stroke-width", l), P.setAttributeNS(null, "fill", "#000000"), P.setAttributeNS(null, "points", F + " " + O + " " + $), h.appendChild(P), S -= 2 * n, T -= n;
        }
      }
    }
    return { ax: p, ay: y, svg: f };
  },
  _setIconStyles: function(e, t, i) {
    let n;
    const r = this.options, s = B.point(r[t === "shadow" ? "shadowSize" : "iconSize"]), a = this.options.strokeWidth, l = this.options.pointRadius;
    if (t === "shadow")
      n = i, e.style.width = n.x + "px", e.style.height = n.y + "px";
    else {
      e.style.position = "absolute";
      const c = 2 * a + 2 * l, u = c, d = c / 2, f = u / 2;
      n = B.point([d, f]);
    }
    !n && s && (n = s.divideBy(2, !0)), n && (e.style.marginLeft = -n.x + "px", e.style.marginTop = -n.y + "px"), s && (e.style.width = s.x + "px", e.style.height = s.y + "px");
  },
  createShadow: function() {
    const e = this.options.deg + 90, t = this.options.speed, i = this._createBarbs(t), n = document.createElement("div");
    this.options.mirrorVel ? (i.svg.style.transform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.MozTransform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.webkitTransform = "rotate(" + e + "deg) scaleY(-1)", i.svg.style.msTransform = "rotate(" + e + "deg) scaleY(-1)") : (i.svg.style.transform = "rotate(" + e + "deg)", i.svg.style.MozTransform = "rotate(" + e + "deg)", i.svg.style.webkitTransform = "rotate(" + e + "deg)", i.svg.style.msTransform = "rotate(" + e + "deg)"), n.appendChild(i.svg);
    const r = { x: i.ax, y: i.ay };
    return this._setIconStyles(n, "shadow", r), n;
  }
});
B.WindBarb = {};
B.WindBarb.version = "0.0.5";
B.WindBarb.Icon = Ow;
B.WindBarb.icon = function(e) {
  return new B.WindBarb.Icon(e);
};
const Bw = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=", Rw = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7cua5gzeKg8hJo3grY4g7c3grU0gLI2frE0daAubJc2gbQwd6QzeKk2gLMtd5sxdKIua5g1frA2f7IydaM0e6w2fq41fK01eqo3grgubJgta5cxdKI1f7AydaQydaMxc6EubJgvbJkwcZ4ubZkwcJwubZgubJcydqUydKIxapgubJctbJcubZcubJcvbJYubJcvbZkubJctbJctbZcubJg2f7AubJcrbZcubJcubJcua5g3grY0fq8ubJcubJdEkdEwhsw6i88vhswuhcsuhMtBjMgthMsrg8srgss6is8qgcs8i9A9iMYtg8spgcoogMo7hcMngMonf8olfso4gr8kfck5iM8jfMk4iM8he8k1fro7itAgesk2hs8eecgzfLcofssdeMg0hc4cd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqhUndROmdM1fK0wcZ8vb5w0eqpQm9MzeKhXoNVcpdYydKNWn9VZotVKltJFjsIwcJ1Rms9OlslLmtH///8+kc9epdYzd6dbo9VHkMM2f7FHmNBClM8ydqVcpNY9hro3gLM9hLczealQmcw3fa46f7A8gLMxc6I3eagyc6FIldJMl9JSnNRSntNNl9JPnNJFi75UnM9ZodVKksg8kM45jc09e6ZHltFBk883gbRBh7pDk9EwcaBzn784g7dKkcY2i81Om9M7j85Llc81is09g7Q4grY/j9A0eqxKmdFFltBEjcXf6fFImdBCiLxJl9FGlNFBi78yiMxVndEvbpo6js74+vx+psPP3+o/ks5HkcpGmNCjwdZCkNDM3ehYoNJEls+lxNkxh8xHks0+jdC1zd5Lg6r+/v/H2ufz9/o3jM3t8/edvdM/k89Th61OiLBSjbZklbaTt9BfptdjmL1AicBHj8hGk9FAgK1dkLNTjLRekrdClc/k7fM0icy0y9tgp9c4jc2NtM9Dlc8zicxeXZn3AAAAQ3RSTlMAHDdTb4yPA+LtnEQmC4L2EmHqB7XA0d0sr478x4/Yd5i1zOfyPkf1sLVq4Nh3FvjxopQ2/STNuFzUwFIwxKaejILpIBEV9wAABhVJREFUeF6s1NdyFEcYBeBeoQIhRAkLlRDGrhIgY3BJL8CVeKzuyXFzzjkn5ZxzzuScg3PO8cKzu70JkO0LfxdTU//pM9vTu7Xgf6KqOVTb9X7toRrVEfBf1HTVjZccrT/2by1VV928Yty9ZbVuucdz90frG8DBjl9pVApbOstvmMuvVgaNXSfAAd6pGxpy6yxf5ph43pS/4f3uoaGm2rdu72S9xzOvMymkZFq/ptDrk90mhW7e4zl7HLzhxGWPR20xmSxJ/VqldG5m9XhaVOA1DadsNh3Pu5L2N6QtPO/32JpqQBVVk20oy/Pi2s23WEvyfHbe1thadVQttvm7Llf65gGmXK67XtupyoM7HQhmXdLS8oGWJNeOJ3C5fG5XCEJnkez3/oFdsvgJ4l2ANZwhrJKk/7OSXa+3Vw2WJMlKnGkobouYk6T0TyX30klOUnTD9HJ5qpckL3EW/w4XF3Xd0FGywXUrstrclVsqz5Pd/sXFYyDnPdrLcQODmGOK47IZb4CmibmMn+MYRzFZ5jg33ZL/EJrWcszHmANy3ARBK/IXtciJy8VsitPSdE3uuHxzougojcUdr8/32atnz/ev3f/K5wtpxUTpcaI45zusVDpYtZi+jg0oU9b3x74h7+n9ABvYEZeKaVq0sh0AtLKsFtqNBdeT0MrSzwwlq9+x6xAO4tgOtSzbCjrNQQiNvQUbUEubvzBUeGw26yDCsRHCoLkTHDa7IdOLIThs/gHvChszh2CimE8peRs47cxANI0lYNB5y1DljpOF0IhzBDPOZnDOqYYbeGKECbPzWnXludPphw5c2YBq5zlwXphIbO4VDCZ0gnPfUO1TwZoYwAs2ExPCedAu9DAjfQUjzITQb3jNj0KG2Sgt6BHaQUdYzWz+XmBktOHwanXjaSTcwwziBcuMOtwBmqPrTOxFQR/DRKKPqyur0aiW6cULYsx6tBm0jXpR/AUWR6HRq9WVW6MRhIq5jLyjbaCTDCijyYJNpCajdyobP/eTw0iexBAKkJ3gA5KcQb2zBXsIBckn+xVv8jkZSaEFHE+jFEleAEfayRU0MouNoBmB/L50Ai/HSLIHxcrpCvnhSQAuakKp2C/YbCylJjXRVy/z3+Kv/RrNcCo+WUzlVEhzKffnTQnxeN9fWF88fiNCUdSTsaufaChKWInHeysygfpIqagoakW+vV20J8uyl6TyNKEZWV4oRSPyCkWpgOLSbkCObT8o2r6tlG58HQquf6O0v50tB7JM7F4EORd2dx/K0w/KHsVkLPaoYrwgP/y7krr3SSMA4zj+OBgmjYkxcdIJQyQRKgg2viX9Hddi9UBb29LrKR7CVVEEEXWojUkXNyfTNDE14W9gbHJNuhjDettN3ZvbOvdOqCD3Jp/9l+/wJE+9PkYGjx/fqkys3S2rMozM/o2106rfMUINo6hVqz+eu/hd1c4xTg0TAfy5kV+4UG6+IthHTU9woWmxuKNbTfuCSfovBCxq7EtHqvYL4Sm6F8GVxsSXHMQ07TOi1DKtZxjWaaIyi4CXWjxPccUw8WVbMYY5wxC1mzEyXMJWkllpRloi+Kkoq69sxBTlElF6aAxYUbjXNlhlDZilDnM4U5SlN5biRsRHnbx3mbeWjEh4mEyiuJDl5XcWVmX5GvNkFgLWZM5qwsop4/AWfLhU1cR7k1VVvcYCWRkOI6Xy5gmnphCYIkvzuNYzHzosq2oNk2RtSs8khfUOfHIDgR6ysYBaMpl4uEgk2U/oJTs9AaTSwma7dT69geAE2ZpEjUsn2ieJNHeKfrI3EcAGJ2ZaNgVuC8EBctCLc57P5u5led6IOBkIYkuQMrmmjChs4VkfOerHqSBkPzZlhe06RslZ3zMjk2sscqKwY0RcjKK+LWbzd7KiHhkncs/siFJ+V5eXxD34B8nVuJEpGJNmxN2gH3vSvp7J70tF+D1Ej8qUJD1TkErAND2GZwTFg/LubvmgiBG3SOvdlsqFQrkEzJCL1rstlnVFROixZoDDSuXQFHESwVGlcuQcMb/b42NgjLowh5MTDFE3vNB5qStRIErdCQEh6pLPR92anSUb/wAIhldAaDMpGgAAAABJRU5ErkJggg==", $w = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
window.nezasa = { iso8601: kc };
delete B.Icon.Default.prototype._getIconUrl;
B.Icon.Default.mergeOptions({
  iconUrl: Bw,
  iconRetinaUrl: Rw,
  shadowUrl: $w
});
B.PM.setOptIn(!0);
const Iw = B.GridLayer.prototype._getTiledPixelBounds;
B.GridLayer.include({
  _getTiledPixelBounds: function(e) {
    let t = Iw.call(this, e);
    const i = this.options.edgeBufferTiles;
    if (i > 0) {
      const n = B.GridLayer.prototype.getTileSize.call(this).multiplyBy(i);
      t = new B.Bounds(t.min.subtract(n), t.max.add(n));
    }
    return t;
  }
});
const zw = B.Map.prototype._createRenderer;
B.Map.include({
  _createRenderer: function(e) {
    return zw.call(this, Object.assign(o.get(this.options, "rendererOptions", {}), e));
  }
});
const Nw = {
  emits: [
    "map-ready",
    "layer-added",
    "layer-removed",
    "layer-shown",
    "layer-hidden",
    "layer-enabled",
    "layer-disabled",
    "pane-added",
    "pane-removed",
    "pane-shown",
    "pane-hidden"
  ],
  data() {
    return {
      layers: {},
      orphanLayers: []
    };
  },
  methods: {
    refreshMap() {
      this.map && this.map.invalidateSize();
    },
    setupMap(e, t = {}) {
      const i = o.defaults(t, o.get(this, "activityOptions.engine.viewer", {}), {
        minZoom: 3,
        maxZoom: 21,
        center: [47, 3],
        zoom: 6,
        maxBounds: [[-90, -180], [90, 180]],
        maxBoundsViscosity: 0.25,
        scale: !0,
        geolocate: !0,
        rotateControl: !1
        // Rotate plugin show this even if rotation is disabled
      });
      this.map = B.map(e, Object.assign({ zoomControl: !1 }, i));
      const n = o.get(i, "backgroundColor");
      n && (this.map._container.style.backgroundColor = n), this.map.pm === void 0 && (this.map.options.pmIgnore = !1, B.PM.reInitLayer(this.map), this.map.pm.setLang(Bt())), B.DomEvent.on(this.map._container, Nn.join(" "), this.onTouchEvent, this), Dt(this.map, ni.Map, this, i);
      const r = o.get(i, "scale", !0);
      r && this.setupScaleControl(r);
      const s = o.get(i, "geolocate", !0);
      s && this.setupGeolocateControl(s);
      const a = this.map.createPane("kdk-hidden-features");
      a.style.display = "none", this.onMapReady();
    },
    convertTouches(e) {
      const t = [];
      if (e && e.length)
        for (let i = 0; i < e.length; i++) {
          const n = typeof e.item == "function" ? e.item(i) : e[i], r = {
            containerPoint: this.map.mouseEventToContainerPoint(n)
          };
          r.containerPoint && (r.layerPoint = this.map.containerPointToLayerPoint(r.containerPoint), r.latlng = this.map.layerPointToLatLng(r.layerPoint)), t.push(r);
        }
      return t;
    },
    onTouchEvent(e) {
      if (e.pointerType === "mouse") return;
      const n = {
        pointerdown: "touchstart",
        pointermove: "touchmove",
        pointerup: "touchend",
        pointercancel: "touchcancel"
      }[e.type] || e.type;
      let r = this.map._findEventTargets(e, n);
      if (!r.length) return;
      const s = this.convertTouches(e.touches), a = this.convertTouches(e.changedTouches), l = this.convertTouches(e.targetTouches);
      for (let c = 0; c < r.length; c++) {
        const u = r[c], d = {
          originalEvent: e,
          touches: s,
          changedTouches: a,
          targetTouches: l
        }, f = o.isEmpty(s) ? o.isEmpty(a) ? [] : a : s, h = u.getLatLng && (!u._radius || u._radius <= 10);
        if (d.containerPoint = h ? this.map.latLngToContainerPoint(u.getLatLng()) : o.get(f, "[0].containerPoint"), d.containerPoint && (d.layerPoint = this.map.containerPointToLayerPoint(d.containerPoint), d.latlng = h ? u.getLatLng() : this.map.layerPointToLatLng(d.layerPoint)), u.fire(n, d, !0), d.originalEvent._stopped) return;
      }
    },
    onMapReady() {
      this.$emit("map-ready", "leaflet"), this.$engineEvents.emit("map-ready", "leaflet");
    },
    setupScaleControl(e) {
      typeof e == "object" ? this.scaleControl = new B.control.graphicScale(e) : this.scaleControl = new B.control.scale(), this.scaleControl.addTo(this.map);
    },
    setupGeolocateControl() {
      this.locateControl = new B.control.locate({
        // eslint-disable-line
        locateOptions: {
          maxZoom: 16,
          watch: !1,
          setView: !1,
          timeout: 3e4,
          enableHighAccuracy: !0
        },
        strings: {
          title: this.$t("geolocation.TITLE"),
          metersUnit: this.$t("geolocation.METERS"),
          feetUnit: this.$t("geolocation.FEET"),
          popup: this.$t("geolocation.POPUP"),
          outsideMapBoundsMsg: this.$t("geolocation.OUTSIDE_MAP_BOUNDS")
        }
      }), this.locateControl.addTo(this.map), this.locateControl._container.style.display = "none";
    },
    processLeafletLayerOptions(e) {
      const t = o.cloneDeep(e), i = t.leaflet;
      return this.leafletObjectOptions.forEach((n) => {
        typeof o.get(i, n) == "string" && o.set(i, n, o.get(B, o.get(i, n)));
      }), o.has(i, "minZoom") && !o.isNumber(i.minZoom) && o.unset(i, "minZoom"), o.has(i, "maxZoom") && !o.isNumber(i.maxZoom) && o.unset(i, "maxZoom"), i.attribution = t.attribution, t;
    },
    getLeafletPaneName(e) {
      return typeof e == "object" ? e.name || e.zIndex.toString() : e.toString();
    },
    createLeafletPane(e) {
      const t = this.getLeafletPaneName(e);
      let i = this.map.getPane(t);
      if (!i) {
        let n;
        typeof e == "object" ? n = e.zIndex || 400 : typeof e == "number" && (n = e);
        let r = e.container;
        this.map._rotate && !r && (r = "rotatePane"), r = this.map.getPane(r), i = this.map.createPane(t, r), o.set(i, "style.zIndex", n || 400);
      }
      return this.leafletPanes[t] = i, this.onPaneAdded(t, i), i;
    },
    onPaneAdded(e, t) {
      this.$emit("pane-added", e, t), this.$engineEvents.emit("pane-added", e, t);
    },
    getLeafletPaneByName(e) {
      const t = e.toString();
      return this.leafletPanes[t];
    },
    removeLeafletPane(e) {
      const t = e.toString(), i = this.getLeafletPaneByName(t);
      i && (delete this.leafletPanes[t], this.onPaneRemoved(t, i));
    },
    onPaneRemoved(e, t) {
      this.$emit("pane-removed", e, t), this.$engineEvents.emit("pane-removed", e, t);
    },
    isPaneVisible(e) {
      const t = this.getLeafletPaneByName(e);
      return t && t.style.display === "block";
    },
    showPane(e) {
      const t = this.getLeafletPaneByName(e);
      !t || t.style.display === "block" || (t.style.display = "block", this.onPaneShown(e, t));
    },
    onPaneShown(e, t) {
      this.$emit("pane-shown", e, t), this.$engineEvents.emit("pane-shown", e, t);
    },
    hidePane(e) {
      const t = this.getLeafletPaneByName(e);
      !t || t.style.display === "none" || (t.style.display = "none", this.onPaneHidden(e, t));
    },
    onPaneHidden(e, t) {
      this.$emit("pane-hidden", e, t), this.$engineEvents.emit("pane-hidden", e, t);
    },
    updateLeafletPanesVisibility() {
      const e = Math.floor(this.map.getZoom());
      o.forOwn(this.leafletPanes, (t, i) => {
        const n = !!o.get(t, "minZoom"), r = !!o.get(t, "maxZoom");
        if (!(!n && !r)) {
          if (t.style || (t.style = {}), n && e < o.get(t, "minZoom")) {
            this.hidePane(i);
            return;
          }
          if (r && e > o.get(t, "maxZoom")) {
            this.hidePane(i);
            return;
          }
          this.showPane(i);
        }
      });
    },
    createLeafletLayer(e) {
      const t = e.name, i = e.leaflet || e, n = { name: t }, r = !!o.get(i, "minZoom"), s = !!o.get(i, "maxZoom"), a = !!o.get(i, "zIndex");
      r && (n.minZoom = o.get(i, "minZoom")), s && (n.maxZoom = o.get(i, "maxZoom")), a && (n.zIndex = o.get(i, "zIndex")), a && (this.createLeafletPane(n), o.has(i, "pane") || o.set(i, "pane", n.name));
      const l = o.get(i, "panes", []);
      l && l.forEach((f) => {
        const h = this.createLeafletPane(f);
        Object.assign(h, f);
      }), this.updateLeafletPanesVisibility();
      let c = o.get(i, "options", []);
      typeof c == "object" && (c = [c]);
      let u, d = i.type;
      if (i.source) {
        const f = i.source;
        delete i.source, u = o.get(B, d)(f, o.omit(i, ["options"]), ...c);
      } else
        u = o.get(B, d)(o.omit(i, ["options"]), ...c);
      return u;
    },
    registerLeafletConstructor(e) {
      this.leafletFactory.push(e);
    },
    async createLayer(e) {
      const t = this.processLeafletLayerOptions(e);
      let i;
      for (let n = 0; n < this.leafletFactory.length; n++) {
        const r = this.leafletFactory[n];
        if (i = await r(t), i) break;
      }
      return i || this.createLeafletLayer(t);
    },
    createLeafletTimedWmsLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tileLayer.wms" && t.type !== "TileLayer.wmsHeader") return;
      let i = this.createLeafletLayer(e);
      const n = o.get(t, "timeDimension");
      if (n) {
        o.set(n, "period", "P1D");
        const r = o.get(n, "times"), s = typeof r == "string" ? r.split("/") : [], a = typeof r == "string" ? r.split(",") : [];
        let l = [];
        o.isEmpty(a) ? s.length === 2 ? o.set(n, "times", `${r}/P1D`) : s.length === 3 && o.set(n, "period", s[2]) : (o.unset(n, "period"), l = o.sortBy(a.map((u) => fe.utc(u)), (u) => u.valueOf()));
        const c = fe.duration(o.get(n, "period"));
        i = this.createLeafletLayer({
          type: "timeDimension.layer.wms",
          source: i,
          timeDimension: B.timeDimension(n),
          currentTime: pe.getCurrentTime().toDate().getTime()
        }), i.setCurrentTime = (u) => {
          i._timeDimension.setCurrentTime(u.toDate().getTime());
        }, i._createLayerForTime = (u) => {
          u = fe.utc(u);
          const d = o.omit(i._baseLayer.options, ["timeDimension", "isVisible", "type"]);
          if (c.years() > 0)
            d.time = u.format("YYYY").toISOString();
          else if (c.months() > 0)
            d.time = u.format("YYYY-MM");
          else if (c.days() > 0)
            d.time = u.format("YYYY-MM-DD");
          else if (o.isEmpty(l))
            d.time = u.toISOString();
          else {
            const { index: h, difference: g } = hs(u, l, !0);
            h >= 0 ? d.time = a[h] : d.time = u.toISOString();
          }
          let f = o.get(t, "options", []);
          return typeof f == "object" && (f = [f]), new i._baseLayer.constructor(i._baseLayer.getURL(), d, ...f);
        };
      }
      return i;
    },
    hasLayer(e) {
      return o.has(this.layers, e);
    },
    isLayerVisible(e) {
      const t = this.getLeafletLayerByName(e);
      return t && this.map.hasLayer(t);
    },
    isLayerDisabled(e) {
      const t = o.get(e, "leaflet.minZoom"), i = o.get(e, "leaflet.maxZoom");
      let n = !1;
      return t && this.map.getZoom() < t && (n = !0), i && this.map.getZoom() > i && (n = !0), n;
    },
    updateLayerDisabled(e) {
      const t = e.isDisabled, i = this.isLayerDisabled(e);
      t !== i && (e.isDisabled = i, t ? this.onLayerEnabled(e) : this.onLayerDisabled(e));
    },
    onLayerEnabled(e) {
      this.$emit("layer-enabled", e), this.$engineEvents.emit("layer-enabled", e);
    },
    onLayerDisabled(e) {
      this.$emit("layer-disabled", e), this.$engineEvents.emit("layer-disabled", e);
    },
    getLayerByName(e) {
      return this.layers[e];
    },
    getOrphanLayerByName(e) {
      return this.orphanLayers.find((t) => t?.name === e);
    },
    getLeafletLayerByName(e) {
      return this.leafletLayers[e];
    },
    getLayerById(e) {
      const t = this.getLayers({ _id: e });
      return o.get(t, "[0]");
    },
    getLayers(e = {}) {
      return o.values(this.layers).filter(Pe(e));
    },
    hasLayers(e = {}) {
      return o.values(this.layers).filter(Pe(e)).length > 0;
    },
    async showLayer(e) {
      const t = this.getLayerByName(e);
      if (!t || this.isLayerVisible(e)) return;
      let i = this.getLeafletLayerByName(e);
      if (!i)
        try {
          i = await this.createLayer(t);
        } catch (n) {
          z.error(n);
          return;
        }
      this.leafletLayers[e] = i, this.map.addLayer(i), t.isVisible = !0, typeof i.setCurrentTime == "function" && i.setCurrentTime(pe.getCurrentTime()), this.onLayerShown(t, i);
    },
    onLayerShown(e, t) {
      this.$emit("layer-shown", e, t), this.$engineEvents.emit("layer-shown", e, t);
    },
    hideLayer(e) {
      if (!this.isLayerVisible(e)) return;
      const t = this.getLayerByName(e);
      if (!t) return;
      t.isVisible = !1;
      const i = this.leafletLayers[e];
      delete this.leafletLayers[e], this.map.removeLayer(i);
      const n = o.get(t, "leaflet.panes");
      n && n.forEach((r) => this.removeLeafletPane(r.name || r.zIndex)), this.onLayerHidden(t, i);
    },
    onLayerHidden(e, t) {
      this.$emit("layer-hidden", e, t), this.$engineEvents.emit("layer-hidden", e, t);
    },
    async addLayer(e) {
      return e && !this.hasLayer(e.name) && (e.isVisible = !1, e.isDisabled = this.isLayerDisabled(e), this.layers[e.name] = e, this.onLayerAdded(e), o.get(e, "leaflet.isVisible", !1) && await this.showLayer(e.name)), e;
    },
    onLayerAdded(e) {
      this.$emit("layer-added", e), this.$engineEvents.emit("layer-added", e);
    },
    async addGeoJsonLayer(e, t, i = !0) {
      ba(e, t) && (await this.addLayer(e), await this.updateLayer(e.name, t), i && (t.bbox ? this.zoomToBBox(t.bbox) : this.zoomToLayer(e.name)));
    },
    renameLayer(e, t) {
      const i = this.getLayerByName(e), n = this.getLeafletLayerByName(e);
      i && (n && (this.leafletLayers[t] = n, delete this.leafletLayers[e]), this.layers[t] = i, delete this.layers[e]);
    },
    reorganizeLayers() {
      for (let e = this.layerCategories.length - 1; e >= 0; e--) {
        const t = this.layerCategories[e];
        if (t?.layers)
          for (let i = t.layers.length - 1; i >= 0; i--) {
            const n = t.layers[i];
            this.bringLayerToFront(n);
          }
      }
      for (let e = this.orphanLayers.length - 1; e >= 0; e--) {
        const t = this.orphanLayers[e];
        this.bringLayerToFront(t.name);
      }
    },
    removeLayer(e) {
      const t = this.getLayerByName(e);
      t && (this.hideLayer(e), delete this.layers[t.name], this.onLayerRemoved(t));
    },
    onLayerRemoved(e) {
      this.$emit("layer-removed", e), this.$engineEvents.emit("layer-removed", e);
    },
    clearLayers() {
      Object.keys(this.layers).forEach((e) => this.removeLayer(e));
    },
    toGeoJson(e) {
      if (!this.isLayerVisible(e)) {
        const i = this.geojsonCache[e];
        if (i) return i;
      }
      const t = this.getLeafletLayerByName(e);
      if (!(!t || typeof t.toGeoJSON != "function"))
        return t.toGeoJSON();
    },
    zoomToLayer(e, t) {
      const i = this.getLayerByName(e);
      if (!i) return;
      if (this.isLayerDisabled(i)) {
        const r = o.get(i, "leaflet.minZoom");
        if (r) {
          const s = this.getCenter();
          this.center(s.longitude, s.latitude, r);
          return;
        }
      }
      const n = o.get(i, "bbox");
      if (n)
        this.zoomToBBox(n);
      else {
        const r = this.getLeafletLayerByName(e);
        if (r)
          if (typeof r.getBounds == "function") {
            const s = r.getBounds();
            s.isValid() && this.map.fitBounds(s, t);
          } else {
            const s = o.get(i, "leaflet.bounds", this.map.options.maxBounds);
            this.zoomToBounds(s);
          }
      }
    },
    zoomToBounds(e) {
      this.map.fitBounds(e);
    },
    zoomToBBox(e) {
      this.zoomToBounds([[e[1], e[0]], [e[3], e[2]]]);
    },
    bringLayerToFront(e) {
      let t = this.getLeafletLayerByName(e);
      if (!t) return;
      const i = o.get(t, "options.panes");
      if (i) {
        i.forEach((n) => {
          const r = this.getLeafletPaneByName(this.getLeafletPaneName(n));
          r && B.DomUtil.toFront(r);
        });
        return;
      }
      if (t instanceof B.MarkerClusterGroup) {
        const n = t;
        t = t.getLayers().find((r) => r._container === n);
      }
      t && typeof t.bringToFront == "function" && t.bringToFront();
    },
    bringLayerToBack(e) {
      let t = this.getLeafletLayerByName(e);
      if (!t) return;
      const i = o.get(t, "options.panes");
      if (i) {
        i.forEach((n) => {
          const r = this.getLeafletPaneByName(this.getLeafletPaneName(n));
          r && B.DomUtil.toBack(r);
        });
        return;
      }
      if (t instanceof B.MarkerClusterGroup) {
        const n = t;
        t = t.getLayers().find((r) => r._container === n);
      }
      t && typeof t.bringToBack == "function" && t.bringToBack();
    },
    animateCenter(e) {
      this.centerAnimation.startTime || (this.centerAnimation.startTime = e);
      const {
        id: t,
        duration: i,
        startTime: n,
        fps: r,
        animate: { center: s, zoom: a, bearing: l },
        startLongitude: c,
        endLatitude: u,
        startLatitude: d,
        startZoom: f,
        startBearing: h,
        endLongitude: g,
        endZoom: v,
        endBearing: x
      } = this.centerAnimation, w = e - n;
      if (r && this.centerAnimation.lastTime) {
        const C = e - this.centerAnimation.lastTime, T = 1e3 / r;
        if (C < T) {
          this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
          return;
        }
      }
      const M = Math.abs(w / (1e3 * i));
      let p, y, S;
      if (M <= 1) {
        const C = this.getCenter();
        if (s) {
          const O = s.easing.function, $ = s.easing.parameters || [];
          p = Hi[O](M, ...$);
        }
        if (a) {
          const O = a.easing.function, $ = a.easing.parameters || [];
          y = Hi[O](M, ...$);
        }
        if (l) {
          const O = l.easing.function, $ = l.easing.parameters || [];
          S = Hi[O](M, ...$);
        }
        const T = this.centerAnimation.offset, k = s && T && p * T.x || 0, I = s && T && p * T.y || 0;
        let A = C.longitude, P = C.latitude;
        if (s)
          if (s.rhumb) {
            const O = Bc(this.centerAnimation.rhumbStart, p * this.centerAnimation.rhumbDistance, this.centerAnimation.rhumbBearing);
            A = O.geometry.coordinates[0], P = O.geometry.coordinates[1];
          } else
            A = c + p * (g - c), P = d + p * (u - d);
        const D = a ? f + y * (v - f) : null;
        let F;
        if (!o.isNil(h)) {
          const O = (x - h + 540) % 360 - 180;
          F = l ? (h + S * O + 360) % 360 : null;
        }
        this.center(A, P, D, F, { offset: { x: Math.round(k), y: Math.round(I) }, bearingTolerance: this.centerAnimation.bearingTolerance }), this.centerAnimation.lastTime = e, this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
      } else
        this.centerAnimation.id = null;
    },
    center(e, t, i, n, r = {}) {
      const s = B.point(o.get(r, "offset.x", 0), o.get(r, "offset.y", 0));
      if (o.isNil(i) && (i = this.map.getZoom()), o.isNil(n) && (n = this.map.getBearing()), n < 0 && (n += 360), o.get(r, "duration", 0)) {
        o.defaultsDeep(r, {
          animate: {
            center: { easing: { function: "linear" }, rhumb: !1 },
            zoom: { easing: { function: "linear" } },
            bearing: { easing: { function: "linear" } }
          }
        }), o.has(this.centerAnimation, "id") && cancelAnimationFrame(o.get(this.centerAnimation, "id"));
        const l = this.getCenter(r), c = kr([l.longitude, l.latitude]), u = kr([e, t]);
        this.centerAnimation = {
          id: requestAnimationFrame(this.animateCenter),
          ...r,
          startLongitude: l.longitude,
          startLatitude: l.latitude,
          startZoom: l.zoom,
          endLongitude: e,
          endLatitude: t,
          rhumbStart: c,
          rhumbEnd: u,
          rhumbBearing: Oc(c, u),
          rhumbDistance: Ac(c, u),
          endZoom: i
        }, typeof this.map.getBearing == "function" && Object.assign(this.centerAnimation, {
          startBearing: this.map.getBearing(),
          endBearing: n
        });
      } else
        typeof this.map.setBearing == "function" && this.setBearing(n, r), this.map.setView(new B.LatLng(t, e), i, { animate: !1, duration: 0 }), this.map.panBy(s, { animate: !1, duration: 0 });
    },
    getCenter() {
      const e = this.map.getCenter(), t = this.map.getZoom();
      return {
        longitude: e.lng,
        latitude: e.lat,
        zoomLevel: t
      };
    },
    setBearing(e, t = {}) {
      if (typeof this.map.setBearing != "function") {
        z.warn("[KDK] Map not configured to handle bearing, ignoring");
        return;
      }
      const i = B.point(o.get(t, "offset.x", 0), o.get(t, "offset.y", 0)), n = o.get(t, "bearingTolerance", 0.1);
      Math.abs(this.map.getBearing() - e) >= n && this.map.setBearing(e, i);
    },
    getBearing() {
      return typeof this.map.getBearing != "function" ? 0 : this.map.getBearing();
    },
    setCompassBearingTrackingEnabled(e) {
      e ? this.map.compassBearing.enabled() || this.map.compassBearing.enable() : this.map.compassBearing.enabled() && this.map.compassBearing.disable();
    },
    setTouchRotateEnabled(e) {
      e ? this.map.touchRotate.enabled() || this.map.touchRotate.enable() : this.map.touchRotate.enabled() && this.map.touchRotate.disable();
    },
    getBounds() {
      this.viewBounds = this.map.getBounds();
      const e = this.viewBounds.getSouth(), t = this.viewBounds.getWest(), i = this.viewBounds.getNorth(), n = this.viewBounds.getEast();
      return [[e, t], [i, n]];
    },
    showUserLocation() {
      if (ot.hasLocation()) {
        const e = ot.getLongitude(), t = ot.getLatitude(), i = ot.getAccuracy();
        i ? this.zoomToBounds(new B.LatLng(t, e).toBounds(i * 2)) : this.center(e, t);
      }
      this.locateControl && this.locateControl.start();
    },
    hideUserLocation() {
      this.locateControl && this.locateControl.stop();
    },
    isUserLocationVisible() {
      return this.locateControl && this.locateControl._active;
    },
    isOrphanLayer(e) {
      return this.orphanLayers.some((t) => t.name === e.name);
    },
    setCursor(e) {
      B.DomUtil.addClass(this.map._container, e);
    },
    isCursor(e) {
      return B.DomUtil.hasClass(this.map._container, e);
    },
    unsetCursor(e) {
      B.DomUtil.removeClass(this.map._container, e);
    },
    onCurrentMapTimeChanged(e) {
      o.forEach(this.leafletLayers, (t) => {
        typeof t.setCurrentTime == "function" && t.setCurrentTime(e);
      });
    },
    onMapZoomChanged() {
      this.updateLeafletPanesVisibility(), o.values(this.layers).filter(Pe({
        $or: [{ "leaflet.minZoom": { $exists: !0 } }, { "leaflet.maxZoom": { $exists: !0 } }]
      })).forEach(async (t) => {
        this.updateLayerDisabled(t);
      });
    }
  },
  async created() {
    this.leafletLayers = {}, this.leafletPanes = {}, this.leafletFactory = [], this.leafletObjectOptions = ["crs", "rendererFactory"], this.registerLeafletConstructor(this.createLeafletTimedWmsLayer), this.$engineEvents = new Co(), this.$engineEvents.on("zoomend", this.onMapZoomChanged), ne.on("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  beforeUnmount() {
    this.clearLayers(), B.DomEvent.off(this.map._container, Nn.join(" "), this.onTouchEvent, this), this.$engineEvents.off("zoomend", this.onMapZoomChanged), ne.off("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  unmounted() {
    this.map && (this.map.off(), this.map.remove());
  }
};
B.Polygon.extend({
  initialize: function(e, t) {
    B.setOptions(this, Object.assign({
      interactive: !1,
      fitBounds: !0,
      bounds: new B.LatLngBounds([-90, -360], [90, 360])
    }), t);
    const i = [
      this.options.bounds.getSouthWest(),
      this.options.bounds.getNorthWest(),
      this.options.bounds.getNorthEast(),
      this.options.bounds.getSouthEast()
    ], n = [];
    if (o.get(e, "type") === "Feature") {
      const s = o.get(e, "geometry.type"), a = o.get(e, "geometry.coordinates");
      s === "Polygon" && a ? this.addPolygon(a, n) : s === "MultiPolygon" && a && o.forEach(a, (l) => this.addPolygon(l, n)), e.bbox || (e.bbox = Fi(e));
    } else
      z.warn("Invalid/Unsupported GeoJson object for MaskLayer");
    B.Polygon.prototype.initialize.call(this, [i, n], this.options);
  },
  addPolygon(e, t) {
    const i = [];
    o.forEach(e, (n) => {
      const r = [];
      for (let s = 0; s < n.length; s++)
        r.push(new B.LatLng(n[s][1], n[s][0]));
      i.push(r);
    }), t.push(i);
  }
});
const jw = B.GridLayer.extend({
  initialize(e) {
    this.enableDebug = o.get(e, "enableDebug", !1), B.GridLayer.prototype.initialize.call(this, e), this.on("tileunload", (t) => {
      this.onTileUnload(t);
    }), this.userIsDragging = !1, this.userIsZooming = !1, this.pendingStationUpdates = [], this.pendingRequests = [], this.getFeatureKey = (t) => st(t, this.layer), this.probeSource = e.probeSource, this.featureSource = e.featureSource, this.flyingTiles = /* @__PURE__ */ new Map(), this.modifiedTiles = /* @__PURE__ */ new Set(), this.allFeatures = /* @__PURE__ */ new Map();
  },
  setup(e, t) {
    this.activity = e, this.layer = t;
  },
  onAdd(e) {
    this.userIsDragging = !1, this.userIsZooming = !1, this.pendingStationUpdates = [], this.zoomStartLevel = this.zoomEndLevel = this._map.getZoom(), this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), B.GridLayer.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), B.GridLayer.prototype.onRemove.call(this, e);
  },
  getEvents() {
    const e = B.GridLayer.prototype.getEvents.call(this), t = e.movestart;
    e.movestart = (s) => {
      this.userIsDragging = !0, t && t.call(this, s);
    };
    const i = e.moveend;
    e.moveend = (s) => {
      this.userIsDragging = !1, i && i.call(this, s);
    };
    const n = e.zoomstart;
    e.zoomstart = (s) => {
      n && n.call(this, s), this.zoomStartLevel = this._map.getZoom(), this.userIsZooming = !0;
    };
    const r = e.zoomend;
    return e.zoomend = (s) => {
      if (r && r.call(this, s), this.zoomEndLevel = this._map.getZoom(), this.userIsZooming = !1, this.layer.probeService) {
        const a = o.get(this.options, "minFeatureZoom", this._map.getMinZoom()), l = o.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
        if (this.zoomStartLevel >= a && this.zoomEndLevel < a || this.zoomStartLevel <= l && this.zoomEndLevel > l) {
          let c = [];
          for (const u of this.allFeatures.values())
            c.push(o.cloneDeep(u.geojson));
          c = it(c), this.activity.updateLayer(this.layer.name, c, { replace: !0 });
        } else if (this.pendingStationUpdates.length)
          for (const c of this.pendingStationUpdates) {
            const u = [];
            ki(c, (d) => {
              this.allFeatures.has(this.getFeatureKey(d)) && u.push(d);
            }), this.activity.updateLayer(this.layer.name, it(u));
          }
        this.pendingStationUpdates.length = 0;
      }
    }, e;
  },
  createTile(e) {
    const t = Mt(e);
    let i = this.flyingTiles.get(t);
    return i === void 0 ? (i = {
      div: document.createElement("div"),
      coords: e,
      bbox: this._tileCoordsToBounds(e),
      featuresRequest: null,
      featuresChildren: [],
      features: [],
      measuresRequest: null,
      measuresChildren: [],
      unload: !1
    }, this.flyingTiles.set(t, i), this.enableDebug && (i.div.style.outline = "1px solid orange", i.div.innerHTML = "")) : (i.unload = !1, this.enableDebug && (i.div.innerHTML += "</br>createTile: found in flying tiles")), this.modifiedTiles.add(t), i.div;
  },
  onTileUnload(e) {
    const t = Mt(e.coords), i = this.flyingTiles.get(t);
    i && (i.unload = !0), this.modifiedTiles.add(t), this.enableDebug && i && (i.div.innerHTML += "</br>unload scheduled");
  },
  mergeRequests(e) {
    const t = [], i = e.sort((n, r) => n.coords.x === r.coords.x ? n.coords.y < r.coords.y ? -1 : n.coords.y !== r.coords.y ? 1 : 0 : n.coords.x < r.coords.x ? -1 : 1);
    if (i.length) {
      const n = i[0].coords.z, r = [];
      if (i.forEach((s) => {
        let a = !0;
        if (r.length) {
          const l = r[r.length - 1];
          s.coords.x === l.x && s.coords.y === l.maxy + 1 && (l.tiles.push(s), l.maxy = s.coords.y, a = !1);
        }
        a && r.push({
          x: s.coords.x,
          miny: s.coords.y,
          maxy: s.coords.y,
          tiles: [s]
        });
      }), r.forEach((s) => {
        let a = !0;
        if (t.length) {
          const l = t[t.length - 1];
          s.miny === l.miny && s.maxy === l.maxy && s.x === l.maxx + 1 && (l.tiles.push(...s.tiles), l.maxx = s.x, a = !1);
        }
        a && t.push({
          minx: s.x,
          maxx: s.x,
          miny: s.miny,
          maxy: s.maxy,
          tiles: [].concat(s.tiles)
        });
      }), t.forEach((s) => {
        const a = B.point(s.minx, s.miny), l = B.point(s.maxx, s.maxy);
        a.z = l.z = n;
        const c = this._tileCoordsToBounds(a);
        c.extend(this._tileCoordsToBounds(l)), s.query = {
          south: c.getSouth(),
          north: c.getNorth(),
          west: c.getWest(),
          east: c.getEast()
        };
      }), this.enableDebug) {
        let s = 0;
        t.forEach((a) => {
          s += a.tiles.length;
        }), s !== e.length && z.debug("TiledFeatureLayer: less requested tiles than expected !");
      }
    }
    return this.enableDebug && e.length && z.debug(`TiledFeatureLayer: ${e.length} requests reduced to ${t.length}`), t;
  },
  _update(e) {
    if (B.GridLayer.prototype._update.call(this), this.pendingRequests = this.pendingRequests.filter((u) => u.status.pending), this.userIsDragging) return;
    const t = [], i = [], n = [], r = o.get(this.options, "minFeatureZoom", this._map.getMinZoom()), s = o.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
    this.modifiedTiles.forEach((u) => {
      const d = this.flyingTiles.get(u);
      if (d !== void 0)
        if (d.unload)
          d.featuresRequest === null && d.measuresRequest === null && t.push(d);
        else {
          const f = this.layer.probeService && d.coords.z >= r && d.coords.z <= s;
          this.enableDebug && (d.div.innerHTML += "</br>features", f && (d.div.innerHTML += " + measures"));
          const h = ef(this.flyingTiles, d.coords);
          if (h === void 0)
            i.push(d), f && n.push(d), this.enableDebug && (d.div.innerHTML += "</br>need request(s)");
          else {
            const g = this.flyingTiles.get(Mt(h));
            g.featuresRequest === null ? (g.features.forEach((v) => {
              const x = this.allFeatures.get(v);
              d.bbox.intersects(x.bbox) && (x.refCount += 1, d.features.push(v));
            }), this.enableDebug && (d.div.style.outline = "1px solid green", d.div.innerHTML += `</br>found ${d.features.length} features in parent tile`)) : (g.featuresChildren.push(d), d.featuresRequest = g.featuresRequest, this.enableDebug && (d.div.innerHTML += "</br>pending parent features request")), f && (g.measuresRequest !== null ? (g.measuresChildren.push(d), d.measuresRequest = g.measuresRequest, this.enableDebug && (d.div.innerHTML += "</br>pending parent measures request")) : h.z < r && (n.push(d), this.enableDebug && (d.div.innerHTML += "</br>need measures request")));
          }
        }
    }), this.modifiedTiles.clear(), this.mergeRequests(i).forEach((u) => {
      const d = this.layer.probeService ? this.probeSource(u.query) : this.featureSource(u.query);
      u.tiles.forEach((f) => {
        f.featuresRequest = d, this.enableDebug && (f.div.innerHTML += "</br>features request issued");
      }), d.status = { cancelled: !1, pending: !0 }, this.pendingRequests.push(d), d.then((f) => {
        if (d.status.cancelled) return;
        const h = [u.tiles];
        u.tiles.forEach((x) => {
          x.featuresChildren.length && h.push(x.featuresChildren);
        });
        const g = h.flat(), v = [];
        if (f.features.forEach((x) => {
          const w = this.getFeatureKey(x);
          let M = this.allFeatures.get(w);
          const p = M === void 0;
          if (p) {
            const y = Fi(x), S = B.latLng(y[1], y[0]), C = B.latLng(y[3], y[2]);
            M = { geojson: x, refCount: 0, bbox: B.latLngBounds(S, C) };
          }
          g.forEach((y) => {
            y.bbox.intersects(M.bbox) && (M.refCount += 1, y.features.push(w));
          }), M.refCount > 0 && p && (v.push(o.cloneDeep(x)), this.allFeatures.set(w, M));
        }), v.length) {
          const x = it(v);
          this.activity.updateLayer(this.layer.name, x);
        }
        g.forEach((x) => {
          x.featuresRequest = null, x.featuresChildren = [], x.unload && this.modifiedTiles.add(Mt(x.coords)), this.enableDebug && (x.div.style.outline = "1px solid green", x.div.innerHTML += `</br>features request success: ${f.features.length} total, ${x.features.length} for tile`);
        }), this.enableDebug && z.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).catch((f) => {
        if (d.status.cancelled) return;
        const h = [u.tiles];
        u.tiles.forEach((v) => {
          v.featuresChildren.length && h.push(v.featuresChildren);
        }), h.flat().forEach((v) => {
          this.flyingTiles.delete(Mt(v.coords)), this.enableDebug && (v.div.style.outline = "1px solid red", v.div.innerHTML += `</br>features request failed: ${f}`);
        }), this.enableDebug && z.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).finally(() => {
        d.status.pending = !1;
      });
    }), this.mergeRequests(n).forEach((u) => {
      const d = this.featureSource(u.query), f = [];
      u.tiles.forEach((h) => {
        h.measuresRequest = d, h.featuresRequest && f.push(h.featuresRequest), this.enableDebug && (h.div.innerHTML += "</br>measures request issued");
      }), d.status = { cancelled: !1, pending: !0 }, this.pendingRequests.push(d), Promise.all(f).then(() => {
        if (d.status.cancelled) return;
        const h = [];
        u.tiles.forEach((g) => {
          g.features.forEach((v) => {
            const x = this.allFeatures.get(v);
            if (x) {
              const w = o.cloneDeep(x.geojson);
              w.measureRequestIssued = !0, h.push(w);
            }
          });
        }), h.length && this.updateStations(it(h));
      }), d.then((h) => {
        if (d.status.cancelled) return;
        const g = [u.tiles];
        u.tiles.forEach((w) => {
          w.measuresChildren.length && g.push(w.measuresChildren);
        });
        const v = g.flat(), x = [];
        v.forEach((w) => {
          w.measuresRequest = null, w.measuresChildren = [], w.featuresRequest && x.push(w.featuresRequest), this.enableDebug && (w.div.innerHTML += `</br>measures request success: ${h.features.length} total`);
        }), Promise.all(x).then(() => {
          const w = [];
          ki(h, (M) => {
            const p = this.getFeatureKey(M);
            this.allFeatures.has(p) && w.push(M);
          }), w.length && this.updateStations(it(w));
        });
      }).catch((h) => {
        if (d.status.cancelled) return;
        const g = [u.tiles];
        u.tiles.forEach((x) => {
          x.measuresChildren.length && g.push(x.measuresChildren);
        }), g.flat().forEach((x) => {
          this.enableDebug && (x.div.style.outline = "1px solid red", x.div.innerHTML += `</br>measures request failed: ${h}`);
        });
      }).finally(() => {
        d.status.pending = !1;
      });
    });
    const c = [];
    t.forEach((u) => {
      u.features.forEach((d) => {
        const f = this.allFeatures.get(d);
        f.refCount === 1 ? (c.push(f.geojson), this.allFeatures.delete(d)) : f.refCount -= 1;
      }), this.flyingTiles.delete(Mt(u.coords));
    }), c.length && this.activity.updateLayer(this.layer.name, it(c), { remove: !0 }), this.enableDebug && (z.debug(`TiledFeatureLayer: flyingTiles is ${this.flyingTiles.size} long`), z.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`), this.flyingTiles.size === 0 && this.allFeatures.size !== 0 && (z.debug(`TileFeatureLayer: no more flyingTiles but ${this.allFeatures.size} remaining features !`), this.allFeatures.forEach((u) => {
      z.debug(`TileFeatureLayer: ${this.getFeatureKey(u.geojson)}: refCount ${u.refCount}`);
    })));
  },
  updateStations(e) {
    if (this.userIsZooming)
      this.pendingStationUpdates.push(e);
    else {
      const t = o.get(this.options, "minFeatureZoom", this._map.getMinZoom()), i = o.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
      this.zoomEndLevel >= t && this.zoomEndLevel <= i && this.activity.updateLayer(this.layer.name, e);
    }
  },
  redraw() {
    const e = Array.from(this.allFeatures.values(), (t) => t.geojson);
    this.activity.updateLayer(this.layer.name, it(e), { remove: !0 }), this.flyingTiles.clear(), this.modifiedTiles.clear(), this.allFeatures.clear(), this.pendingStationUpdates.length = 0, this.pendingRequests.forEach((t) => {
      t.status.cancelled = !0;
    }), B.GridLayer.prototype.redraw.call(this);
  }
});
function Vw(e, t = {}) {
  return fetch(e, { redirect: "follow", headers: t }).then((i) => i.text()).then((i) => Mr.parseStringPromise(i, { tagNameProcessors: [Mr.processors.stripPrefix] }));
}
function Uw(e, t, i, n = {}, r = {}, { xml2json: s = !0 } = {}) {
  const a = Gn(e, Object.assign({
    SERVICE: "WFS",
    VERSION: t,
    REQUEST: "GetFeature",
    TYPENAMES: typeof i == "string" ? i : i.join(" ")
  }, n));
  return s ? Vw(a, r) : fetch(a, { redirect: "follow", headers: r }).then((l) => l.json());
}
const qw = {
  emits: [
    "layer-updated"
  ],
  methods: {
    processRealtimeGeoJsonLayerOptions(e) {
      const t = e.leaflet || e;
      t.type = "realtime", o.set(t, "getFeatureId", (n) => st(n, e));
      const i = o.get(t, "container");
      if (typeof i == "string" && (t.container = this.createLeafletLayer({ type: i })), o.has(t, "updateFeature") || (t.updateFeature = jd(t)), e.service)
        if (e = this.getLayerByName(e.name), o.set(t, "start", !1), t.tiled)
          t.removeMissing = !1, o.set(t, "source", async (n, r) => {
          }), t.probeSource = (n) => this.getProbeFeatures(o.merge({ baseQuery: n }, e)), t.featureSource = (n) => this.getFeatures(o.merge({ baseQuery: n }, e));
        else {
          t.removeMissing = !e.probeService;
          let n = !e.probeService;
          o.set(t, "source", async (r, s) => {
            if (!n)
              try {
                const a = await this.getProbeFeatures(e);
                Ie(a).forEach((c) => {
                  c.measureRequestIssued = !0;
                }), r(a), n = !0;
              } catch (a) {
                s(a);
              }
            try {
              const a = await this.getFeatures(e);
              r(a);
            } catch (a) {
              s(a);
            }
          });
        }
      else if (e.wfs)
        o.set(t, "start", !1), o.set(t, "source", async (n, r) => {
        }), t.tiled && (t.removeMissing = !1, t.featureSource = (n) => {
          const r = Object.assign({
            OUTPUTFORMAT: e.wfs.outputFormat,
            // request as geojson
            SRSNAME: "EPSG:4326",
            // result in 4326
            BBOX: `${n.south},${n.west},${n.north},${n.east},urn:ogc:def:crs:EPSG::4326`
            // request bbox
          }, e.wfs.searchParams);
          return Uw(e.wfs.url, e.wfs.version, e.wfs.layer, r, e.wfs.headers, { xml2json: !1 });
        });
      else if (o.has(t, "sourceTemplate")) {
        const n = o.template(o.get(t, "sourceTemplate"));
        let r;
        o.set(t, "source", async (s, a) => {
          try {
            const l = n({ time: pe.getCurrentTime() });
            (!r || r !== l) && (r = l, s(await si(l, e)));
          } catch (l) {
            a(l);
          }
        }), o.set(t, "start", !1);
      } else o.has(t, "source") || (o.set(t, "start", !1), o.set(t, "source", async (n, r) => {
      }));
    },
    async processGeoJsonLayerOptions(e) {
      const t = e.leaflet || e, i = o.get(t, "source");
      if (o.isNil(i))
        o.set(t, "source", { type: "FeatureCollection", features: [] });
      else if (typeof i == "string") {
        let n;
        e.service ? n = await this.getFeatures(e) : n = await si(i, e), o.set(t, "source", n);
      }
    },
    processClusterLayerOptions(e) {
      const t = e.leaflet || e, i = Object.assign({ type: "markerClusterGroup" }, t.cluster);
      t.pane && (i.clusterPane = t.pane), t.container = this.createLeafletLayer(i), Dt(t.container, ni.Cluster, this, e);
    },
    async createLeafletGeoJsonLayer(e) {
      const t = e.leaflet || e;
      if (t.type === "geoJson")
        try {
          const i = !!o.get(t, "minZoom"), n = !!o.get(t, "maxZoom"), r = !!o.get(t, "zIndex"), s = e.name, a = { name: s };
          i && (a.minZoom = o.get(t, "minZoom")), n && (a.maxZoom = o.get(t, "maxZoom")), r && (a.zIndex = o.get(t, "zIndex"));
          const l = o.get(t, "panes", []);
          o.find(l, { name: a.name }) || l.push(a), o.has(t, "pane") || (t.pane = a.name), o.has(t, "shadowPane") || (t.shadowPane = a.name);
          for (const v of ["point", "line", "polygon"])
            o.set(t, `style.${v}.pane`, a.name), o.set(t, `style.${v}.shadowPane`, a.name);
          r || (o.find(l, { name: `${s}-markers` }) || l.push(Object.assign({ name: `${s}-markers`, zIndex: 600 }, o.omit(a, ["name"]))), o.find(l, { name: `${s}-shadows` }) || l.push(Object.assign({ name: `${s}-shadows`, zIndex: 500 }, o.omit(a, ["name"]))), o.has(t, "shadowPane") || (t.shadowPane = `${s}-shadows`), o.set(t, "style.point.pane", `${s}-markers`), o.set(t, "style.point.shadowPane", `${s}-shadows`)), t.panes = l, !o.has(t, "cluster") && o.get(this, "activityOptions.engine.cluster") && (t.cluster ? Object.assign(t.cluster, o.get(this, "activityOptions.engine.cluster")) : t.cluster = Object.assign({}, o.get(this, "activityOptions.engine.cluster"))), t.cluster && this.processClusterLayerOptions(e), t.realtime ? this.processRealtimeGeoJsonLayerOptions(e) : await this.processGeoJsonLayerOptions(e);
          const c = o.get(t, "template");
          c && (t.template = c.map((v) => ({
            property: v,
            compiler: o.template(o.get(t, v))
          })));
          const u = o.get(t, "popup.template");
          u && (t.popup.compiler = o.template(u));
          const d = o.get(t, "tooltip.template");
          d && (t.tooltip.compiler = o.template(d)), o.get(e, "variables", []).forEach((v) => {
            o.has(v, "chromajs") && (v.colorScale = Zn(o.get(v, "chromajs")));
          }), t.style ? (t.layerPointStyle = o.get(t.style, "point"), t.layerLineStyle = o.get(t.style, "line"), t.layerPolygonStyle = o.get(t.style, "polygon")) : (t.layerPointStyle = li(t), t.layerLineStyle = ci(t), t.layerPolygonStyle = ui(t));
          const h = this.getGeoJsonOptions(e);
          Object.keys(h).forEach((v) => {
            (!o.has(t, v) || v === "style") && o.set(t, v, o.get(h, v));
          });
          let g = this.createLeafletLayer(e);
          if (t.realtime) {
            if (t.tiled) {
              const v = !!o.get(t, "minZoom"), x = !!o.get(t, "maxZoom"), w = [];
              v || w.push("minZoom"), x || w.push("maxZoom");
              const M = new jw(o.omit(t, w));
              M.setup(this, e), g.tiledLayer = M, g.on("add", () => M.addTo(this.map)), g.on("remove", () => M.removeFrom(this.map));
            }
            g.on("update", (v) => this.onLayerUpdated(e, g, v)), g.update();
          } else
            t.cluster && t.container && (t.container.addLayer(g), g = t.container);
          return t.timeDimension && (g = this.createLeafletLayer(Object.assign({ type: "timeDimension.layer.geoJson", source: g }, t.timeDimension))), g;
        } catch (i) {
          return z.error(i), null;
        }
    },
    getGeoJsonOptions(e = {}) {
      return {
        onEachFeature: (i, n) => {
          Kr(n, ni.Feature), typeof this.onLeafletFeature == "function" && this.onLeafletFeature(i, n, e), n.getPopup() && n.unbindPopup();
          const r = this.generateStyle("popup", i, n, e);
          if (r) {
            const a = n.getPopup() && n.isPopupOpen();
            n.bindPopup(r), Dt(n.getPopup(), ni.Popup, this, e), a && n.openPopup();
          }
          n.getTooltip() && n.unbindTooltip();
          const s = this.generateStyle("tooltip", i, n, e, this.map.getZoom());
          if (s) {
            const a = n.getTooltip() && n.isTooltipOpen();
            n.bindTooltip(s), Dt(n.getTooltip(), ni.Tooltip, this, e), a && n.openTooltip();
          }
          Dt(n, ni.Feature, this, e);
        },
        style: (i) => {
          const n = an(i);
          if (!n) {
            z.warn(`[KDK] cannot get a style type from the feature of geometry type ${i.geometry.type}`);
            return;
          }
          return this.generateStyle(n, i, e, o.get(this, `activityOptions.engine.style.${n}`), this.map.getZoom());
        },
        pointToLayer: (i, n) => {
          const r = this.generateStyle("point", i, e, o.get(this, "activityOptions.engine.style.point"), this.map.getZoom());
          if (!r) {
            z.warn("[KDK] cannot generate point style from a feature");
            return;
          }
          return ua(n, r);
        }
      };
    },
    getUpdateAnimation(e, t, i, n) {
      const { duration: r, removeMissing: s, animate: a } = i, l = o.keys(a);
      l.forEach((u) => {
        o.defaultsDeep(a, {
          [u]: { easing: { function: "linear" }, bearing: !1 }
        });
      });
      const c = Ie(n);
      return c.forEach((u) => {
        const d = t.getLayer(t.options.getFeatureId(u)), f = d ? d.feature : null;
        if (f) {
          delete f.previousFeature, u.previousFeature = f;
          const h = u.previousFeature.geometry.coordinates[0], g = u.previousFeature.geometry.coordinates[1], v = u.geometry.coordinates[0], x = u.geometry.coordinates[1], w = kr([h, g]), M = kr([v, x]);
          Object.assign(u, {
            rhumbStart: w,
            rhumbEnd: M,
            rhumbBearing: Oc(w, M),
            rhumbDistance: Ac(w, M)
          });
        }
      }), (u) => {
        i.startTime || (i.startTime = u);
        const { id: d, startTime: f, fps: h } = i, g = u - f;
        if (h && i.lastTime) {
          const x = u - i.lastTime, w = 1e3 / h;
          if (x < w) {
            i.id = requestAnimationFrame(i.step);
            return;
          }
        }
        const v = Math.abs(g / (1e3 * r));
        if (v <= 1) {
          const x = [];
          c.forEach((w) => {
            if (!w.previousFeature) {
              x.push(w);
              return;
            }
            const M = w.geometry.coordinates[0], p = w.geometry.coordinates[1];
            let y = M, S = p;
            if (a.geometry) {
              const I = a.geometry.easing.function, A = a.geometry.easing.parameters || [], P = Hi[I](v, ...A);
              if (a.geometry.rhumb) {
                const D = Bc(w.rhumbStart, P * w.rhumbDistance, w.rhumbBearing);
                y = D.geometry.coordinates[0], S = D.geometry.coordinates[1];
              } else {
                const D = w.previousFeature.geometry.coordinates[0], F = w.previousFeature.geometry.coordinates[1];
                y = D + P * (M - D), S = F + P * (p - F);
              }
            }
            const C = {}, T = w.previousFeature.properties || {}, k = w.properties || {};
            l.forEach((I) => {
              if (I === "geometry") return;
              const A = a[I], P = A.easing.function, D = A.easing.parameters || [], F = Hi[P](v, ...D), O = T[I], $ = k[I];
              let X = O + F * ($ - O);
              if (A.bearing) {
                const te = ($ - O + 540) % 360 - 180;
                X = (O + F * te + 360) % 360;
              }
              C[I] = X;
            }), x.push({
              type: w.type,
              geometry: {
                type: w.geometry.type,
                coordinates: [y, S]
              },
              properties: Object.assign({}, k, C),
              style: w.style
            });
          }), t._onNewData(o.isNil(s) ? t.options.removeMissing : s, x), i.lastTime = u, i.id = requestAnimationFrame(i.step);
        } else
          delete i.id;
      };
    },
    updateLayer(e, t, i = {}) {
      let n = this.getLeafletLayerByName(e);
      if (!n) return;
      if (!o.get(n, "options.realtime")) {
        z.warn(`Impossible to update non-realtime layer ${e}`);
        return;
      }
      if (o.get(i, "replace", !1))
        this.updateLayer(e, t, { remove: !0 }), this.updateLayer(e, t, o.omit(i, ["replace"]));
      else {
        const s = typeof i == "boolean" ? i : i.remove, a = o.get(i, "removeMissing", n.options.removeMissing);
        let l;
        if (n instanceof B.MarkerClusterGroup && (l = n, n = l.getLayers().find((u) => u._container === l)), s) {
          if (typeof n.remove != "function") return;
          let u = Ie(t);
          u = u.filter((d) => n.getLayer(n.options.getFeatureId(d))), n.remove(u);
        } else if (t) {
          if (typeof n._onNewData == "function") {
            let u = o.get(i, "duration", 0);
            const d = Array.isArray(t) ? t : t.type === "FeatureCollection" ? t.features : [t];
            if (u && d.length === 0 && (u = 0), u && o.some(d, (f) => xm(f) !== "Point") && (z.warn(`Impossible to animate layer ${e} as it does not contain only point geometries`), u = 0), u) {
              o.defaultsDeep(i, {
                animate: {
                  geometry: { easing: { function: "linear" }, rhumb: !1 }
                }
              });
              const f = o.get(this.updateAnimations, `${e}.id`);
              o.isNil(f) || cancelAnimationFrame(f), i.step = this.getUpdateAnimation(e, n, i, t), i.id = requestAnimationFrame(i.step), o.set(this.updateAnimations, e, i);
            } else
              o.unset(this.updateAnimations, e), n._onNewData(a, t);
          }
        } else
          n.tiledLayer ? n.tiledLayer.redraw() : typeof n.update == "function" ? n.update() : typeof n._onNewData == "function" && n._onNewData(a, this.toGeoJson(e));
        const c = this.getLayerByName(e);
        if (At(c)) {
          const u = n.toGeoJSON(!1);
          this.geojsonCache[e] = u;
        }
      }
    },
    onLayerUpdated(e, t, i) {
      this.$emit("layer-updated", e, t, i), this.$engineEvents.emit("layer-updated", e, t, i);
    },
    onCurrentTimeChangedGeoJsonLayers(e) {
      o.values(this.layers).filter(Pe(xr.TimeUpdate)).forEach(async (i) => {
        const n = this.getLeafletLayerByName(i.name);
        (!n.lastUpdateTime || !this.shouldSkipFeaturesUpdate(n.lastUpdateTime, i)) && (n.lastUpdateTime = pe.getCurrentTime().clone(), n.tiledLayer ? n.tiledLayer.redraw() : n.update());
      });
    },
    onCurrentLevelChangedGeoJsonLayers(e) {
      let t = this.selectableLevelsLayer;
      t && o.get(t, `${this.engine}.type`) === "geoJson" && (t = this.getLeafletLayerByName(t.name), t.tiledLayer ? t.tiledLayer.redraw() : t.update());
    },
    onDefaultUnitChangedGeoJsonLayers(e) {
      o.forOwn(e.default, (t, i) => {
        const n = o.map(be.getUnits(i), "name");
        let r = o.values(this.layers).filter(Pe(xr.UnitUpdate));
        r = r.filter((s) => Vd(n, s)), r.forEach((s) => {
          s = this.getLeafletLayerByName(s.name), s.tiledLayer ? s.tiledLayer.redraw() : s.update();
        });
      });
    },
    onMapZoomChangedGeoJsonLayers() {
      o.values(this.layers).filter(Pe(xr.TooltipUpdate)).forEach(async (t) => {
        const i = this.getLeafletLayerByName(t.name), n = o.get(t, "leaflet.tooltip.minZoom"), r = o.get(t, "leaflet.tooltip.maxZoom"), s = this.map.getZoom();
        let a = !0;
        r && s > r && (a = !1), n && s < n && (a = !1), i.showTooltips !== a && (i.showTooltips = a, this.updateLayer(t.name, this.toGeoJson(t.name)));
      });
    },
    onLayerShownGeoJsonLayers(e, t) {
      const i = this.geojsonCache[e.name];
      if (i)
        if (At(e)) {
          if (t instanceof B.MarkerClusterGroup) {
            const n = t;
            t = n.getLayers().find((r) => r._container === n);
          }
          t._onNewData(!1, i);
        } else
          delete this.geojsonCache[e.name];
    },
    onLayerRemovedGeoJsonLayers(e) {
      o.has(this.geojsonCache, e.name) && delete this.geojsonCache[e.name];
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGeoJsonLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers), ne.on("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.on("zoomend", this.onMapZoomChangedGeoJsonLayers), this.$engineEvents.on("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.on("layer-removed", this.onLayerRemovedGeoJsonLayers), this.updateAnimations = {}, this.geojsonCache = {};
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers), ne.off("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.off("zoomend", this.onMapZoomChangedGeoJsonLayers), this.$engineEvents.off("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.off("layer-removed", this.onLayerRemovedGeoJsonLayers), this.geojsonCache = {};
  }
}, Gw = {
  methods: {
    async importFiles(e) {
      const t = await Pi.filter(e);
      for (let i = 0; i < t.length; i++) {
        const n = t[i];
        try {
          const r = await Pi.read(n), s = qt.basename(n.name, qt.extname(n.name)), a = o.join(o.map(n.files, (l) => l.name), ",");
          await this.addGeoJsonLayer({ name: s, description: a }, r);
        } catch {
        }
      }
    }
  },
  mounted() {
    this.$engineEvents.on("map-ready", () => {
      const e = this.map.getContainer(), t = document.createElement("input");
      t.setAttribute("id", "dropFileInput"), t.type = "file", t.style.display = "none", t.addEventListener("change", async (i) => {
        z.debug("[KDK] processing dropped files: ", i.target.files), await this.importFiles(i.target.files);
      }), e.appendChild(t), this.map._container.addEventListener("dragenter", () => this.map.scrollWheelZoom.disable(), !1), this.map._container.addEventListener("dragleave", () => this.map.scrollWheelZoom.enable(), !1), this.map._container.addEventListener("dragover", (i) => {
        i.stopPropagation(), i.preventDefault();
      }, !1), this.map._container.addEventListener("drop", async (i) => {
        z.debug("[KDK] processing dropped files: ", i.dataTransfer.files), i.stopPropagation(), i.preventDefault(), await this.importFiles(i.dataTransfer.files), this.map.scrollWheelZoom.enable();
      }, !1);
    });
  }
};
function lh(e, t, i) {
  if (i === void 0 && (i = {}), i.final === !0)
    return Kw(e, t);
  var n = rt(e), r = rt(t), s = Ze(n[0]), a = Ze(r[0]), l = Ze(n[1]), c = Ze(r[1]), u = Math.sin(a - s) * Math.cos(c), d = Math.cos(l) * Math.sin(c) - Math.sin(l) * Math.cos(c) * Math.cos(a - s);
  return Vr(Math.atan2(u, d));
}
function Kw(e, t) {
  var i = lh(t, e);
  return i = (i + 180) % 360, i;
}
const ac = ["pm:drawstart", "pm:drawend", "pm:create"], lc = ["layerremove", "pm:update", "pm:dragend", "pm:rotateend", "pm:markerdragend"], _n = "editHelpersPane", Hw = {
  emits: [
    "edit-start",
    "edit-stop",
    "edit-point-moved"
  ],
  data() {
    return {
      editingLayer: !1,
      allowedLayerEditModes: [],
      layerEditMode: ""
    };
  },
  watch: {
    async $route(e, t) {
      if (this.editedFeature) {
        if (o.get(e, "params.featureId"))
          this.editedPopup = this.editedFeature.getPopup(), this.editedPopup && this.editedFeature.unbindPopup(this.editedPopup);
        else if (o.get(t, "params.featureId")) {
          this.editedPopup && this.editedFeature.bindPopup(this.editedPopup);
          const i = this.editedLayer._id ? o.get(this.editedLayer, "service", "features") : "features-edition", n = await q.getService(i).get(this.editedFeature.feature._id);
          this.editableLayer.removeLayer(this.editedFeature), this.editableLayer.addData(n), this.editedPopup = null, this.editedFeature = null;
        }
      }
    }
  },
  methods: {
    isLayerEdited(e) {
      return this.editedLayer && this.editedLayer.name === e.name;
    },
    getGeoJsonEditOptions(e, t) {
      let i = e;
      const n = e.leaflet || e, r = {};
      r.layerPointStyle = n.style ? o.get(n.style, "point") : li(n), r.layerLineStyle = n.style ? o.get(n.style, "line") : ci(n), r.layerPolygonStyle = n.style ? o.get(n.style, "polygon") : ui(n), (o.has(i, "leaflet.tooltip") || o.has(i, "leaflet.popup")) && (i = Object.assign({}, e), i.leaflet.tooltip && delete i.leaflet.tooltip, i.leaflet.popup && delete i.leaflet.popup);
      const { onEachFeature: s, style: a, pointToLayer: l } = this.getGeoJsonOptions(i);
      return {
        // Ensure it is on top of all others layers while editing
        pane: "popupPane",
        // Allow geoman edition
        pmIgnore: !1,
        onEachFeature: s,
        // Use default styling when editing as dynamic styling can conflict
        style: (c) => {
          if (c.geometry.type === "LineString" || c.geometry.type === "MultiLineString")
            return !o.isEmpty(t) && !t.includes("LineString") && !t.includes("MultiLineString") ? a(c) : ga(c, r, o.get(this, "activityOptions.engine.style.edition.line"));
          if (c.geometry.type === "Polygon" || c.geometry.type === "MultiPolygon")
            return !o.isEmpty(t) && !t.includes("Polygon") && !t.includes("MultiPolygon") ? a(c) : pa(c, r, o.get(this, "activityOptions.engine.style.edition.polygon"));
          logger.warn(`[KDK] the geometry of type of ${c.geometry.type} is not supported`);
        },
        pointToLayer: (c, u) => {
          if (!o.isEmpty(t) && !t.includes("Point") && !t.includes("MultiPoint")) return l(c, layer);
          const d = ma(c, r, o.get(this, "activityOptions.engine.style.edition.point"));
          return d.options = { pmIgnore: !1 }, ua(u, d);
        }
      };
    },
    setEditMode(e) {
      this.editableLayer && (this.map.pm.globalDrawModeEnabled() && this.map.pm.disableDraw(), this.map.pm.globalEditModeEnabled() && this.map.pm.disableGlobalEditMode(), this.map.pm.globalDragModeEnabled() && this.map.pm.disableGlobalDragMode(), this.map.pm.globalRemovalModeEnabled() && this.map.pm.disableGlobalRemovalMode(), this.map.pm.globalRotateModeEnabled() && this.map.pm.disableGlobalRotateMode(), this.map.pm.setGlobalOptions({
        layerGroup: this.map,
        // Ensure it is on top of all others layers while editing
        panes: {
          layerPane: _n,
          vertexPane: _n,
          markerPane: _n
        }
      }), this.allowedLayerEditModes.indexOf(e) !== -1 && (e === "edit-properties" || (e === "edit-geometry" ? this.map.pm.enableGlobalEditMode() : e === "drag" ? this.map.pm.enableGlobalDragMode() : e === "rotate" ? this.map.pm.enableGlobalRotateMode() : e === "remove" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableGlobalRemovalMode()) : e === "add-polygons" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Polygon", { continueDrawing: !0 })) : e === "add-rectangles" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Rectangle", { continueDrawing: !0 })) : e === "add-lines" ? (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Line", { continueDrawing: !0 })) : e === "add-points" && (this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer }), this.map.pm.enableDraw("Marker", { continueDrawing: !0 }))), this.layerEditMode = e));
    },
    async startEditLayer(e, {
      features: t = [],
      // Target features to be edited, otherwise the whole layer will be
      geometryTypes: i = [],
      // Target geometry types to be edited, otherwise the whole layer will be
      allowedEditModes: n = null,
      editMode: r = null,
      zIndex: s = -1,
      callback: a = null
      // Callback function to be called once edition is started/ended
    } = {}) {
      this.editedLayer && await this.stopEditLayer("accept");
      const l = this.getLeafletLayerByName(e.name);
      if (!l) return;
      this.allowedLayerEditModes = n || [
        "edit-properties",
        "edit-geometry",
        "drag",
        "rotate",
        "remove",
        "add-polygons",
        "add-rectangles",
        "add-lines",
        "add-points"
      ], this.editedLayer = e, this.editingLayer = !0, this.editingCallback = a, typeof this.setHighlightsEnabled == "function" && this.setHighlightsEnabled(e, !1), typeof this.setSelectionEnabled == "function" && this.setSelectionEnabled(!1), this.onEditStart(this.editedLayer);
      const c = l.toGeoJSON();
      let u = Ie(c);
      if (o.isEmpty(t) && o.isEmpty(i) ? l.clearLayers() : o.isEmpty(t) ? o.isEmpty(i) || (u = u.filter((f) => i.includes(o.get(f, "geometry.type"))), l.getLayers().forEach((f) => {
        const h = f.feature;
        i.includes(o.get(h, "geometry.type")) && l.removeLayer(f);
      })) : (u = u.filter((f) => t.includes(st(f, e))), l.getLayers().forEach((f) => {
        const h = f.feature;
        t.includes(st(h, f)) && l.removeLayer(f);
      })), this.editedLayer._id === void 0)
        for (const f of u)
          f._id = Gt().toString(), await q.getService("features-edition").create(f);
      else
        this.editedLayerServiceEventListeners = Qn(this.editedLayer, {
          created: this.onEditedFeaturesCreated,
          updated: this.onEditedFeaturesUpdated,
          patched: this.onEditedFeaturesUpdated,
          removed: this.onEditedFeaturesRemoved
        });
      this.editableLayer = B.geoJson(u, this.getGeoJsonEditOptions(e, i)), this.map.addLayer(this.editableLayer), Dt(this.map, ac, this), Dt(this.editableLayer, lc, this), this.$engineEvents.on("click", this.onEditFeatureProperties), this.$engineEvents.on("mousemove", this.onMouseMoveWhileEditing), this.$engineEvents.on("zoomend", this.onMapZoomWhileEditing), this.$engineEvents.on("pm:drawstart", this.onDrawStart), this.$engineEvents.on("pm:drawend", this.onDrawEnd), this.$engineEvents.on("pm:create", this.onCreateFeatures), this.$engineEvents.on("pm:update", this.onEditFeatures), this.$engineEvents.on("pm:dragend", this.onEditFeatures), this.$engineEvents.on("pm:rotateend", this.onEditFeatures), this.$engineEvents.on("layerremove", this.onRemoveFeatures), this.$engineEvents.on("pm:markerdragend", this.onPointMoveEnd);
      let d = this.map.getPane(_n);
      d || (d = this.map.createPane(_n)), o.set(d, "style.zIndex", s !== -1 ? s : 700), r && this.setEditMode(r);
    },
    onEditStart(e) {
      this.$emit("edit-start", { layer: e }), this.$engineEvents.emit("edit-start", { layer: e }), this.editingCallback && this.editingCallback({ status: "edit-start", layer: e });
    },
    async stopEditLayer(e = "accept") {
      if (!this.editedLayer) return;
      const t = this.getLeafletLayerByName(this.editedLayer.name);
      if (t) {
        if (this.map.pm.globalDrawModeEnabled() && this.map.pm.disableDraw(), this.map.pm.globalEditModeEnabled() && this.map.pm.disableGlobalEditMode(), this.map.pm.globalDragModeEnabled() && this.map.pm.disableGlobalDragMode(), this.map.pm.globalRemovalModeEnabled() && this.map.pm.disableGlobalRemovalMode(), this.map.pm.globalRotateModeEnabled() && this.map.pm.disableGlobalRotateMode(), this.map.pm.setGlobalOptions({ layerGroup: this.map }), Kr(this.map, ac), Kr(this.editableLayer, lc), this.pendingOperations.length > 0) {
          const i = this.pendingOperations.flat();
          await Promise.all(i);
        }
        if (this.editedLayer._id === void 0) {
          const i = this.editableLayer.toGeoJSON(), n = Ie(i), r = q.getService("features-edition");
          await Promise.all(n.map((s) => r.remove(s._id)));
        } else
          ln(this.editedLayer, this.editedLayerServiceEventListeners);
        this.map.removeLayer(this.editableLayer), t.addLayer(this.editableLayer), typeof this.setHighlightsEnabled == "function" && this.setHighlightsEnabled(this.editedLayer, !0), typeof this.setSelectionEnabled == "function" && this.setSelectionEnabled(!0), this.onEditStop(e, this.editedLayer), this.editedLayer = null, this.editingLayer = !1, this.editingCallback = null, this.$engineEvents.off("click", this.onEditFeatureProperties), this.$engineEvents.off("mousemove", this.onMouseMoveWhileEditing), this.$engineEvents.off("zoomend", this.onMapZoomWhileEditing), this.$engineEvents.off("pm:drawstart", this.onDrawStart), this.$engineEvents.off("pm:drawend", this.onDrawEnd), this.$engineEvents.off("pm:create", this.onCreateFeatures), this.$engineEvents.off("pm:update", this.onEditFeatures), this.$engineEvents.off("pm:dragend", this.onEditFeatures), this.$engineEvents.off("pm:rotateend", this.onEditFeatures), this.$engineEvents.off("layerremove", this.onRemoveFeatures), this.$engineEvents.off("pm:markerdragend", this.onPointMoveEnd);
      }
    },
    onEditStop(e, t) {
      this.$emit("edit-stop", { status: e, layer: t }), this.$engineEvents.emit("edit-stop", { status: e, layer: t }), this.editingCallback && this.editingCallback({ status: e, layer: t });
    },
    resetEditionTooltip() {
      this.hintTooltip && (this.hintTooltipInitialContent = this.hintTooltip.getContent());
    },
    updateEditionTooltip(e) {
      if (!this.hintTooltip) return;
      const { latlng: t } = e;
      if (o.isNil(t)) return;
      let i = this.hintTooltipInitialContent;
      const n = ["add-polygons", "add-rectangles", "add-lines", "add-points"], r = ["add-polygons", "add-lines"];
      if (n.includes(this.layerEditMode) && (i += `<br/>${Ss(t.lat, t.lng, V.get("locationFormat", "FFf"))}`), r.includes(this.layerEditMode) && this.workingLayer) {
        const s = ft(this.workingLayer.toGeoJSON());
        if (s.length > 0) {
          const a = lh(s[s.length - 1], [t.lng, t.lat]);
          i += `<br/>${be.format(a, "deg", be.getDefaultUnit("angle"))}`;
        }
      }
      this.hintTooltip.setContent(i);
    },
    onDrawStart(e) {
      this.hintMarker = o.get(this.map.pm, `${e.source}.${e.shape}._hintMarker`), this.hintMarker && (this.hintTooltip = this.hintMarker.getTooltip(), this.hintTooltip && (e.workingLayer && (this.workingLayer = e.workingLayer, this.workingLayer.on("pm:vertexadded", this.onVertexAddedWhileEditing)), this.resetEditionTooltip()));
    },
    onDrawEnd(e) {
      this.hintTooltip && this.workingLayer && this.workingLayer.off("pm:vertexadded", this.onVertexAddedWhileEditing), this.hintMarker = null, this.hintTooltip = null;
    },
    onMouseMoveWhileEditing(e, t) {
      this.updateEditionTooltip(t);
    },
    onVertexAddedWhileEditing(e) {
      this.resetEditionTooltip();
    },
    async onEditFeatureProperties(e, t) {
      const i = t && t.target, n = o.get(i, "feature");
      this.layerEditMode !== "edit-properties" || !this.isLayerEdited(e) || !o.get(e, "schema.content") || !i || !n || (this.editedFeature = i, this.$router.push({
        name: "edit-map-layer-feature",
        query: this.$route.query,
        params: Object.assign(this.$route.params, {
          layerId: this.editedLayer._id,
          layerName: this.editedLayer.name,
          featureId: n._id,
          contextId: V.get("context")
        })
      }));
    },
    async onCreateFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "add-polygons" && this.layerEditMode !== "add-rectangles" && this.layerEditMode !== "add-lines" && this.layerEditMode !== "add-points" || !t) return;
      let i = t.toGeoJSON();
      if (this.createdFeature && this.createdFeature._id === i._id) return;
      const n = Gt().toString();
      let r = o.get(this.editedLayer, "featureId");
      r = r && r !== "_id" ? "properties." + r : "_id", o.set(i, r, n), this.editedLayer._id ? i = await this.createFeatures(i, this.editedLayer) : (i._id = n, await q.getService("features-edition").create(i)), this.editableLayer.removeLayer(t), this.editableLayer.addData(i);
    },
    async onEditFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "edit-geometry" && this.layerEditMode !== "drag" && this.layerEditMode !== "rotate" || !t) return;
      const i = t.toGeoJSON();
      if (!(this.updatedFeature && this.updatedFeature._id === i._id))
        if (this.editedLayer._id)
          await this.editFeaturesGeometry(i, this.editedLayer);
        else {
          const n = Ie(i), r = q.getService("features-edition"), s = Promise.all(n.map((l) => r.patch(l._id, { geometry: l.geometry })));
          this.pendingOperations.push(s), await s;
          const a = this.pendingOperations.indexOf(s);
          this.pendingOperations.splice(a, 1);
        }
    },
    async onRemoveFeatures(e) {
      const t = e && e.layer;
      if (this.layerEditMode !== "remove" || !t || !e.target || e.target !== this.editableLayer) return;
      const i = t.toGeoJSON();
      if (!(this.removedFeature && this.removedFeature._id === i._id))
        if (this.editedLayer._id)
          await this.removeFeatures(i, this.editedLayer);
        else {
          const n = Ie(i), r = q.getService("features-edition");
          await Promise.all(n.map((s) => r.remove(s._id)));
        }
    },
    onMapZoomWhileEditing(e) {
      this.editableLayer && this.editableLayer.bringToFront();
    },
    onPointMoveEnd(e) {
      if (typeof e.layer.getLatLngs != "function") return;
      let t = e.layer.getLatLngs();
      for (let r = 0; r < e.indexPath.length; ++r)
        t = t[e.indexPath[r]];
      const i = this.editableLayer.pm._layers.findIndex((r) => r._leaflet_id === e.layer._leaflet_id), n = e.indexPath.slice(0, e.indexPath.length);
      n.splice(0, 0, i), this.onEditPointMoved(n, t, "user");
    },
    moveEditPoint(e, t, i, n) {
      if (!this.editingLayer) return;
      const r = B.latLng(t, i), s = e[0], a = e.slice(1, e.length), l = this.editableLayer.pm._layers[s], c = l.getLatLngs(), u = a.slice(0, a.length - 1), d = a[a.length - 1];
      let f = c;
      for (const g of u)
        f = f[g];
      f[d] = r, l.setLatLngs(c);
      let h = l.pm._markers;
      for (const g of a)
        h = h[g];
      h.setLatLng(r), this.onEditPointMoved(e, r, n || "app");
    },
    onEditPointMoved(e, t, i) {
      const n = {
        layer: this.editedLayer,
        pointPath: e,
        latitude: t.lat,
        longitude: t.lng,
        origin: i
      };
      this.$emit("edit-point-moved", n), this.$engineEvents.emit("edit-point-moved", n);
    },
    onEditedFeaturesCreated(e, t) {
      !Si(e) || !ri(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.createdFeature = e, this.editableLayer.addData(e), this.createdFeature = null));
    },
    onEditedFeaturesUpdated(e, t) {
      !Si(e) || !ri(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.updatedFeature = e, this.editableLayer.eachLayer((i) => {
        o.get(i, "feature._id") === e._id && (this.editableLayer.removeLayer(i), this.editableLayer.addData(e));
      }), this.updatedFeature = null));
    },
    onEditedFeaturesRemoved(e, t) {
      !Si(e) || !ri(e) || (!t && e.layer && (t = this.getLayerById(e.layer)), !(!t || !this.isLayerEdited(t)) && (this.removedFeature = e, this.editableLayer.eachLayer((i) => {
        o.get(i, "feature._id") === e._id && this.editableLayer.removeLayer(i);
      }), this.removedFeature = null));
    }
  },
  created() {
    this.pendingOperations = [];
  }
}, Ww = {
  created() {
    this.registerStyle("point", ma), this.registerStyle("line", ga), this.registerStyle("polygon", pa);
  }
}, Zw = {
  methods: {
    getDefaultTooltip(e, t, i, n) {
      const r = e.properties;
      let s;
      if (r) {
        const a = i.leaflet || i;
        if (o.has(a, "tooltip") && !o.get(a, "tooltip") || o.has(r, "tooltip") && !o.get(r, "tooltip")) return;
        const l = Object.assign(
          {},
          o.get(this, "activityOptions.engine.tooltip"),
          a.tooltip,
          r.tooltip
        ), c = o.get(a, "tooltip.minZoom"), u = o.get(a, "tooltip.maxZoom");
        if (u && n > u || c && n < c) return;
        let d = l.html;
        if (!d) {
          if (l.property)
            d = o.has(r, l.property) ? o.get(r, l.property) : o.get(e, l.property), d && typeof d.toString == "function" && (d = d.toString());
          else if (l.template) {
            const f = l.compiler;
            d = f({ properties: r, feature: e, $t: this.$t, Units: be, Time: pe, moment: fe });
          }
        }
        d && (s = B.tooltip(l.options || { permanent: !1 }, t), s.setContent(d));
      }
      return s;
    }
  },
  created() {
    this.registerStyle("tooltip", this.getDefaultTooltip);
  }
}, Jw = {
  methods: {
    getDefaultPopup(e, t, i) {
      let n = e.properties, r;
      if (n) {
        const s = i.leaflet || i;
        if (o.has(s, "popup") && !o.get(s, "popup") || o.has(n, "popup") && !o.get(n, "popup")) return;
        const a = Object.assign(
          {},
          o.get(this, "activityOptions.engine.popup"),
          s.popup,
          n.popup
        );
        let l = a.html;
        if (!l)
          if (a.template) {
            const c = a.compiler;
            l = c({ properties: n, feature: e, $t: this.$t, Units: be, Time: pe, moment: fe });
          } else a.pick ? n = o.pick(n, a.pick) : a.omit && (n = o.omit(n, a.omit));
        if (l || (l = Ud(n)), !l) return null;
        a.options ? r = B.popup(a.options, t) : r = B.popup({
          maxHeight: 400,
          maxWidth: 400,
          autoPan: !1
        }, t), r.setContent(l);
      }
      return r;
    }
  },
  created() {
    this.registerStyle("popup", this.getDefaultPopup);
  }
}, Qw = {
  methods: {
    async initializeMap(e) {
      this.map || (this.setupMap(e), await this.initialize(), this.map.on("moveend", this.storeView));
    },
    finalizeMap() {
      this.map.off("moveend", this.storeView);
    },
    storeView() {
      typeof this.storeContext == "function" && (o.get(this.centerAnimation, "id") || this.storeContext("view"));
    },
    onMapResized(e) {
      this.observe && (this.refreshMap(), this.mapContainer && (this.engineContainerWidth = this.mapContainer.getBoundingClientRect().width, this.engineContainerHeight = this.mapContainer.getBoundingClientRect().height));
    }
  },
  created() {
    this.engine = "leaflet", this.observe = !0;
  },
  beforeUnmount() {
    this.observe = !1, this.finalizeMap();
  }
};
var cc = {};
const ch = /* @__PURE__ */ new WeakMap(), yo = /* @__PURE__ */ new WeakMap();
function ke(e) {
  const t = ch.get(e);
  return console.assert(
    t != null,
    "'this' is expected an Event object, but got",
    e
  ), t;
}
function uc(e) {
  if (e.passiveListener != null) {
    typeof console < "u" && typeof console.error == "function" && console.error(
      "Unable to preventDefault inside passive event listener invocation.",
      e.passiveListener
    );
    return;
  }
  e.event.cancelable && (e.canceled = !0, typeof e.event.preventDefault == "function" && e.event.preventDefault());
}
function tn(e, t) {
  ch.set(this, {
    eventTarget: e,
    event: t,
    eventPhase: 2,
    currentTarget: e,
    canceled: !1,
    stopped: !1,
    immediateStopped: !1,
    passiveListener: null,
    timeStamp: t.timeStamp || Date.now()
  }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
  const i = Object.keys(t);
  for (let n = 0; n < i.length; ++n) {
    const r = i[n];
    r in this || Object.defineProperty(this, r, uh(r));
  }
}
tn.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return ke(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return ke(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return ke(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const e = ke(this).currentTarget;
    return e == null ? [] : [e];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return ke(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const e = ke(this);
    e.stopped = !0, typeof e.event.stopPropagation == "function" && e.event.stopPropagation();
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const e = ke(this);
    e.stopped = !0, e.immediateStopped = !0, typeof e.event.stopImmediatePropagation == "function" && e.event.stopImmediatePropagation();
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return !!ke(this).event.bubbles;
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return !!ke(this).event.cancelable;
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    uc(ke(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return ke(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return !!ke(this).event.composed;
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return ke(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return ke(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return ke(this).stopped;
  },
  set cancelBubble(e) {
    if (!e)
      return;
    const t = ke(this);
    t.stopped = !0, typeof t.event.cancelBubble == "boolean" && (t.event.cancelBubble = !0);
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !ke(this).canceled;
  },
  set returnValue(e) {
    e || uc(ke(this));
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
  }
};
Object.defineProperty(tn.prototype, "constructor", {
  value: tn,
  configurable: !0,
  writable: !0
});
typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(tn.prototype, window.Event.prototype), yo.set(window.Event.prototype, tn));
function uh(e) {
  return {
    get() {
      return ke(this).event[e];
    },
    set(t) {
      ke(this).event[e] = t;
    },
    configurable: !0,
    enumerable: !0
  };
}
function Yw(e) {
  return {
    value() {
      const t = ke(this).event;
      return t[e].apply(t, arguments);
    },
    configurable: !0,
    enumerable: !0
  };
}
function Xw(e, t) {
  const i = Object.keys(t);
  if (i.length === 0)
    return e;
  function n(r, s) {
    e.call(this, r, s);
  }
  n.prototype = Object.create(e.prototype, {
    constructor: { value: n, configurable: !0, writable: !0 }
  });
  for (let r = 0; r < i.length; ++r) {
    const s = i[r];
    if (!(s in e.prototype)) {
      const l = typeof Object.getOwnPropertyDescriptor(t, s).value == "function";
      Object.defineProperty(
        n.prototype,
        s,
        l ? Yw(s) : uh(s)
      );
    }
  }
  return n;
}
function dh(e) {
  if (e == null || e === Object.prototype)
    return tn;
  let t = yo.get(e);
  return t == null && (t = Xw(dh(Object.getPrototypeOf(e)), e), yo.set(e, t)), t;
}
function e_(e, t) {
  const i = dh(Object.getPrototypeOf(t));
  return new i(e, t);
}
function t_(e) {
  return ke(e).immediateStopped;
}
function i_(e, t) {
  ke(e).eventPhase = t;
}
function n_(e, t) {
  ke(e).currentTarget = t;
}
function dc(e, t) {
  ke(e).passiveListener = t;
}
const fh = /* @__PURE__ */ new WeakMap(), fc = 1, hc = 2, Tr = 3;
function Pr(e) {
  return e !== null && typeof e == "object";
}
function Mn(e) {
  const t = fh.get(e);
  if (t == null)
    throw new TypeError(
      "'this' is expected an EventTarget object, but got another value."
    );
  return t;
}
function r_(e) {
  return {
    get() {
      let i = Mn(this).get(e);
      for (; i != null; ) {
        if (i.listenerType === Tr)
          return i.listener;
        i = i.next;
      }
      return null;
    },
    set(t) {
      typeof t != "function" && !Pr(t) && (t = null);
      const i = Mn(this);
      let n = null, r = i.get(e);
      for (; r != null; )
        r.listenerType === Tr ? n !== null ? n.next = r.next : r.next !== null ? i.set(e, r.next) : i.delete(e) : n = r, r = r.next;
      if (t !== null) {
        const s = {
          listener: t,
          listenerType: Tr,
          passive: !1,
          once: !1,
          next: null
        };
        n === null ? i.set(e, s) : n.next = s;
      }
    },
    configurable: !0,
    enumerable: !0
  };
}
function hh(e, t) {
  Object.defineProperty(
    e,
    `on${t}`,
    r_(t)
  );
}
function mc(e) {
  function t() {
    Jt.call(this);
  }
  t.prototype = Object.create(Jt.prototype, {
    constructor: {
      value: t,
      configurable: !0,
      writable: !0
    }
  });
  for (let i = 0; i < e.length; ++i)
    hh(t.prototype, e[i]);
  return t;
}
function Jt() {
  if (this instanceof Jt) {
    fh.set(this, /* @__PURE__ */ new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0]))
    return mc(arguments[0]);
  if (arguments.length > 0) {
    const e = new Array(arguments.length);
    for (let t = 0; t < arguments.length; ++t)
      e[t] = arguments[t];
    return mc(e);
  }
  throw new TypeError("Cannot call a class as a function");
}
Jt.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(e, t, i) {
    if (t == null)
      return;
    if (typeof t != "function" && !Pr(t))
      throw new TypeError("'listener' should be a function or an object.");
    const n = Mn(this), r = Pr(i), a = (r ? !!i.capture : !!i) ? fc : hc, l = {
      listener: t,
      listenerType: a,
      passive: r && !!i.passive,
      once: r && !!i.once,
      next: null
    };
    let c = n.get(e);
    if (c === void 0) {
      n.set(e, l);
      return;
    }
    let u = null;
    for (; c != null; ) {
      if (c.listener === t && c.listenerType === a)
        return;
      u = c, c = c.next;
    }
    u.next = l;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(e, t, i) {
    if (t == null)
      return;
    const n = Mn(this), s = (Pr(i) ? !!i.capture : !!i) ? fc : hc;
    let a = null, l = n.get(e);
    for (; l != null; ) {
      if (l.listener === t && l.listenerType === s) {
        a !== null ? a.next = l.next : l.next !== null ? n.set(e, l.next) : n.delete(e);
        return;
      }
      a = l, l = l.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(e) {
    if (e == null || typeof e.type != "string")
      throw new TypeError('"event.type" should be a string.');
    const t = Mn(this), i = e.type;
    let n = t.get(i);
    if (n == null)
      return !0;
    const r = e_(this, e);
    let s = null;
    for (; n != null; ) {
      if (n.once ? s !== null ? s.next = n.next : n.next !== null ? t.set(i, n.next) : t.delete(i) : s = n, dc(
        r,
        n.passive ? n.listener : null
      ), typeof n.listener == "function")
        try {
          n.listener.call(this, r);
        } catch (a) {
          typeof console < "u" && typeof console.error == "function" && console.error(a);
        }
      else n.listenerType !== Tr && typeof n.listener.handleEvent == "function" && n.listener.handleEvent(r);
      if (t_(r))
        break;
      n = n.next;
    }
    return dc(r, null), i_(r, 0), n_(r, null), !r.defaultPrevented;
  }
};
Object.defineProperty(Jt.prototype, "constructor", {
  value: Jt,
  configurable: !0,
  writable: !0
});
typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(Jt.prototype, window.EventTarget.prototype);
class Xn extends Jt {
  /**
   * AbortSignal cannot be constructed directly.
   */
  constructor() {
    throw super(), new TypeError("AbortSignal cannot be constructed directly");
  }
  /**
   * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
   */
  get aborted() {
    const t = es.get(this);
    if (typeof t != "boolean")
      throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
    return t;
  }
}
hh(Xn.prototype, "abort");
function s_() {
  const e = Object.create(Xn.prototype);
  return Jt.call(e), es.set(e, !1), e;
}
function o_(e) {
  es.get(e) === !1 && (es.set(e, !0), e.dispatchEvent({ type: "abort" }));
}
const es = /* @__PURE__ */ new WeakMap();
Object.defineProperties(Xn.prototype, {
  aborted: { enumerable: !0 }
});
typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Xn.prototype, Symbol.toStringTag, {
  configurable: !0,
  value: "AbortSignal"
});
let ts = class {
  /**
   * Initialize this controller.
   */
  constructor() {
    mh.set(this, s_());
  }
  /**
   * Returns the `AbortSignal` object associated with this object.
   */
  get signal() {
    return gc(this);
  }
  /**
   * Abort and signal to any observers that the associated activity is to be aborted.
   */
  abort() {
    o_(gc(this));
  }
};
const mh = /* @__PURE__ */ new WeakMap();
function gc(e) {
  const t = mh.get(e);
  if (t == null)
    throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${e === null ? "null" : typeof e}`);
  return t;
}
Object.defineProperties(ts.prototype, {
  signal: { enumerable: !0 },
  abort: { enumerable: !0 }
});
typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ts.prototype, Symbol.toStringTag, {
  configurable: !0,
  value: "AbortController"
});
const a_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortController: ts,
  AbortSignal: Xn,
  default: ts
}, Symbol.toStringTag, { value: "Module" })), l_ = /* @__PURE__ */ Pb(a_);
var pc;
function c_() {
  if (pc) return cc;
  pc = 1;
  const e = l_, t = typeof self < "u" ? self : typeof window < "u" ? window : typeof Al < "u" ? Al : (
    /* otherwise */
    void 0
  );
  return t && (typeof t.AbortController > "u" && (t.AbortController = e.AbortController), typeof t.AbortSignal > "u" && (t.AbortSignal = e.AbortSignal)), cc;
}
c_();
Te.settings.PREFER_ENV = Te.ENV.WEBGL2;
Te.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
(function() {
  const e = new Float32Array(1), t = new Int32Array(e.buffer);
  return function(n) {
    e[0] = n;
    const r = t[0];
    let s = r >> 16 & 32768, a = r >> 12 & 2047;
    const l = r >> 23 & 255;
    return l < 103 ? s : l > 142 ? (s |= 31744, s |= (l === 255 ? 0 : 1) && r & 8388607, s) : l < 113 ? (a |= 2048, s |= (a >> 114 - l) + (a >> 113 - l & 1), s) : (s |= l - 112 << 10 | a >> 1, s += a & 1, s);
  };
})();
const Zs = {
  latLonToWebMercator: `vec2 latLonToWebMercator(vec3 latLonZoom) {
  const float d = 3.14159265359 / 180.0;
  const float maxLat = 85.0511287798;     // max lat using Web Mercator, used by EPSG:3857 CRS
  const float R = 6378137.0;              // earth radius

  // project
  // float lat = max(min(maxLat, latLonZoom[0]), -maxLat);
  float lat = clamp(latLonZoom[0], -maxLat, maxLat);
  float sla = sin(lat * d);
  vec2 point = vec2(R * latLonZoom[1] * d, R * log((1.0 + sla) / (1.0 - sla)) / 2.0);

  // scale
  float scale = 256.0 * pow(2.0, latLonZoom[2]);

  // transform
  const float s = 0.5 / (3.14159265359 * R);
  const vec4 abcd = vec4(s, 0.5, -s, 0.5);

  return scale * ((point * abcd.xz) + abcd.yw);
}`,
  unpack2: `vec2 unpack2(vec2 v, vec4 offsetScale) {
  return offsetScale.xy + v * offsetScale.zw;
}`,
  rgbFromFloat: `vec4 rgbFromFloat(float v) {
  const uint mask = uint(0xFF);
  uint asuint = floatBitsToUint(v);
  return vec4(asuint & mask, (asuint >> 8) & mask, (asuint >> 16) & mask, (asuint >> 24) & mask) / vec4(255.0);
}`
};
Te.TYPES.HALF_FLOAT_VERTEX = 5131;
function yc(e) {
  let t = `#version 300 es
precision highp float;`, i = `#version 300 es
precision highp float;`;
  t += `

/// attributes, uniforms and varyings
`, i += `

/// uniforms and varyings
out vec4 outColor;
`;
  for (const n of e) {
    let r = "", s = "";
    for (const a of o.get(n, "vertex.attributes", [])) r += `in ${a};
`;
    for (const a of o.get(n, "vertex.uniforms", [])) r += `uniform ${a};
`;
    for (const a of o.get(n, "fragment.uniforms", [])) s += `uniform ${a};
`;
    for (const a of o.get(n, "varyings", []))
      r += `out ${a};
`, s += `in ${a};
`;
    r && (t += `// ${n.name} ------
${r}`), s && (i += `// ${n.name} ------
${s}`);
  }
  t += `
/// additional functions
`, i += `
/// additional functions
`;
  for (const n of e) {
    for (const r of o.get(n, "vertex.functions", [])) t += `// ${n.name} ------
${r}
`;
    for (const r of o.get(n, "fragment.functions", [])) i += `// ${n.name} ------
${r}
`;
  }
  t += `
/// vertex shader code
void main()
{
`, i += `
/// fragment shader code
void main()
{
`;
  for (const n of e) {
    const r = o.get(n, "vertex.code"), s = o.get(n, "fragment.code");
    r && (t += `// ${n.name} ------
${r}
`), s && (i += `// ${n.name} ------
${s}
`);
  }
  return t += "}", i += "}", [t, i];
}
function gh(e, t, i) {
  for (let r = 1; r < e.length; ++r)
    if (e[r - 1] > e[r])
      throw new Error("Threshold array is not correctly sorted, color map shader code will be buggy!");
  let n = `vec4 ColorMap(float value) {
`;
  for (let r = 0; r < t.length; ++r)
    n += `  const vec4 color${r} = vec4(${t[r].join(",")});
`;
  if (n += `
`, i) {
    n += `  if (value < float(${e[0]})) { return color0; }
`;
    for (let r = 1; r < e.length; ++r) {
      const s = e[r - 1], a = e[r], l = a - s;
      n += `  if (value <= float(${a})) { float t = (value - float(${s})) / float(${l}); return mix(color${r - 1}, color${r}, t); }
`;
    }
    n += `  return color${t.length - 1};
`;
  } else {
    for (let r = 1; r < e.length - 1; ++r) {
      const s = e[r];
      n += `  if (value < float(${s})) { return color${r - 1}; }
`;
    }
    n += `  return color${t.length - 1};
`;
  }
  return n += "}", n;
}
function u_(e, t, i = !1) {
  let n = [], r = t.slice();
  if (e.length === t.length)
    n = e.slice();
  else if (e.length < t.length) {
    const s = (e[e.length - 1] - e[0]) / (t.length - 1);
    for (let a = 0; a < t.length; ++a)
      n.push(e[0] + a * s);
  }
  return n[0] > n[n.length - 1] && (n = n.reverse(), i = !i), i && (r = r.reverse()), gh(n, r, !0);
}
function d_(e, t, i) {
  let n = e.slice(), r = t.slice();
  return n[0] > n[n.length - 1] && (n = n.reverse(), i = !i), i && (r = r.reverse()), gh(n, r, !1);
}
const Js = B.GridLayer.extend({
  initialize(e, t) {
    this.conf = {}, this.conf.chromajs = e.chromajs, this.conf.render = {
      cutOver: e.cutOver,
      cutUnder: e.cutUnder,
      pixelColorMapping: e.pixelColorMapping,
      showWireframe: e.showWireframe,
      enableCulling: o.get(e, "enableCulling", !0)
    }, this.conf.debug = {
      showTileInfos: e.showTileInfos,
      meshAsPoints: e.meshAsPoints,
      showShader: e.showShader
    }, this.conf.resolutionScale = o.get(e, "resolutionScale", [1, 1]), B.GridLayer.prototype.initialize.call(this, e), this.pixiRoot = new Te.Container(), this.pixiLayer = B.pixiOverlay(
      (i) => this.renderPixiLayer(i),
      this.pixiRoot,
      { destroyInteractionManager: !0, shouldRedrawOnMove: function() {
        return !0;
      } }
    ), this.layerUniforms = new Te.UniformGroup({ in_layerAlpha: e.opacity, in_zoomLevel: 1 }), this.pixiState = new Te.State(), this.pixiState.culling = this.conf.render.enableCulling, this.pixiState.blendMode = Te.BLEND_MODES.SCREEN, this.cutValueUniform = null, e.cutOver && (this.layerUniforms.uniforms.in_cutOver = 0, e.cutOver === "levels" ? this.cutValueUniform = "in_cutOver" : this.layerUniforms.uniforms.in_cutOver = e.cutOver), e.cutUnder && (this.layerUniforms.uniforms.in_cutUnder = 0, e.cutUnder === "levels" ? this.cutValueUniform = "in_cutUnder" : this.layerUniforms.uniforms.in_cutUnder = e.cutUnder), this.on("tileload", (i) => {
      this.onTileLoad(i);
    }), this.on("tileunload", (i) => {
      this.onTileUnload(i);
    }), this.gridSource = t, this.onDataChangedCallback = this.onDataChanged.bind(this), this.gridSource.on("data-changed", this.onDataChangedCallback);
  },
  onAdd(e) {
    e.addLayer(this.pixiLayer), this.layerUniforms.uniforms.in_zoomLevel = this.pixiLayer._initialZoom, this.zoomStartCallback = this.onZoomStart.bind(this), this.zoomEndCallback = this.onZoomEnd.bind(this), e.on("zoomstart", this.zoomStartCallback), e.on("zoomend", this.zoomEndCallback), B.GridLayer.prototype.onAdd.call(this, e);
  },
  onRemove(e) {
    e.off("zoomstart", this.zoomStartCallback), e.off("zoomend", this.zoomEndCallback), this.zoomStartCallback = null, this.zoomEndCallback = null, e.removeLayer(this.pixiLayer), B.GridLayer.prototype.onRemove.call(this, e);
  },
  createTile(e, t) {
    const i = document.createElement("div"), n = this._tileCoordsToBounds(e), r = [n.getSouth(), n.getWest(), n.getNorth(), n.getEast()], s = this.getTileSize(), a = [
      this.conf.resolutionScale[0] * ((r[2] - r[0]) / (s.y - 1)),
      this.conf.resolutionScale[1] * ((r[3] - r[1]) / (s.x - 1))
    ];
    return i.fetchController = new AbortController(), this.gridSource.fetch(i.fetchController.signal, r, a).then((l) => {
      if (i.fetchController = null, l)
        if (l.hasData()) {
          const { coords: c, minLat: u, minLon: d, deltaLat: f, deltaLon: h } = l.genCoordsBuffer(), g = l.genValuesBuffer(), v = l.genMeshIndexBuffer(), x = new Te.Geometry().addAttribute("in_layerCoord", c, 2, !1, Te.TYPES.HALF_FLOAT_VERTEX).addAttribute("in_layerValue", g, 1, !1, Te.TYPES.FLOAT).addIndex(v), w = {
            in_layerBounds: Float32Array.from(r),
            in_layerOffsetScale: Float32Array.of(u, d, f, h),
            layerUniforms: this.layerUniforms
          };
          l.nodata !== void 0 && (w.in_nodata = l.nodata);
          const M = new Te.Shader(this.program, w), p = this.conf.debug.meshAsPoints ? Te.DRAW_MODES.POINTS : Te.DRAW_MODES.TRIANGLE_STRIP;
          if (i.mesh = new Te.Mesh(x, M, this.pixiState, p), this.conf.render.showWireframe) {
            const y = new Te.Geometry().addAttribute("in_layerCoord", x.getBuffer("in_layerCoord"), 2, !1, Te.TYPES.HALF_FLOAT_VERTEX).addIndex(l.genWireframeIndexBuffer()), S = new Te.Shader(this.wireframeProgram, w);
            i.wireframe = new Te.Mesh(y, S, this.pixiState, Te.DRAW_MODES.LINE_STRIP);
          }
          this.conf.debug.showTileInfos && (i.innerHTML = `leaflet tile is ${s.y} x ${s.x} pixels</br>
                 covering ${r[0].toPrecision(6)},${r[1].toPrecision(6)} to ${r[2].toPrecision(6)},${r[3].toPrecision(6)}</br>
                 req res: ${a[0].toPrecision(4)} ${a[1].toPrecision(4)}</br>
                 mesh is made of ${g.length} points`, i.style.outline = "1px solid green");
        } else this.conf.debug.showTileInfos && (i.style.outline = "1px solid red", i.innerHTML = "no data here (grid maybe full of nodata)!");
      else this.conf.debug.showTileInfos && (i.style.outline = "1px solid red", i.innerHTML = "no data here (grid source returned null grid)!");
      t(null, i);
    }).catch((l) => {
      z.error(l), t(l, i);
    }), i;
  },
  onTileLoad(e) {
    const t = e.tile.mesh;
    if (t) {
      if (t.zoomLevel = e.coords.z, t.visible = t.zoomLevel === this._map.getZoom(), this.pixiRoot.addChild(t), this.conf.render.showWireframe) {
        const i = e.tile.wireframe;
        i.zoomLevel = t.zoomLevel, i.visible = t.visible, this.pixiRoot.addChild(i);
      }
      t.visible && this.pixiLayer.redraw();
    }
  },
  onTileUnload(e) {
    e.tile.fetchController && (e.tile.fetchController.abort(), e.tile.fetchController = null), e.tile.mesh && (this.pixiRoot.removeChild(e.tile.mesh), this.conf.render.showWireframe && (this.pixiRoot.removeChild(e.tile.wireframe), e.tile.wireframe.destroy(), e.tile.wireframe = null), e.tile.mesh.visible && this.pixiLayer.redraw(), e.tile.mesh.destroy(), e.tile.mesh = null);
  },
  onZoomStart(e) {
    const t = this._map.getZoom();
    for (const i of this.pixiRoot.children)
      i.zoomLevel === t && (i.visible = !1);
  },
  onZoomEnd(e) {
    const t = this._map.getZoom();
    for (const i of this.pixiRoot.children)
      i.zoomLevel === t && (i.visible = !0);
    this.pixiLayer.redraw();
  },
  onDataChanged() {
    const e = this.gridSource.getBBox();
    if (e) {
      const t = B.latLng(e[0], e[1]), i = B.latLng(e[2], e[3]);
      this.options.bounds = B.latLngBounds(t, i);
    }
    this.updateColorMap(), this.updateShader(), this.redraw(), this.colorMap && (this.fire("data"), this.hasData = !0);
  },
  updateColorMap() {
    const e = this.conf.chromajs;
    if (o.isNil(e)) return;
    this.colorMap = null, this.colorMapShaderCode = null;
    const t = e.classes;
    let i;
    t || (i = e.domain, i || (i = this.gridSource.getDataBounds()));
    const r = Pt.scale(e.colors).colors().map((s) => Pt(s).gl());
    this.colorMap = Zn(e), i ? this.colorMapShaderCode = u_(i, r) : t && (this.colorMapShaderCode = d_(t, r));
  },
  updateShader() {
    const e = [
      // feature projecting layer position
      {
        name: "layerCoord",
        varyings: ["vec2 frg_layerCoord"],
        vertex: {
          attributes: ["vec2 in_layerCoord"],
          uniforms: ["mat3 translationMatrix", "mat3 projectionMatrix", "float in_zoomLevel", "vec4 in_layerOffsetScale"],
          functions: [Zs.latLonToWebMercator, Zs.unpack2],
          code: `  frg_layerCoord = unpack2(in_layerCoord, in_layerOffsetScale);
  vec2 projected = latLonToWebMercator(vec3(frg_layerCoord, in_zoomLevel));
  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(projected, 1.0)).xy, 0.0, 1.0);
  ${this.conf.debug.meshAsPoints ? "gl_PointSize = 10.0;" : ""}`
        },
        fragment: {
          uniforms: ["vec4 in_layerBounds"],
          code: `  bvec4 outside = bvec4(lessThan(frg_layerCoord, in_layerBounds.xy), greaterThan(frg_layerCoord, in_layerBounds.zw));
  if (any(outside)) discard;`
        }
      },
      // feature defining layer's scalar value
      {
        name: "layerValue",
        varyings: ["float frg_layerValue"],
        vertex: {
          attributes: ["float in_layerValue"],
          code: "  frg_layerValue = in_layerValue;"
        }
      }
    ];
    this.conf.render.cutOver && e.push({
      name: "cutOver",
      fragment: {
        uniforms: ["float in_cutOver"],
        code: "  if (frg_layerValue > in_cutOver) discard;"
      }
    }), this.conf.render.cutUnder && e.push({
      name: "cutUnder",
      fragment: {
        uniforms: ["float in_cutUnder"],
        code: "  if (frg_layerValue < in_cutUnder) discard;"
      }
    }), this.gridSource.supportsNoData() && e.push({
      name: "nodata",
      varyings: ["float frg_validValue"],
      vertex: {
        uniforms: ["float in_nodata"],
        code: "  frg_validValue = (in_layerValue == in_nodata ? 0.0 : 1.0);"
      },
      fragment: {
        code: "  if (frg_validValue != 1.0) discard;"
      }
    }), this.colorMapShaderCode ? this.conf.render.pixelColorMapping ? e.push({
      name: "colormap",
      fragment: {
        functions: [this.colorMapShaderCode],
        code: "  vec4 color = ColorMap(frg_layerValue);"
      }
    }) : e.push({
      name: "colormap",
      varyings: ["vec4 frg_color"],
      vertex: {
        functions: [this.colorMapShaderCode],
        code: "  frg_color = ColorMap(frg_layerValue);"
      },
      fragment: {
        code: "  vec4 color = frg_color;"
      }
    }) : e.push({
      name: "colormap",
      varyings: ["vec4 frg_color"],
      vertex: {
        functions: [Zs.rgbFromFloat],
        code: "  frg_color = rgbFromFloat(frg_layerValue);"
      },
      fragment: {
        code: "  vec4 color = frg_color;"
      }
    }), e.push({
      name: "tail",
      fragment: {
        uniforms: ["float in_layerAlpha"],
        code: "  outColor = vec4(color.rgb * in_layerAlpha, in_layerAlpha);"
      }
    });
    const [t, i] = yc(e);
    if (this.program = new Te.Program(t, i), this.conf.render.showWireframe) {
      const [n, r] = yc([e[0], {
        name: "tail",
        fragment: {
          uniforms: ["float in_layerAlpha"],
          code: "  outColor = vec4(0.0, 0.0, 0.0, in_layerAlpha);"
        }
      }]);
      this.wireframeProgram = new Te.Program(n, r);
    }
    this.conf.debug.showShader && (console.log("Generated vertex shader:"), console.log(t), console.log("Generated fragment shader:"), console.log(i));
  },
  renderPixiLayer(e) {
    e.getRenderer().render(this.pixiRoot);
  },
  setLevel(e) {
    this.cutValueUniform ? (this.layerUniforms.uniforms[this.cutValueUniform] = e, this.pixiLayer.redraw()) : typeof this.gridSource.setLevel == "function" && (this._resetView(), this.gridSource.setLevel(e));
  },
  setTime(e) {
    typeof this.gridSource.setTime == "function" && (this._resetView(), this.gridSource.setTime(e));
  },
  setModel(e) {
    typeof this.gridSource.setModel == "function" && (this._resetView(), this.gridSource.setModel(e));
  },
  getBounds() {
    const e = this.options.bounds ? this.options.bounds : B.latLngBounds(B.latLng(-90, -180), B.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(e) : e;
  }
}), f_ = {
  methods: {
    async createLeafletTiledMeshLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tiledMeshLayer") return;
      const i = o.get(e, "variables[0].chromajs", null);
      i && Object.assign(t, { chromajs: i });
      const [n, r] = Yn(e), s = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : this.getWeacastApi(), a = s.hasConfig("gatewayJwt") ? await s.get("storage").getItem(s.getConfig("gatewayJwt")) : null, l = en(n, { weacastApi: s, apiToken: a });
      return l.setup(r), l.updateCtx && (a && (l.updateCtx.jwtToken = a), l.updateCtx.meteoElements = o.get(e, "meteoElements")), new Js(t, l);
    },
    updateTiledMeshLayerZoomBounds(e, t) {
      const i = o.get(e, `leaflet.meteoModelMinZoom[${t.name}]`), n = o.get(e, `leaflet.meteoModelMaxZoom[${t.name}]`);
      i ? e.leaflet.minZoom = i : delete e.leaflet.minZoom, n ? e.leaflet.maxZoom = n : delete e.leaflet.maxZoom, this.updateLayerDisabled(e);
      const r = this.getLeafletLayerByName(e.name);
      r && (i ? r.options.minZoom = i : delete r.options.minZoom, n ? r.options.maxZoom = n : delete r.options.maxZoom);
    },
    onAddTiledMeshLayer(e) {
      !this.forecastModel || o.get(e, "leaflet.type") !== "tiledMeshLayer" || this.updateTiledMeshLayerZoomBounds(e, this.forecastModel);
    },
    onShowTiledMeshLayer(e, t) {
      t instanceof Js && (this.tiledMeshLayers.set(e._id, t), t.setModel(this.forecastModel), t.setTime(pe.getCurrentTime()));
    },
    onHideTiledMeshLayer(e, t) {
      t instanceof Js && this.tiledMeshLayers.delete(e._id);
    },
    onSelectedLevelChangedTiledMeshLayer(e) {
      if (!this.selectableLevelsLayer) return;
      const t = this.tiledMeshLayers.get(this.selectableLevelsLayer._id);
      t && t.setLevel(e);
    },
    onForecastModelChangedTiledMeshLayer(e) {
      const t = o.filter(this.layers, (i) => o.get(i, "leaflet.type") === "tiledMeshLayer");
      for (const i of t) this.updateTiledMeshLayerZoomBounds(i, e);
      this.tiledMeshLayers.forEach((i) => {
        i.setModel(e);
      });
    },
    onCurrentTimeChangedTiledMeshLayer(e) {
      this.tiledMeshLayers.forEach((t) => {
        t.setTime(e);
      });
    }
  },
  created() {
    this.tiledMeshLayers = /* @__PURE__ */ new Map(), this.registerLeafletConstructor(this.createLeafletTiledMeshLayer), this.$engineEvents.on("layer-added", this.onAddTiledMeshLayer), this.$engineEvents.on("layer-shown", this.onShowTiledMeshLayer), this.$engineEvents.on("layer-hidden", this.onHideTiledMeshLayer), this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer), this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledMeshLayer), this.$engineEvents.off("layer-shown", this.onShowTiledMeshLayer), this.$engineEvents.off("layer-hidden", this.onHideTiledMeshLayer), this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer), this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer), ne.off("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  }
}, Qs = B.GridLayer.extend({
  initialize(e, t, i) {
    this.conf = {}, this.conf.enableDebug = o.get(e, "enabledDebug", !1), this.conf.resolutionScale = o.get(e, "resolutionScale", [1, 1]), this.conf.meteoModelOverride = o.get(e, "meteoModelOverride"), B.GridLayer.prototype.initialize.call(this, e), this.userIsDragging = !1, this.pendingFetchs = 0, this.loadedTiles = /* @__PURE__ */ new Set();
    const n = o.get(e, "chromajs");
    this.colorMap = Zn(n), this.uSource = t, this.vSource = i, this.onDataChangedCallback = this.onDataChanged.bind(this), this.uSource.on("data-changed", this.onDataChangedCallback), this.vSource.on("data-changed", this.onDataChangedCallback), this.numDataChanged = 0;
    const r = Object.assign({
      displayValues: !1,
      minVelocity: this.colorMap.domain()[0],
      maxVelocity: this.colorMap.domain()[1],
      velocityScale: 0.01,
      colorScale: this.colorMap.colors(),
      data: null
    }, e);
    this.velocityLayer = B.velocityLayer(r), this.velocityLayer.onDrawLayer = (s, a) => {
      if (this._map && this.velocityLayer._windy) {
        let l = !0;
        const c = this._map.getZoom();
        this.options.maxZoom && c > this.options.maxZoom && (l = !1), this.options.minZoom && c < this.options.minZoom && (l = !1), this.pendingFetchs === 0 && !this.userIsDragging && l ? this.velocityLayer._clearAndRestart() : this.velocityLayer._clearWind();
      }
    }, this.uFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 2
      },
      data: []
    }, this.vFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 3
      },
      data: []
    };
  },
  getEvents() {
    const e = B.GridLayer.prototype.getEvents.call(this), t = e.dragstart;
    e.dragstart = (n) => {
      this.userIsDragging = !0, t && t.call(this, n);
    };
    const i = e.dragend;
    return e.dragend = (n) => {
      this.userIsDragging = !1, i && i.call(this, n);
    }, e;
  },
  setTime(e) {
    const t = typeof this.uSource.setTime == "function", i = typeof this.vSource.setTime == "function";
    (t || i) && (this.pendingAdd || this._resetView(), t && this.uSource.setTime(e), i && this.vSource.setTime(e));
  },
  setLevel(e) {
    const t = typeof this.uSource.setLevel == "function", i = typeof this.vSource.setLevel == "function";
    (t || i) && (this.pendingAdd || this._resetView(), t && this.uSource.setLevel(e), i && this.vSource.setLevel(e));
  },
  setModel(e) {
    const t = {
      nx: e.size[0],
      ny: e.size[1],
      lo1: e.origin[0],
      la1: e.origin[1],
      dx: e.resolution[0],
      dy: e.resolution[1]
    };
    if (this.conf.meteoModelOverride) {
      const s = this.conf.meteoModelOverride[e.name];
      s && Object.assign(t, s);
    }
    Object.assign(this.uFlow.header, t), Object.assign(this.vFlow.header, t);
    const i = t.nx * t.ny;
    this.uFlow.data = new Array(i), this.vFlow.data = new Array(i);
    for (let s = 0; s < i; ++s) this.uFlow.data[s] = this.vFlow.data[s] = 0;
    const n = typeof this.uSource.setModel == "function", r = typeof this.vSource.setModel == "function";
    (n || r) && (this.pendingAdd || this._resetView(), n && this.uSource.setModel(e), r && this.vSource.setModel(e));
  },
  onDataChanged() {
    if (++this.numDataChanged, this.numDataChanged !== 2) return;
    this.numDataChanged = 0, this.loadedTiles.clear();
    const e = [], t = this.vSource.getBBox();
    t && (e.push(B.latLng(t[0], t[1])), e.push(B.latLng(t[2], t[3])));
    const i = this.uSource.getBBox();
    i && (e.push(B.latLng(i[0], i[1])), e.push(B.latLng(i[2], i[3]))), this.options.bounds = e.length ? B.latLngBounds(e) : null, this.pendingAdd ? this.onPendingAdd() : this.redraw(), this.fire("data"), this.hasData = !0;
  },
  onAdd(e) {
    this.pendingAdd = e;
  },
  onPendingAdd() {
    const e = this.pendingAdd;
    this.loadedTiles.clear(), B.GridLayer.prototype.onAdd.call(this, e), e.addLayer(this.velocityLayer), this.velocityLayer.setData([this.uFlow, this.vFlow]), this.velocityLayer._initWindy(this.velocityLayer), this._map.off("dragstart", this.velocityLayer._windy.stop), this._map.off("dragend", this.velocityLayer._clearAndRestart), this.pendingAdd = null;
  },
  onRemove(e) {
    this.pendingAdd ? this.pendingAdd = null : (e.removeLayer(this.velocityLayer), B.GridLayer.prototype.onRemove.call(this, e)), this.uSource.invalidate(), this.vSource.invalidate(), this.loadedTiles.clear();
  },
  updateWindArray(e, t, i, n) {
    const [r, s, a, l] = e.getBestFit(i), c = e.getLat(r), u = e.getLon(s), d = Math.round((u - t.header.lo1) / t.header.dy), f = Math.round((t.header.la1 - c) / t.header.dx);
    for (let h = s; h <= l; ++h)
      for (let g = r; g <= a; ++g) {
        const v = e.getValue(g, h);
        let x = d + (h - s), w = f - (g - r);
        x < 0 && (x += t.header.nx), w < 0 && (w += t.header.ny);
        const M = x + w * t.header.nx;
        t.data[M] = v;
      }
  },
  createTile(e) {
    const t = document.createElement("div"), i = Xd(this.loadedTiles, e);
    if (this.conf.enableDebug && (t.style.outline = "1px solid blue", t.innerHTML = `${e.x} ${e.y} ${e.z} :`), i)
      this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += " skipped");
    else {
      this.conf.enableDebug && (t.innerHTML += " requested");
      const n = this._tileCoordsToBounds(e), r = [n.getSouth(), n.getWest(), n.getNorth(), n.getEast()], s = this.getTileSize(), a = [
        this.conf.resolutionScale[0] * ((r[2] - r[0]) / (s.y - 1)),
        this.conf.resolutionScale[1] * ((r[3] - r[1]) / (s.x - 1))
      ], l = this.uSource.fetch(null, r, a), c = this.vSource.fetch(null, r, a);
      ++this.pendingFetchs;
      const u = () => {
        --this.pendingFetchs, this.pendingFetchs === 0 && !this.userIsDragging && (this.velocityLayer._clearAndRestart(), this.conf.enableDebug && (t.innerHTML += ", triggered wind restart"));
      };
      Promise.all([l, c]).then((d) => {
        const f = d[0], h = d[1];
        f && h ? f.sourceKey === this.uSource.sourceKey && h.sourceKey === this.vSource.sourceKey ? (this.updateWindArray(f, this.uFlow, r), this.updateWindArray(h, this.vFlow, r), this.loadedTiles.add(Mt(e)), this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += ", added to loadedTiles")) : this.conf.enableDebug && (t.style.outline = "1px solid red", t.innerHTML += ", discarded (out of date)") : this.conf.enableDebug && (t.style.outline = "1px solid green", t.innerHTML += ", empty"), u();
      }).catch((d) => {
        throw this.conf.enableDebug && (t.style.outline = "1px solid red", t.innerHTML += `, failed (${d})`), u(), d;
      });
    }
    return t;
  },
  redraw() {
    this.loadedTiles.clear(), this.velocityLayer._clearWind(), this.uFlow.data.fill(0), this.vFlow.data.fill(0), B.GridLayer.prototype.redraw.call(this);
  },
  getBounds() {
    const e = this.options.bounds ? this.options.bounds : B.latLngBounds(B.latLng(-90, -180), B.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(e) : e;
  }
}), h_ = {
  methods: {
    async createLeafletTiledWindLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "tiledWindLayer") return;
      const i = o.get(e, "variables[0].chromajs", null);
      i && Object.assign(t, { chromajs: i });
      const [n, r] = Yn(e), s = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : this.getWeacastApi(), a = en(n, { weacastApi: s }), l = en(n, { weacastApi: s });
      if (a.setup(r), l.setup(r), a.updateCtx) {
        const c = s.hasConfig("gatewayJwt") ? await s.get("storage").getItem(s.getConfig("gatewayJwt")) : null;
        c && (a.updateCtx.jwtToken = c, l.updateCtx.jwtToken = c), a.updateCtx.windComponent = o.get(e, "meteoElements[0]"), l.updateCtx.windComponent = o.get(e, "meteoElements[1]");
      }
      return new Qs(t, a, l);
    },
    updateTiledWindLayerZoomBounds(e, t) {
      const i = o.get(e, `leaflet.meteoModelMinZoom[${t.name}]`), n = o.get(e, `leaflet.meteoModelMaxZoom[${t.name}]`);
      i ? e.leaflet.minZoom = i : delete e.leaflet.minZoom, n ? e.leaflet.maxZoom = n : delete e.leaflet.maxZoom, this.updateLayerDisabled(e);
      const r = this.getLeafletLayerByName(e.name);
      r && (i ? r.options.minZoom = i : delete r.options.minZoom, n ? r.options.maxZoom = n : delete r.options.maxZoom);
    },
    onAddTiledWindLayer(e) {
      !this.forecastModel || o.get(e, "leaflet.type") !== "tiledWindLayer" || this.updateTiledWindLayerZoomBounds(e, this.forecastModel);
    },
    onShowTiledWindLayer(e, t) {
      t instanceof Qs && (this.tiledWindLayers.set(e._id, t), t.setModel(this.forecastModel), t.setTime(pe.getCurrentTime()));
    },
    onHideTiledWindLayer(e, t) {
      t instanceof Qs && this.tiledWindLayers.delete(e._id);
    },
    onForecastModelChangedTiledWindLayer(e) {
      const t = o.filter(this.layers, (i) => o.get(i, "leaflet.type") === "tiledWindLayer");
      for (const i of t) this.updateTiledWindLayerZoomBounds(i, e);
      this.tiledWindLayers.forEach((i) => {
        i.setModel(e);
      });
    },
    onCurrentTimeChangedTiledWindLayer(e) {
      this.tiledWindLayers.forEach((t) => {
        t.setTime(e);
      });
    },
    onSelectedLevelChangedTiledWindLayer(e) {
      if (!this.selectableLevelsLayer) return;
      const t = this.tiledWindLayers.get(this.selectableLevelsLayer._id);
      t && t.setLevel(e);
    }
  },
  created() {
    this.tiledWindLayers = /* @__PURE__ */ new Map(), this.registerLeafletConstructor(this.createLeafletTiledWindLayer), this.$engineEvents.on("layer-added", this.onAddTiledWindLayer), this.$engineEvents.on("layer-shown", this.onShowTiledWindLayer), this.$engineEvents.on("layer-hidden", this.onHideTiledWindLayer), this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer), this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledWindLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledWindLayer), this.$engineEvents.off("layer-shown", this.onShowTiledWindLayer), this.$engineEvents.off("layer-hidden", this.onHideTiledWindLayer), this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer), this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledWindLayer), ne.off("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  }
}, m_ = {
  methods: {
    async createLeafletHeatmapLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "heatmap") return;
      const i = this.createLeafletLayer(e), n = o.get(t, "url"), r = o.get(t, "urlTemplate");
      r && (i.sourceCompiler = o.template(r));
      const s = o.get(t, "valueTemplate");
      if (s && (i.valueCompiler = o.template(s)), e.service) {
        i.lastUpdateTime = pe.getCurrentTime().clone();
        const a = await this.getFeatures(e);
        this.updateLeafletHeatmap(i, a);
      } else if (o.isNil(n)) {
        if (!o.isNil(r)) {
          const a = i.sourceCompiler({ time: pe.getCurrentTime() });
          i.lastFetchedSource = a;
          const l = await si(a, e);
          this.updateLeafletHeatmap(i, l);
        }
      } else {
        const a = await si(n, e);
        this.updateLeafletHeatmap(i, a);
      }
      return i;
    },
    updateLeafletHeatmap(e, t) {
      const i = o.get(e, "cfg.valueField", "value"), n = o.get(e, "cfg.min"), r = o.get(e, "cfg.max"), s = e.valueCompiler ? t.features.map((a) => o.toNumber(e.valueCompiler({ properties: a.properties, feature: a }))) : t.features.map((a) => o.toNumber(o.get(a, `properties.${i}`, 1)));
      e.setData({
        min: n || (i ? o.min(s) : 0),
        max: r || (i ? o.max(s) : 1),
        data: t.features.map((a, l) => {
          const c = xi(a);
          return {
            lng: o.get(c, "geometry.coordinates[0]"),
            lat: o.get(c, "geometry.coordinates[1]"),
            [i]: s[l]
          };
        })
      });
    },
    updateHeatmap(e, t) {
      const i = this.getLeafletLayerByName(e);
      i && this.updateLeafletHeatmap(i, t);
    },
    onCurrentTimeChangedHeatmapLayers(e) {
      o.values(this.layers).filter(Pe({
        "leaflet.type": "heatmap",
        $or: [
          // Supported by template URL or time-based features
          { "leaflet.urlTemplate": { $exists: !0 } },
          { service: { $exists: !0 } }
        ],
        isVisible: !0
      })).forEach(async (i) => {
        const n = this.getLeafletLayerByName(i.name);
        if (i.service) {
          if (!n.lastUpdateTime || !this.shouldSkipFeaturesUpdate(n.lastUpdateTime, i)) {
            n.lastUpdateTime = pe.getCurrentTime().clone();
            const r = await this.getFeatures(i);
            this.updateLeafletHeatmap(n, r);
          }
        } else if (n.sourceCompiler) {
          const r = n.sourceCompiler({ time: pe.getCurrentTime() });
          if (!n.lastFetchedSource || n.lastFetchedSource !== r) {
            n.lastFetchedSource = r;
            const s = await si(r, i);
            this.updateLeafletHeatmap(n, s);
          }
        }
      });
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletHeatmapLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  }
};
B.heatmap = function(e) {
  return new Em(e);
};
const g_ = {
  methods: {
    async createLeafletMapillaryLayer(e) {
      if ((e.leaflet || e).type !== "mapillary") return;
      const i = await this.createLeafletLayer(o.merge(e, {
        leaflet: {
          type: "vectorGrid.protobuf",
          source: "https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=" + this.mapillaryToken,
          interactive: !0,
          minZoom: 13,
          maxNativeZoom: 14,
          vectorTileLayerStyles: {
            sequence: function(n, r) {
              return {
                weight: r > 13 ? 1 : 2,
                color: "#44BB44",
                opacity: r > 13 ? 0.5 : 1
              };
            },
            image: []
          }
        }
      }));
      return Dt(i, ni.Feature, this, e), i;
    }
  },
  created() {
    if (this.mapillaryToken = V.get("capabilities.api.mapillary.token"), !this.mapillaryToken) {
      z.warn("You must provide a client token to use Mapillary");
      return;
    }
    this.registerLeafletConstructor(this.createLeafletMapillaryLayer);
  }
}, p_ = B.TileLayer.extend({
  initialize(e) {
    this.product = e.product || "rain";
    const t = this.makeUrl(e.time), i = Object.assign({ tms: !0 }, e);
    B.TileLayer.prototype.initialize.call(this, t, i);
    const n = e.chromajs;
    n && (this.colorMap = Zn(n), this.colorMap && this.on("tileload", (r) => {
      this.hasData || (this.fire("data"), this.hasData = !0);
    }));
  },
  makeUrl(e) {
    const t = e || fe(), i = fe.duration(30, "minutes"), n = fe(Math.trunc(t / i) * i).utc(), r = "https://sharaku.eorc.jaxa.jp/cgi-bin/trmm/GSMaP_NOW/tilemap/", s = `year=${n.year()}&month=${n.month() + 1}&day=${n.date()}&hour=${n.hour()}&min=${n.minute()}&z={z}&x={x}&y={y}`;
    return this.product === "rain12" || this.product === "rain24" || this.product === "rain72" ? r + `tile_total.py?prod=${this.product}&` + s : this.product === "ir" ? r + `gsmapnow_tile_ir.py?prod=${this.product}&` + s : r + "tile_rain.py?prod=rain&" + s;
  },
  setCurrentTime(e) {
    const t = this.makeUrl(e);
    this.setUrl(t, !1);
  }
}), y_ = {
  methods: {
    async createLeafletGSMaPLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "gsmapLayer") return;
      const i = o.get(e, "variables[0].chromajs", null);
      return i && Object.assign(t, { chromajs: i }), t.time = pe.getCurrentTime(), new p_(t);
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGSMaPLayer);
  }
}, Ea = {
  initialize() {
    this.ctx || (this.ctx = {});
  },
  get() {
    return this.ctx;
  },
  merge(e) {
    this.ctx = Object.assign({}, this.ctx, e);
  }
};
Ea.initialize();
function v_(e, t) {
  const i = { node: e.target, display: e.target.style.display };
  i.node.style.display = "none";
  const n = document.elementFromPoint(e.clientX, e.clientY);
  if (n && n !== t) {
    const r = new MouseEvent(e.type, e);
    (!n.dispatchEvent(r) || r._stopped) && B.DomEvent.stop(e);
  }
  i.node.style.display = i.display;
}
B.KanvasLayer = (B.Layer ? B.Layer : B.Class).extend({
  // -- initialized is called on prototype
  initialize: function(e) {
    if (this._map = null, this._mapPaneOffset = null, this._canvas = null, this._frame = null, this._delegate = null, B.setOptions(this, e), this.clickableFeatures = [], this.mousePosition = null, this.highlighting = !1, this.autoRedraw = !1, e.tooltip) {
      if (this._tooltip = B.tooltip({}), this._tooltipContent = "", e.tooltip.html)
        this._getTooltipContent = (t) => e.tooltip.html;
      else if (e.tooltip.property)
        this._getTooltipContent = (t) => `${o.get(t, e.tooltip.property)}`;
      else if (e.tooltip.template) {
        const t = o.template(e.tooltip.template);
        this._getTooltipContent = (i) => t({ feature: i, properties: i.properties });
      }
    }
  },
  delegate: function(e) {
    this._delegate = e;
  },
  setAutoRedraw: function(e) {
    this.autoRedraw = e, e && this._frame === null && this.needRedraw();
  },
  needRedraw: function() {
    this._frame !== null || this._canvas === null || (this._frame = B.Util.requestAnimFrame(this.drawLayer, this));
  },
  redrawNow: function() {
    const e = this._frame, t = this.autoRedraw;
    this.autoRedraw = !1, this.drawLayer(), this._frame = e, this.autoRedraw = t;
  },
  latLonToCanvas: function(e) {
    let t = this._map.latLngToLayerPoint(B.latLng(e.lat, e.lon));
    return this._map._rotate && (t = t.add(this._map._getRotatePanePos()).rotateFrom(this._map._bearing, this._map._getRotatePanePos())), t.add(this._mapPaneOffset);
  },
  clearClickableFeatures: function() {
    this.clickableFeatures.length = 0;
  },
  addClickableFeature: function(e, t, { clickableStrokeWidth: i = 0, highlightPath: n = void 0, highlightAsStroke: r = !1, highlightStyle: s = {} }) {
    this.clickableFeatures.push({
      feature: e,
      click: { path: t, strokeWidth: i }
    }), n && (this.clickableFeatures[this.clickableFeatures.length - 1].highlight = {
      path: n,
      asStroke: r,
      style: s
    });
  },
  hasClickableFeaturesAt: function(e) {
    if (!e || this.clickableFeatures.length === 0) return !1;
    const t = this.latLonToCanvas({ lat: e.lat, lon: e.lng }), i = this._canvas.getContext("2d");
    let n = !1;
    for (const r of this.clickableFeatures)
      if (i.save(), r.click.strokeWidth ? (i.lineWidth = r.click.strokeWidth, n = i.isPointInStroke(r.click.path, t.x, t.y)) : n = i.isPointInPath(r.click.path, t.x, t.y), i.restore(), n) return !0;
    return !1;
  },
  getClickableFeaturesAt: function(e) {
    if (!e || this.clickableFeatures.length === 0) return [];
    const t = this.latLonToCanvas({ lat: e.lat, lon: e.lng }), i = [], n = this._canvas.getContext("2d");
    return this.clickableFeatures.forEach((r, s) => {
      n.save(), r.click.strokeWidth ? (n.lineWidth = r.click.strokeWidth, n.isPointInStroke(r.click.path, t.x, t.y) && i.push(s)) : n.isPointInPath(r.click.path, t.x, t.y) && i.push(s), n.restore();
    }), i;
  },
  // -------------------------------------------------------------
  _onLayerDidResize: function(e) {
    this._canvas.width = e.newSize.x, this._canvas.height = e.newSize.y;
  },
  // -------------------------------------------------------------
  _onLayerDidMove: function() {
    if (this._mapPaneOffset = this._map._getMapPanePos(), this._map._rotate) {
      const e = this._mapPaneOffset.add(this._map._getRotatePanePos());
      this._canvas.style[B.DomUtil.TRANSFORM] = // TODO: zoomAnimation is currently always off on the layer beacause of rotate plugin
      // this._map.options.zoomAnimation ?
      "translate(-50%, -50%) rotate(" + -this._map._bearing + "rad) translate(50%, 50%) translate3d(" + -e.x + "px," + -e.y + "px, 0)";
    } else
      B.DomUtil.setPosition(this._canvas, B.point(0, 0).subtract(this._mapPaneOffset));
    this.redrawNow();
  },
  // -------------------------------------------------------------
  _onLayerClick: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    const t = this.getClickableFeaturesAt(e.latlng);
    if (t.length)
      this.fire("click", Object.assign({}, e, { feature: this.clickableFeatures[t[0]].feature }));
    else if (this.options.clickThroughEnabled) {
      const i = this.options.pane ? this._map._panes[this.options.pane] : this._map._panes.overlayPane;
      v_(e.originalEvent, i);
    }
  },
  // -------------------------------------------------------------
  _onLayerContextMenu: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    const t = this.getClickableFeaturesAt(e.latlng);
    t.length !== 0 && this.fire("contextmenu", Object.assign({}, e, { feature: this.clickableFeatures[t[0]].feature }));
  },
  // -------------------------------------------------------------
  _onMouseMove: function(e) {
    if (e.originalEvent.target !== this._canvas) return;
    this.mousePosition = e.latlng;
    let t = !1;
    if (this._tooltip) {
      const i = this.getClickableFeaturesAt(e.latlng);
      if (i.length === 0 && this._map.hasLayer(this._tooltip))
        this._map.closeTooltip(this._tooltip), this._tooltipContent = "";
      else if (i.length) {
        const n = this._getTooltipContent(this.clickableFeatures[i[0]].feature);
        n !== this._tooltipContent && (this._tooltip.setLatLng(e.latlng), this._tooltip.setContent(n), this._tooltipContent = n), this._map.hasLayer(this._tooltip) || this._map.openTooltip(this._tooltip), t = !0;
      }
    } else
      t = this.hasClickableFeaturesAt(e.latlng);
    if (!t && !this.highlighting) {
      this._canvas.style.cursor = "";
      return;
    } else
      this._canvas.style.cursor = "pointer", this.needRedraw();
  },
  // -------------------------------------------------------------
  _onLayerDidRotate: function(e) {
    this._onLayerDidMove();
  },
  // -------------------------------------------------------------
  getEvents: function() {
    const e = {
      resize: this._onLayerDidResize,
      moveend: this._onLayerDidMove,
      zoom: this._onLayerDidMove,
      rotate: this._onLayerDidRotate
    };
    return this._map.options.zoomAnimation && B.Browser.any3d && (e.zoomanim = this._animateZoom), this.options.pointerEventsEnabled && (e.click = this._onLayerClick, e.contextmenu = this._onLayerContextMenu, e.mousemove = this._onMouseMove), e;
  },
  // -------------------------------------------------------------
  onAdd: function(e) {
    this._map = e, this._canvas = B.DomUtil.create("canvas", "leaflet-layer"), this.options.pointerEventsEnabled || (this._canvas.style.pointerEvents = "none");
    const t = this._map.getSize();
    this._canvas.width = t.x, this._canvas.height = t.y, this._mapPaneOffset = e._getMapPanePos(), B.DomUtil.setPosition(this._canvas, B.point(0, 0).subtract(this._mapPaneOffset)), B.DomUtil.addClass(this._canvas, "leaflet-zoom-hide"), (this.options.pane ? e._panes[this.options.pane] : e._panes.overlayPane).appendChild(this._canvas), e.on(this.getEvents(), this);
    const n = this._delegate || this;
    n.onLayerDidMount && n.onLayerDidMount(), this.needRedraw();
  },
  // -------------------------------------------------------------
  onRemove: function(e) {
    const t = this._delegate || this;
    t.onLayerWillUnmount && t.onLayerWillUnmount(), this._frame !== null && B.Util.cancelAnimFrame(this._frame), (this.options.pane ? e._panes[this.options.pane] : e._panes.overlayPane).removeChild(this._canvas), e.off(this.getEvents(), this), this._canvas = null, this._frame = null;
  },
  // ---------- --------------------------------------------------
  addTo: function(e) {
    return e.addLayer(this), this;
  },
  // --------------------------------------------------------------------------------
  LatLonToMercator: function(e) {
    return {
      x: e.lng * 6378137 * Math.PI / 180,
      y: Math.log(Math.tan((90 + e.lat) * Math.PI / 360)) * 6378137
    };
  },
  // ------------------------------------------------------------------------------
  drawLayer: function() {
    const e = this._map.getSize(), t = this._map.getBounds(), i = this._map.getZoom(), n = this.LatLonToMercator(this._map.getCenter()), r = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize())), s = this._delegate || this;
    s.onDrawLayer && s.onDrawLayer({
      layer: this,
      canvas: this._canvas,
      bounds: t,
      size: e,
      zoom: i,
      center: n,
      corner: r
    });
    const a = this.getClickableFeaturesAt(this.mousePosition);
    if (this.highlighting = a.length > 0, this.highlighting) {
      const l = this._canvas.getContext("2d");
      for (const c of a) {
        const u = this.clickableFeatures[c];
        l.save(), l.globalAlpha = 0.5;
        for (const d in u.highlight.style) l[d] = u.highlight.style[d];
        u.highlight.asStroke ? l.stroke(u.highlight.path) : l.fill(u.highlight.path), l.restore();
      }
    }
    this._frame = null, this.autoRedraw && this.needRedraw();
  },
  // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7
  // ------------------------------------------------------------------------------
  _setTransform: function(e, t, i) {
    const n = t || new B.Point(0, 0);
    e.style[B.DomUtil.TRANSFORM] = (B.Browser.ie3d ? "translate(" + n.x + "px," + n.y + "px)" : "translate3d(" + n.x + "px," + n.y + "px,0)") + (i ? " scale(" + i + ")" : "");
  },
  // ------------------------------------------------------------------------------
  _animateZoom: function(e) {
    const t = this._map.getZoomScale(e.zoom), i = B.Layer ? this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min : this._map._getCenterOffset(e.center)._multiplyBy(-t).subtract(this._map._getMapPanePos());
    B.DomUtil.setTransform(this._canvas, i, t);
  }
});
B.kanvasLayer = function(e) {
  return new B.KanvasLayer(e);
};
const b_ = {
  methods: {
    createLeafletCanvasLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "kanvasLayer") return;
      const i = this.createLeafletLayer(e);
      return this.setCanvasLayerDrawCode(i, t.draw), t.userData && this.setCanvasLayerUserData(i, t.userData), t.autoRedraw && this.setCanvasLayerAutoRedraw(i, t.autoRedraw), Dt(i, ["click", "contextmenu"], this, e), i;
    },
    setCanvasLayerDrawCode(e, t, i = !1) {
      const n = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      if (!n) return;
      const r = (s, a) => {
        for (const l in s.listenedLayers) {
          if (s.listenedLayers[l] === a) continue;
          const u = this.getLeafletLayerByName(l);
          u && (a ? u.on("update", s.needRedraw, s) : u.off("update", s.needRedraw, s), s.listenedLayers[l] = a);
        }
      };
      r(n, !1), n.listenedLayers = {}, n.drawCalls = [], n.userData === void 0 && (n.userData = {}), n.compatContext === void 0 && (n.compatContext = {}), n.clearClickableFeatures();
      for (const s of t) {
        const a = Function(`
// define visible variables
const ctx = this;
with(this.proxy) { ${s.code} }
`);
        if (s.feature) {
          const [l, c] = s.feature.split("?");
          n.drawCalls.push((u) => {
            const d = this.getLeafletLayerByName(l);
            if (!d) return;
            const f = d._features ? d._features[c] : void 0;
            f && (u.feature = f, a.call(u));
          }), o.has(n.listenedLayers, l) || (n.listenedLayers[l] = !1);
        } else s.layer && (n.drawCalls.push((l) => {
          const c = this.getLeafletLayerByName(s.layer);
          if (c)
            for (const u of Object.values(c._features))
              l.feature = u, a.call(l);
        }), o.has(n.listenedLayers, s.layer) || (n.listenedLayers[s.layer] = !1));
      }
      n.onDrawLayer || (n.onDrawLayer = (s) => {
        r(n, !0);
        const a = s.canvas.getContext("2d"), l = Object.assign(
          // current state context
          {
            canvas: a,
            now: Date.now(),
            zoom: s.zoom,
            latLonToCanvas: n.latLonToCanvas.bind(n),
            clearClickableFeatures: n.clearClickableFeatures.bind(n),
            addClickableFeature: n.addClickableFeature.bind(n),
            userData: n.userData
          },
          n.compatContext,
          // global context
          this.canvasLayerDrawContext
        );
        a.save(), a.clearRect(0, 0, s.canvas.width, s.canvas.height);
        for (const c of n.drawCalls) c(l);
        a.restore();
      }), n.setAutoRedraw(i), n.needRedraw();
    },
    setCanvasLayerUserData(e, t) {
      const i = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      i && (i.userData = Object.assign(i.userData, t), i.needRedraw());
    },
    setCanvasLayerAutoRedraw(e, t) {
      const i = typeof e == "string" ? this.getLeafletLayerByName(e) : e;
      i && i.setAutoRedraw(t);
    },
    /* Compatibility methods */
    updateCanvasLayerDrawCode(e, t, i = !1) {
      this.setCanvasLayerDrawCode(e, t, i);
    },
    setCanvasLayerContext(e, t) {
      const i = this.getLeafletLayerByName(e);
      i && (i.compatContext = t, i.needRedraw());
    }
  },
  created() {
    this.canvasLayerDrawProxy = new Proxy(window, {
      get: (e, t, i) => {
      }
    }), this.canvasLayerDrawContext = Object.assign({
      proxy: this.canvasLayerDrawProxy,
      // Math constants
      Math,
      // a few handy helpers for draw code
      vec2: (e, t) => ({ x: e.x - t.x, y: e.y - t.y }),
      len2: (e) => Math.sqrt(e.x * e.x + e.y * e.y),
      scale2: (e, t) => ({ x: e.x * t, y: e.y * t }),
      norm2: (e) => {
        const t = Math.sqrt(e.x * e.x + e.y * e.y);
        return { x: e.x / t, y: e.y / t };
      }
    }, Ea.get()), this.registerLeafletConstructor(this.createLeafletCanvasLayer);
  },
  beforeUnmount() {
  }
}, w_ = {
  methods: {
    async createLeafletPMTilesLayer(e) {
      const t = e.leaflet || e;
      if (t.type !== "pmtiles") return;
      const i = typeof e.getPlanetApi == "function" ? e.getPlanetApi() : q, n = i.hasConfig("apiJwt") ? await i.get("storage").getItem(i.getConfig("apiJwt")) : null, r = i.hasConfig("gatewayJwt") ? await i.get("storage").getItem(i.getConfig("gatewayJwt")) : null, s = o.get(t, "urlTemplate");
      s && (t.url = o.template(s)({ apiJwt: n, gatewayJwt: r }));
      const a = o.get(t, "styleTemplate");
      a && (t.style = o.template(a)({ apiJwt: n, gatewayJwt: r }));
      const l = o.get(t, "template");
      l && (t.template = l.map((d) => ({
        property: d,
        compiler: o.template(o.get(t, d))
      })));
      let c = {}, u = o.get(t, "style");
      if (typeof u == "string") {
        const d = await fetch(u);
        if (d.status !== 200)
          throw new Error(`Impossible to fetch style ${u}: ` + d.status);
        u = await d.json();
        const f = u.layers.find((h) => h.type === "background");
        f && (t.backgroundColor = f.paint["fill-color"]), c = Tm(u, {});
      } else if (o.get(t, "template", []).forEach((d) => {
        const f = (h, g) => {
          const v = Object.assign({ properties: g.props, feature: g, chroma: Pt, moment: fe, Units: be, Time: pe, level: this.selectedLevel }, us.get());
          return d.property.endsWith("filter") ? d.compiler(v) === "true" : d.compiler(v);
        };
        o.set(t, d.property, f);
      }), u) {
        const d = o.map(
          u,
          (g) => Object.assign(o.omit(g, ["symbolizer"]), {
            symbolizer: new Tc[g.symbolizer.type](g.symbolizer)
          })
        ), f = (g) => typeof g.symbolizer.place == "function", h = (g) => !f(g);
        c.paint_rules = c.paintRules = o.filter(d, h), c.label_rules = c.labelRules = o.filter(d, f);
      }
      return this.createLeafletLayer({
        ...t,
        ...c
        //debug: true,
        //levelDiff: 2
      });
    },
    onCurrentTimeChangedPMTilesLayers(e) {
      o.values(this.layers).filter(Pe({
        "leaflet.type": "pmtiles",
        // Skip invisible layers
        isVisible: !0
      })).forEach(async (i) => {
        this.getLeafletLayerByName(i.name).redraw();
      });
    },
    onCurrentLevelChangedPMTilesLayers(e) {
      let t = this.selectableLevelsLayer;
      t && o.get(t, `${this.engine}.type`) === "pmtiles" && (t = this.getLeafletLayerByName(t.name), t.redraw());
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletPMTilesLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers), this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers), this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  }
};
B.pmtiles = function(e) {
  return Tc.leafletLayer(e);
};
const __ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: Qw,
  baseMap: Nw,
  canvasLayers: b_,
  editLayers: Hw,
  fileLayers: Gw,
  geojsonLayers: qw,
  gsmapLayers: y_,
  heatmapLayers: m_,
  mapillaryLayers: g_,
  pmtilesLayers: w_,
  popup: Jw,
  style: Ww,
  tiledMeshLayers: f_,
  tiledWindLayers: h_,
  tooltip: Zw
}, Symbol.toStringTag, { value: "Module" }));
function L_(e, t = [], i = []) {
  if (!e || e.length < 2) return;
  if (t = t || Array(e.length).fill(0), t = Array.isArray(t) ? t : Array(e.length).fill(t), !i) {
    i = [];
    for (let h = 0, g = e.length; h < g; ++h) {
      const v = Cesium.Cartographic.fromCartesian(e[h]);
      i.push(v.height);
    }
  }
  i = Array.isArray(i) ? i : Array(e.length).fill(i);
  const n = (h, g) => {
    const v = Cesium.Cartographic.fromCartesian(h);
    return v.height = g, Cesium.Cartographic.toCartesian(v);
  }, r = [], s = [0], a = (e.length - 1) * 2;
  let l = 0, c = -1;
  for (let h = 0; h < a; h++)
    if (h % 2 ? r.push(h + 2, h - 1, h + 1) : r.push(h + 1, h, h + 3), e[h + 1]) {
      const g = Cesium.Cartesian3.distance(e[h], e[h + 1]);
      s.push(g), l += g;
    }
  let u = 0;
  const d = [], f = [];
  for (let h = 0; h < e.length; h++) {
    u += s[h] / l, h === e.length - 1 && (u = 1), d.push(1 - u, 0, 1 - u, 1);
    const g = e[h], v = n(g, t[h]), x = n(g, i[h]);
    f.push(
      v.x,
      v.y,
      v.z,
      x.x,
      x.y,
      x.z
    );
    const w = Math.abs(i[h] - t[h]);
    (c === -1 || w < c) && (c = w);
  }
  return {
    geometry: new Cesium.Geometry({
      attributes: {
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: f
        }),
        st: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 2,
          values: new Float64Array(d)
        })
      },
      indices: new Uint16Array(r),
      primitiveType: Cesium.PrimitiveType.TRIANGLES,
      boundingSphere: Cesium.BoundingSphere.fromVertices(f)
    }),
    dimensions: {
      minHeight: c,
      lineLength: l
    }
  };
}
function x_(e, t, i) {
  if (!e || e.length < 2) return;
  const n = (w, M) => {
    const p = Cesium.Cartographic.fromCartesian(w);
    return p.height = M, Cesium.Cartographic.toCartesian(p);
  }, r = (w, M, p) => {
    const y = Cesium.Cartesian3.subtract(M, w, new Cesium.Cartesian3()), S = Cesium.Cartesian3.subtract(p, w, new Cesium.Cartesian3()), C = Cesium.Cartesian3.dot(y, S), T = Cesium.Cartesian3.magnitude(y), k = Cesium.Cartesian3.magnitude(S);
    return Math.acos(C / (T * k));
  }, s = (w, M, p, y, S) => {
    let C;
    if (!M)
      C = Cesium.Cartesian3.subtract(p, w, new Cesium.Cartesian3());
    else if (!p)
      C = Cesium.Cartesian3.subtract(w, M, new Cesium.Cartesian3());
    else {
      const A = Cesium.Cartesian3.subtract(p, w, new Cesium.Cartesian3()), P = Cesium.Cartesian3.subtract(w, M, new Cesium.Cartesian3());
      C = Cesium.Cartesian3.add(A, P, new Cesium.Cartesian3());
    }
    Cesium.Cartesian3.normalize(C, C);
    const T = S || Cesium.Cartesian3.UNIT_Z, k = Cesium.Cartesian3.cross(C, T, new Cesium.Cartesian3());
    Cesium.Cartesian3.normalize(k, k);
    const I = Cesium.Cartesian3.multiplyByScalar(k, y, new Cesium.Cartesian3());
    return { direction: C, position: Cesium.Cartesian3.add(w, I, new Cesium.Cartesian3()) };
  };
  for (let w = 0; w < e.length; w++)
    e[w] = n(e[w], i);
  const a = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(e[0]), l = [0];
  let c = 0;
  const u = [];
  let d = null, f = null, h = null;
  for (let w = 0; w < e.length; w++) {
    const M = s(e[w], e[w - 1], e[w + 1], -t / 2, a), p = s(e[w], e[w - 1], e[w + 1], t / 2, a);
    if (w > 0) {
      const y = Cesium.Cartesian3.cross(M.direction, h, new Cesium.Cartesian3()).z < 0, S = r(e[w - 1], e[w], y ? d : f);
      r(e[w - 1], e[w], y ? M.position : p.position) > S && (y ? M.position = d : p.position = f);
      const T = Cesium.Cartesian3.distance(e[w - 1], e[w]);
      l.push(T), c += T;
    }
    u.push(
      M.position.x,
      M.position.y,
      M.position.z,
      p.position.x,
      p.position.y,
      p.position.z
    ), d = M.position, f = p.position, h = M.direction;
  }
  let g = 0;
  const v = [], x = [];
  for (let w = 0; w < e.length; w++)
    if (g += l[w] / c, w === e.length - 1 && (g = 1), v.push(1 - g, 0, 1 - g, 1), w < e.length - 1) {
      const M = w * 2;
      x.push(
        M,
        M + 1,
        M + 2,
        M + 1,
        M + 3,
        M + 2
      );
    }
  return {
    geometry: new Cesium.Geometry({
      attributes: {
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: u
        }),
        st: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 2,
          values: new Float64Array(v)
        })
      },
      indices: new Uint16Array(x),
      primitiveType: Cesium.PrimitiveType.TRIANGLES,
      boundingSphere: Cesium.BoundingSphere.fromVertices(u)
    }),
    dimensions: {
      lineLength: c,
      width: t
    }
  };
}
function S_(e) {
  if (!e.image) return;
  let t = null;
  try {
    throw t = Cesium.Material.fromType("MovingMaterial"), t.uniforms.image = e.image, t.uniforms.repeat = new Cesium.Cartesian2(1, 1), t.uniforms.offset = new Cesium.Cartesian2(0, 0), t.translucent = e.translucent, new Error("Load material from type is not working");
  } catch {
    const n = `
      czm_material czm_getMaterial(czm_materialInput materialInput) {
          czm_material material = czm_getDefaultMaterial(materialInput);

          vec2 st = materialInput.st * repeat + offset;

          // Loop texture with fract
          st = fract(st);

          vec4 color = texture(image, st);
          material.${e.useAsDiffuse ? "diffuse" : "emission"} = color.rgb;
          material.alpha = color.a * opacity;
          return material;
      }`;
    t = new Cesium.Material({
      fabric: {
        type: "MovingMaterial",
        source: n,
        uniforms: {
          image: e.image,
          repeat: new Cesium.Cartesian2(1, 1),
          offset: new Cesium.Cartesian2(0, 0),
          opacity: 0
        }
      },
      translucent: o.get(e, "translucent", !1)
    });
  }
  return t;
}
function vo(e, t) {
  if (!t.positions || !o.get(t, "material.image", !1)) return;
  const i = {
    positions: t.material.reverseAnimation === !0 ? t.positions.reverse() : t.positions
  };
  let n = null;
  switch (e) {
    case "wall":
      i.minimumHeights = o.get(t, "minimumHeights", 0), i.maximumHeights = o.get(t, "maximumHeights", null), n = L_(i.positions, i.minimumHeights, i.maximumHeights);
      break;
    case "corridor":
      i.width = o.get(t, "width", 10), i.height = o.get(t, "height", 0), n = x_(i.positions, i.width, i.height);
      break;
  }
  if (!n) return;
  const r = n.dimensions;
  n = n.geometry;
  const s = S_(o.get(t, "material"));
  if (!s) return;
  s.uniforms.repeat.x = r.lineLength / (r.minHeight || r.width);
  const a = o.get(t, "material.scale");
  let l = 1;
  return a && (Array.isArray(a) ? (s.uniforms.repeat.x *= a[0], s.uniforms.repeat.y *= a[1], l = a[0]) : (s.uniforms.repeat.x *= a, s.uniforms.repeat.y *= a, l = a)), {
    primitive: new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({
        geometry: n
      }),
      appearance: new Cesium.MaterialAppearance({
        material: s,
        translucent: s.translucent
      }),
      asynchronous: !1
    }),
    material: {
      material: s,
      animationSpeed: o.get(t, "material.animationSpeed") * l,
      length: r.lineLength
    }
  };
}
function ph(e, t) {
  const i = t.scene.context._pickObjects, n = [];
  for (const r in i) {
    const s = i[r], a = o.get(s, "id._id");
    if (a && e.toString() === a) {
      const l = o.get(s, "primitive");
      l && !n.includes(l) && n.push(l);
    }
  }
  return n;
}
function yh(e) {
  const t = {
    left: 0,
    middle: 1,
    right: 2
  }, i = e.split("_"), n = i[1].toLowerCase();
  let r = i[0].toLowerCase(), s;
  return e.startsWith("PINCH") ? s = "pinch" : e.endsWith("CLICK") ? s = "click" : e.endsWith("DOUBLE_CLICK") ? s = "dblclick" : e.startsWith("WHEEL") ? s = "wheel" : s = "mouse", s === "mouse" ? (s += n, r = t[r]) : s.endsWith("click") ? r = t[r] : s === "pinch" ? (s += n, r = void 0) : r = 1, { name: s, button: r };
}
const bo = {
  // Filter to identify layers that require an update at a given frequency
  TimeUpdate: {
    // Possible for realtime layers only
    "cesium.type": "geoJson",
    "cesium.realtime": !0,
    $or: [
      // Supported by template URL or time-based features service
      { "cesium.sourceTemplate": { $exists: !0 } },
      { service: { $exists: !0 } }
    ],
    // Skip layers powered by realtime service events
    serviceEvents: { $ne: !0 },
    // Skip invisible layers
    isVisible: !0
  },
  // Filter to identify layers with variables affected by a unit change
  UnitUpdate: {
    "cesium.type": "geoJson",
    "cesium.realtime": !0,
    // Not sure why but this does not seem to work with sift
    //'variables': { $elemMatch: { unit: { $in: units } } },
    variables: { $exists: !0 },
    isVisible: !0,
    $or: [{
      "cesium.style": { $exists: !0 },
      "cesium.template": { $exists: !0 }
    }, {
      "cesium.tooltip.template": { $exists: !0 }
    }]
  }
};
function vh(e, t) {
  t.position = e.position, t.orientation = e.orientation, t.properties = e.properties, t.description = e.description, e.billboard && (t.billboard = e.billboard), e.polyline && (t.polyline = e.polyline), e.polygon && (t.polygon = e.polygon);
}
function bh(e, t) {
  const i = o.intersection(e, o.map(t.variables, "unit"));
  if (o.isEmpty(i)) return !1;
  if (o.get(t, "cesium.tooltip.template", "").includes("Units")) return !0;
  for (const n of t.cesium.template)
    if (n.startsWith("style.")) {
      const r = o.get(t.cesium, n);
      if (typeof r == "string" && r.includes("Units")) return !0;
    }
  return !1;
}
function wh(e) {
  e = sn(e), e = o.pickBy(e, (n) => !o.isNil(n));
  const t = o.keys(e);
  let i;
  return t.length === 0 ? null : (t.length === 1 ? i = o.get(e, t[0]) : i = t.map((n) => n + ": " + o.get(e, n)).join(`
`), i);
}
const is = {
  stroke: "stroke",
  "stroke-color": "stroke",
  "stroke-opacity": "stroke.alpha",
  "stroke-width": "strokeWidth",
  fill: "fill",
  "fill-color": "fill",
  "fill-opacity": "fill.alpha",
  "marker-size": "markerSize",
  "marker-symbol": "markerSymbol",
  "marker-color": "markerColor"
}, C_ = o.values(is), _h = [
  "billboard",
  "box",
  "corridor",
  "cylinder",
  "ellipse",
  "ellipsoid",
  "label",
  "model",
  "path",
  "plane",
  "point",
  "polygon",
  "polyline",
  "rectangle",
  "wall"
], E_ = {
  Point: "point",
  LineString: "polyline",
  Polygon: "polygon"
}, Ys = {
  altitudeMode: "heightReference",
  width: "width",
  color: "material"
}, T_ = {
  clampToGround: "Cesium.HeightReference.CLAMP_TO_GROUND",
  relativeToGround: "Cesium.HeightReference.RELATIVE_TO_GROUND",
  absolute: "Cesium.HeightReference.NONE"
};
function Ta(e, t) {
  if (!e) return {};
  const i = t ? e : {};
  return o.forOwn(e, (n, r) => {
    if (o.has(is, r)) {
      const s = o.get(is, r);
      typeof n == "string" && ["markerColor", "fill", "stroke"].includes(s) ? (n = Ut(n), o.set(i, s, pi.fromCssColorString(Pt(n).alpha(o.get(i, [s, "alpha"], 1)).css()))) : o.set(i, s, n), t && o.unset(e, r);
    }
  }), i;
}
function Lh(e, t) {
  let i = o.get(e, "style", !1);
  if (!i || !o.get(e, "geometry")) return {};
  let n = o.get(E_, o.get(e, "geometry.type"));
  if (!n) return {};
  const r = n === "point" ? li(e.properties) : n === "polyline" ? ci(e.properties) : ui(e.properties);
  i = Object.assign({}, i, r);
  const s = {}, a = {};
  return (o.get(t, "cesium.minZoom") || o.get(t, "cesium.maxZoom")) && (a.distanceDisplayCondition = {
    type: "Cesium.DistanceDisplayCondition",
    options: [
      o.get(t, "cesium.minZoom", 0) || 0,
      o.get(t, "cesium.maxZoom", Number.MAX_VALUE) || Number.MAX_VALUE
    ]
  }), o.forOwn(i, (l, c) => {
    if (typeof l == "string" && ["color"].includes(c)) {
      let u = pi.fromCssColorString(Nr(l));
      o.has(i, "opacity") && (u = pi.fromAlpha(u, o.get(i, "opacity"))), o.set(a, o.get(Ys, c), u);
    } else if (c === "altitudeMode")
      o.set(a, o.get(Ys, c), o.get(T_, l)), o.set(a, "clampToGround", l === "clampToGround");
    else if (c === "extrude")
      switch (n) {
        case "polygon":
          o.set(a, "extrudedHeight", 0), o.set(a, "perPositionHeight", !0);
          break;
        case "polyline":
          n = "wall";
          break;
      }
    else if (c === "icon")
      n = "billboard", o.set(a, "image", o.get(l, "url"));
    else {
      const u = o.get(Ys, c);
      u && o.set(a, u, l);
    }
  }), n === "polygon" && !o.has(i, "extrude") && (!o.has(i, "altitudeMode") || i.altitudeMode === "clampToGround") && (o.set(a, "perPositionHeight", !1), o.get(e, "geometry.coordinates[0][0]", []).length < 3 && o.forEach(o.get(e, "geometry.coordinates", []), (l, c) => {
    e.geometry.coordinates[c] = o.map(l, (u) => [u[0], u[1], 0]);
  }), o.get(i, "opacity") === 0 && (n = "polyline", o.set(s, "geometry.type", "LineString"), o.set(s, "geometry.coordinates", o.get(e, "geometry.coordinates[0]")), o.set(s, "style.opacity", o.get(i, "stroke.opacity", 1)), o.set(a, "clampToGround", !0))), o.set(s, ["properties", "entityStyle", n], a), o.defaultsDeep(s.properties.entityStyle, o.get(e, "properties.entityStyle", {})), s;
}
function Pa(e, t, i, n) {
  if (!i) return;
  const r = i.cesium || i, s = Object.assign({ properties: t.properties, feature: t, chroma: Pt, moment: fe, Units: be, Time: pe }, us.get());
  r.template && (i.variables && (s.variables = o.reduce(
    i.variables,
    (l, c) => Object.assign(l, { [c.name]: c }),
    {}
  )), r.template.forEach((l) => {
    o.set(e, o.get(n, o.kebabCase(l.property), l.property), l.compiler(s));
  }));
  const a = an(t);
  return o.get(e, `style.${a}.visibility`, o.get(e, "style.visibility", !0)), e;
}
function xh(e, t, i, n = "style.point") {
  const r = o.get(i, n, {}), s = t ? o.get(t.cesium || t, "layerPointStyle") : {}, a = Pa({ style: { point: o.merge({}, r, s) } }, e, t, na), l = o.get(t, "ignoreFeatureStyle") ? {} : o.get(e, "style", {}), c = o.merge({}, r, s, a ? a.style.point : {}, l);
  return gs(Qd(c));
}
function Sh(e, t, i, n = "style.line") {
  const r = o.get(i, n, {}), s = t ? o.get(t.cesium || t, "layerLineStyle") : {}, a = Pa({ style: { line: o.merge({}, r, s) } }, e, t, ra), l = o.get(t, "ignoreFeatureStyle") ? {} : o.get(e, "style", {}), c = o.merge({}, r, s, a ? a.style.line : {}, l);
  return gs(aa(c));
}
function Ch(e, t, i, n = "style.polygon") {
  const r = o.get(i, n, {}), s = t ? o.get(t.cesium || t, "layerPolygonStyle") : {}, a = Pa({ style: { polygon: o.merge({}, r, s) } }, e, t, sa), l = o.get(t, "ignoreFeatureStyle") ? {} : o.get(e, "style", {}), c = o.merge({}, r, s, a ? a.style.polygon : {}, l);
  return gs(Yd(c));
}
function Ci() {
  const e = Array.from(arguments), t = e[0];
  e.shift();
  const i = o.get(zt, t);
  let n;
  if (typeof i == "function") {
    try {
      n = i(...e);
    } catch {
    }
    try {
      n = new i(...e);
    } catch {
    }
  } else n = i;
  return n;
}
function Fn(e) {
  const t = (i) => {
    if (typeof i == "object") {
      const n = i.type, r = i.options;
      if (n && r) {
        const s = n.replace("Cesium.", "");
        let a;
        return r.type ? (a = Fn({ object: r }), a = a.object) : a = Fn(r), Array.isArray(r) ? Ci(s, ...a) : Ci(s, a);
      } else return Fn(i);
    } else if (typeof i == "string") {
      if (i.startsWith("Cesium.")) {
        const r = i.replace("Cesium.", "");
        return Ci(r);
      }
      const n = o.toNumber(i);
      o.isFinite(n) && (i = n);
    }
    return i;
  };
  return typeof e == "object" ? Array.isArray(e) ? e.map(t) : o.mapValues(e, t) : o.mapValues({ value: e }, t).value;
}
async function wo(e) {
  const t = [];
  if (e.values.length === 0) return { type: "FeatureCollection", features: t };
  if (o.forEach(e.values, (r) => {
    r.feature && t.push(r.feature);
  }), t.length > 0) return { type: "FeatureCollection", features: t };
  const i = await Fc({ entities: e, modelCallback: () => "" }), n = new DOMParser();
  return Mc(n.parseFromString(i.kml, "application/xml"));
}
window.CESIUM_BASE_URL = "/Cesium/";
Dc.setBaseUrl("/Cesium/");
const P_ = {
  emits: [
    "globe-ready",
    "layer-added",
    "layer-removed",
    "layer-shown",
    "layer-hidden"
  ],
  data() {
    return {
      layers: {}
    };
  },
  methods: {
    refreshGlobe() {
    },
    setupGlobe(e, t, i = {}) {
      this.viewerOptions = o.defaults(i, o.get(this, "activityOptions.engine.viewer", {}), {
        sceneMode: 3,
        // SceneMode.COLUMBUS_VIEW = 1, SceneMode.SCENE3D = 3,
        sceneModePicker: !1,
        infoBox: !1,
        scene3DOnly: !0,
        homeButton: !1,
        geocoder: !1,
        navigationHelpButton: !1,
        baseLayer: !1,
        baseLayerPicker: !1,
        vrButton: !1,
        fullscreenButton: !1,
        animation: !1,
        timeline: !1,
        depthTestAgainstTerrain: !1,
        cameraMoveEventPercentage: 0.2,
        entityLoadTextureDelay: 24
      }), t ? Da.defaultAccessToken = t : Da.defaultAccessToken = "", Object.assign(this.viewerOptions, {
        imageryProviderViewModels: [],
        terrainProviderViewModels: []
      }), this.viewer = new um(e, this.viewerOptions), this.viewer.scene.globe.depthTestAgainstTerrain = o.get(this.viewerOptions, "depthTestAgainstTerrain", !1);
      const n = o.get(this.viewerOptions, "backgroundColor");
      if (this.viewer.scene.backgroundColor = n ? Ci("Color", ...n) : pi.BLACK, this.viewer.scene.globe) {
        const r = o.get(this.viewerOptions, "baseColor");
        this.viewer.scene.globe.baseColor = r ? Ci("Color", ...r) : pi.BLACK;
        const s = o.get(this.viewerOptions, "undergroundColor");
        this.viewer.scene.globe.undergroundColor = s ? Ci("Color", ...s) : pi.BLACK;
      }
      o.has(zt.Primitive.prototype, "pickIds") || Object.defineProperties(zt.Primitive.prototype, {
        pickIds: {
          get: function() {
            return this._pickIds;
          },
          set: function(r) {
            this._pickIds = r;
          }
        }
      }), this.viewer.scene.preRender.addEventListener(() => {
        this.cesiumMaterials && o.forEach(this.cesiumMaterials, (r) => {
          if (!r.material.uniforms.offset) return;
          r.startTime || (r.startTime = Date.now());
          const s = (Date.now() - r.startTime) * 1e-3;
          if (r.animationSpeed) {
            const a = r.length / r.material.uniforms.repeat.x / r.animationSpeed;
            r.material.uniforms.offset.x = s % a / a;
          }
        });
      }), this.viewerOptions.debug && this.viewer.extend(dm), this.viewer.scene.imageryLayers && this.viewer.scene.imageryLayers.removeAll(), this.registerCesiumHandler(this.getDefaultPickHandler, "MOUSE_MOVE"), this.registerCesiumHandler(this.getDefaultPickHandler, "LEFT_CLICK"), this.registerCesiumHandler(this.getDefaultPickHandler, "RIGHT_CLICK"), this.viewer.camera.moveStart.addEventListener(this.onCameraMoveStart), this.viewer.camera.moveEnd.addEventListener(this.onCameraMoveEnd), this.viewer.camera.percentageChanged = this.viewerOptions.cameraMoveEventPercentage, this.viewer.camera.changed.addEventListener(this.onCameraChanged), this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(rr.LEFT_CLICK), this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(rr.LEFT_DOUBLE_CLICK), this.viewBounds = new Fa(), this.onGlobeReady();
    },
    onGlobeReady() {
      this.$emit("globe-ready", "cesium"), this.$engineEvents.emit("globe-ready", "cesium");
    },
    processCesiumLayerOptions(e) {
      const t = o.cloneDeep(e);
      return t.cesium.iconUrl = Dc(t.iconUrl), t.cesium.name = t.name, t.cesium.attribution = t.attribution, t;
    },
    async createCesiumLayer(e) {
      let t = e.cesium || e;
      t = this.convertToCesiumObjects(t);
      let i = [t], n, r, s;
      t.type === "3DTileset" ? (n = r = "Cesium3DTileset.fromUrl", i = [t.url].concat([o.omit(t, ["url", "style"])])) : wi(t) ? t.type === "Ellipsoid" ? n = "EllipsoidTerrainProvider" : t.url || t.assetId ? (n = r = t.url ? "CesiumTerrainProvider.fromUrl" : "CesiumTerrainProvider.fromIonAssetId", i = [t.url || t.assetId].concat([o.omit(t, ["url", "assetId"])])) : n = r = "createWorldTerrainAsync" : (n = t.type, r = `create${n}Async`, o.get(zt, r) ? n = r : (s = !0, n += "ImageryProvider", r = `${n}.fromUrl`, o.get(zt, r) && (n = r, i = [t.url].concat([o.omit(t, ["url"])]))));
      const a = o.get(zt, n);
      if (a)
        return n === r ? n = await a(...i) : n = new a(...i), t.type === "3DTileset" && o.has(t, "style") && (n.style = o.get(t, "style")), s ? new nr(n) : n;
    },
    registerCesiumConstructor(e) {
      this.cesiumFactory.push(e);
    },
    registerCesiumHandler(e, t) {
      this.cesiumHandler || (this.cesiumHandler = new cm(this.viewer.scene.canvas));
      const i = yh(t);
      this.cesiumHandler.setInputAction(
        (n) => e(Object.assign(n, { originalEvent: i })),
        rr[t]
      );
    },
    unregisterCesiumHandler(e) {
      this.cesiumHandler.removeInputAction(rr[e]);
    },
    async createLayer(e) {
      const t = this.processCesiumLayerOptions(e);
      let i;
      for (let n = 0; n < this.cesiumFactory.length; n++) {
        const r = this.cesiumFactory[n];
        if (i = await r(t), i) break;
      }
      return i = i || await this.createCesiumLayer(t), i.processedOptions = t, i;
    },
    hasLayer(e) {
      return o.has(this.layers, e);
    },
    isLayerVisible(e) {
      const t = this.getLayerByName(e);
      if (!t) return !1;
      const i = this.getCesiumLayerByName(e);
      return wi(t) ? this.viewer.terrainProvider === i : i instanceof nr ? this.viewer.scene.imageryLayers.contains(i) : i instanceof xn ? this.viewer.scene.primitives.contains(i) && i.show : this.viewer.dataSources.contains(i);
    },
    isLayerDisabled(e) {
      return !1;
    },
    getLayerByName(e) {
      return this.layers[e];
    },
    getCesiumLayerByName(e) {
      return this.cesiumLayers[e];
    },
    getLayerById(e) {
      const t = this.getLayers({ _id: e });
      return o.get(t, "[0]");
    },
    getLayers(e = {}) {
      return o.values(this.layers).filter(Pe(e));
    },
    hasLayers(e = {}) {
      return o.values(this.layers).filter(Pe(e)).length > 0;
    },
    async showLayer(e) {
      const t = this.getLayerByName(e);
      if (!t || this.isLayerVisible(e)) return;
      let i = this.getCesiumLayerByName(e);
      if (!i)
        try {
          i = await this.createLayer(t);
        } catch (n) {
          z.error(n);
          return;
        }
      if (this.cesiumLayers[e] = i, wi(t))
        this.viewer.terrainProvider = i;
      else if (i instanceof nr)
        this.viewer.scene.imageryLayers.add(i);
      else if (i instanceof xn)
        i.show = !0, this.viewer.scene.primitives.contains(i) || this.viewer.scene.primitives.add(i);
      else {
        for (const [n, r] of i.primitives)
          r.primitive.show = !0;
        this.viewer.dataSources.add(i);
      }
      t.isVisible = !0, this.onLayerShown(t, i);
    },
    onLayerShown(e, t) {
      this.$emit("layer-shown", e, t), this.$engineEvents.emit("layer-shown", e, t);
    },
    hideLayer(e) {
      const t = this.getLayerByName(e);
      if (!t || !this.isLayerVisible(e)) return;
      t.isVisible = !1;
      const i = this.cesiumLayers[e];
      if (delete this.cesiumLayers[e], wi(t))
        this.viewer.terrainProvider = null;
      else if (i instanceof nr)
        this.viewer.scene.imageryLayers.remove(i, !1);
      else if (i instanceof xn)
        i.show = !1;
      else {
        for (const [n, r] of i.primitives)
          r.primitive.show = !1;
        this.viewer.dataSources.remove(i, !0);
      }
      this.onLayerHidden(t, i);
    },
    onLayerHidden(e, t) {
      this.$emit("layer-hidden", e, t), this.$engineEvents.emit("layer-hidden", e, t);
    },
    async addLayer(e) {
      return e && !this.hasLayer(e.name) && (e.isVisible = !1, e.isDisabled = this.isLayerDisabled(e), this.layers[e.name] = e, this.onLayerAdded(e), o.get(e, "cesium.isVisible", !1) && await this.showLayer(e.name)), e;
    },
    onLayerAdded(e) {
      this.$emit("layer-added", e), this.$engineEvents.emit("layer-added", e);
    },
    async addGeoJsonLayer(e, t, i) {
      ba(e, t) && (await this.addLayer(e), await this.updateLayer(e.name, t), i && (t.bbox ? this.zoomToBBox(t.bbox) : this.zoomToLayer(e.name)));
    },
    renameLayer(e, t) {
      const i = this.getLayerByName(e), n = this.getCesiumLayerByName(e);
      i && (n && (this.cesiumLayers[t] = n, delete this.cesiumLayers[e]), this.layers[t] = i, delete this.layers[e]);
    },
    removeLayer(e) {
      const t = this.getLayerByName(e);
      if (!t) return;
      this.hideLayer(e);
      const i = this.cesiumLayers[e];
      i instanceof xn && this.viewer.scene.primitives.remove(i), delete this.layers[t.name], delete this.cesiumLayers[e], this.onLayerRemoved(t);
    },
    onLayerRemoved(e) {
      this.$emit("layer-removed", e), this.$engineEvents.emit("layer-removed", e);
    },
    clearLayers() {
      Object.keys(this.layers).forEach((e) => this.removeLayer(e));
    },
    async toGeoJson(e) {
      if (!this.isLayerVisible(e)) {
        const n = this.geojsonCache[e];
        if (n) return n;
      }
      const t = this.getCesiumLayerByName(e);
      return t.entities ? await wo(t.entities) : void 0;
    },
    zoomToBounds(e, t = 0, i = -90, n = 0, r = 0) {
      this.viewer.camera.flyTo({
        destination: Array.isArray(e) ? Fa.fromDegrees(e[0][1], e[0][0], e[1][1], e[1][0]) : e,
        orientation: {
          heading: Ee.toRadians(t),
          pitch: Ee.toRadians(i),
          roll: Ee.toRadians(n)
        },
        duration: r
      });
    },
    zoomToBBox(e, t = 0, i = -90, n = 0, r = 0) {
      this.zoomToBounds([[e[1], e[0]], [e[3], e[2]]], t, i, n, r);
    },
    zoomToLayer(e) {
      const t = this.getCesiumLayerByName(e);
      if (t)
        if (t.entities)
          this.viewer.flyTo(t.entities, { duration: 0 });
        else {
          const i = o.get(t, "bbox");
          if (i)
            this.zoomToBBox(i);
          else {
            const n = o.get(t, "cesium.rectangle", [[-90, -180], [90, 180]]);
            this.zoomToBounds(n);
          }
        }
    },
    center(e, t, i, n = 0, r = -90, s = 0, a = {}) {
      const l = this.viewer.camera.positionCartographic, c = o.get(a, "duration", 0), u = mn.fromDegrees(e, t, i || l.height), d = new Ln(
        Ee.toRadians(n),
        Ee.toRadians(r),
        Ee.toRadians(s)
      ), f = new mn(
        o.get(a, "offset.x", 0),
        o.get(a, "offset.y", 0),
        o.get(a, "offset.z", 0)
      ), h = new Ln(
        Ee.toRadians(o.get(a, "offset.heading", 0)),
        Ee.toRadians(o.get(a, "offset.pitch", 0)),
        Ee.toRadians(o.get(a, "offset.roll", 0))
      ), g = {
        destination: u,
        orientation: {
          heading: d.heading,
          pitch: d.pitch,
          roll: d.roll
        },
        duration: c
      };
      if (c ? this.viewer.camera.flyTo(g) : this.viewer.camera.setView(g), this.viewer.camera.move(this.viewer.camera.right, f.x), this.viewer.camera.move(this.viewer.camera.direction, f.y), this.viewer.camera.move(this.viewer.camera.up, f.z), this.viewer.camera.look(this.viewer.camera.up, h.heading), this.viewer.camera.look(this.viewer.camera.direction, h.pitch), this.viewer.camera.look(this.viewer.camera.right, h.roll), this.viewerOptions.debug) {
        const v = qi.headingPitchRollQuaternion(u, d, vr.WGS84, qi.eastNorthUpToFixedFrame), x = qi.headingPitchRollQuaternion(
          this.viewer.camera.positionWC,
          new Ln(this.viewer.camera.heading, this.viewer.camera.pitch, this.viewer.camera.roll),
          vr.WGS84,
          qi.eastNorthUpToFixedFrame
        );
        this.baseFrameDebug ? (this.baseFrameDebug.modelMatrix = tr.fromRotationTranslation(ir.fromQuaternion(v), u), this.finalFrameDebug.modelMatrix = tr.fromRotationTranslation(ir.fromQuaternion(x), this.viewer.camera.positionWC)) : (this.baseFrameDebug = new ks({
          modelMatrix: tr.fromRotationTranslation(ir.fromQuaternion(v), u),
          length: 25,
          width: 5
        }), this.viewer.scene.primitives.add(this.baseFrameDebug), this.finalFrameDebug = new ks({
          modelMatrix: tr.fromRotationTranslation(ir.fromQuaternion(x), this.viewer.camera.positionWC),
          length: 25,
          width: 5
        }), this.viewer.scene.primitives.add(this.finalFrameDebug)), this.cameraDebug && this.viewer.scene.primitives.remove(this.cameraDebug), this.cameraDebug = new lm({
          camera: this.viewer.camera,
          color: zt.Color.YELLOW,
          updateOnChange: !1
        }), this.viewer.scene.primitives.add(this.cameraDebug);
      }
    },
    getCenter() {
      const e = this.viewer.camera.positionCartographic;
      return {
        longitude: Ee.toDegrees(e.longitude),
        latitude: Ee.toDegrees(e.latitude),
        altitude: e.height
      };
    },
    getBounds() {
      const e = this.viewer.camera.computeViewRectangle(this.viewer.scene.globe.ellipsoid, this.viewBounds), t = Ee.toDegrees(e.south), i = Ee.toDegrees(e.west), n = Ee.toDegrees(e.north), r = Ee.toDegrees(e.east);
      return [[t, i], [n, r]];
    },
    getCamera() {
      const e = this.viewer.camera.positionCartographic;
      return {
        longitude: Ee.toDegrees(e.longitude),
        latitude: Ee.toDegrees(e.latitude),
        altitude: e.height,
        heading: Ee.toDegrees(this.viewer.camera.heading),
        pitch: Ee.toDegrees(this.viewer.camera.pitch),
        roll: Ee.toDegrees(this.viewer.camera.roll),
        fovy: this.viewer.camera.frustum.fovy,
        viewMatrix: this.viewer.camera.viewMatrix,
        inverseViewMatrix: this.viewer.camera.inverseViewMatrix
      };
    },
    getAnimatedHeading(e) {
      this.headingAnimation.startTime || (this.headingAnimation.startTime = e);
      const { duration: t, startTime: i, easing: n, startHeading: r, endHeading: s } = this.headingAnimation, a = e - i, l = Math.abs(a / (1e3 * t));
      if (l > 1)
        return s;
      const c = o.get(n, "function", "cubicBezier"), u = o.get(n, "parameters", []), d = Hi[c](l, ...u);
      return Ee.lerp(
        r,
        s,
        d
      );
    },
    onEntityTracked(e) {
      const t = (g, v) => {
        let x = (v - g + Math.PI) % (2 * Math.PI);
        return x < 0 && (x += 2 * Math.PI), x - Math.PI;
      };
      if (this.viewerOptions.debug && (this.trackedFrameDebug ? this.trackedFrameDebug.modelMatrix = this.viewer.trackedEntity.computeModelMatrix(e) : (this.trackedFrameDebug = new ks({
        modelMatrix: this.viewer.trackedEntity.computeModelMatrix(e),
        length: 25,
        width: 5
      }), this.viewer.scene.primitives.add(this.trackedFrameDebug))), !this.viewer.trackedEntity || !o.get(this.entityTrackingOptions, "mode")) return;
      const i = this.entityTrackingOptions.mode, n = Date.now();
      if (i === "freeLook" && !o.get(this.entityTrackingOptions, "resetHeading")) return;
      const r = this.viewer.trackedEntity.position.getValue(e), s = this.viewer.trackedEntity.orientation.getValue(e);
      if (!s) return;
      const a = o.get(this.entityTrackingOptions, "distance", 10), l = Ee.toRadians(o.get(this.entityTrackingOptions, "offset.heading", 0)), c = Ee.toRadians(o.get(this.entityTrackingOptions, "offset.pitch", 0)), u = Ln.fromQuaternion(s);
      o.get(this.entityTrackingOptions, "animate") && (this.headingAnimation ? i === "followOrientation" && (this.headingAnimation.endHeading = this.headingAnimation.startHeading + t(this.headingAnimation.startHeading, u.heading)) : (this.headingAnimation = {
        ...this.entityTrackingOptions,
        startTime: n,
        startHeading: this.viewer.camera.heading - l,
        endHeading: i === "freeLook" ? 0 - l : u.heading
      }, this.headingAnimation.endHeading = this.headingAnimation.startHeading + t(this.headingAnimation.startHeading, this.headingAnimation.endHeading)));
      let d = 0;
      o.get(this.entityTrackingOptions, "animate") ? (d = this.getAnimatedHeading(n), d === this.headingAnimation.endHeading && (o.set(this.entityTrackingOptions, "animate", !1), o.set(this.entityTrackingOptions, "resetHeading", !1), this.headingAnimation = null)) : i === "followOrientation" && (d = u.heading);
      const f = new mn(
        r.x + o.get(this.entityTrackingOptions, "offset.x", 0),
        r.y + o.get(this.entityTrackingOptions, "offset.y", 0),
        r.z + o.get(this.entityTrackingOptions, "offset.z", 0)
      ), h = new am(
        d + l,
        c,
        a
      );
      this.viewer.camera.lookAt(new mn(f.x, f.y, f.z), h);
    },
    trackEntity(e, t = {}) {
      let i = null;
      this.viewer.entities.values.forEach((n) => {
        e === n.id && (i = n);
      });
      for (let n = 0; n < this.viewer.dataSources.length; n++)
        this.viewer.dataSources.get(n).entities.values.forEach((s) => {
          e === s.id && (i = s);
        });
      i && (this.entityTrackingOptions = t, o.set(this.entityTrackingOptions, "animate", !0), i !== this.viewer.trackedEntity && (this.untrackEntity(), this.viewer.trackedEntity = i, this.viewer.clock.onTick.addEventListener(this.onEntityTracked)));
    },
    untrackEntity() {
      this.viewer.trackedEntity && (this.trackedFrameDebug && this.viewer.scene.primitives.remove(this.trackedFrameDebug), this.viewer.clock.onTick.removeEventListener(this.onEntityTracked)), this.viewer.trackedEntity = null;
    },
    async showUserLocation() {
      if (ot.hasLocation()) {
        const e = ot.getLongitude(), t = ot.getLatitude();
        this.center(e, t);
        const n = await new sm().fromMakiIconId("marker", pi.fromCssColorString(Eo("primary")), 48);
        this.userLocationEntity = this.viewer.entities.add({
          name: "user-location",
          position: mn.fromDegrees(e, t),
          billboard: {
            image: n.toDataURL(),
            verticalOrigin: om.BOTTOM
          }
        }), this.viewer.selectedEntity = this.userLocationEntity, this.userLocation = !0;
      }
    },
    hideUserLocation() {
      this.userLocationEntity && (this.viewer.entities.remove(this.userLocationEntity), this.userLocationEntity = null), this.userLocation = !1;
    },
    isUserLocationVisible() {
      return this.userLocation;
    },
    setCursor(e) {
      this.viewer.container.classList.add(e);
    },
    isCursor(e) {
      return this.viewer.container.classList.contains(e);
    },
    unsetCursor(e) {
      this.viewer.container.classList.remove(e);
    },
    getLayerNameForEntity(e) {
      let t;
      return o.forOwn(this.cesiumLayers, (i, n) => {
        !t && i.entities && i.entities.contains(e) && (t = n);
      }), t;
    },
    getNbChildrenForEntity(e) {
      return e._children ? e._children.length : 0;
    },
    getChildForEntity(e, t) {
      if (this.getNbChildrenForEntity(e) > 0) return e._children[t || 0];
    },
    getPositionForEntity(e) {
      let t = e.position;
      return t || (e.polygon ? t = Ps.fromPoints(e.polygon.hierarchy.getValue().positions).center : e.polyline ? t = Ps.fromPoints(e.polyline.positions.getValue()).center : e.wall && (t = Ps.fromPoints(e.wall.positions.getValue()).center), t && vr.WGS84.scaleToGeodeticSurface(t, t)), t;
    },
    async getDefaultPickHandler(e) {
      const t = {};
      let i, n = this.viewer.camera.pickEllipsoid(e.endPosition || e.position, this.viewer.scene.globe.ellipsoid);
      if (n) {
        t.pickedPosition = n, n = Ma.fromCartesian(n);
        const s = Ee.toDegrees(n.longitude), a = Ee.toDegrees(n.latitude);
        t.latlng = [a, s], t.latlng.lng = s, t.latlng.lat = a;
      }
      const r = this.viewer.scene.pick(e.endPosition || e.position);
      if (r && (t.target = r.id || r.primitive.id, t.target instanceof nm)) {
        if (!t.target.feature) {
          let a = {
            _id: t.target.id,
            type: "Feature"
          };
          if (typeof Fc == "function") {
            const l = new rm();
            l.add(t.target);
            const c = await wo(l);
            c.features.length > 0 && Object.assign(a, c.features[0]);
          }
          if (!a.geometry) {
            const l = Ma.fromCartesian(t.target.position ? t.target.position.getValue(0) : t.pickedPosition);
            a.geometry = {
              type: "Point",
              coordinates: [Ee.toDegrees(l.longitude), Ee.toDegrees(l.latitude)]
            };
          }
          a.properties = t.target.properties ? t.target.properties.getValue(0) : {}, t.target.feature = a;
        }
        let s = this.getLayerNameForEntity(t.target);
        s && (s = this.getCesiumLayerByName(s)), s && (i = s.processedOptions);
      }
      this.$engineEvents.emit(e.originalEvent.name, i, t);
    },
    getCameraEllipsoidTarget() {
      const e = new zt.Cartesian2(this.viewer.container.clientWidth / 2, this.viewer.container.clientHeight / 2), t = this.viewer.camera.pickEllipsoid(e);
      if (!t) return null;
      const i = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(t);
      return {
        longitude: Ee.toDegrees(i.longitude),
        latitude: Ee.toDegrees(i.latitude),
        altitude: i.height
      };
    },
    onCameraMoveStart() {
      let e = this.getCameraEllipsoidTarget();
      e && (e = { latlng: { lng: e.longitude, lat: e.latitude }, altitude: e.altitude }), this.$engineEvents.emit("movestart", this.viewerOptions, e);
    },
    onCameraMoveEnd() {
      let e = this.getCameraEllipsoidTarget();
      e && (e = { latlng: { lng: e.longitude, lat: e.latitude }, altitude: e.altitude }), this.$engineEvents.emit("moveend", this.viewerOptions, e);
    },
    onCameraChanged() {
      let e = this.getCameraEllipsoidTarget();
      e && (e = { latlng: { lng: e.longitude, lat: e.latitude }, altitude: e.altitude }), this.$engineEvents.emit("move", this.viewerOptions, e);
    },
    getPostProcessStage(e) {
      return this.cesiumPostProcessStages[e];
    },
    setupPostProcess(e, t = { enabled: !0 }) {
      let i = this.cesiumPostProcessStages[e];
      if (t.enabled) {
        if (!i && e === "desaturation") {
          const n = `
    uniform sampler2D colorTexture;
    in vec2 v_textureCoordinates;
    void main() {
        vec4 color = texture(colorTexture, v_textureCoordinates);
        if (czm_selected()) {
            out_FragColor = color;
        } else {
            out_FragColor = vec4(czm_saturation(color.rgb, 0.0), color.a);
        }
    }
    `;
          i = this.viewer.scene.postProcessStages.add(new zt.PostProcessStage({ fragmentShader: n })), i.selected = [], this.cesiumPostProcessStages[e] = i;
        }
      } else
        i && (this.viewer.scene.postProcessStages.remove(i), delete this.cesiumPostProcessStages[e]);
    }
  },
  created() {
    this.cesiumLayers = {}, this.cesiumFactory = [], this.cesiumMaterials = [], this.cesiumPostProcessStages = {}, this.userLocation = !1, this.$engineEvents = new Co();
  },
  beforeUnmount() {
    this.clearLayers(), this.viewer.camera.moveStart.removeEventListener(this.onCameraMoveStart), this.viewer.camera.moveEnd.removeEventListener(this.onCameraMoveEnd), this.unregisterCesiumHandler("MOUSE_MOVE"), this.unregisterCesiumHandler("LEFT_CLICK"), this.unregisterCesiumHandler("RIGHT_CLICK");
  },
  unmounted() {
    this.viewer.destroy();
  }
}, yr = ["wall", "corridor", "stroke"];
function ji(e, t) {
  return `${e}-${t}`;
}
function k_(e, t) {
  const i = `-${t}`;
  return e.endsWith(i) ? e.slice(0, -i.length) : "";
}
function vc(e, t, i, n, r) {
  const s = t.primitives.get(i);
  s && setTimeout(() => {
    e.viewer.scene.primitives.remove(s.primitive);
    const a = e.cesiumMaterials.indexOf(s.material);
    e.cesiumMaterials.splice(a, 1);
  }, e.viewerOptions.entityLoadTextureDelay), t.primitives.set(i, { primitive: n, material: r }), e.viewer.scene.primitives.add(n), e.cesiumMaterials.push(r), setTimeout(() => {
    r.material.uniforms.opacity = 1;
  }, e.viewerOptions.entityLoadTextureDelay);
}
function bc(e, t, i) {
  const n = t.primitives.get(i);
  if (n) {
    e.viewer.scene.primitives.remove(n.primitive);
    const r = e.cesiumMaterials.indexOf(n.material);
    e.cesiumMaterials.splice(r, 1), t.primitives.delete(i);
  }
}
const M_ = {
  emits: [
    "layer-updated"
  ],
  methods: {
    convertFromSimpleStyleOrDefaults(e) {
      let { stroke: t, strokeWidth: i, fill: n } = Ta(e);
      return t || (t = gn.stroke), i || (i = gn.strokeWidth), n || (n = gn.fill), { stroke: t, strokeWidth: i, fill: n };
    },
    async loadGeoJson(e, t, i, n = {}) {
      const r = i.cesium, s = Ie(t);
      if (o.get(n, "remove", !1)) {
        s.forEach((d) => {
          const f = st(d, i);
          yr.forEach((h) => {
            const g = ji(f, h);
            e.entities.getById(f) && e.entities.removeById(f), e.entities.getById(g) && e.entities.removeById(g), bc(this, e, g);
          });
        });
        return;
      }
      const a = new gn();
      a.notFromDrop = !0, await a.load(t, r);
      let l = a.entities.values;
      if (l.forEach((d) => {
        d.feature = s.find((h) => st(h, i) === d.id);
        const f = e.entities.getById(d.id);
        f ? vh(d, f) : e.entities.add(d);
      }), o.get(n, "removeMissing", r.removeMissing)) {
        const d = [];
        e.entities.values.forEach((f) => {
          const h = f.id;
          a.entities.getById(h) || d.push(h), yr.forEach((g) => {
            const v = ji(h, g);
            e.entities.getById(v) && d.push(v);
          });
        }), d.forEach((f) => e.entities.removeById(f));
        for (const f of e.primitives.keys())
          yr.forEach((h) => {
            const g = k_(f, h);
            g && !a.entities.contains(g) && bc(this, e, f);
          });
      }
      l = e.entities.values;
      const c = [], u = [];
      for (let d = 0; d < l.length; d++) {
        const f = l[d], h = f.properties.getValue(0), g = o.get(h, "radius"), v = o.get(h, "geodesic");
        if (g && v) {
          const { stroke: y, strokeWidth: S, fill: C } = this.convertFromSimpleStyleOrDefaults(h);
          c.push({
            id: f.id,
            position: f.position.getValue(0),
            name: f.name ? f.name : f.id,
            description: f.description.getValue(0),
            properties: f.properties.getValue(0),
            ellipse: {
              semiMinorAxis: g,
              semiMajorAxis: g,
              material: new Ms(C),
              outlineColor: new ei(y),
              outlineWidth: S,
              outline: new ei(!0)
            },
            feature: f.feature
          }), u.push(f);
        }
        if ((o.get(h, "wall") || o.get(h, "entityStyle.wall")) && f.polyline) {
          const { stroke: y, strokeWidth: S, fill: C } = this.convertFromSimpleStyleOrDefaults(h), T = ji(f.id, "wall");
          if (o.get(h, "entityStyle.wall.material.image") && o.get(h, "entityStyle.wall.animateMaterialAlongPath", !1)) {
            const I = o.get(h, "entityStyle.wall");
            I.positions = f.polyline.positions.getValue(0);
            const { primitive: A, material: P } = vo("wall", I);
            A && vc(this, e, T, A, P), u.push(f);
          } else
            c.push({
              id: T,
              parent: f,
              name: f.name ? f.name : T,
              description: f.description.getValue(0),
              properties: f.properties.getValue(0),
              wall: {
                positions: f.polyline.positions.getValue(0),
                material: new Ms(C),
                outlineColor: new ei(y),
                outlineWidth: S,
                outline: new ei(!0)
              },
              feature: f.feature
            }), u.push(f);
        }
        if ((o.get(h, "corridor") || o.get(h, "entityStyle.corridor")) && f.polyline) {
          const { stroke: y, strokeWidth: S, fill: C } = this.convertFromSimpleStyleOrDefaults(h), T = ji(f.id, "corridor");
          if (o.get(h, "entityStyle.corridor.material.image") && o.get(h, "entityStyle.corridor.animateMaterialAlongPath", !1)) {
            const I = o.get(h, "entityStyle.corridor");
            I.positions = f.polyline.positions.getValue(0);
            const { primitive: A, material: P } = vo("corridor", I);
            A && vc(this, e, T, A, P), u.push(f);
          } else
            c.push({
              id: T,
              parent: f,
              name: f.name ? f.name : T,
              description: f.description.getValue(0),
              properties: f.properties.getValue(0),
              corridor: {
                positions: f.polyline.positions.getValue(0),
                material: new Ms(C),
                outlineColor: new ei(y),
                outlineWidth: S,
                outline: new ei(!0)
              },
              feature: f.feature
            }), u.push(f);
        }
        f.billboard && o.get(h, "marker-symbol") === "none" && u.push(f);
        const M = o.get(h, "icon-text") || o.get(h, "entityStyle.label.text"), p = o.get(h, "entityStyle.billboard.image");
        if (M) {
          const { stroke: y, strokeWidth: S, fill: C } = this.convertFromSimpleStyleOrDefaults(h);
          c.push({
            id: f.id,
            position: f.position.getValue(0),
            name: f.name ? f.name : f.id,
            description: f.description.getValue(0),
            properties: f.properties.getValue(0),
            label: {
              text: M,
              fillColor: new ei(C),
              outlineColor: new ei(y),
              outlineWidth: S
            },
            billboard: p ? { image: p } : void 0,
            feature: f.feature
          }), u.push(f);
        }
        if (o.get(f, "polygon") && o.get(h, "entityStyle.polygon.perPositionHeight") === !1) {
          const y = ji(f.id, "stroke"), { stroke: S, strokeWidth: C } = this.convertFromSimpleStyleOrDefaults(h);
          if (o.every(o.get(f, "feature.geometry.coordinates[0]", []), (k) => k.length > 2 && k[2] === 0)) {
            const k = {
              id: y,
              name: f.name ? f.name : y,
              description: f.description.getValue(0),
              properties: f.properties.getValue(0),
              polyline: {
                positions: f.polygon.hierarchy.getValue().positions,
                width: C,
                material: S,
                clampToGround: !0
              },
              feature: f.feature
            };
            c.push(k), e.entities.getById(k.id) && u.push(k);
          }
        }
      }
      u.forEach((d) => e.entities.remove(d)), c.forEach((d) => e.entities.add(d));
    },
    async updateGeoJsonData(e, t, i, n = {}) {
      const r = t.cesium, s = o.get(r, "source"), a = o.get(r, "sourceTemplate");
      try {
        if (i)
          t.processor && Jn(i, t.processor), await this.loadGeoJson(e, i, t, n);
        else if (t.probeService)
          await this.loadGeoJson(e, this.getProbeFeatures(t), t, n), await this.loadGeoJson(e, this.getFeatures(t), t, n);
        else if (t.service)
          await this.loadGeoJson(e, this.getFeatures(Object.assign({}, t, this.getLayerByName(t.name))), t, n);
        else if (a) {
          const l = e.sourceCompiler({ time: pe.getCurrentTime() });
          (!e.lastFetchedSource || e.lastFetchedSource !== l) && (e.lastFetchedSource = l, await this.loadGeoJson(e, si(l, t), t, n));
        } else o.isNil(s) || await this.loadGeoJson(e, si(s, t), t, n);
        this.applyStyle(e.entities, t), typeof this.applyTooltips == "function" && this.applyTooltips(e.entities, t);
      } catch (l) {
        z.error(l);
      }
    },
    async createCesiumRealtimeGeoJsonLayer(e, t) {
      const i = t.cesium;
      e.updateGeoJson = async (n, r) => {
        await this.updateGeoJsonData(e, t, n, r);
      }, o.has(i, "sourceTemplate") && (e.sourceCompiler = o.template(o.get(i, "sourceTemplate")));
    },
    async createCesiumGeoJsonLayer(e) {
      const t = e.cesium;
      if (t.type !== "geoJson") return;
      const i = o.get(this, "activityOptions.engine");
      e.processor = (u) => {
        !e.featureId && !u._id && (u._id = Gt().toString()), u.id = st(u, e);
        let d = an(u);
        if (o.has(u, "properties.entityStyle") && (o.has(u, "properties.entityStyle.wall") || o.has(u, "properties.entityStyle.corridor")) && (d = "polygon"), o.get(u, "style.extrude") && (d = "polygon"), !o.has(u, "style")) {
          const x = d === "point" ? li(u.properties) : d === "line" ? ci(u.properties) : ui(u.properties);
          o.set(u, "style", x);
        }
        const f = {
          point: xh(u, e, i),
          line: Sh(u, e, i),
          polygon: Ch(u, e, i)
        }, h = Object.assign(...Object.values(f), f[d]), g = o.get(u, "style.text.label");
        g && (h["icon-text"] = g), u.properties ? Object.assign(u.properties, h) : u.properties = h;
        const v = Lh(u, e);
        o.mergeWith(u, v, (x, w) => {
          if (o.isArray(x)) return w;
        });
      }, o.has(this, "activityOptions.engine.cluster") && (t.cluster ? Object.assign(t.cluster, o.get(this, "activityOptions.engine.cluster")) : t.cluster = Object.assign({}, o.get(this, "activityOptions.engine.cluster")));
      const n = o.get(t, "template");
      n && (t.template = n.map((u) => ({
        property: u,
        compiler: o.template(o.get(t, u))
      })));
      const r = o.get(t, "entityStyle.template");
      r && o.set(t, "entityStyleTemplate", r.map((u) => ({
        property: u,
        compiler: o.template(o.get(t, `entityStyle.${u}`))
      })));
      const s = o.get(t, "popup.template");
      s && (t.popup.compiler = o.template(s));
      const a = o.get(t, "tooltip.template");
      a && (t.tooltip.compiler = o.template(a)), t.style ? (t.layerPointStyle = o.get(t.style, "point"), t.layerLineStyle = o.get(t.style, "line"), t.layerPolygonStyle = o.get(t.style, "polygon")) : (t.layerPointStyle = li(t), t.layerLineStyle = ci(t), t.layerPolygonStyle = ui(t)), t.entityStyle && !r && (t.entityStyle = this.convertToCesiumObjects(t.entityStyle)), t.clusterStyle && (t.clusterStyle = this.convertToCesiumObjects(t.clusterStyle)), t.tooltip && (t.tooltip = this.convertToCesiumObjects(t.tooltip)), t.popup && (t.popup = this.convertToCesiumObjects(t.popup));
      let c = o.get(t, "source");
      if (c)
        for (let u = 0; u < this.viewer.dataSources.length; u++) {
          const d = this.viewer.dataSources.get(u);
          if (d.name === c) {
            c = d, this.viewer.dataSources.remove(d, !1);
            break;
          }
        }
      return !c || !c.name ? (c = new gn(), c.notFromDrop = !0, c.primitives = /* @__PURE__ */ new Map(), t.realtime && await this.createCesiumRealtimeGeoJsonLayer(c, e), this.updateGeoJsonData(c, e)) : (this.applyStyle(c.entities, e), typeof this.applyTooltips == "function" && this.applyTooltips(c.entities, e)), t.cluster && (o.assign(c.clustering, {
        enabled: !0,
        pixelRange: 100,
        minimumClusterSize: 3,
        clusterBillboards: !0,
        clusterLabels: !0,
        clusterPoints: !0
      }, t.cluster), c.clustering.clusterEvent.addEventListener(
        (u, d) => this.applyClusterStyle(u, d, e)
      )), c;
    },
    getGeoJsonOptions(e) {
      return o.get(this, "activityOptions.engine.featureStyle", {});
    },
    async updateLayer(e, t, i = {}) {
      const n = this.getCesiumLayerByName(e);
      if (!n) return;
      typeof n.updateGeoJson == "function" && await n.updateGeoJson(t, i);
      const r = this.getLayerByName(e);
      At(r) && (this.geojsonCache[e] = await this.toGeoJson(e)), this.onLayerUpdated(r, n, { features: t ? t.features || [t] : [] });
    },
    onLayerUpdated(e, t, i) {
      this.$emit("layer-updated", e, t, i), this.$engineEvents.emit("layer-updated", e, t, i);
    },
    onCurrentTimeChangedGeoJsonLayers(e) {
      o.values(this.layers).filter(Pe(bo.TimeUpdate)).forEach(async (i) => {
        const n = this.getCesiumLayerByName(i.name);
        (!n.lastUpdateTime || !this.shouldSkipFeaturesUpdate(n.lastUpdateTime, i)) && (n.lastUpdateTime = pe.getCurrentTime().clone(), n.updateGeoJson());
      });
    },
    onDefaultUnitChangedGeoJsonLayers(e) {
      o.forOwn(e.default, (t, i) => {
        const n = o.map(be.getUnits(i), "name");
        let r = o.values(this.layers).filter(Pe(bo.UnitUpdate));
        r = r.filter((s) => bh(n, s)), r.forEach((s) => {
          this.getCesiumLayerByName(s.name).updateGeoJson();
        });
      });
    },
    onLayerShownGeoJsonLayers(e, t) {
      const i = this.geojsonCache[e.name];
      i && (At(e) ? this.updateLayer(e.name, i) : delete this.geojsonCache[e.name]);
    },
    onLayerRemovedGeoJsonLayers(e) {
      o.has(this.geojsonCache, e.name) && delete this.geojsonCache[e.name];
    },
    selectFeaturesForPostProcess(e, t, i) {
      const n = this.getPostProcessStage(e);
      if (!n) return;
      let r = [];
      Array.isArray(t) || (t = [t], i = [i]);
      for (let a = 0; a < t.length; a++) {
        const l = t[a], c = i[a], u = this.getCesiumLayerByName(l);
        if (!u || !u.entities && !u.primitives.size) return;
        (Array.isArray(c) ? c : [c]).forEach((f) => {
          let h = u.entities.getById(f), g = u.primitives.get(f);
          yr.forEach((v) => {
            if (h || g) return;
            const x = ji(f, v);
            h = u.entities.getById(x), g = u.primitives.get(x);
          }), h ? g = ph(f, this.viewer) : g = o.get(g, "primitive"), g && (r = o.concat(r, o.isArray(g) ? g : [g]));
        });
      }
      n.selected = r;
    }
  },
  created() {
    this.registerCesiumConstructor(this.createCesiumGeoJsonLayer), ne.on("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), ne.on("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.on("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.on("layer-removed", this.onLayerRemovedGeoJsonLayers), this.updatingGeoJsonData = {}, this.geojsonCache = {};
  },
  beforeUnmount() {
    ne.off("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers), ne.off("units-changed", this.onDefaultUnitChangedGeoJsonLayers), this.$engineEvents.off("layer-shown", this.onLayerShownGeoJsonLayers), this.$engineEvents.off("layer-removed", this.onLayerRemovedGeoJsonLayers), this.geojsonCache = {};
  }
}, F_ = {
  mounted() {
    this.$engineEvents.on("globe-ready", () => {
      const e = o.defaults(o.get(this, "activityOptions.engine.fileLayers", {}), {
        clearOnDrop: !1,
        flyToOnDrop: !0,
        clampToGround: !0
      });
      this.viewer.extend(fm, e), this.viewer.dropError.addEventListener((t, i, n) => {
        z.error(n);
      }), this.viewer.dataSources.dataSourceAdded.addEventListener((t, i) => {
        i.notFromDrop || (i.name || (i.name = this.$t("mixins.fileLayers.IMPORTED_DATA_NAME")), z.debug("[KDK] processing dropped file: ", i.name), this.addLayer({
          name: i.name,
          label: i.name,
          type: "OverlayLayer",
          icon: "insert_drive_file",
          cesium: {
            type: "geoJson",
            isVisible: !0,
            cluster: o.get(e, "cluster", { pixelRange: 50 }),
            entityStyle: o.get(e, "entityStyle"),
            source: i.name
            // Set the data source name instead of URL in this case
          }
        }));
      });
    });
  }
}, D_ = {
  methods: {
    applyStyle(e, t) {
      for (let i = 0; i < e.values.length; i++) {
        const n = e.values[i], r = this.generateStyle("entityStyle", n, t);
        _h.forEach((s) => {
          n[s] && r[s] && o.merge(n[s], r[s]);
        }), r.model && n.billboard && (n.billboard = void 0, n.model = r.model), r.orientation && (n.orientation = r.orientation), o.has(r, "visibility") && (n.show = r.visibility);
      }
    },
    applyClusterStyle(e, t, i) {
      const n = this.generateStyle("clusterStyle", e, t, i);
      ["billboard", "label", "point"].forEach((s) => {
        o.has(t, s) && o.merge(t[s], n[s]);
      });
    },
    // Alias to ease development
    convertFromSimpleStyle(e, t) {
      return Ta(e, t);
    },
    // Alias to ease development
    convertToCesiumObjects(e) {
      return Fn(e);
    },
    getDefaultEntityStyle(e, t) {
      const i = e.properties ? e.properties.getValue(0) : null, n = t.cesium || t;
      let r = o.merge({}, o.get(this, "activityOptions.engine.entityStyle"));
      const s = o.get(n, "entityStyleTemplate");
      if (s) {
        const a = o.cloneDeep(n.entityStyle);
        s.forEach((l) => {
          let c = l.compiler({ feature: e.feature || { properties: i }, properties: i, chroma: Pt, moment: fe, Units: be, Time: pe });
          const u = l.property;
          if (u === "orientation" && e.position) {
            const d = o.get(a, "localFrameAxes", ["east", "north"]), f = qi.localFrameToFixedFrameGenerator(...d), h = e.position.getValue(this.viewer.clock.currentTime);
            c = c.split(",").map((g) => Ee.toRadians(parseFloat(g))), c = new Ln(...c), c = qi.headingPitchRollQuaternion(h, c, vr.WGS84, f);
          }
          o.set(a, u, c);
        }), r = o.merge(r, this.convertToCesiumObjects(a));
      } else
        r = o.merge(r, n.entityStyle || {});
      return i && i.entityStyle && o.merge(r, this.convertToCesiumObjects(i.entityStyle)), r;
    },
    getDefaultClusterStyle(e, t, i) {
      const n = i.cesium || i, r = o.merge(
        {},
        o.get(this, "activityOptions.engine.clusterStyle"),
        n.clusterStyle || {}
      );
      if (o.has(r, "label.text")) {
        const s = o.template(o.get(r, "label.text")), a = o.cloneDeep(o.get(r, "label"));
        o.set(a, "text", s({ entities: e, cluster: t, $t: this.$t })), o.set(r, "label", a);
      }
      return r;
    }
  },
  created() {
    this.registerStyle("entityStyle", this.getDefaultEntityStyle), this.registerStyle("clusterStyle", this.getDefaultClusterStyle);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    o.has(this, "activityOptions.engine.entityStyle") && o.set(this, "activityOptions.engine.entityStyle", this.convertToCesiumObjects(o.get(this, "activityOptions.engine.entityStyle"))), o.has(this, "activityOptions.engine.clusterStyle") && o.set(this, "activityOptions.engine.clusterStyle", this.convertToCesiumObjects(o.get(this, "activityOptions.engine.clusterStyle")));
  }
}, A_ = {
  methods: {
    applyTooltips(e, t) {
      for (let i = 0; i < e.values.length; i++) {
        const n = e.values[i], r = this.generateStyle("tooltip", n, t);
        if (r) {
          const s = this.getPositionForEntity(n);
          if (s) {
            const a = this.viewer.entities.add({ parent: n, position: s, label: r });
            r.sticky && (a.sticky = !0);
          }
        }
      }
    },
    getDefaultTooltip(e, t) {
      let i;
      if (e.properties) {
        const n = e.properties.getValue(0), r = t.cesium || t;
        if (o.has(r, "tooltip") && !o.get(r, "tooltip") || o.has(n, "tooltip") && !o.get(n, "tooltip")) return;
        const s = o.merge(
          {},
          o.get(this, "activityOptions.engine.tooltip", {}),
          r.tooltip,
          n.tooltip
        );
        let a = s.text;
        if (!a) {
          if (s.property)
            a = o.get(n, s.property), a && typeof a.toString == "function" && (a = a.toString());
          else if (s.template) {
            const l = s.compiler;
            a = l({ feature: e.feature || { properties: n }, properties: n, $t: this.$t, Units: be, Time: pe, moment: fe });
          }
        }
        a && (i = Object.assign({
          text: a,
          show: !!o.get(s, "options.permanent")
        }, s.options));
      }
      return i;
    },
    isTooltipOpen(e) {
      return this.getNbChildrenForEntity(e) > 0 ? o.get(e, "label.show", !1) : !1;
    },
    openTooltip(e, t) {
      if (this.getNbChildrenForEntity(e) > 0) {
        const i = this.getChildForEntity(e);
        i.label && (i.label.show = !0), i.sticky && (i.position = t);
      }
    },
    closeTooltip(e) {
      if (this.getNbChildrenForEntity(e) > 0) {
        const t = this.getChildForEntity(e);
        t.label && (t.label.show = !1);
      }
    },
    onTooltip(e, t) {
      if (e) {
        const r = (e.cesium || e).tooltip;
        if (o.get(r, "options.permanent")) return;
      }
      const i = t.target;
      this.overEntity && (this.closeTooltip(this.overEntity), this.overEntity = null), e && i && (this.overEntity = i, this.openTooltip(this.overEntity, t.pickedPosition));
    }
  },
  created() {
    this.registerStyle("tooltip", this.getDefaultTooltip);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    o.has(this, "activityOptions.engine.tooltip") && o.set(this, "activityOptions.engine.tooltip", this.convertToCesiumObjects(o.get(this, "activityOptions.engine.tooltip")));
  },
  mounted() {
    this.$engineEvents.on("mousemove", this.onTooltip);
  },
  beforeUnmount() {
    this.$engineEvents.off("mousemove", this.onTooltip);
  }
}, O_ = {
  methods: {
    getDefaultPopup(e, t) {
      let i;
      if (e.properties) {
        let n = e.properties.getValue(0);
        const r = t.cesium || t;
        if (o.has(r, "popup") && !o.get(r, "popup") || o.has(n, "popup") && !o.get(n, "popup")) return;
        const s = o.merge(
          {},
          o.get(this, "activityOptions.engine.popup"),
          r.popup,
          n.popup
        );
        let a = s.text;
        if (!a)
          if (s.template) {
            const l = s.compiler;
            a = l({ feature: e.feature || { properties: n }, properties: n, $t: this.$t, Units: be, Time: pe, moment: fe });
          } else s.pick ? n = o.pick(n, s.pick) : s.omit && (n = o.omit(n, s.omit));
        if (a || (a = wh(n)), !a) return null;
        i = Object.assign({
          text: a,
          show: !0
        }, s.options);
      }
      return i;
    },
    onPopup(e, t) {
      const i = t.target;
      if (this.popupEntity && (this.viewer.entities.remove(this.popupEntity), this.popupEntity = null), this.clickedEntity === i ? this.clickedEntity = null : this.clickedEntity = i, !this.clickedEntity || !e) return;
      const n = this.generateStyle("popup", this.clickedEntity, e);
      if (n) {
        const r = t.pickedPosition ? t.pickedPosition : this.getPositionForEntity(this.clickedEntity);
        this.popupEntity = this.viewer.entities.add({ position: r, label: n });
      }
    }
  },
  created() {
    this.registerStyle("popup", this.getDefaultPopup);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    o.has(this, "activityOptions.engine.popup") && o.set(this, "activityOptions.engine.popup", this.convertToCesiumObjects(o.get(this, "activityOptions.engine.popup")));
  },
  mounted() {
    this.$engineEvents.on("click", this.onPopup);
  },
  beforeUnmount() {
    this.$engineEvents.off("click", this.onPopup);
  }
}, B_ = {
  methods: {
    async initializeGlobe(e, t) {
      this.viewer || (this.setupGlobe(e, t), await this.initialize(), this.viewer.camera.moveEnd.addEventListener(this.storeView));
    },
    finalizeGlobe() {
      this.viewer.camera.moveEnd.removeEventListener(this.storeView);
    },
    storeView() {
      typeof this.storeContext == "function" && this.storeContext("view");
    },
    onGlobeResized(e) {
      this.observe && (this.refreshGlobe(), this.globeContainer && (this.engineContainerWidth = this.globeContainer.getBoundingClientRect().width, this.engineContainerHeight = this.globeContainer.getBoundingClientRect().height));
    },
    onToggleVr() {
      this.viewer.scene.useWebVR ? (sr.fullscreen && sr.exitFullscreen(), this.viewer.scene.useWebVR = !1) : (sr.fullscreen || sr.requestFullscreen(document.body), this.viewer.scene.useWebVR = !0);
    }
  },
  created() {
    this.engine = "cesium", this.observe = !0;
  },
  mounted() {
  },
  beforeUnmount() {
    this.observe = !1, this.finalizeGlobe();
  }
}, R_ = {
  methods: {
    createCesiumOpendapLayer(e) {
      if (e.cesium.type !== "opendap") return;
      const i = async () => {
        const r = await q.passport.getJWT();
        return new hm({
          url: "http://localhost:8081/api/daptiles/tileset.json",
          headers: {
            Authorization: `Bearer ${r}`
          },
          queryParameters: {
            file: "mf-arpege-01/2019/06/15/11360000000.20190615180000.grib",
            query: "Temperature_height_above_ground",
            dimensions: JSON.stringify({ time2: 0, height_above_ground1: 0 }),
            latitude: "lat",
            longitude: "lon"
          }
        });
      };
      return new xn({
        url: i
        // url: 'http://127.0.0.1:3000/tileset.json?file=mf-arpege-05/2019/06/16/18/T6086_G_T_Sol_20190616180000.grib&variable=Temperature_surface&time=0',
        // shadows: Cesium.ShadowMode.DISABLED,
        // classificationType: Cesium.ClassificationType.CESIUM_3D_TILE,
        // url: Cesium.IonResource.f ffromAssetId(5741)
        // debugShowBoundingVolume: true,
        // debugShowUrl: true
      });
    }
  },
  created() {
    this.registerCesiumConstructor(this.createCesiumOpendapLayer);
  }
}, $_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: B_,
  baseGlobe: P_,
  fileLayers: F_,
  geojsonLayers: M_,
  opendapLayers: R_,
  popup: O_,
  style: D_,
  tooltip: A_
}, Symbol.toStringTag, { value: "Module" })), I_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CesiumEntityTypes: _h,
  CesiumStyleMappings: is,
  CesiumStyleOptions: C_,
  DefaultStyle: oa,
  GeoJsonCesiumLayerFilters: bo,
  GeoJsonLeafletLayerFilters: xr,
  IconStyleToSimpleStyle: qd,
  LeafletEvents: ni,
  LeafletStyleMappings: co,
  LineStyleTemplateMappings: ra,
  LineStyleToSimpleStyle: Hd,
  PointStyleTemplateMappings: na,
  PointStyleToSimpleStyle: Gd,
  PolygonStyleTemplateMappings: sa,
  PolygonStyleToSimpleStyle: Zd,
  SimpleStyleNumbers: jn,
  SimpleStyleToLineStyle: Wd,
  SimpleStyleToPointStyle: Kd,
  SimpleStyleToPolygonStyle: Jd,
  TouchEvents: Nn,
  bindLeafletEvents: Dt,
  buildGradientPath: Cf,
  cacheView: I0,
  capture: Ed,
  checkFeatures: _a,
  computeIdealMaxNativeZoom: x0,
  convertCesiumHandlerEvent: yh,
  convertEntitiesToGeoJson: wo,
  convertLineStyleToLeafletPath: da,
  convertLineStyleToSimpleStyle: aa,
  convertPointStyleToSimpleStyle: Qd,
  convertPolygonStyleToLeafletPath: fa,
  convertPolygonStyleToSimpleStyle: Yd,
  convertSimpleStyleColors: gs,
  convertSimpleStyleToLineStyle: ci,
  convertSimpleStyleToPointStyle: li,
  convertSimpleStyleToPolygonStyle: ui,
  convertStyle: $t,
  convertToCesiumFromSimpleStyle: Ta,
  convertToCesiumFromStyle: Lh,
  convertToCesiumObjects: Fn,
  convertToLeafletFromSimpleStyleSpec: _0,
  coordinatesToGeoJSON: Gb,
  createCesiumObject: Ci,
  createFeatures: La,
  createMarkerFromPointStyle: ua,
  createOfflineServices: $0,
  createPrimitiveWithMovingTexture: vo,
  editFeaturesGeometry: Ff,
  editFeaturesProperties: Df,
  editFeaturesStyle: Af,
  editFilterStyle: O0,
  editLayerStyle: _f,
  fetchGeoJson: si,
  filterGeocoders: Rf,
  filterQueryToConditions: ca,
  formatForwardGeocodingResult: Bf,
  formatUserCoordinates: Ss,
  generateLayerDefinition: ba,
  generatePropertiesSchema: $f,
  generateStyleTemplates: la,
  getBaseQueryForFeatures: bs,
  getCatalogProjectQuery: Vn,
  getCategories: qr,
  getDefaultLineStyle: ga,
  getDefaultPointStyle: ma,
  getDefaultPolygonStyle: pa,
  getDefaultStyleFromTemplates: ps,
  getFeatureId: st,
  getFeatureLabel: qb,
  getFeatureStyleType: an,
  getFeaturesFromQuery: Hr,
  getFeaturesQuery: wa,
  getFeaturesQueryInterval: xs,
  getFeaturesUpdateInterval: Ls,
  getFilterQueryForFeatures: ws,
  getForecastTimeSeries: N0,
  getGeoJsonFeatures: Ie,
  getHtmlTable: Ud,
  getLayers: Ur,
  getLayersByCategory: Td,
  getLayersBySublegend: Yb,
  getLineSimpleStyle: Sh,
  getMeasureForFeature: Mf,
  getMeasureForFeatureBaseQuery: Wr,
  getMeasureForFeatureFromQuery: Zr,
  getMeasureForFeatureQuery: kf,
  getMeasureTimeSeries: j0,
  getNearestTime: hs,
  getOrphanLayers: Pd,
  getParentTileInTileSet: ef,
  getPointSimpleStyle: xh,
  getPolygonSimpleStyle: Ch,
  getPrimitivesForEntity: ph,
  getProbeFeatures: Tf,
  getShapeFromLineStyle: p0,
  getShapeFromPointStyle: g0,
  getShapeFromPolygonStyle: y0,
  getSortQueryForFeatures: _s,
  getSublegends: Gr,
  getTextTable: wh,
  getTimeInterval: Ub,
  getUpdateFeatureFunction: jd,
  getUpdatedLayerLegend: kn,
  getViews: kd,
  hasFeatureSchema: nf,
  hasUnitInCesiumLayerTemplate: bh,
  hasUnitInLeafletLayerTemplate: Vd,
  isFeatureInQueryInterval: Pf,
  isFeatureLayer: on,
  isInMemoryLayer: At,
  isLayerCachable: ys,
  isLayerCached: cf,
  isLayerDataEditable: pf,
  isLayerEditable: lf,
  isLayerFilterEditable: yf,
  isLayerHighlightable: sf,
  isLayerProbable: of,
  isLayerRemovable: mf,
  isLayerSelectable: rf,
  isLayerStorable: af,
  isLayerStyleEditable: gf,
  isMeasureLayer: vf,
  isTerrainLayer: wi,
  isUserLayer: fi,
  key2tile: L0,
  listenToFeaturesServiceEventsForLayer: Qn,
  parseCoordinates: Of,
  processFeatures: Jn,
  removeFeatures: xa,
  removeLayer: Sf,
  saveGeoJsonLayer: Lf,
  saveLayer: xf,
  setBaseLayerCached: uf,
  setEngineJwt: Qo,
  setGeojsonLayerCached: df,
  setLayerCached: ya,
  setLayerUncached: va,
  setPMTilesLayerCached: hf,
  setUrlJwt: gt,
  shouldSkipFeaturesUpdate: Ef,
  tile2key: Mt,
  tileSetContainsParent: Xd,
  transformFeatures: vs,
  unbindLeafletEvents: Kr,
  uncacheView: z0,
  unlistenToFeaturesServiceEventsForLayer: ln,
  updateCesiumGeoJsonEntity: vh,
  updateLayerWithFiltersStyle: A0
}, Symbol.toStringTag, { value: "Module" }));
function z_(e, t, i) {
  i === void 0 && (i = {});
  var n = rt(e), r = rt(t), s = Ze(r[1] - n[1]), a = Ze(r[0] - n[0]), l = Ze(n[1]), c = Ze(r[1]), u = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(l) * Math.cos(c);
  return vd(2 * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u)), i.units);
}
function Eh(e, t) {
  return t === void 0 && (t = {}), wb(e, function(i, n) {
    var r = n.geometry.coordinates;
    return i + z_(r[0], r[1], t);
  }, 0);
}
function ka(e) {
  if (!e) throw new Error("geojson is required");
  var t = [];
  return Mi(e, function(i) {
    t.push(i);
  }), it(t);
}
function N_(e, t, i) {
  const n = o.get(e, "geometry.type");
  if (n !== "LineString" && n !== "MultiLineString")
    return [];
  const r = n === "MultiLineString" ? ka(e).features : [e], s = [], a = [];
  let l = !0, c = 0, u = 0;
  for (let d = 0; d < r.length && l; ++d) {
    const f = r[d], h = o.get(f, "properties.altitudeUnit", "m");
    a.push({ numPoints: f.geometry.coordinates.length }), Zt(f, (g, v) => {
      s.length && v === 0 || (g.length > 2 ? s.push({ x: 0, y: be.convert(g[2], h, i) }) : l = !1);
    }), l && _d(f, (g) => {
      u === 0 && (s[0].x = 0), c += Eh(g, { units: "kilometers" }) * 1e3, u += 1, s[u].x = be.convert(c, "m", t);
    });
  }
  return { dataset: l ? s : [], segments: a };
}
function wc(e) {
  return Array.isArray(e) || e === void 0 ? e : [e];
}
async function j_(e, t, i, n, { additionalHeaders: r, defaultResolution: s, defaultResolutionUnit: a, noCorridor: l } = {}) {
  const c = o.get(t, "geometry.type");
  if (c !== "LineString" && c !== "MultiLineString")
    return [];
  const u = [], d = wc(o.get(t, "properties.elevationProfile.resolution", s)), f = o.get(t, "properties.elevationProfile.resolutionUnit", a), h = l ? void 0 : wc(o.get(t, "properties.elevationProfile.corridorWidth")), g = l ? void 0 : o.get(t, "properties.elevationProfile.corridorWidthUnit", "m");
  c === "MultiLineString" ? ka(t).features.forEach((w, M) => {
    u.push({
      profile: w,
      resolution: be.convert(d[M], f, "m"),
      corridorWidth: h ? be.convert(h[M], g, "m") : void 0
    });
  }) : u.push({
    profile: t,
    resolution: be.convert(d[0], f, "m"),
    corridorWidth: h ? be.convert(h[0], g, "m") : void 0
  });
  const v = [];
  for (const w of u)
    v.push(fetch(e + `?resolution=${w.resolution}` + (w.corridorWidth !== void 0 ? `&corridorWidth=${w.corridorWidth}` : ""), {
      method: "POST",
      mode: "cors",
      body: JSON.stringify(w.profile),
      headers: Object.assign({ "Content-Type": "application/json" }, r)
    }));
  let x;
  try {
    x = await Promise.all(v);
    for (const w of x)
      if (!w.ok) throw new Error("Fetch failed");
  } catch {
    return [];
  }
  for (let w = 0; w < u.length; ++w) {
    const M = u[w];
    M.elevation = await x[w].json(), M.length = Eh(M.profile, { units: "kilometers" }) * 1e3, M.resolution = be.convert(d[w], f, i), M.corridorWidth = h ? be.convert(h[w], g, i) : void 0, M.length = be.convert(M.length, "m", i);
    for (const p of M.elevation.features)
      p.properties.z = be.convert(p.properties.z, "m", n), p.properties.t = be.convert(p.properties.t, "m", i);
  }
  return u;
}
function V_(e, t, i) {
  if (t.length === 0) return;
  const n = o.get(e, "properties.elevationProfile.securityMargin");
  if (n === void 0) return;
  const r = o.get(e, "properties.elevationProfile.securityMarginUnit", "m");
  o.get(e, "geometry.type") === "MultiLineString" ? ka(e).features.forEach((a, l) => {
    t[l].securityMargin = be.convert(n[l], r, i);
  }) : t[0].securityMargin = be.convert(n, r, i);
}
async function U_(e, t, i, n, { additionalHeaders: r, defaultResolution: s, defaultResolutionUnit: a, noCorridor: l, noSecurityMargin: c, minElevationValue: u } = {}) {
  const d = await j_(e, t, i, n, { additionalHeaders: r, defaultResolution: s, defaultResolutionUnit: a, noCorridor: l });
  if (c || V_(t, d, n), u !== void 0)
    for (let f = 0; f < d.length; ++f) {
      const h = d[f];
      for (const g of h.elevation.features)
        g.properties.z < u && (g.properties.z = 0);
    }
  return d;
}
function q_(e, { noDataset: t, noGeojson: i, queryParametersInDataset: n, queryParametersInGeojson: r } = {}) {
  const s = [], a = [];
  let l = 0;
  for (let u = 0; u < e.length; ++u) {
    const d = e[u].securityMargin ? e[u].securityMargin : 0, f = e[u].resolution, h = e[u].corridorWidth, g = e[u].securityMargin;
    e[u].elevation.features.forEach((v, x) => {
      if (u !== 0 && x === 0) return;
      const w = l + v.properties.t, M = d + v.properties.z;
      if (!t) {
        const p = { x: w, y: M };
        n && (p.elevation = { resolution: f }, h !== void 0 && (p.elevation.corridorWidth = h), g !== void 0 && (p.elevation.securityMargin = g)), s.push(p);
      }
      if (!i) {
        const p = { z: M, t: w };
        n && (p.resolution = f, h !== void 0 && (p.corridorWidth = h), g !== void 0 && (p.securityMargin = g)), a.push(dt(v.geometry.coordinates, p));
      }
    }), l += e[u].length;
  }
  const c = i ? {} : it(a);
  return { dataset: s, geojson: c };
}
const G_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extractElevation: q_,
  fetchElevation: U_,
  fetchProfileDataset: N_
}, Symbol.toStringTag, { value: "Module" })), K_ = {
  processing: !1,
  async process(e) {
    this.processing ? Xe.create({ type: "negative", message: Y.t("KCapture.ERROR_MESSAGE") }) : (this.processing = !0, await Ed(e), this.processing = !1);
  }
}, H_ = Object.assign({}, Fw, { map: __, globe: $_ }), dx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CanvasDrawContext: Ea,
  Capture: K_,
  Geolocation: ot,
  Navigator: rh,
  Planets: Ca,
  composables: Lw,
  dap: Y0,
  default: ah,
  elevationUtils: G_,
  errors: U0,
  grid: W0,
  hooks: u0,
  mixins: H_,
  permissions: G0,
  setupApi: oh,
  utils: I_
}, Symbol.toStringTag, { value: "Module" })), fx = { core: pd, map: ah };
export {
  fx as default,
  cx as kdkCore,
  dx as kdkMap
};
