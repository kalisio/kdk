import Ajv from "ajv";
import addFormats from "ajv-formats";
import addKeywords from "ajv-keywords";
import _$1 from "lodash";
import { FeathersError } from "@feathersjs/errors";
import bbox$1 from "@turf/bbox";
import logger$1 from "loglevel";
import config from "config";
import { getFingerprint, getFingerprintData } from "@thumbmarkjs/thumbmarkjs";
import createOfflineService, { LocalForage } from "@kalisio/feathers-localforage";
import { getClientService } from "@kalisio/feathers-s3/client.js";
import { reactive, toRef, ref, createApp, computed, markRaw, defineComponent, getCurrentInstance, h, onBeforeUnmount, Transition, withDirectives, TransitionGroup, onDeactivated, nextTick, watch, onMounted, onUnmounted, Teleport, inject, onBeforeUpdate, onActivated, toRaw, defineAsyncComponent, shallowReactive, shallowRef, readonly, watchEffect, onBeforeMount, unref } from "vue";
import { createI18n } from "vue-i18n";
import moment$1 from "moment-timezone/builds/moment-timezone-with-data-10-year-range.js";
import * as math from "mathjs";
import sift from "sift";
import sanitize from "sanitize-html";
import moment from "moment";
import path from "path-browserify";
import { useRouter, useRoute } from "vue-router";
import makeDebug from "debug";
import Papa from "papaparse";
import formatcoords from "formatcoords";
import { image } from "@pdfme/schemas";
import { generate } from "@pdfme/generator";
import SphericalMercator from "@mapbox/sphericalmercator";
import { PMTiles, zxyToTileId, findTile } from "pmtiles";
import * as protomaps from "protomaps-leaflet";
import { sourcesToViews } from "protomaps-leaflet";
import chroma from "chroma-js";
import L$1 from "leaflet";
import require$$1 from "iso8601-js-period";
import { kml, gpx } from "@tmcw/togeojson";
import * as Cesium$1 from "cesium";
import { Color, exportKml, buildModuleUrl, Math as Math$1, Cartographic, Entity, EntityCollection, BoundingSphere, Ellipsoid, PinBuilder, VerticalOrigin, Cartesian3, DebugModelMatrixPrimitive, HeadingPitchRoll, HeadingPitchRange, Transforms, Matrix4, Matrix3, DebugCameraPrimitive, Rectangle, Cesium3DTileset, ImageryLayer, ScreenSpaceEventType, ScreenSpaceEventHandler, Ion, Viewer, viewerCesiumInspectorMixin, GeoJsonDataSource, ConstantProperty, ColorMaterialProperty, viewerDragDropMixin, Fullscreen as Fullscreen$1, Resource } from "cesium";
import jwtdecode from "jwt-decode";
import feathers from "@feathersjs/client";
import { io } from "socket.io-client";
import { rx } from "feathers-reactive";
import { createAliasResolver, AbilityBuilder, Ability } from "@casl/ability";
import { toMongoQuery } from "@casl/mongoose";
import emailValidator from "email-validator";
import AjvLocalize from "ajv-i18n";
import "leaflet-realtime";
import "leaflet.markercluster/dist/MarkerCluster.css";
import "leaflet.markercluster/dist/MarkerCluster.Default.css";
import "leaflet.markercluster";
import { lineOffset, point as point$1, rhumbDistance as rhumbDistance$1, rhumbBearing as rhumbBearing$1, rhumbDestination as rhumbDestination$1, getType as getType$1 } from "@turf/turf";
import * as PIXI from "pixi.js";
import "leaflet-pixi-overlay";
import parser from "jsdap/src/parser.js";
import xdr from "jsdap/src/xdr.js";
import * as GeoTIFF from "geotiff";
import xml2js from "xml2js";
import { memory } from "@feathersjs/memory";
import shp from "shpjs";
import "leaflet/dist/leaflet.css";
import "leaflet-fullscreen";
import "leaflet-fullscreen/dist/leaflet.fullscreen.css";
import "@kalisio/leaflet.donutcluster/src/Leaflet.DonutCluster.css";
import "@kalisio/leaflet.donutcluster";
import "leaflet.geodesic";
import "@kalisio/leaflet-graphicscale";
import "@kalisio/leaflet-graphicscale/dist/Leaflet.GraphicScale.min.css";
import "leaflet.locatecontrol";
import "leaflet.locatecontrol/dist/L.Control.Locate.css";
import "leaflet-wms-header";
import "leaflet-timedimension/dist/leaflet.timedimension.control.css";
import "@geoman-io/leaflet-geoman-free";
import "@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css";
import "leaflet-velocity";
import HeatmapOverlay from "leaflet-heatmap";
import { mapbox_style } from "@kalisio/leaflet-pmtiles";
import "cesium/Source/Widgets/widgets.css";
const Store$1 = {};
function useStore(name, initialStore) {
  if (!_$1.has(Store$1, name)) {
    _$1.set(Store$1, name, reactive(initialStore || {}));
  }
  const store2 = _$1.get(Store$1, name);
  function clear() {
    _$1.forOwn(store2, function(value, key) {
      _$1.unset(store2, key);
    });
  }
  function set2(path2, value) {
    _$1.set(store2, path2, value);
  }
  function get2(path2, defaultValue) {
    return path2 ? _$1.get(store2, path2, defaultValue) : store2;
  }
  function unset2(path2) {
    _$1.unset(store2, path2);
  }
  function has2(path2) {
    return _$1.has(store2, path2);
  }
  function forOwn(f) {
    _$1.forOwn(store2, function(value, key) {
      f(value, key);
    });
  }
  return {
    Store: Store$1,
    store: store2,
    clear,
    set: set2,
    get: get2,
    unset: unset2,
    has: has2,
    forOwn
  };
}
class EventBus {
  constructor() {
    this.__stack = {};
  }
  on(name, callback, ctx) {
    (this.__stack[name] || (this.__stack[name] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  }
  once(name, callback, ctx) {
    const listener = () => {
      this.off(name, listener);
      callback.apply(ctx, arguments);
    };
    listener.__callback = callback;
    return this.on(name, listener, ctx);
  }
  emit(name) {
    const list = this.__stack[name];
    if (list !== void 0) {
      const params = [].slice.call(arguments, 1);
      list.forEach((entry) => {
        entry.fn.apply(entry.ctx, params);
      });
    }
    return this;
  }
  off(name, callback) {
    const list = this.__stack[name];
    if (list === void 0) {
      return this;
    }
    if (callback === void 0) {
      delete this.__stack[name];
      return this;
    }
    const liveEvents = list.filter(
      (entry) => entry.fn !== callback && entry.fn.__callback !== callback
    );
    if (liveEvents.length !== 0) {
      this.__stack[name] = liveEvents;
    } else {
      delete this.__stack[name];
    }
    return this;
  }
}
const Events = new EventBus();
const { store: store$1, set: set$1, get: get$1, unset: unset$1, has: has$1 } = useStore("store");
const Store = Object.assign(store$1, {
  get: get$1,
  has: has$1,
  // Override write methods to send events
  set(path2, value) {
    const previousValue = get$1(path2);
    set$1(path2, value);
    const eventName = _$1.kebabCase(`${path2}-changed`);
    Events.emit(eventName, value, previousValue);
    Events.emit("store-changed", path2, value, previousValue);
  },
  patch(path2, value) {
    const previousValue = get$1(path2);
    if (previousValue) {
      Object.assign(previousValue, value);
      this.set(path2, previousValue);
    }
  },
  unset(path2) {
    unset$1(path2);
    const eventName = _$1.kebabCase(`${path2}-changed`);
    Events.emit(eventName, void 0);
  },
  getRef(path2) {
    const index2 = path2.lastIndexOf(".");
    const key = path2.substring(index2 + 1);
    const object = index2 < 0 ? store$1 : get$1(path2.replace(`.${key}`, ""));
    return toRef(object, key);
  }
});
const reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function rgbToHex({ r, g, b, a }) {
  const alpha = a !== void 0;
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);
  if (r > 255 || g > 255 || b > 255 || alpha && a > 100) {
    throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
  }
  a = alpha ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1) : "";
  return "#" + (b | g << 8 | r << 16 | 1 << 24).toString(16).slice(1) + a;
}
function hexToRgb(hex2) {
  if (typeof hex2 !== "string") {
    throw new TypeError("Expected a string");
  }
  hex2 = hex2.replace(/^#/, "");
  if (hex2.length === 3) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
  } else if (hex2.length === 4) {
    hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
  }
  const num = parseInt(hex2, 16);
  return hex2.length > 6 ? { r: num >> 24 & 255, g: num >> 16 & 255, b: num >> 8 & 255, a: Math.round((num & 255) / 2.55) } : { r: num >> 16, g: num >> 8 & 255, b: num & 255 };
}
function hsvToRgb({ h: h2, s, v, a }) {
  let r, g, b;
  s = s / 100;
  v = v / 100;
  h2 = h2 / 360;
  const i = Math.floor(h2 * 6), f = h2 * 6 - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a
  };
}
function rgbToHsv({ r, g, b, a }) {
  const max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min, s = max === 0 ? 0 : d / max, v = max / 255;
  let h2;
  switch (max) {
    case min:
      h2 = 0;
      break;
    case r:
      h2 = g - b + d * (g < b ? 6 : 0);
      h2 /= 6 * d;
      break;
    case g:
      h2 = b - r + d * 2;
      h2 /= 6 * d;
      break;
    case b:
      h2 = r - g + d * 4;
      h2 /= 6 * d;
      break;
  }
  return {
    h: Math.round(h2 * 360),
    s: Math.round(s * 100),
    v: Math.round(v * 100),
    a
  };
}
function textToRgb(str) {
  if (typeof str !== "string") {
    throw new TypeError("Expected a string");
  }
  const color = str.replace(/ /g, "");
  const m = reRGBA.exec(color);
  if (m === null) {
    return hexToRgb(color);
  }
  const rgb2 = {
    r: Math.min(255, parseInt(m[2], 10)),
    g: Math.min(255, parseInt(m[3], 10)),
    b: Math.min(255, parseInt(m[4], 10))
  };
  if (m[1]) {
    const alpha = parseFloat(m[5]);
    rgb2.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
  }
  return rgb2;
}
function lighten(color, percent) {
  if (typeof color !== "string") {
    throw new TypeError("Expected a string as color");
  }
  if (typeof percent !== "number") {
    throw new TypeError("Expected a numeric percent");
  }
  const rgb2 = textToRgb(color), t = percent < 0 ? 0 : 255, p = Math.abs(percent) / 100, R = rgb2.r, G = rgb2.g, B = rgb2.b;
  return "#" + (16777216 + (Math.round((t - R) * p) + R) * 65536 + (Math.round((t - G) * p) + G) * 256 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}
function luminosity(color) {
  if (typeof color !== "string" && (!color || color.r === void 0)) {
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  }
  const rgb2 = typeof color === "string" ? textToRgb(color) : color, r = rgb2.r / 255, g = rgb2.g / 255, b = rgb2.b / 255, R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4), G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4), B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
function brightness(color) {
  if (typeof color !== "string" && (!color || color.r === void 0)) {
    throw new TypeError("Expected a string or a {r, g, b} object as color");
  }
  const rgb2 = typeof color === "string" ? textToRgb(color) : color;
  return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
}
function blend(fgColor, bgColor) {
  if (typeof fgColor !== "string" && (!fgColor || fgColor.r === void 0)) {
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as fgColor");
  }
  if (typeof bgColor !== "string" && (!bgColor || bgColor.r === void 0)) {
    throw new TypeError("Expected a string or a {r, g, b[, a]} object as bgColor");
  }
  const rgb1 = typeof fgColor === "string" ? textToRgb(fgColor) : fgColor, r1 = rgb1.r / 255, g1 = rgb1.g / 255, b1 = rgb1.b / 255, a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1, rgb2 = typeof bgColor === "string" ? textToRgb(bgColor) : bgColor, r2 = rgb2.r / 255, g2 = rgb2.g / 255, b2 = rgb2.b / 255, a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1, a = a1 + a2 * (1 - a1), r = Math.round((r1 * a1 + r2 * a2 * (1 - a1)) / a * 255), g = Math.round((g1 * a1 + g2 * a2 * (1 - a1)) / a * 255), b = Math.round((b1 * a1 + b2 * a2 * (1 - a1)) / a * 255);
  const ret = { r, g, b, a: Math.round(a * 100) };
  return typeof fgColor === "string" ? rgbToHex(ret) : ret;
}
function changeAlpha(color, offset) {
  if (typeof color !== "string") {
    throw new TypeError("Expected a string as color");
  }
  if (offset === void 0 || offset < -1 || offset > 1) {
    throw new TypeError("Expected offset to be between -1 and 1");
  }
  const { r, g, b, a } = textToRgb(color);
  const alpha = a !== void 0 ? a / 100 : 0;
  return rgbToHex({
    r,
    g,
    b,
    a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
  });
}
function getPaletteColor(colorName) {
  if (typeof colorName !== "string") {
    throw new TypeError("Expected a string as color");
  }
  const el = document.createElement("div");
  el.className = `text-${colorName} invisible fixed no-pointer-events`;
  document.body.appendChild(el);
  const result = getComputedStyle(el).getPropertyValue("color");
  el.remove();
  return rgbToHex(textToRgb(result));
}
const colors = {
  rgbToHex,
  hexToRgb,
  hsvToRgb,
  rgbToHsv,
  textToRgb,
  lighten,
  luminosity,
  brightness,
  blend,
  changeAlpha,
  getPaletteColor
};
function getCssVar(propName, element = document.body) {
  if (typeof propName !== "string") {
    throw new TypeError("Expected a string as propName");
  }
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  return getComputedStyle(element).getPropertyValue(`--q-${propName}`).trim() || null;
}
function setCssVar(propName, value, element = document.body) {
  if (typeof propName !== "string") {
    throw new TypeError("Expected a string as propName");
  }
  if (typeof value !== "string") {
    throw new TypeError("Expected a string as value");
  }
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  element.style.setProperty(`--q-${propName}`, value);
}
const themeColors = ["primary", "secondary", "accent", "dark", "info", "positive", "negative", "warning"];
const defaultCssColors = {
  primary: "#bf360c",
  secondary: "#bf360",
  accent: "#bf360c",
  dark: "#bf360c",
  info: "#bf360c",
  positive: "#7bb946",
  negative: "#c74a4a",
  warning: "#d09931"
};
const Theme = {
  initialize() {
    if (this.default) return;
    this.default = {};
    themeColors.forEach((color) => {
      this.default[color] = getCssVar(color) || defaultCssColors[color];
    });
  },
  apply(theme) {
    if (typeof theme === "string") {
      setCssVar("primary", theme);
      setCssVar("secondary", colors.lighten(theme, 75));
      setCssVar("accent", colors.lighten(theme, 25));
      setCssVar("dark", colors.lighten(theme, -25));
      setCssVar("info", colors.lighten(theme, 25));
      setCssVar("positive", this.default.positive);
      setCssVar("negative", this.default.negative);
      setCssVar("warning", this.default.warning);
    } else {
      themeColors.forEach((color) => {
        setCssVar(color, _$1.get(theme, color, this.default[color]));
      });
    }
  },
  restore() {
    themeColors.forEach((color) => {
      setCssVar(color, this.default[color]);
    });
  }
};
class KError extends Error {
}
const errors$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KError
}, Symbol.toStringTag, { value: "Module" }));
const resolveAction = createAliasResolver({
  update: ["patch"],
  read: ["get", "find"],
  remove: ["delete"],
  all: ["read", "create", "update", "remove"]
});
const Roles = {
  member: 0,
  manager: 1,
  owner: 2
};
const RoleNames = [
  "member",
  "manager",
  "owner"
];
let hooks = [];
const RESOURCE_TYPE = "type";
const RESOURCE_TYPE_KEY = Symbol.for(RESOURCE_TYPE);
function defineResourceRules(subject, resource, resourceService, can) {
  const role = Roles[resource.permissions];
  if (role >= Roles.member) {
    can("read", resourceService, { _id: resource._id });
  }
  if (role >= Roles.manager) {
    can("update", resourceService, { _id: resource._id });
    can(["create", "remove"], "authorisations", { resource: resource._id });
  }
  if (role >= Roles.owner) {
    can("remove", resourceService, { _id: resource._id });
  }
}
function defineUserAbilities$1(subject, can, cannot) {
  can("service", "users");
  can("create", "users");
  can("service", "account");
  can(["create", "verifyEmail"], "account");
  can("service", "import-export");
  can("create", "import-export");
  can("service", "push");
  can("create", "push");
  can("service", "tags");
  can("create", "tags");
  if (subject && subject._id) {
    can("read", "users");
    can(["update", "remove"], "users", { _id: subject._id });
    can("service", "authorisations");
    can("service", "storage");
    can("create", "storage", { id: "avatars/" + subject._id.toString() });
    can("create", "storage", { id: "avatars/" + subject._id.toString() + ".thumbnail" });
    can(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + subject._id.toString() });
    can(["createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"], "storage", { id: "avatars/" + subject._id.toString() + ".thumbnail" });
    can("remove", "storage", { _id: "avatars/" + subject._id.toString() });
    can("remove", "storage", { _id: "avatars/" + subject._id.toString() + ".thumbnail" });
    can("read", "storage", { _id: { $regex: "^avatars/*" } });
  }
}
async function defineAbilities(subject, ...args) {
  const { build, can, cannot } = new AbilityBuilder(Ability);
  await Promise.all(hooks.map(async (hook) => {
    await hook(subject, can, cannot, ...args);
  }));
  return build({
    detectSubjectType: (resource) => {
      if (!resource || typeof resource === "string") {
        return resource;
      }
      return resource[RESOURCE_TYPE_KEY];
    },
    resolveAction
  });
}
defineAbilities.registerHook = function(hook) {
  if (!hooks.includes(hook)) {
    hooks.push(hook);
  }
};
defineAbilities.unregisterHook = function(hook) {
  hooks = hooks.filter((registeredHook) => registeredHook !== hook);
};
function hasServiceAbilities(abilities, service2) {
  if (!abilities) return false;
  const path2 = typeof service2 === "string" ? service2 : service2.getPath();
  const allContextsPath = _$1.replace(path2, /^.*\//, "*/");
  return abilities.can("service", path2) || abilities.can("service", `*/${path2}`) || abilities.can("service", allContextsPath);
}
function hasResourceAbilities(abilities, operation, resourceType, context2, resource) {
  if (!abilities) return false;
  const object = Object.assign({}, resource);
  object[RESOURCE_TYPE_KEY] = resourceType;
  if (context2) object.context = typeof context2 === "object" ? context2._id.toString() : context2.toString();
  const result = abilities.can(operation, object);
  return result;
}
function removeContext(query) {
  _$1.forOwn(query, (value, key) => {
    if (key === "context") {
      delete query.context;
    } else if (Array.isArray(value)) {
      value.forEach((item) => removeContext(item));
      if (_$1.isEmpty(value)) delete query[key];
    } else if (typeof value === "object") {
      removeContext(value);
      if (_$1.isEmpty(value)) delete query[key];
    }
  });
  return query;
}
function getQueryForAbilities(abilities, operation, resourceType) {
  if (!abilities) return null;
  const query = toMongoQuery(abilities, resourceType, operation);
  return query ? removeContext(_$1.cloneDeep(query)) : null;
}
function buildSubjectsQueryForResource(resourceScope, resourceId, role) {
  const query = { [resourceScope]: { $elemMatch: { _id: resourceId } } };
  if (role) {
    _$1.set(query[resourceScope], "$elemMatch.permissions", typeof role === "string" ? role : RoleNames[role]);
  }
  return query;
}
function findSubjectsForResource(subjectService, resourceScope, resourceId, role) {
  const query = buildSubjectsQueryForResource(resourceScope, resourceId, role);
  return subjectService.find({ query });
}
function countSubjectsForResource(subjectService, resourceScope, resourceId, role) {
  const query = buildSubjectsQueryForResource(resourceScope, resourceId, role);
  query.$limit = 0;
  return subjectService.find({ query });
}
function isSeniorRole(roleName, juniorName) {
  return Roles[roleName] >= Roles[juniorName];
}
function isJuniorRole(roleName, seniorName) {
  return Roles[roleName] < Roles[seniorName];
}
function getSeniorRoles(roleName) {
  const seniorRoles = [];
  _$1.forEach(Roles, (role) => {
    if (Roles[roleName] < role) seniorRoles.push(RoleNames[role]);
  });
  return seniorRoles;
}
function getJuniorRoles(roleName) {
  const juniorRoles = [];
  _$1.forEach(Roles, (role) => {
    if (Roles[roleName] >= role) juniorRoles.push(RoleNames[role]);
  });
  return juniorRoles;
}
const permissions$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RESOURCE_TYPE,
  RESOURCE_TYPE_KEY,
  RoleNames,
  Roles,
  countSubjectsForResource,
  defineAbilities,
  defineResourceRules,
  defineUserAbilities: defineUserAbilities$1,
  findSubjectsForResource,
  getJuniorRoles,
  getQueryForAbilities,
  getSeniorRoles,
  hasResourceAbilities,
  hasServiceAbilities,
  isJuniorRole,
  isSeniorRole,
  removeContext
}, Symbol.toStringTag, { value: "Module" }));
const defaultOptions = {
  allErrors: true,
  strict: false,
  $data: true,
  keywords: ["field"]
};
const Schema = {
  initialize(options) {
    this.ajv = new Ajv(options || defaultOptions);
    addKeywords(this.ajv);
    addFormats(this.ajv);
  },
  register(schema) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    if (!schema.$id) throw new Error("the schema must have an `$id` property");
    return this.ajv.getSchema(schema.$id) || this.ajv.compile(schema);
  },
  addKeyword(keyword) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.addKeyword(keyword);
  },
  getKeyword(keyword) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    return this.ajv.getKeyword(keyword);
  },
  removeKeyword(keyword) {
    if (!this.ajv) throw new Error("Schema must be initialized first");
    this.ajv.removeKeyword(keyword);
  }
};
const debug = makeDebug("kdk:core:offline");
async function makeServiceSnapshot(service2, options) {
  let { baseQuery, baseQueries, offlineService, dataPath = "data" } = options;
  let items = [];
  if (!baseQueries) baseQueries = [baseQuery];
  for (let i = 0; i < baseQueries.length; i++) {
    const query = Object.assign({ $skip: 0 }, baseQueries[i]);
    debug(`[KDK] making service snapshot with query ${JSON.stringify(query)}`);
    if (offlineService && _$1.get(options, "clear", true)) await offlineService.remove(null, { query: _$1.omit(baseQueries[i], ["$limit"]) });
    let result = await service2.find({ query });
    let data = _$1.get(result, dataPath) || result;
    if (offlineService) await offlineService.create(data, { addId: false, snapshot: true });
    items = items.concat(data);
    if (!_$1.get(result, dataPath)) return items;
    const { total, limit } = result;
    while (query.$skip + data.length < total) {
      query.$skip += limit;
      debug(`[KDK] getting service ${service2.name} next page with query ${JSON.stringify(query)}`);
      result = await service2.find({ query });
      data = _$1.get(result, dataPath);
      if (offlineService) {
        await offlineService.create(data, { addId: false, snapshot: true });
      } else {
        items = items.concat(data);
      }
    }
  }
  return items;
}
function addQueryParameter(baseUrl, parameter, value) {
  const prefix = baseUrl.includes("?") ? "&" : "?";
  return `${baseUrl}${prefix}${parameter}=${Array.isArray(value) ? JSON.stringify(value) : value}`;
}
function buildUrl(baseUrl, parameters) {
  let url = baseUrl;
  _$1.forOwn(parameters, function(value, key) {
    url = addQueryParameter(url, key, value);
  });
  return url;
}
function buildEncodedUrl(baseUrl, parameters) {
  return encodeURI(buildEncodedUrl());
}
function makeDiacriticPattern(pattern, options = {}) {
  const diacritics = ["a,á,à,ä,â,ã", "e,é,ë,è,ê", "i,í,ï,ì,î", "o,ó,ö,ò,õ,ô", "u,ü,ú,ù,û", "c,ç"];
  let result = "";
  for (const character of pattern) {
    const family = diacritics.find((family2) => {
      if (options.reverse) return family2.includes(character);
      else return family2[0] === character;
    });
    if (!family) result += character;
    else result += `[${family}]`;
  }
  return result;
}
const LocalCache = {
  initialize() {
    const config2 = { name: "offline_cache", storeName: "cache_entries" };
    this.storage = LocalForage.createInstance(config2);
    logger$1.debug("[KDK] LocalForage initialized with configuration:", config2);
  },
  getStorage() {
    return this.storage;
  },
  async getItem(key) {
    return await this.storage.getItem(key);
  },
  async setItem(key, item) {
    await this.storage.setItem(key, item);
  },
  async removeItem(key) {
    return await this.storage.removeItem(key);
  },
  async createCache(cacheName) {
    const cache = await caches.open(cacheName);
    return cache;
  },
  async getCache(cacheName) {
    const cache = await caches.open(cacheName);
    return cache;
  },
  async removeCache(cacheName) {
    await caches.delete(cacheName);
  },
  async has(key) {
    return !_$1.isNil(this.getCount(key));
  },
  async getCount(key) {
    return await this.storage.getItem(key);
  },
  async setCount(key, count) {
    await this.storage.setItem(key, count);
  },
  async set(cacheName, key, url, fetchOptions = {}) {
    const count = await this.getCount(key);
    if (!_$1.isNil(count)) {
      await this.setCount(key, count + 1);
    } else {
      const cache = await this.getCache(cacheName);
      let response = await fetch(url, fetchOptions);
      if (response.status === 206) response = new Response(response.body, { status: 200, headers: response.headers });
      await cache.put(key, response);
      await this.storage.setItem(key, 1);
    }
  },
  async unset(cacheName, key) {
    const cache = await this.getCache(cacheName);
    const count = await this.getCount(key);
    if (_$1.isNil(count)) return;
    if (count <= 1) {
      cache.delete(key);
      await this.storage.removeItem(key);
    } else {
      await this.setCount(key, count - 1);
    }
  }
};
function emit(hook) {
  if (_$1.get(hook, `params.skip-${hook.type}-event`)) return;
  Events.emit(hook.type + "-hook", hook);
}
function log(hook) {
  let message = `[KDK] ${hook.type}: ${hook.path} - Method: ${hook.method}`;
  if (hook.type === "error") {
    message += `: ${hook.error.message}`;
  }
  logger$1.debug(message);
  if (hook.error) {
    logger$1.error(hook.error);
  }
  if (hook.data) {
    logger$1.trace(hook.data);
  }
  if (hook.params) {
    logger$1.trace(hook.params);
  }
  if (hook.result) {
    logger$1.trace(hook.result);
  }
}
let buf, bufIdx = 0;
const hexBytes = new Array(256);
for (let i = 0; i < 256; i++) {
  hexBytes[i] = (i + 256).toString(16).substring(1);
}
const randomBytes = (() => {
  const lib = typeof crypto !== "undefined" ? crypto : typeof window !== "undefined" ? window.crypto || window.msCrypto : void 0;
  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }
    if (lib.getRandomValues !== void 0) {
      return (n) => {
        const bytes = new Uint8Array(n);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }
  return (n) => {
    const r = [];
    for (let i = n; i > 0; i--) {
      r.push(Math.floor(Math.random() * 256));
    }
    return r;
  };
})();
const BUFFER_SIZE = 4096;
function uid$2() {
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }
  const b = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b[6] = b[6] & 15 | 64;
  b[8] = b[8] & 63 | 128;
  return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + "-" + hexBytes[b[4]] + hexBytes[b[5]] + "-" + hexBytes[b[6]] + hexBytes[b[7]] + "-" + hexBytes[b[8]] + hexBytes[b[9]] + "-" + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
}
function removeServerSideParameters$1(context2) {
  const params = context2.params;
  _$1.unset(params, "query.$locale");
  _$1.unset(params, "query.$collation");
  _$1.unset(params, "query.populate");
  if (_$1.has(params, "query.upsert")) {
    _$1.set(params, "upsert", _$1.get(params, "query.upsert"));
    _$1.unset(params, "query.upsert");
  }
}
function generateId(context2) {
  const params = context2.params;
  if (params.snapshot) return;
  const data = Array.isArray(context2.data) ? context2.data : [context2.data];
  data.filter((item) => !item._id).forEach((item) => {
    item._id = uid$2().toString();
  });
}
function ensureSerializable(context2) {
  if (context2.data) context2.data = _$1.cloneDeep(context2.data);
}
async function checkUnique(hook) {
  const accountService = hook.app.getService("account");
  try {
    await accountService.create({
      action: "checkUnique",
      value: { email: hook.data.email }
    }, {
      // As we manage error we make this call transparent from the client perspective
      // This will avoid displaying an error message twice
      "skip-before-event": true,
      "skip-after-event": true,
      "skip-error-event": true
    });
  } catch (error) {
    if (error.code === 400) {
      error.data.translation = { key: "EMAIL_ALREADY_TAKEN" };
    }
    throw error;
  }
  return hook;
}
const index$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  checkUnique,
  emit,
  ensureSerializable,
  generateId,
  log,
  removeServerSideParameters: removeServerSideParameters$1
}, Symbol.toStringTag, { value: "Module" }));
feathers.authentication.AuthenticationClient.prototype.handleSocket = () => {
};
async function createClient(config$1) {
  if (_$1.get(config, "logs.level")) {
    logger$1.setLevel(_$1.get(config, "logs.level"), false);
  } else {
    logger$1.setLevel("info");
  }
  const api2 = feathers();
  api2.isDisconnected = !navigator.onLine;
  addEventListener("online", () => {
    api2.isDisconnected = false;
    Events.emit("navigator-reconnected", api2);
  });
  addEventListener("offline", () => {
    api2.isDisconnected = true;
    Events.emit("navigator-disconnected", api2);
  });
  api2.useLocalFirst = config$1.useLocalFirst;
  api2.setLocalFirstEnabled = function(enabled) {
    api2.useLocalFirst = enabled;
  };
  let matchers = [];
  function siftMatcher2(originalQuery) {
    const keysToOmit = Object.keys(originalQuery).filter((key) => key.charCodeAt(0) === 36);
    let query = _$1.omit(originalQuery, ...keysToOmit);
    _$1.forOwn(query, (value, key) => {
      if (typeof value === "object" && _$1.has(value, "$search")) {
        query[key] = { $regex: new RegExp(_$1.get(value, "$search"), "i") };
      }
    });
    for (const matcher of matchers) {
      query = matcher(query);
    }
    return sift(query);
  }
  api2.registerMatcher = function(matcher) {
    if (!matchers.includes(matcher)) {
      matchers.push(matcher);
    }
  };
  api2.unregisterMatcher = function(matcher) {
    matchers = matchers.filter((registeredMatcher) => registeredMatcher !== matcher);
  };
  api2.matcher = siftMatcher2;
  api2.getServicePath = function(name, context2, withApiPrefix = true) {
    let path2 = name;
    if (!_$1.isEmpty(context2)) {
      if (typeof context2 === "string") {
        if (context2 !== "global") path2 = context2 + "/" + name;
      } else if (context2._id) {
        path2 = context2._id + "/" + name;
      }
    }
    if (withApiPrefix) {
      path2 = config$1.apiPath + "/" + path2;
    }
    if (path2.startsWith("/")) path2 = path2.substr(1);
    return path2;
  };
  api2.getServiceInstance = function(name, context2, options = {}) {
    let service2;
    if (!_$1.isEmpty(context2)) {
      const servicePath = api2.getServicePath(name, context2);
      service2 = options.create ? api2.service(servicePath) : api2.services[servicePath];
    } else {
      const currentContext = Store.get("context");
      const contextualPath = api2.getServicePath(name, currentContext);
      const contextualService = api2.services[contextualPath];
      const globalPath = api2.getServicePath(name);
      const globalService = api2.services[globalPath];
      service2 = contextualService || globalService;
      if (!service2 && options.create) {
        service2 = api2.service(globalPath);
      }
    }
    return service2;
  };
  api2.getOnlineService = function(name, context2, options = {}) {
    return api2.getServiceInstance(name, context2, Object.assign({ create: true }, options));
  };
  api2.getOfflineService = function(name, context2, options = {}) {
    return api2.getServiceInstance(`${name}-offline`, context2, Object.assign({ create: false }, options));
  };
  api2.getService = function(name, context2, options = {}) {
    let service2;
    if (api2.isDisconnected || api2.useLocalFirst) {
      service2 = api2.getOfflineService(name, context2, options);
      if (!service2 && !api2.useLocalFirst) {
        logger$1.warn("[KDK] Cannot retrieve offline service " + name + " for context " + (typeof context2 === "object" ? context2._id : context2));
      }
    }
    if (!service2) {
      service2 = api2.getOnlineService(name, context2, options);
      if (!service2) {
        throw new Error("Cannot retrieve service " + name + " for context " + (typeof context2 === "object" ? context2._id : context2));
      }
    }
    return service2;
  };
  api2.createService = function(name, options = {}) {
    const servicePath = api2.getServicePath(name, options.context);
    let service2 = options.service;
    if (typeof service2 === "function") {
      service2 = service2(name, api2, options);
    }
    if (!service2) service2 = api2.transporter.service(servicePath);
    api2.use(servicePath, service2, options);
    service2 = api2.service(servicePath);
    if (options.hooks) service2.hooks(options.hooks);
    if (options.context) service2.context = options.context;
    service2.path = servicePath;
    return service2;
  };
  api2.createOfflineService = async function(serviceName, options = {}) {
    const offlineServiceName = `${serviceName}-offline`;
    let offlineService = api2.getOfflineService(serviceName);
    if (!offlineService) {
      const serviceOptions = _$1.omit(options, ["hooks", "snapshot", "clear", "baseQuery", "baseQueries", "dataPath"]);
      const services = await LocalCache.getItem("services") || {};
      _$1.set(services, serviceName, serviceOptions);
      await LocalCache.setItem("services", services);
      offlineService = api2.createService(offlineServiceName, {
        service: createOfflineService({
          id: "_id",
          name: "offline_services",
          storeName: serviceName,
          multi: true,
          storage: ["IndexedDB"],
          // FIXME: this should not be hard-coded as it depends on the service
          // For now we set it at the max value but if a component
          // does not explicitly set the limit it will get a lot of data
          paginate: { default: 5e3, max: 5e3 }
        }),
        // Set required default hooks
        hooks: _$1.defaultsDeep(_$1.get(options, "hooks"), {
          before: {
            all: [ensureSerializable, removeServerSideParameters$1],
            create: [generateId]
          }
        }),
        ...serviceOptions
      });
    }
    if (_$1.get(options, "snapshot", true)) {
      const service2 = api2.getOnlineService(serviceName);
      await makeServiceSnapshot(service2, Object.assign({ offlineService }, options));
    }
    return offlineService;
  };
  api2.removeService = function(name, context2) {
    const path2 = api2.getServicePath(name, context2);
    api2.unuse(path2);
  };
  api2.getConfig = function(path2) {
    return path2 ? _$1.get(config$1, path2) : config$1;
  };
  api2.setConfig = function(path2, value) {
    _$1.set(config$1, path2, value);
  };
  api2.hasConfig = function(path2, value) {
    return _$1.has(config$1, path2, value);
  };
  api2.can = function() {
    let service2, context2, resource;
    const user = arguments[arguments.length - 1];
    const hasUser = _$1.has(user, "abilities");
    const nbArguments = hasUser ? arguments.length - 1 : arguments.length;
    const operation = arguments[0];
    service2 = arguments[1];
    if (nbArguments === 4) {
      context2 = arguments[2];
      resource = arguments[3];
    } else {
      if (typeof arguments[2] === "string") context2 = arguments[2];
      else resource = arguments[2];
    }
    if (_$1.has(service2, "abilities")) service2 = void 0;
    if (_$1.has(context2, "abilities")) context2 = void 0;
    if (_$1.has(resource, "abilities")) resource = void 0;
    const abilities = hasUser ? _$1.get(user, "abilities") : Store.get("user.abilities");
    logger$1.debug("[KDK] Check for abilities ", operation, service2, context2, resource, abilities);
    if (!abilities) {
      logger$1.debug("[KDK] Access denied without abilities");
      return false;
    }
    let result;
    if (service2) {
      const path2 = api2.getServicePath(service2, context2, false);
      result = hasServiceAbilities(abilities, path2);
      if (!result) {
        logger$1.debug("[KDK] Access to service path " + path2 + " denied");
        return false;
      } else if (operation === "service") {
        return true;
      }
      result = hasResourceAbilities(abilities, operation, service2, context2, resource);
    } else {
      result = abilities.can(operation);
    }
    if (!result) {
      logger$1.debug("[KDK] Access to resource denied");
    } else {
      logger$1.debug("[KDK] Access to resource granted");
    }
    return result;
  };
  const origin = api2.getConfig("domain");
  if (config$1.transport === "http") {
    api2.transporter = feathers.rest(origin).fetch(window.fetch.bind(window));
    api2.configure(api2.transporter);
  } else {
    api2.socket = io(origin, {
      transports: ["websocket"],
      path: (config$1.apiPath || "/") + "ws"
    });
    api2.transporter = feathers.socketio(api2.socket, { timeout: config$1.apiTimeout || 1e4 });
    api2.configure(api2.transporter);
    api2.socket.on("rate-limit", (error) => Events.emit("error", error));
    api2.socket.io.on("reconnect", async () => {
      api2.isDisconnected = false;
      api2.socket.sendBuffer = [];
      await api2.reAuthenticate(true);
      Events.emit("websocket-reconnected", api2);
      logger$1.info("[KDK] Socket has been reconnected");
    });
    api2.socket.io.on("reconnect_error", () => {
      api2.isDisconnected = true;
      Events.emit("websocket-disconnected", api2);
      logger$1.error(new Error("[KDK] Socket has been disconnected"));
    });
  }
  api2.configure(feathers.authentication({
    storage: window.localStorage,
    storageKey: config$1.apiJwt || "feathers-jwt",
    path: config$1.apiPath + "/authentication"
  }));
  api2.configure(rx({
    idField: "_id",
    matcher: siftMatcher2
    // Our custom matcher to handle fuzzy search
  }));
  api2.renewJwtOnExpiration = function(authResult) {
    const { accessToken } = authResult;
    const jwt = jwtdecode(accessToken);
    if (!jwt.exp) return;
    const now = moment();
    const expiration = moment.unix(jwt.exp);
    const delay = expiration.diff(now) - 2e3;
    setTimeout(() => {
      api2.reAuthenticate(true);
    }, delay);
  };
  if (_$1.get(config$1, "renewJwt", true)) {
    api2.on("login", api2.renewJwtOnExpiration);
  }
  api2.configure = async function(fn) {
    await fn.call(this, this);
    return this;
  };
  if (!api2.getConfig("domain")) api2.setConfig("domain", window.location.origin);
  if (!api2.isDisconnected) {
    try {
      const url = new URL(api2.getConfig("domain") + config$1.apiPath + "/capabilities");
      url.searchParams.set("random", Math.random().toFixed(18).substring(2, 18));
      await window.fetch(url.toString(), { method: "HEAD" });
    } catch (error) {
      api2.isDisconnected = true;
      Events.emit("navigator-disconnected", api2);
      logger$1.warn(`[KDK] Cannot request target domain ${api2.getConfig("domain")}, setting state to offline`, error);
    }
  }
  return api2;
}
let api;
async function initializeApi(fn) {
  api = await createClient(config);
  if (fn) fn.call(api, config);
  return api;
}
const Context = {
  serviceName: null,
  service: null,
  initialize() {
    this.serviceName = _$1.get(config, "context.service");
    if (!_$1.isEmpty(this.serviceName)) {
      Store.set("context", null);
      logger$1.debug(`[KDK] Context configured with service '${this.serviceName}'`);
    }
  },
  get() {
    return Store.get("context");
  },
  getId() {
    return _$1.get(this.get(), "_id");
  },
  getRef() {
    return Store.getRef("context");
  },
  getService() {
    if (_$1.isEmpty(this.serviceName)) throw new Error("[KDK] Context service undefined !");
    if (this.service) return this.service;
    this.service = api.getService(this.serviceName);
    if (_$1.isNil(this.service)) throw new Error("[KDK] Context service not found !");
    return this.service;
  },
  set(context2) {
    Store.set("context", context2);
  }
};
function injectProp(target2, propName, get2, set2) {
  Object.defineProperty(target2, propName, {
    get: get2,
    set: set2,
    enumerable: true
  });
  return target2;
}
const isRuntimeSsrPreHydration = ref(
  false
);
let iosCorrection;
function getMatch(userAgent2, platformMatch) {
  const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent2) || /(opr)[\/]([\w.]+)/.exec(userAgent2) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent2) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent2) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+)/.exec(userAgent2) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent2) || [];
  return {
    browser: match[5] || match[3] || match[1] || "",
    version: match[2] || match[4] || "0",
    versionNumber: match[4] || match[2] || "0",
    platform: platformMatch[0] || ""
  };
}
function getPlatformMatch(userAgent2) {
  return /(ipad)/.exec(userAgent2) || /(ipod)/.exec(userAgent2) || /(windows phone)/.exec(userAgent2) || /(iphone)/.exec(userAgent2) || /(kindle)/.exec(userAgent2) || /(silk)/.exec(userAgent2) || /(android)/.exec(userAgent2) || /(win)/.exec(userAgent2) || /(mac)/.exec(userAgent2) || /(linux)/.exec(userAgent2) || /(cros)/.exec(userAgent2) || /(playbook)/.exec(userAgent2) || /(bb)/.exec(userAgent2) || /(blackberry)/.exec(userAgent2) || [];
}
const hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function applyIosCorrection(is) {
  iosCorrection = { is: { ...is } };
  delete is.mac;
  delete is.desktop;
  const platform = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(is, {
    mobile: true,
    ios: true,
    platform,
    [platform]: true
  });
}
function getPlatform(UA) {
  const userAgent2 = UA.toLowerCase(), platformMatch = getPlatformMatch(userAgent2), matched = getMatch(userAgent2, platformMatch), browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
    browser.versionNumber = parseInt(matched.versionNumber, 10);
  }
  if (matched.platform) {
    browser[matched.platform] = true;
  }
  const knownMobiles = browser.android || browser.ios || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser["windows phone"];
  if (knownMobiles === true || userAgent2.indexOf("mobile") > -1) {
    browser.mobile = true;
    if (browser.edga || browser.edgios) {
      browser.edge = true;
      matched.browser = "edge";
    } else if (browser.crios) {
      browser.chrome = true;
      matched.browser = "chrome";
    } else if (browser.fxios) {
      browser.firefox = true;
      matched.browser = "firefox";
    }
  } else {
    browser.desktop = true;
  }
  if (browser.ipod || browser.ipad || browser.iphone) {
    browser.ios = true;
  }
  if (browser["windows phone"]) {
    browser.winphone = true;
    delete browser["windows phone"];
  }
  if (browser.chrome || browser.opr || browser.safari || browser.vivaldi || browser.mobile === true && browser.ios !== true && knownMobiles !== true) {
    browser.webkit = true;
  }
  if (browser.edg) {
    matched.browser = "edgechromium";
    browser.edgeChromium = true;
  }
  if (browser.safari && browser.blackberry || browser.bb) {
    matched.browser = "blackberry";
    browser.blackberry = true;
  }
  if (browser.safari && browser.playbook) {
    matched.browser = "playbook";
    browser.playbook = true;
  }
  if (browser.opr) {
    matched.browser = "opera";
    browser.opera = true;
  }
  if (browser.safari && browser.android) {
    matched.browser = "android";
    browser.android = true;
  }
  if (browser.safari && browser.kindle) {
    matched.browser = "kindle";
    browser.kindle = true;
  }
  if (browser.safari && browser.silk) {
    matched.browser = "silk";
    browser.silk = true;
  }
  if (browser.vivaldi) {
    matched.browser = "vivaldi";
    browser.vivaldi = true;
  }
  browser.name = matched.browser;
  browser.platform = matched.platform;
  {
    if (userAgent2.indexOf("electron") > -1) {
      browser.electron = true;
    } else if (document.location.href.indexOf("-extension://") > -1) {
      browser.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser.capacitor = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "capacitor";
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser.cordova = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "cordova";
      }
      if (hasTouch === true && browser.mac === true && (browser.desktop === true && browser.safari === true || browser.nativeMobile === true && browser.android !== true && browser.ios !== true && browser.ipad !== true)) {
        applyIosCorrection(browser);
      }
    }
  }
  return browser;
}
const userAgent = navigator.userAgent || navigator.vendor || window.opera;
const ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: { iframe: false }
};
const client = {
  userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch
  },
  within: {
    iframe: window.self !== window.top
  }
};
const Platform$1 = {
  install(opts) {
    const { $q } = opts;
    if (isRuntimeSsrPreHydration.value === true) {
      opts.onSSRHydrated.push(() => {
        Object.assign($q.platform, client);
        isRuntimeSsrPreHydration.value = false;
        iosCorrection = void 0;
      });
      $q.platform = reactive(this);
    } else {
      $q.platform = this;
    }
  }
};
{
  let hasWebStorage;
  injectProp(client.has, "webStorage", () => {
    if (hasWebStorage !== void 0) {
      return hasWebStorage;
    }
    try {
      if (window.localStorage) {
        hasWebStorage = true;
        return true;
      }
    } catch (e) {
    }
    hasWebStorage = false;
    return false;
  });
  client.is.ios === true && window.navigator.vendor.toLowerCase().indexOf("apple") === -1;
  if (isRuntimeSsrPreHydration.value === true) {
    Object.assign(Platform$1, client, iosCorrection, ssrClient);
  } else {
    Object.assign(Platform$1, client);
  }
}
const Platform = {
  async initialize() {
    _$1.merge(this, _$1.omit(Platform$1, ["install", "__installed"]));
    this.fingerprint = await getFingerprint();
    this.fingerprintData = await getFingerprintData();
    this.is.pwa = _$1.get(config, "buildMode", "spa") === "pwa";
    logger$1.debug("[KDK] Platform initialized with:", this);
  },
  getData(scope) {
    const data = {
      userAgent: this.userAgent,
      application: {
        mode: this.is.pwa ? "PWA" : "SPA",
        iframe: this.within.iframe,
        permissions: _$1.get(this.fingerprintData, "permissions")
      },
      browser: Object.assign(
        {},
        _$1.get(this.fingerprintData, "system.browser"),
        { locale: _$1.get(this.fingerprintData, "locales") },
        { webgl: _$1.get(this.fingerprintData, "hardware.videocard") }
      ),
      system: {
        os: _$1.get(this.fingerprintData, "system.platform"),
        desktop: this.is.desktop || false,
        mobile: this.is.mobile || false,
        touch: this.is.touch || false
      }
    };
    if (_$1.isEmpty(scope)) return data;
    return _$1.get(data, scope);
  }
};
const Capabilities = {
  async initialize() {
    if (api.isDisconnected || api.useLocalFirst) {
      this.content = await LocalCache.getItem("capabilities");
    }
    if (!this.content) {
      const capabilities = await window.fetch(api.getConfig("domain") + _$1.get(config, "apiPath") + "/capabilities");
      this.content = await capabilities.json();
      await LocalCache.setItem("capabilities", this.content);
    }
    logger$1.debug("[KDK] Capabilities initialized with content:", this.content);
    if (!this.content) return;
    _$1.forOwn(_$1.pick(this.content, ["gateway"]), (value, key) => {
      api.setConfig(key, value);
    });
    Store.set("capabilities.api", this.content);
    Store.set("capabilities.client", _$1.pick(config, ["version", "buildNumber"]));
  },
  get(key, defaultValue) {
    if (!this.content) logger$1.error(new Error("[KDK] Capabilities must be initialized first"));
    else return _$1.get(this.content, key, defaultValue);
  }
};
const LocalStorage = {
  initialize() {
    this.prefix = _$1.get(config, "appSlug", _$1.kebabCase(_$1.get(config, "appName", "kdk")));
    logger$1.debug(`[KDK] LocalStorage initialized with prefix: '${this.prefix}'`);
  },
  localKey(key) {
    const keyPrefix = `${this.prefix}-`;
    if (_$1.startsWith(keyPrefix)) return key;
    return `${keyPrefix}${key}`;
  },
  set(key, value) {
    const jsonValue = JSON.stringify(value);
    window.localStorage.setItem(this.localKey(key), jsonValue);
  },
  has(key) {
    const value = window.localStorage.getItem(this.localKey(key));
    return !_$1.isNil(value);
  },
  get(key, defaultValue) {
    const value = window.localStorage.getItem(this.localKey(key));
    if (_$1.isNil(value)) {
      logger$1.debug(`[KDK] Cannot find local storage value with key '${key}'. Returning default value '${defaultValue}'`);
      return defaultValue;
    }
    return JSON.parse(value);
  },
  clear(key) {
    window.localStorage.removeItem(this.localKey(key));
  }
};
const Broadcaster = {
  initialize() {
    this.channelName = _$1.get(config, "appSlug", _$1.kebabCase(_$1.get(config, "appName", "kdk")));
    this.channel = new BroadcastChannel(this.channelName);
    logger$1.debug(`[KDK] Broadcaster initialized with channel '${this.channelName}'`);
  },
  getChannelName() {
    return this.channelName;
  },
  getChannel() {
    return this.channel;
  },
  post(message) {
    this.channel.postMessage(message);
  }
};
const defineReactivePlugin = (state, plugin) => {
  const reactiveState = reactive(state);
  for (const name in state) {
    injectProp(
      plugin,
      name,
      () => reactiveState[name],
      (val) => {
        reactiveState[name] = val;
      }
    );
  }
  return plugin;
};
const listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: { passive: true },
        notPassive: { passive: false },
        passiveCapture: { passive: true, capture: true },
        notPassiveCapture: { passive: false, capture: true }
      });
    }
  });
  window.addEventListener("qtest", null, opts);
  window.removeEventListener("qtest", null, opts);
} catch (e) {
}
function noop() {
}
function position(e) {
  if (e.touches && e.touches[0]) {
    e = e.touches[0];
  } else if (e.changedTouches && e.changedTouches[0]) {
    e = e.changedTouches[0];
  } else if (e.targetTouches && e.targetTouches[0]) {
    e = e.targetTouches[0];
  }
  return {
    top: e.clientY,
    left: e.clientX
  };
}
function getEventPath(e) {
  if (e.path) {
    return e.path;
  }
  if (e.composedPath) {
    return e.composedPath();
  }
  const path2 = [];
  let el = e.target;
  while (el) {
    path2.push(el);
    if (el.tagName === "HTML") {
      path2.push(document);
      path2.push(window);
      return path2;
    }
    el = el.parentElement;
  }
}
function stop(e) {
  e.stopPropagation();
}
function prevent(e) {
  e.cancelable !== false && e.preventDefault();
}
function stopAndPrevent(e) {
  e.cancelable !== false && e.preventDefault();
  e.stopPropagation();
}
function addEvt(ctx, targetName, events) {
  const name = `__q_${targetName}_evt`;
  ctx[name] = ctx[name] !== void 0 ? ctx[name].concat(events) : events;
  events.forEach((evt) => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name = `__q_${targetName}_evt`;
  if (ctx[name] !== void 0) {
    ctx[name].forEach((evt) => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name] = void 0;
  }
}
function debounce(fn, wait = 250, immediate) {
  let timer = null;
  function debounced() {
    const args = arguments;
    const later = () => {
      timer = null;
      {
        fn.apply(this, args);
      }
    };
    if (timer !== null) {
      clearTimeout(timer);
    }
    timer = setTimeout(later, wait);
  }
  debounced.cancel = () => {
    timer !== null && clearTimeout(timer);
  };
  return debounced;
}
const SIZE_LIST = ["sm", "md", "lg", "xl"];
const { passive } = listenOpts;
const Screen = defineReactivePlugin({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false
}, {
  setSizes: noop,
  setDebounce: noop,
  install({ $q, onSSRHydrated }) {
    $q.screen = this;
    if (this.__installed === true) {
      if ($q.config.screen !== void 0) {
        if ($q.config.screen.bodyClasses === false) {
          document.body.classList.remove(`screen--${this.name}`);
        } else {
          this.__update(true);
        }
      }
      return;
    }
    const { visualViewport } = window;
    const target2 = visualViewport || window;
    const scrollingElement = document.scrollingElement || document.documentElement;
    const getSize2 = visualViewport === void 0 || client.is.mobile === true ? () => [
      Math.max(window.innerWidth, scrollingElement.clientWidth),
      Math.max(window.innerHeight, scrollingElement.clientHeight)
    ] : () => [
      visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
      visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
    ];
    const classes = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;
    this.__update = (force) => {
      const [w, h2] = getSize2();
      if (h2 !== this.height) {
        this.height = h2;
      }
      if (w !== this.width) {
        this.width = w;
      } else if (force !== true) {
        return;
      }
      let s = this.sizes;
      this.gt.xs = w >= s.sm;
      this.gt.sm = w >= s.md;
      this.gt.md = w >= s.lg;
      this.gt.lg = w >= s.xl;
      this.lt.sm = w < s.sm;
      this.lt.md = w < s.md;
      this.lt.lg = w < s.lg;
      this.lt.xl = w < s.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s = this.xs === true && "xs" || this.sm === true && "sm" || this.md === true && "md" || this.lg === true && "lg" || "xl";
      if (s !== this.name) {
        if (classes === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s}`);
        }
        this.name = s;
      }
    };
    let updateEvt, updateSizes = {}, updateDebounce = 16;
    this.setSizes = (sizes) => {
      SIZE_LIST.forEach((name) => {
        if (sizes[name] !== void 0) {
          updateSizes[name] = sizes[name];
        }
      });
    };
    this.setDebounce = (deb) => {
      updateDebounce = deb;
    };
    const start = () => {
      const style2 = getComputedStyle(document.body);
      if (style2.getPropertyValue("--q-size-sm")) {
        SIZE_LIST.forEach((name) => {
          this.sizes[name] = parseInt(style2.getPropertyValue(`--q-size-${name}`), 10);
        });
      }
      this.setSizes = (sizes) => {
        SIZE_LIST.forEach((name) => {
          if (sizes[name]) {
            this.sizes[name] = sizes[name];
          }
        });
        this.__update(true);
      };
      this.setDebounce = (delay) => {
        updateEvt !== void 0 && target2.removeEventListener("resize", updateEvt, passive);
        updateEvt = delay > 0 ? debounce(this.__update, delay) : this.__update;
        target2.addEventListener("resize", updateEvt, passive);
      };
      this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length !== 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0;
      } else {
        this.__update();
      }
      classes === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    if (isRuntimeSsrPreHydration.value === true) {
      onSSRHydrated.push(start);
    } else {
      start();
    }
  }
});
const Plugin$4 = defineReactivePlugin({
  isActive: false,
  mode: false
}, {
  __media: void 0,
  set(val) {
    Plugin$4.mode = val;
    if (val === "auto") {
      if (Plugin$4.__media === void 0) {
        Plugin$4.__media = window.matchMedia("(prefers-color-scheme: dark)");
        Plugin$4.__updateMedia = () => {
          Plugin$4.set("auto");
        };
        Plugin$4.__media.addListener(Plugin$4.__updateMedia);
      }
      val = Plugin$4.__media.matches;
    } else if (Plugin$4.__media !== void 0) {
      Plugin$4.__media.removeListener(Plugin$4.__updateMedia);
      Plugin$4.__media = void 0;
    }
    Plugin$4.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? "light" : "dark"}`);
    document.body.classList.add(`body--${val === true ? "dark" : "light"}`);
  },
  toggle() {
    {
      Plugin$4.set(Plugin$4.isActive === false);
    }
  },
  install({ $q, onSSRHydrated, ssrContext }) {
    const { dark } = $q.config;
    $q.dark = this;
    if (this.__installed === true && dark === void 0) {
      return;
    }
    this.isActive = dark === true;
    const initialVal = dark !== void 0 ? dark : false;
    if (isRuntimeSsrPreHydration.value === true) {
      const ssrSet = (val) => {
        this.__fromSSR = val;
      };
      const originalSet = this.set;
      this.set = ssrSet;
      ssrSet(initialVal);
      onSSRHydrated.push(() => {
        this.set = originalSet;
        this.set(this.__fromSSR);
      });
    } else {
      this.set(initialVal);
    }
  }
});
const getTrue = () => true;
function filterInvalidPath(path2) {
  return typeof path2 === "string" && path2 !== "" && path2 !== "/" && path2 !== "#/";
}
function normalizeExitPath(path2) {
  path2.startsWith("#") === true && (path2 = path2.substring(1));
  path2.startsWith("/") === false && (path2 = "/" + path2);
  path2.endsWith("/") === true && (path2 = path2.substring(0, path2.length - 1));
  return "#" + path2;
}
function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return () => false;
  }
  if (cfg.backButtonExit === "*") {
    return getTrue;
  }
  const exitPaths = ["#/"];
  Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
    ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
  );
  return () => exitPaths.includes(window.location.hash);
}
const History = {
  __history: [],
  add: noop,
  remove: noop,
  install({ $q }) {
    if (this.__installed === true) {
      return;
    }
    const { cordova: cordova2, capacitor } = client.is;
    if (cordova2 !== true && capacitor !== true) {
      return;
    }
    const qConf = $q.config[cordova2 === true ? "cordova" : "capacitor"];
    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    }
    if (
      // if we're on Capacitor mode
      capacitor === true && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)
    ) {
      return;
    }
    this.add = (entry) => {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }
      this.__history.push(entry);
    };
    this.remove = (entry) => {
      const index2 = this.__history.indexOf(entry);
      if (index2 >= 0) {
        this.__history.splice(index2, 1);
      }
    };
    const shouldExit = getShouldExitFn(
      Object.assign(
        { backButtonExit: true },
        qConf
      )
    );
    const backHandler = () => {
      if (this.__history.length) {
        const entry = this.__history[this.__history.length - 1];
        if (entry.condition() === true) {
          this.__history.pop();
          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };
    if (cordova2 === true) {
      document.addEventListener("deviceready", () => {
        document.addEventListener("backbutton", backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener("backButton", backHandler);
    }
  }
};
const defaultLang = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh",
    expand: (label) => label ? `Expand "${label}"` : "Expand",
    collapse: (label) => label ? `Collapse "${label}"` : "Collapse"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: false,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (rows) => rows === 1 ? "1 record selected." : (rows === 0 ? "No" : rows) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (start, end, total) => start + "-" + end + " of " + total,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function getLocale$1() {
  const val = Array.isArray(navigator.languages) === true && navigator.languages.length !== 0 ? navigator.languages[0] : navigator.language;
  if (typeof val === "string") {
    return val.split(/[-_]/).map((v, i) => i === 0 ? v.toLowerCase() : i > 1 || v.length < 4 ? v.toUpperCase() : v[0].toUpperCase() + v.slice(1).toLowerCase()).join("-");
  }
}
const Plugin$3 = defineReactivePlugin({
  __langPack: {}
}, {
  getLocale: getLocale$1,
  set(langObject = defaultLang, ssrContext) {
    const lang = {
      ...langObject,
      rtl: langObject.rtl === true,
      getLocale: getLocale$1
    };
    {
      lang.set = Plugin$3.set;
      if (Plugin$3.__langConfig === void 0 || Plugin$3.__langConfig.noHtmlAttrs !== true) {
        const el = document.documentElement;
        el.setAttribute("dir", lang.rtl === true ? "rtl" : "ltr");
        el.setAttribute("lang", lang.isoName);
      }
      Object.assign(Plugin$3.__langPack, lang);
      Plugin$3.props = lang;
      Plugin$3.isoName = lang.isoName;
      Plugin$3.nativeName = lang.nativeName;
    }
  },
  install({ $q, lang, ssrContext }) {
    {
      $q.lang = Plugin$3.__langPack;
      Plugin$3.__langConfig = $q.config.lang;
      if (this.__installed === true) {
        lang !== void 0 && this.set(lang);
      } else {
        this.set(lang || defaultLang);
      }
    }
  }
});
let lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}
function getMobilePlatform(is) {
  if (is.ios === true) return "ios";
  if (is.android === true) return "android";
}
function getBodyClasses({ is, has: has2, within }, cfg) {
  const cls = [
    is.desktop === true ? "desktop" : "mobile",
    `${has2.touch === false ? "no-" : ""}touch`
  ];
  if (is.mobile === true) {
    const mobile = getMobilePlatform(is);
    mobile !== void 0 && cls.push("platform-" + mobile);
  }
  if (is.nativeMobile === true) {
    const type = is.nativeMobileWrapper;
    cls.push(type);
    cls.push("native-mobile");
    if (is.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push("q-ios-padding");
    }
  } else if (is.electron === true) {
    cls.push("electron");
  } else if (is.bex === true) {
    cls.push("bex");
  }
  within.iframe === true && cls.push("within-iframe");
  return cls;
}
function applyClientSsrCorrections() {
  const { is } = client;
  const classes = document.body.className;
  const classList = new Set(classes.replace(/ {2}/g, " ").split(" "));
  if (iosCorrection !== void 0) {
    classList.delete("desktop");
    classList.add("platform-ios");
    classList.add("mobile");
  } else if (is.nativeMobile !== true && is.electron !== true && is.bex !== true) {
    if (is.desktop === true) {
      classList.delete("mobile");
      classList.delete("platform-ios");
      classList.delete("platform-android");
      classList.add("desktop");
    } else if (is.mobile === true) {
      classList.delete("desktop");
      classList.add("mobile");
      const mobile = getMobilePlatform(is);
      if (mobile !== void 0) {
        classList.add(`platform-${mobile}`);
        classList.delete(`platform-${mobile === "ios" ? "android" : "ios"}`);
      } else {
        classList.delete("platform-ios");
        classList.delete("platform-android");
      }
    }
  }
  if (client.has.touch === true) {
    classList.delete("no-touch");
    classList.add("touch");
  }
  if (client.within.iframe === true) {
    classList.add("within-iframe");
  }
  const newCls = Array.from(classList).join(" ");
  if (classes !== newCls) {
    document.body.className = newCls;
  }
}
function setColors(brand) {
  for (const color in brand) {
    setCssVar(color, brand[color]);
  }
}
const Body = {
  install(opts) {
    if (this.__installed === true) {
      return;
    }
    if (isRuntimeSsrPreHydration.value === true) {
      applyClientSsrCorrections();
    } else {
      const { $q } = opts;
      $q.config.brand !== void 0 && setColors($q.config.brand);
      const cls = getBodyClasses(client, $q.config);
      document.body.classList.add.apply(document.body.classList, cls);
    }
    if (client.is.ios === true) {
      document.body.addEventListener("touchstart", noop);
    }
    window.addEventListener("keydown", onKeyDownComposition, true);
  }
};
const materialIcons = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
};
const Plugin$2 = defineReactivePlugin({
  iconMapFn: null,
  __icons: {}
}, {
  set(setObject, ssrContext) {
    const def = { ...setObject, rtl: setObject.rtl === true };
    {
      def.set = Plugin$2.set;
      Object.assign(Plugin$2.__icons, def);
    }
  },
  install({ $q, iconSet, ssrContext }) {
    {
      if ($q.config.iconMapFn !== void 0) {
        this.iconMapFn = $q.config.iconMapFn;
      }
      $q.iconSet = this.__icons;
      injectProp($q, "iconMapFn", () => this.iconMapFn, (val) => {
        this.iconMapFn = val;
      });
      if (this.__installed === true) {
        iconSet !== void 0 && this.set(iconSet);
      } else {
        this.set(iconSet || materialIcons);
      }
    }
  }
});
const quasarKey = "_q_";
const formKey = "_q_fo_";
const globalConfig = {};
let globalConfigIsFrozen = false;
function freezeGlobalConfig() {
  globalConfigIsFrozen = true;
}
function isObject$2(v) {
  return v !== null && typeof v === "object" && Array.isArray(v) !== true;
}
function isNumber$1(v) {
  return typeof v === "number" && isFinite(v);
}
const autoInstalledPlugins = [
  Platform$1,
  Body,
  Plugin$4,
  Screen,
  History,
  Plugin$3,
  Plugin$2
];
function createChildApp(appCfg, parentApp) {
  const app2 = createApp(appCfg);
  app2.config.globalProperties = parentApp.config.globalProperties;
  const { reload, ...appContext } = parentApp._context;
  Object.assign(app2._context, appContext);
  return app2;
}
function installPlugins(pluginOpts, pluginList) {
  pluginList.forEach((Plugin2) => {
    Plugin2.install(pluginOpts);
    Plugin2.__installed = true;
  });
}
function prepareApp(app2, uiOpts, pluginOpts) {
  app2.config.globalProperties.$q = pluginOpts.$q;
  app2.provide(quasarKey, pluginOpts.$q);
  installPlugins(pluginOpts, autoInstalledPlugins);
  uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach((c) => {
    if (isObject$2(c) === true && c.name !== void 0) {
      app2.component(c.name, c);
    }
  });
  uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach((d) => {
    if (isObject$2(d) === true && d.name !== void 0) {
      app2.directive(d.name, d);
    }
  });
  uiOpts.plugins !== void 0 && installPlugins(
    pluginOpts,
    Object.values(uiOpts.plugins).filter(
      (p) => typeof p.install === "function" && autoInstalledPlugins.includes(p) === false
    )
  );
  if (isRuntimeSsrPreHydration.value === true) {
    pluginOpts.$q.onSSRHydrated = () => {
      pluginOpts.onSSRHydrated.forEach((fn) => {
        fn();
      });
      pluginOpts.$q.onSSRHydrated = () => {
      };
    };
  }
}
const installQuasar = function(parentApp, opts = {}) {
  const $q = { version: "2.12.0" };
  if (globalConfigIsFrozen === false) {
    if (opts.config !== void 0) {
      Object.assign(globalConfig, opts.config);
    }
    $q.config = { ...globalConfig };
    freezeGlobalConfig();
  } else {
    $q.config = opts.config || {};
  }
  prepareApp(parentApp, opts, {
    parentApp,
    $q,
    lang: opts.lang,
    iconSet: opts.iconSet,
    onSSRHydrated: []
  });
};
const Quasar = {
  version: "2.12.0",
  install: installQuasar,
  lang: Plugin$3,
  iconSet: Plugin$2
};
function getBrowserLocale() {
  return navigator.language || _$1.get(navigator, "languages.0") || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;
}
function getLocale(languageOnly = true) {
  const locale2 = _$1.get(config, "locale.default", getBrowserLocale());
  if (!languageOnly) return locale2;
  const codes = _$1.split(locale2, "-");
  return _$1.head(codes);
}
function getFallbackLocale(languageOnly = true) {
  const locale2 = _$1.get(config, "locale.fallbackLocale", "en-GB");
  if (!languageOnly) return locale2;
  const codes = _$1.split(locale2, "-");
  return _$1.head(codes);
}
async function loadTranslationBundles(bundles, locale2, fallbackLocale) {
  const translations = {};
  translations[locale2] = {};
  translations[fallbackLocale] = {};
  for (let i = 0; i < bundles.length; i++) {
    try {
      const localeTranslationsModule = await import(`@i18n/${bundles[i]}_${locale2}.json`);
      _$1.merge(translations[locale2], localeTranslationsModule.default);
    } catch (error) {
      logger$1.warn(`[KDK] unable to load translation file ${bundles[i]}_${locale2}.json`);
    }
    try {
      const fallbackTranslationModule = await import(`@i18n/${bundles[i]}_${fallbackLocale}.json`);
      _$1.merge(translations[fallbackLocale], fallbackTranslationModule.default);
    } catch (error) {
      logger$1.error(`[KDK] unable to load translation file ${bundles[i]}_${fallbackLocale}.json`);
    }
  }
  return translations;
}
const i18n = {
  async initialize(app2, bundles) {
    const fallbackLocale = getFallbackLocale();
    const locale2 = getLocale();
    this.i18n = createI18n({
      locale: locale2,
      fallbackLocale,
      messages: await loadTranslationBundles(bundles, locale2, fallbackLocale),
      silentFallbackWarn: true
    });
    app2.use(this.i18n);
    try {
      const langagePack = await import(`quasar/lang/${getLocale(false)}.js`);
      if (langagePack) Quasar.lang.set(langagePack.default);
    } catch (error) {
      logger$1.error(error);
    }
  },
  registerTranslation(translation) {
    if (!this.i18n) {
      logger$1.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return;
    }
    const locale2 = this.i18n.global.locale;
    let messages = translation[locale2];
    if (messages) this.i18n.global.mergeLocaleMessage(locale2, messages);
    const fallbackLocale = this.i18n.global.fallbackLocale;
    messages = translation[fallbackLocale];
    if (messages) this.i18n.global.mergeLocaleMessage(fallbackLocale, messages);
  },
  t(key, params) {
    if (!this.i18n) {
      logger$1.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return key;
    }
    return this.i18n.global.t(key, params);
  },
  tc(key, choice) {
    if (!this.i18n) {
      logger$1.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return key;
    }
    if (this.i18n.global.te(key)) return this.i18n.global.tc(key, choice);
    if (this.i18n.global.te(key, this.i18n.global.fallbackLocale)) return this.i18n.global.tc(key, choice, this.i18n.global.fallbackLocale);
  },
  tie(key, params) {
    if (!this.i18n) {
      logger$1.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return key;
    }
    if (_$1.isEmpty(key)) return key;
    if (this.i18n.global.te(key)) return this.i18n.global.t(key, params);
    if (this.i18n.global.te(key, this.i18n.global.fallbackLocale)) return this.i18n.global.t(key, this.i18n.global.fallbackLocale, params);
    return key;
  },
  localize(path2) {
    if (!this.i18n) {
      logger$1.error("[KDK] i18n instance is not existing. Did you initialize it ?");
      return path2;
    }
    const index2 = path2.lastIndexOf(".");
    const baseName = index2 > 0 ? path2.substring(0, index2) : path2;
    const extName = index2 > 0 ? path2.substring(index2, path2.length) : "";
    return [
      `${baseName}_${this.i18n.global.locale}${extName}`,
      `${baseName}_${this.i18n.global.fallbackLocale}${extName}`,
      path2
    ];
  }
};
const useSizeDefaults = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
const useSizeProps = {
  size: String
};
function useSize(props2, sizes = useSizeDefaults) {
  return computed(() => props2.size !== void 0 ? { fontSize: props2.size in sizes ? `${sizes[props2.size]}px` : props2.size } : null);
}
const createComponent = (raw) => markRaw(defineComponent(raw));
const createDirective = (raw) => markRaw(raw);
function hSlot(slot, otherwise) {
  return slot !== void 0 ? slot() || otherwise : otherwise;
}
function hMergeSlot(slot, source) {
  return slot !== void 0 ? source.concat(slot()) : source;
}
function hMergeSlotSafely(slot, source) {
  if (slot === void 0) {
    return source;
  }
  return source !== void 0 ? source.concat(slot()) : slot();
}
const defaultViewBox = "0 0 24 24";
const sameFn = (i) => i;
const ionFn = (i) => `ionicons ${i}`;
const libMap = {
  "mdi-": (i) => `mdi ${i}`,
  "icon-": sameFn,
  // fontawesome equiv
  "bt-": (i) => `bt ${i}`,
  "eva-": (i) => `eva ${i}`,
  "ion-md": ionFn,
  "ion-ios": ionFn,
  "ion-logo": ionFn,
  "iconfont ": sameFn,
  "ti-": (i) => `themify-icon ${i}`,
  "bi-": (i) => `bootstrap-icons ${i}`
};
const matMap = {
  o_: "-outlined",
  r_: "-round",
  s_: "-sharp"
};
const symMap = {
  sym_o_: "-outlined",
  sym_r_: "-rounded",
  sym_s_: "-sharp"
};
const libRE = new RegExp("^(" + Object.keys(libMap).join("|") + ")");
const matRE = new RegExp("^(" + Object.keys(matMap).join("|") + ")");
const symRE = new RegExp("^(" + Object.keys(symMap).join("|") + ")");
const mRE = /^[Mm]\s?[-+]?\.?\d/;
const imgRE = /^img:/;
const svgUseRE = /^svguse:/;
const ionRE = /^ion-/;
const faRE = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;
const QIcon = createComponent({
  name: "QIcon",
  props: {
    ...useSizeProps,
    tag: {
      type: String,
      default: "i"
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  setup(props2, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const sizeStyle = useSize(props2);
    const classes = computed(
      () => "q-icon" + (props2.left === true ? " on-left" : "") + (props2.right === true ? " on-right" : "") + (props2.color !== void 0 ? ` text-${props2.color}` : "")
    );
    const type = computed(() => {
      let cls;
      let icon = props2.name;
      if (icon === "none" || !icon) {
        return { none: true };
      }
      if ($q.iconMapFn !== null) {
        const res = $q.iconMapFn(icon);
        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon = res.icon;
            if (icon === "none" || !icon) {
              return { none: true };
            }
          } else {
            return {
              cls: res.cls,
              content: res.content !== void 0 ? res.content : " "
            };
          }
        }
      }
      if (mRE.test(icon) === true) {
        const [def, viewBox = defaultViewBox] = icon.split("|");
        return {
          svg: true,
          viewBox,
          nodes: def.split("&&").map((path2) => {
            const [d, style2, transform] = path2.split("@@");
            return h("path", { style: style2, d, transform });
          })
        };
      }
      if (imgRE.test(icon) === true) {
        return {
          img: true,
          src: icon.substring(4)
        };
      }
      if (svgUseRE.test(icon) === true) {
        const [def, viewBox = defaultViewBox] = icon.split("|");
        return {
          svguse: true,
          src: def.substring(7),
          viewBox
        };
      }
      let content = " ";
      const matches = icon.match(libRE);
      if (matches !== null) {
        cls = libMap[matches[1]](icon);
      } else if (faRE.test(icon) === true) {
        cls = icon;
      } else if (ionRE.test(icon) === true) {
        cls = `ionicons ion-${$q.platform.is.ios === true ? "ios" : "md"}${icon.substring(3)}`;
      } else if (symRE.test(icon) === true) {
        cls = "notranslate material-symbols";
        const matches2 = icon.match(symRE);
        if (matches2 !== null) {
          icon = icon.substring(6);
          cls += symMap[matches2[1]];
        }
        content = icon;
      } else {
        cls = "notranslate material-icons";
        const matches2 = icon.match(matRE);
        if (matches2 !== null) {
          icon = icon.substring(2);
          cls += matMap[matches2[1]];
        }
        content = icon;
      }
      return {
        cls,
        content
      };
    });
    return () => {
      const data = {
        class: classes.value,
        style: sizeStyle.value,
        "aria-hidden": "true",
        role: "presentation"
      };
      if (type.value.none === true) {
        return h(props2.tag, data, hSlot(slots.default));
      }
      if (type.value.img === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("img", { src: type.value.src })
        ]));
      }
      if (type.value.svg === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox || "0 0 24 24"
          }, type.value.nodes)
        ]));
      }
      if (type.value.svguse === true) {
        return h("span", data, hMergeSlot(slots.default, [
          h("svg", {
            viewBox: type.value.viewBox
          }, [
            h("use", { "xlink:href": type.value.src })
          ])
        ]));
      }
      if (type.value.cls !== void 0) {
        data.class += " " + type.value.cls;
      }
      return h(props2.tag, data, hMergeSlot(slots.default, [
        type.value.content
      ]));
    };
  }
});
const QAvatar = createComponent({
  name: "QAvatar",
  props: {
    ...useSizeProps,
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  setup(props2, { slots }) {
    const sizeStyle = useSize(props2);
    const classes = computed(
      () => "q-avatar" + (props2.color ? ` bg-${props2.color}` : "") + (props2.textColor ? ` text-${props2.textColor} q-chip--colored` : "") + (props2.square === true ? " q-avatar--square" : props2.rounded === true ? " rounded-borders" : "")
    );
    const contentStyle = computed(() => props2.fontSize ? { fontSize: props2.fontSize } : null);
    return () => {
      const icon = props2.icon !== void 0 ? [h(QIcon, { name: props2.icon })] : void 0;
      return h("div", {
        class: classes.value,
        style: sizeStyle.value
      }, [
        h("div", {
          class: "q-avatar__content row flex-center overflow-hidden",
          style: contentStyle.value
        }, hMergeSlotSafely(slots.default, icon))
      ]);
    };
  }
});
const useSpinnerProps = {
  size: {
    type: [Number, String],
    default: "1em"
  },
  color: String
};
function useSpinner(props2) {
  return {
    cSize: computed(() => props2.size in useSizeDefaults ? `${useSizeDefaults[props2.size]}px` : props2.size),
    classes: computed(
      () => "q-spinner" + (props2.color ? ` text-${props2.color}` : "")
    )
  };
}
const QSpinner = createComponent({
  name: "QSpinner",
  props: {
    ...useSpinnerProps,
    thickness: {
      type: Number,
      default: 5
    }
  },
  setup(props2) {
    const { cSize, classes } = useSpinner(props2);
    return () => h("svg", {
      class: classes.value + " q-spinner-mat",
      width: cSize.value,
      height: cSize.value,
      viewBox: "25 25 50 50"
    }, [
      h("circle", {
        class: "path",
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none",
        stroke: "currentColor",
        "stroke-width": props2.thickness,
        "stroke-miterlimit": "10"
      })
    ]);
  }
});
function css(element, css2) {
  const style2 = element.style;
  for (const prop in css2) {
    style2[prop] = css2[prop];
  }
}
function childHasFocus(el, focusedEl) {
  if (el === void 0 || el === null || el.contains(focusedEl) === true) {
    return true;
  }
  for (let next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }
  return false;
}
function throttle(fn, limit = 250) {
  let wait = false, result;
  return function() {
    if (wait === false) {
      wait = true;
      setTimeout(() => {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }
    return result;
  };
}
function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && stop(evt);
  const color = ctx.modifiers.color;
  let center2 = ctx.modifiers.center;
  center2 = center2 === true || forceCenter === true;
  const node = document.createElement("span"), innerNode = document.createElement("span"), pos = position(evt), { left, top, width, height } = el.getBoundingClientRect(), diameter = Math.sqrt(width * width + height * height), radius = diameter / 2, centerX = `${(width - diameter) / 2}px`, x = center2 ? centerX : `${pos.left - left - radius}px`, centerY = `${(height - diameter) / 2}px`, y = center2 ? centerY : `${pos.top - top - radius}px`;
  innerNode.className = "q-ripple__inner";
  css(innerNode, {
    height: `${diameter}px`,
    width: `${diameter}px`,
    transform: `translate3d(${x},${y},0) scale3d(.2,.2,1)`,
    opacity: 0
  });
  node.className = `q-ripple${color ? " text-" + color : ""}`;
  node.setAttribute("dir", "ltr");
  node.appendChild(innerNode);
  el.appendChild(node);
  const abort = () => {
    node.remove();
    clearTimeout(timer);
  };
  ctx.abort.push(abort);
  let timer = setTimeout(() => {
    innerNode.classList.add("q-ripple__inner--enter");
    innerNode.style.transform = `translate3d(${centerX},${centerY},0) scale3d(1,1,1)`;
    innerNode.style.opacity = 0.2;
    timer = setTimeout(() => {
      innerNode.classList.remove("q-ripple__inner--enter");
      innerNode.classList.add("q-ripple__inner--leave");
      innerNode.style.opacity = 0;
      timer = setTimeout(() => {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}
function updateModifiers(ctx, { modifiers, value, arg }) {
  const cfg = Object.assign({}, ctx.cfg.ripple, modifiers, value);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}
const Ripple = createDirective(
  {
    name: "ripple",
    beforeMount(el, binding) {
      const cfg = binding.instance.$.appContext.config.globalProperties.$q.config || {};
      if (cfg.ripple === false) {
        return;
      }
      const ctx = {
        cfg,
        enabled: binding.value !== false,
        modifiers: {},
        abort: [],
        start(evt) {
          if (ctx.enabled === true && evt.qSkipRipple !== true && evt.type === (ctx.modifiers.early === true ? "pointerdown" : "click")) {
            showRipple(evt, el, ctx, evt.qKeyEvent === true);
          }
        },
        keystart: throttle((evt) => {
          if (ctx.enabled === true && evt.qSkipRipple !== true && isKeyCode(evt, ctx.modifiers.keyCodes) === true && evt.type === `key${ctx.modifiers.early === true ? "down" : "up"}`) {
            showRipple(evt, el, ctx, true);
          }
        }, 300)
      };
      updateModifiers(ctx, binding);
      el.__qripple = ctx;
      addEvt(ctx, "main", [
        [el, "pointerdown", "start", "passive"],
        [el, "click", "start", "passive"],
        [el, "keydown", "keystart", "passive"],
        [el, "keyup", "keystart", "passive"]
      ]);
    },
    updated(el, binding) {
      if (binding.oldValue !== binding.value) {
        const ctx = el.__qripple;
        if (ctx !== void 0) {
          ctx.enabled = binding.value !== false;
          if (ctx.enabled === true && Object(binding.value) === binding.value) {
            updateModifiers(ctx, binding);
          }
        }
      }
    },
    beforeUnmount(el) {
      const ctx = el.__qripple;
      if (ctx !== void 0) {
        ctx.abort.forEach((fn) => {
          fn();
        });
        cleanEvt(ctx, "main");
        delete el._qripple;
      }
    }
  }
);
const alignMap = {
  left: "start",
  center: "center",
  right: "end",
  between: "between",
  around: "around",
  evenly: "evenly",
  stretch: "stretch"
};
const alignValues = Object.keys(alignMap);
const useAlignProps = {
  align: {
    type: String,
    validator: (v) => alignValues.includes(v)
  }
};
function useAlign(props2) {
  return computed(() => {
    const align = props2.align === void 0 ? props2.vertical === true ? "stretch" : "left" : props2.align;
    return `${props2.vertical === true ? "items" : "justify"}-${alignMap[align]}`;
  });
}
function vmHasRouter(vm2) {
  return vm2.appContext.config.globalProperties.$router !== void 0;
}
function vmIsDestroyed(vm2) {
  return vm2.isUnmounted === true || vm2.isDeactivated === true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key], outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue) {
        return false;
      }
    } else if (Array.isArray(outerValue) === false || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) {
      return false;
    }
  }
  return true;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b) === true ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a) === true ? isEquivalentArray(a, b) : Array.isArray(b) === true ? isEquivalentArray(b, a) : a === b;
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (isSameRouteLocationParamsValue(a[key], b[key]) === false) {
      return false;
    }
  }
  return true;
}
const useRouterLinkProps = {
  // router-link
  to: [String, Object],
  replace: Boolean,
  exact: Boolean,
  activeClass: {
    type: String,
    default: "q-router-link--active"
  },
  exactActiveClass: {
    type: String,
    default: "q-router-link--exact-active"
  },
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};
function useRouterLink({ fallbackTag, useDisableForRouterLinkProps = true } = {}) {
  const vm2 = getCurrentInstance();
  const { props: props2, proxy, emit: emit2 } = vm2;
  const hasRouter = vmHasRouter(vm2);
  const hasHrefLink = computed(() => props2.disable !== true && props2.href !== void 0);
  const hasRouterLinkProps = useDisableForRouterLinkProps === true ? computed(
    () => hasRouter === true && props2.disable !== true && hasHrefLink.value !== true && props2.to !== void 0 && props2.to !== null && props2.to !== ""
  ) : computed(
    () => hasRouter === true && hasHrefLink.value !== true && props2.to !== void 0 && props2.to !== null && props2.to !== ""
  );
  const resolvedLink = computed(() => hasRouterLinkProps.value === true ? getLink(props2.to) : null);
  const hasRouterLink = computed(() => resolvedLink.value !== null);
  const hasLink = computed(() => hasHrefLink.value === true || hasRouterLink.value === true);
  const linkTag = computed(() => props2.type === "a" || hasLink.value === true ? "a" : props2.tag || fallbackTag || "div");
  const linkAttrs = computed(() => hasHrefLink.value === true ? {
    href: props2.href,
    target: props2.target
  } : hasRouterLink.value === true ? {
    href: resolvedLink.value.href,
    target: props2.target
  } : {});
  const linkActiveIndex = computed(() => {
    if (hasRouterLink.value === false) {
      return -1;
    }
    const { matched } = resolvedLink.value, { length: length2 } = matched, routeMatched = matched[length2 - 1];
    if (routeMatched === void 0) {
      return -1;
    }
    const currentMatched = proxy.$route.matched;
    if (currentMatched.length === 0) {
      return -1;
    }
    const index2 = currentMatched.findIndex(
      isSameRouteRecord.bind(null, routeMatched)
    );
    if (index2 > -1) {
      return index2;
    }
    const parentRecordPath = getOriginalPath(matched[length2 - 2]);
    return (
      // we are dealing with nested routes
      length2 > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(
        isSameRouteRecord.bind(null, matched[length2 - 2])
      ) : index2
    );
  });
  const linkIsActive = computed(
    () => hasRouterLink.value === true && linkActiveIndex.value !== -1 && includesParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkIsExactActive = computed(
    () => linkIsActive.value === true && linkActiveIndex.value === proxy.$route.matched.length - 1 && isSameRouteLocationParams(proxy.$route.params, resolvedLink.value.params)
  );
  const linkClass = computed(() => hasRouterLink.value === true ? linkIsExactActive.value === true ? ` ${props2.exactActiveClass} ${props2.activeClass}` : props2.exact === true ? "" : linkIsActive.value === true ? ` ${props2.activeClass}` : "" : "");
  function getLink(to) {
    try {
      return proxy.$router.resolve(to);
    } catch (_2) {
    }
    return null;
  }
  function navigateToRouterLink(e, { returnRouterError, to = props2.to, replace = props2.replace } = {}) {
    if (props2.disable === true) {
      e.preventDefault();
      return Promise.resolve(false);
    }
    if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      e.metaKey || e.altKey || e.ctrlKey || e.shiftKey || e.button !== void 0 && e.button !== 0 || props2.target === "_blank"
    ) {
      return Promise.resolve(false);
    }
    e.preventDefault();
    const promise = proxy.$router[replace === true ? "replace" : "push"](to);
    return returnRouterError === true ? promise : promise.then(() => {
    }).catch(() => {
    });
  }
  function navigateOnClick(e) {
    if (hasRouterLink.value === true) {
      const go = (opts) => navigateToRouterLink(e, opts);
      emit2("click", e, go);
      e.defaultPrevented !== true && go();
    } else {
      emit2("click", e);
    }
  }
  return {
    hasRouterLink,
    hasHrefLink,
    hasLink,
    linkTag,
    resolvedLink,
    linkIsActive,
    linkIsExactActive,
    linkClass,
    linkAttrs,
    getLink,
    navigateToRouterLink,
    navigateOnClick
  };
}
const btnPadding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
const defaultSizes = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 20,
  xl: 24
};
const formTypes = ["button", "submit", "reset"];
const mediaTypeRE = /[^\s]\/[^\s]/;
const btnDesignOptions = ["flat", "outline", "push", "unelevated"];
const getBtnDesign = (props2, defaultValue) => {
  if (props2.flat === true) return "flat";
  if (props2.outline === true) return "outline";
  if (props2.push === true) return "push";
  if (props2.unelevated === true) return "unelevated";
  return defaultValue;
};
const useBtnProps = {
  ...useSizeProps,
  ...useRouterLinkProps,
  type: {
    type: String,
    default: "button"
  },
  label: [Number, String],
  icon: String,
  iconRight: String,
  ...btnDesignOptions.reduce(
    (acc, val) => (acc[val] = Boolean) && acc,
    {}
  ),
  square: Boolean,
  round: Boolean,
  rounded: Boolean,
  glossy: Boolean,
  size: String,
  fab: Boolean,
  fabMini: Boolean,
  padding: String,
  color: String,
  textColor: String,
  noCaps: Boolean,
  noWrap: Boolean,
  dense: Boolean,
  tabindex: [Number, String],
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  align: {
    ...useAlignProps.align,
    default: "center"
  },
  stack: Boolean,
  stretch: Boolean,
  loading: {
    type: Boolean,
    default: null
  },
  disable: Boolean
};
function useBtn(props2) {
  const sizeStyle = useSize(props2, defaultSizes);
  const alignClass = useAlign(props2);
  const { hasRouterLink, hasLink, linkTag, linkAttrs, navigateOnClick } = useRouterLink({
    fallbackTag: "button"
  });
  const style2 = computed(() => {
    const obj = props2.fab === false && props2.fabMini === false ? sizeStyle.value : {};
    return props2.padding !== void 0 ? Object.assign({}, obj, {
      padding: props2.padding.split(/\s+/).map((v) => v in btnPadding ? btnPadding[v] + "px" : v).join(" "),
      minWidth: "0",
      minHeight: "0"
    }) : obj;
  });
  const isRounded = computed(
    () => props2.rounded === true || props2.fab === true || props2.fabMini === true
  );
  const isActionable = computed(
    () => props2.disable !== true && props2.loading !== true
  );
  const tabIndex = computed(() => isActionable.value === true ? props2.tabindex || 0 : -1);
  const design = computed(() => getBtnDesign(props2, "standard"));
  const attributes = computed(() => {
    const acc = { tabindex: tabIndex.value };
    if (hasLink.value === true) {
      Object.assign(acc, linkAttrs.value);
    } else if (formTypes.includes(props2.type) === true) {
      acc.type = props2.type;
    }
    if (linkTag.value === "a") {
      if (props2.disable === true) {
        acc["aria-disabled"] = "true";
      } else if (acc.href === void 0) {
        acc.role = "button";
      }
      if (hasRouterLink.value !== true && mediaTypeRE.test(props2.type) === true) {
        acc.type = props2.type;
      }
    } else if (props2.disable === true) {
      acc.disabled = "";
      acc["aria-disabled"] = "true";
    }
    if (props2.loading === true && props2.percentage !== void 0) {
      Object.assign(acc, {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": props2.percentage
      });
    }
    return acc;
  });
  const classes = computed(() => {
    let colors2;
    if (props2.color !== void 0) {
      if (props2.flat === true || props2.outline === true) {
        colors2 = `text-${props2.textColor || props2.color}`;
      } else {
        colors2 = `bg-${props2.color} text-${props2.textColor || "white"}`;
      }
    } else if (props2.textColor) {
      colors2 = `text-${props2.textColor}`;
    }
    const shape = props2.round === true ? "round" : `rectangle${isRounded.value === true ? " q-btn--rounded" : props2.square === true ? " q-btn--square" : ""}`;
    return `q-btn--${design.value} q-btn--${shape}` + (colors2 !== void 0 ? " " + colors2 : "") + (isActionable.value === true ? " q-btn--actionable q-focusable q-hoverable" : props2.disable === true ? " disabled" : "") + (props2.fab === true ? " q-btn--fab" : props2.fabMini === true ? " q-btn--fab-mini" : "") + (props2.noCaps === true ? " q-btn--no-uppercase" : "") + (props2.dense === true ? " q-btn--dense" : "") + (props2.stretch === true ? " no-border-radius self-stretch" : "") + (props2.glossy === true ? " glossy" : "") + (props2.square ? " q-btn--square" : "");
  });
  const innerClasses = computed(
    () => alignClass.value + (props2.stack === true ? " column" : " row") + (props2.noWrap === true ? " no-wrap text-no-wrap" : "") + (props2.loading === true ? " q-btn__content--hidden" : "")
  );
  return {
    classes,
    style: style2,
    innerClasses,
    attributes,
    hasLink,
    linkTag,
    navigateOnClick,
    isActionable
  };
}
const { passiveCapture } = listenOpts;
let touchTarget = null, keyboardTarget = null, mouseTarget = null;
const QBtn = createComponent({
  name: "QBtn",
  props: {
    ...useBtnProps,
    percentage: Number,
    darkPercentage: Boolean,
    onTouchstart: [Function, Array]
  },
  emits: ["click", "keydown", "mousedown", "keyup"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const {
      classes,
      style: style2,
      innerClasses,
      attributes,
      hasLink,
      linkTag,
      navigateOnClick,
      isActionable
    } = useBtn(props2);
    const rootRef = ref(null);
    const blurTargetRef = ref(null);
    let localTouchTargetEl = null, avoidMouseRipple, mouseTimer = null;
    const hasLabel = computed(
      () => props2.label !== void 0 && props2.label !== null && props2.label !== ""
    );
    const ripple = computed(() => props2.disable === true || props2.ripple === false ? false : {
      keyCodes: hasLink.value === true ? [13, 32] : [13],
      ...props2.ripple === true ? {} : props2.ripple
    });
    const rippleProps = computed(() => ({ center: props2.round }));
    const percentageStyle = computed(() => {
      const val = Math.max(0, Math.min(100, props2.percentage));
      return val > 0 ? { transition: "transform 0.6s", transform: `translateX(${val - 100}%)` } : {};
    });
    const onEvents = computed(() => {
      if (props2.loading === true) {
        return {
          onMousedown: onLoadingEvt,
          onTouchstart: onLoadingEvt,
          onClick: onLoadingEvt,
          onKeydown: onLoadingEvt,
          onKeyup: onLoadingEvt
        };
      }
      if (isActionable.value === true) {
        const acc = {
          onClick,
          onKeydown: onKeydown2,
          onMousedown
        };
        if (proxy.$q.platform.has.touch === true) {
          const suffix = props2.onTouchstart !== void 0 ? "" : "Passive";
          acc[`onTouchstart${suffix}`] = onTouchstart;
        }
        return acc;
      }
      return {
        // needed; especially for disabled <a> tags
        onClick: stopAndPrevent
      };
    });
    const nodeProps = computed(() => ({
      ref: rootRef,
      class: "q-btn q-btn-item non-selectable no-outline " + classes.value,
      style: style2.value,
      ...attributes.value,
      ...onEvents.value
    }));
    function onClick(e) {
      if (rootRef.value === null) {
        return;
      }
      if (e !== void 0) {
        if (e.defaultPrevented === true) {
          return;
        }
        const el = document.activeElement;
        if (props2.type === "submit" && el !== document.body && rootRef.value.contains(el) === false && el.contains(rootRef.value) === false) {
          rootRef.value.focus();
          const onClickCleanup = () => {
            document.removeEventListener("keydown", stopAndPrevent, true);
            document.removeEventListener("keyup", onClickCleanup, passiveCapture);
            rootRef.value !== null && rootRef.value.removeEventListener("blur", onClickCleanup, passiveCapture);
          };
          document.addEventListener("keydown", stopAndPrevent, true);
          document.addEventListener("keyup", onClickCleanup, passiveCapture);
          rootRef.value.addEventListener("blur", onClickCleanup, passiveCapture);
        }
      }
      navigateOnClick(e);
    }
    function onKeydown2(e) {
      if (rootRef.value === null) {
        return;
      }
      emit2("keydown", e);
      if (isKeyCode(e, [13, 32]) === true && keyboardTarget !== rootRef.value) {
        keyboardTarget !== null && cleanup();
        if (e.defaultPrevented !== true) {
          rootRef.value.focus();
          keyboardTarget = rootRef.value;
          rootRef.value.classList.add("q-btn--active");
          document.addEventListener("keyup", onPressEnd, true);
          rootRef.value.addEventListener("blur", onPressEnd, passiveCapture);
        }
        stopAndPrevent(e);
      }
    }
    function onTouchstart(e) {
      if (rootRef.value === null) {
        return;
      }
      emit2("touchstart", e);
      if (e.defaultPrevented === true) {
        return;
      }
      if (touchTarget !== rootRef.value) {
        touchTarget !== null && cleanup();
        touchTarget = rootRef.value;
        localTouchTargetEl = e.target;
        localTouchTargetEl.addEventListener("touchcancel", onPressEnd, passiveCapture);
        localTouchTargetEl.addEventListener("touchend", onPressEnd, passiveCapture);
      }
      avoidMouseRipple = true;
      mouseTimer !== null && clearTimeout(mouseTimer);
      mouseTimer = setTimeout(() => {
        mouseTimer = null;
        avoidMouseRipple = false;
      }, 200);
    }
    function onMousedown(e) {
      if (rootRef.value === null) {
        return;
      }
      e.qSkipRipple = avoidMouseRipple === true;
      emit2("mousedown", e);
      if (e.defaultPrevented !== true && mouseTarget !== rootRef.value) {
        mouseTarget !== null && cleanup();
        mouseTarget = rootRef.value;
        rootRef.value.classList.add("q-btn--active");
        document.addEventListener("mouseup", onPressEnd, passiveCapture);
      }
    }
    function onPressEnd(e) {
      if (rootRef.value === null) {
        return;
      }
      if (e !== void 0 && e.type === "blur" && document.activeElement === rootRef.value) {
        return;
      }
      if (e !== void 0 && e.type === "keyup") {
        if (keyboardTarget === rootRef.value && isKeyCode(e, [13, 32]) === true) {
          const evt = new MouseEvent("click", e);
          evt.qKeyEvent = true;
          e.defaultPrevented === true && prevent(evt);
          e.cancelBubble === true && stop(evt);
          rootRef.value.dispatchEvent(evt);
          stopAndPrevent(e);
          e.qKeyEvent = true;
        }
        emit2("keyup", e);
      }
      cleanup();
    }
    function cleanup(destroying) {
      const blurTarget = blurTargetRef.value;
      if (destroying !== true && (touchTarget === rootRef.value || mouseTarget === rootRef.value) && blurTarget !== null && blurTarget !== document.activeElement) {
        blurTarget.setAttribute("tabindex", -1);
        blurTarget.focus();
      }
      if (touchTarget === rootRef.value) {
        if (localTouchTargetEl !== null) {
          localTouchTargetEl.removeEventListener("touchcancel", onPressEnd, passiveCapture);
          localTouchTargetEl.removeEventListener("touchend", onPressEnd, passiveCapture);
        }
        touchTarget = localTouchTargetEl = null;
      }
      if (mouseTarget === rootRef.value) {
        document.removeEventListener("mouseup", onPressEnd, passiveCapture);
        mouseTarget = null;
      }
      if (keyboardTarget === rootRef.value) {
        document.removeEventListener("keyup", onPressEnd, true);
        rootRef.value !== null && rootRef.value.removeEventListener("blur", onPressEnd, passiveCapture);
        keyboardTarget = null;
      }
      rootRef.value !== null && rootRef.value.classList.remove("q-btn--active");
    }
    function onLoadingEvt(evt) {
      stopAndPrevent(evt);
      evt.qSkipRipple = true;
    }
    onBeforeUnmount(() => {
      cleanup(true);
    });
    Object.assign(proxy, { click: onClick });
    return () => {
      let inner = [];
      props2.icon !== void 0 && inner.push(
        h(QIcon, {
          name: props2.icon,
          left: props2.stack === false && hasLabel.value === true,
          role: "img",
          "aria-hidden": "true"
        })
      );
      hasLabel.value === true && inner.push(
        h("span", { class: "block" }, [props2.label])
      );
      inner = hMergeSlot(slots.default, inner);
      if (props2.iconRight !== void 0 && props2.round === false) {
        inner.push(
          h(QIcon, {
            name: props2.iconRight,
            right: props2.stack === false && hasLabel.value === true,
            role: "img",
            "aria-hidden": "true"
          })
        );
      }
      const child = [
        h("span", {
          class: "q-focus-helper",
          ref: blurTargetRef
        })
      ];
      if (props2.loading === true && props2.percentage !== void 0) {
        child.push(
          h("span", {
            class: "q-btn__progress absolute-full overflow-hidden" + (props2.darkPercentage === true ? " q-btn__progress--dark" : "")
          }, [
            h("span", {
              class: "q-btn__progress-indicator fit block",
              style: percentageStyle.value
            })
          ])
        );
      }
      child.push(
        h("span", {
          class: "q-btn__content text-center col items-center q-anchor--skip " + innerClasses.value
        }, inner)
      );
      props2.loading !== null && child.push(
        h(Transition, {
          name: "q-transition--fade"
        }, () => props2.loading === true ? [
          h("span", {
            key: "loading",
            class: "absolute-full flex flex-center"
          }, slots.loading !== void 0 ? slots.loading() : [h(QSpinner)])
        ] : null)
      );
      return withDirectives(
        h(
          linkTag.value,
          nodeProps.value,
          child
        ),
        [[
          Ripple,
          ripple.value,
          void 0,
          rippleProps.value
        ]]
      );
    };
  }
});
const nodesList = [];
const portalTypeList = [];
let portalIndex = 1;
let target = document.body;
function createGlobalNode(id, portalType) {
  const el = document.createElement("div");
  el.id = portalType !== void 0 ? `q-portal--${portalType}--${portalIndex++}` : id;
  if (globalConfig.globalNodes !== void 0) {
    const cls = globalConfig.globalNodes.class;
    if (cls !== void 0) {
      el.className = cls;
    }
  }
  target.appendChild(el);
  nodesList.push(el);
  portalTypeList.push(portalType);
  return el;
}
function removeGlobalNode(el) {
  const nodeIndex = nodesList.indexOf(el);
  nodesList.splice(nodeIndex, 1);
  portalTypeList.splice(nodeIndex, 1);
  el.remove();
}
function changeGlobalNodesTarget(newTarget) {
  if (newTarget === target) {
    return;
  }
  target = newTarget;
  if (target === document.body || portalTypeList.reduce((acc, type) => type === "dialog" ? acc + 1 : acc, 0) < 2) {
    nodesList.forEach((node) => {
      if (node.contains(target) === false) {
        target.appendChild(node);
      }
    });
    return;
  }
  const lastDialogIndex = portalTypeList.lastIndexOf("dialog");
  for (let i = 0; i < nodesList.length; i++) {
    const el = nodesList[i];
    if ((i === lastDialogIndex || portalTypeList[i] !== "dialog") && el.contains(target) === false) {
      target.appendChild(el);
    }
  }
}
let uid$1 = 0;
const defaults$2 = {};
const groups = {};
const notificationsList = {};
const positionClass$1 = {};
const emptyRE = /^\s*$/;
const notifRefs = [];
const positionList = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right",
  "top",
  "bottom",
  "left",
  "right",
  "center"
];
const badgePositions = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
];
const notifTypes = {
  positive: {
    icon: ($q) => $q.iconSet.type.positive,
    color: "positive"
  },
  negative: {
    icon: ($q) => $q.iconSet.type.negative,
    color: "negative"
  },
  warning: {
    icon: ($q) => $q.iconSet.type.warning,
    color: "warning",
    textColor: "dark"
  },
  info: {
    icon: ($q) => $q.iconSet.type.info,
    color: "info"
  },
  ongoing: {
    group: false,
    timeout: 0,
    spinner: true,
    color: "grey-8"
  }
};
function addNotification(config2, $q, originalApi) {
  if (!config2) {
    return logError("parameter required");
  }
  let Api;
  const notif = { textColor: "white" };
  if (config2.ignoreDefaults !== true) {
    Object.assign(notif, defaults$2);
  }
  if (isObject$2(config2) === false) {
    if (notif.type) {
      Object.assign(notif, notifTypes[notif.type]);
    }
    config2 = { message: config2 };
  }
  Object.assign(notif, notifTypes[config2.type || notif.type], config2);
  if (typeof notif.icon === "function") {
    notif.icon = notif.icon($q);
  }
  if (!notif.spinner) {
    notif.spinner = false;
  } else {
    if (notif.spinner === true) {
      notif.spinner = QSpinner;
    }
    notif.spinner = markRaw(notif.spinner);
  }
  notif.meta = {
    hasMedia: Boolean(notif.spinner !== false || notif.icon || notif.avatar),
    hasText: hasContent(notif.message) || hasContent(notif.caption)
  };
  if (notif.position) {
    if (positionList.includes(notif.position) === false) {
      return logError("wrong position", config2);
    }
  } else {
    notif.position = "bottom";
  }
  if (notif.timeout === void 0) {
    notif.timeout = 5e3;
  } else {
    const t = parseInt(notif.timeout, 10);
    if (isNaN(t) || t < 0) {
      return logError("wrong timeout", config2);
    }
    notif.timeout = t;
  }
  if (notif.timeout === 0) {
    notif.progress = false;
  } else if (notif.progress === true) {
    notif.meta.progressClass = "q-notification__progress" + (notif.progressClass ? ` ${notif.progressClass}` : "");
    notif.meta.progressStyle = {
      animationDuration: `${notif.timeout + 1e3}ms`
    };
  }
  const actions = (Array.isArray(config2.actions) === true ? config2.actions : []).concat(
    config2.ignoreDefaults !== true && Array.isArray(defaults$2.actions) === true ? defaults$2.actions : []
  ).concat(
    notifTypes[config2.type] !== void 0 && Array.isArray(notifTypes[config2.type].actions) === true ? notifTypes[config2.type].actions : []
  );
  const { closeBtn } = notif;
  closeBtn && actions.push({
    label: typeof closeBtn === "string" ? closeBtn : $q.lang.label.close
  });
  notif.actions = actions.map(({ handler, noDismiss, ...item }) => ({
    flat: true,
    ...item,
    onClick: typeof handler === "function" ? () => {
      handler();
      noDismiss !== true && dismiss();
    } : () => {
      dismiss();
    }
  }));
  if (notif.multiLine === void 0) {
    notif.multiLine = notif.actions.length > 1;
  }
  Object.assign(notif.meta, {
    class: `q-notification row items-stretch q-notification--${notif.multiLine === true ? "multi-line" : "standard"}` + (notif.color !== void 0 ? ` bg-${notif.color}` : "") + (notif.textColor !== void 0 ? ` text-${notif.textColor}` : "") + (notif.classes !== void 0 ? ` ${notif.classes}` : ""),
    wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (notif.multiLine === true ? "column no-wrap justify-center" : "row items-center"),
    contentClass: "q-notification__content row items-center" + (notif.multiLine === true ? "" : " col"),
    leftClass: notif.meta.hasText === true ? "additional" : "single",
    attrs: {
      role: "alert",
      ...notif.attrs
    }
  });
  if (notif.group === false) {
    notif.group = void 0;
    notif.meta.group = void 0;
  } else {
    if (notif.group === void 0 || notif.group === true) {
      notif.group = [
        notif.message,
        notif.caption,
        notif.multiline
      ].concat(
        notif.actions.map((props2) => `${props2.label}*${props2.icon}`)
      ).join("|");
    }
    notif.meta.group = notif.group + "|" + notif.position;
  }
  if (notif.actions.length === 0) {
    notif.actions = void 0;
  } else {
    notif.meta.actionsClass = "q-notification__actions row items-center " + (notif.multiLine === true ? "justify-end" : "col-auto") + (notif.meta.hasMedia === true ? " q-notification__actions--with-media" : "");
  }
  if (originalApi !== void 0) {
    if (originalApi.notif.meta.timer) {
      clearTimeout(originalApi.notif.meta.timer);
      originalApi.notif.meta.timer = void 0;
    }
    notif.meta.uid = originalApi.notif.meta.uid;
    const index2 = notificationsList[notif.position].value.indexOf(originalApi.notif);
    notificationsList[notif.position].value[index2] = notif;
  } else {
    const original = groups[notif.meta.group];
    if (original === void 0) {
      notif.meta.uid = uid$1++;
      notif.meta.badge = 1;
      if (["left", "right", "center"].indexOf(notif.position) !== -1) {
        notificationsList[notif.position].value.splice(
          Math.floor(notificationsList[notif.position].value.length / 2),
          0,
          notif
        );
      } else {
        const action = notif.position.indexOf("top") > -1 ? "unshift" : "push";
        notificationsList[notif.position].value[action](notif);
      }
      if (notif.group !== void 0) {
        groups[notif.meta.group] = notif;
      }
    } else {
      if (original.meta.timer) {
        clearTimeout(original.meta.timer);
        original.meta.timer = void 0;
      }
      if (notif.badgePosition !== void 0) {
        if (badgePositions.includes(notif.badgePosition) === false) {
          return logError("wrong badgePosition", config2);
        }
      } else {
        notif.badgePosition = `top-${notif.position.indexOf("left") > -1 ? "right" : "left"}`;
      }
      notif.meta.uid = original.meta.uid;
      notif.meta.badge = original.meta.badge + 1;
      notif.meta.badgeClass = `q-notification__badge q-notification__badge--${notif.badgePosition}` + (notif.badgeColor !== void 0 ? ` bg-${notif.badgeColor}` : "") + (notif.badgeTextColor !== void 0 ? ` text-${notif.badgeTextColor}` : "") + (notif.badgeClass ? ` ${notif.badgeClass}` : "");
      const index2 = notificationsList[notif.position].value.indexOf(original);
      notificationsList[notif.position].value[index2] = groups[notif.meta.group] = notif;
    }
  }
  const dismiss = () => {
    removeNotification(notif);
    Api = void 0;
  };
  if (notif.timeout > 0) {
    notif.meta.timer = setTimeout(() => {
      notif.meta.timer = void 0;
      dismiss();
    }, notif.timeout + /* show duration */
    1e3);
  }
  if (notif.group !== void 0) {
    return (props2) => {
      if (props2 !== void 0) {
        logError("trying to update a grouped one which is forbidden", config2);
      } else {
        dismiss();
      }
    };
  }
  Api = {
    dismiss,
    config: config2,
    notif
  };
  if (originalApi !== void 0) {
    Object.assign(originalApi, Api);
    return;
  }
  return (props2) => {
    if (Api !== void 0) {
      if (props2 === void 0) {
        Api.dismiss();
      } else {
        const newNotif = Object.assign({}, Api.config, props2, {
          group: false,
          position: notif.position
        });
        addNotification(newNotif, $q, Api);
      }
    }
  };
}
function removeNotification(notif) {
  if (notif.meta.timer) {
    clearTimeout(notif.meta.timer);
    notif.meta.timer = void 0;
  }
  const index2 = notificationsList[notif.position].value.indexOf(notif);
  if (index2 !== -1) {
    if (notif.group !== void 0) {
      delete groups[notif.meta.group];
    }
    const el = notifRefs["" + notif.meta.uid];
    if (el) {
      const { width, height } = getComputedStyle(el);
      el.style.left = `${el.offsetLeft}px`;
      el.style.width = width;
      el.style.height = height;
    }
    notificationsList[notif.position].value.splice(index2, 1);
    if (typeof notif.onDismiss === "function") {
      notif.onDismiss();
    }
  }
}
function hasContent(str) {
  return str !== void 0 && str !== null && emptyRE.test(str) !== true;
}
function logError(error, config2) {
  console.error(`Notify: ${error}`, config2);
  return false;
}
function getComponent() {
  return createComponent({
    name: "QNotifications",
    // hide App from Vue devtools
    devtools: { hide: true },
    setup() {
      return () => h("div", { class: "q-notifications" }, positionList.map((pos) => {
        return h(TransitionGroup, {
          key: pos,
          class: positionClass$1[pos],
          tag: "div",
          name: `q-notification--${pos}`
        }, () => notificationsList[pos].value.map((notif) => {
          const meta = notif.meta;
          const mainChild = [];
          if (meta.hasMedia === true) {
            if (notif.spinner !== false) {
              mainChild.push(
                h(notif.spinner, {
                  class: "q-notification__spinner q-notification__spinner--" + meta.leftClass,
                  color: notif.spinnerColor,
                  size: notif.spinnerSize
                })
              );
            } else if (notif.icon) {
              mainChild.push(
                h(QIcon, {
                  class: "q-notification__icon q-notification__icon--" + meta.leftClass,
                  name: notif.icon,
                  color: notif.iconColor,
                  size: notif.iconSize,
                  role: "img"
                })
              );
            } else if (notif.avatar) {
              mainChild.push(
                h(QAvatar, {
                  class: "q-notification__avatar q-notification__avatar--" + meta.leftClass
                }, () => h("img", { src: notif.avatar, "aria-hidden": "true" }))
              );
            }
          }
          if (meta.hasText === true) {
            let msgChild;
            const msgData = { class: "q-notification__message col" };
            if (notif.html === true) {
              msgData.innerHTML = notif.caption ? `<div>${notif.message}</div><div class="q-notification__caption">${notif.caption}</div>` : notif.message;
            } else {
              const msgNode = [notif.message];
              msgChild = notif.caption ? [
                h("div", msgNode),
                h("div", { class: "q-notification__caption" }, [notif.caption])
              ] : msgNode;
            }
            mainChild.push(
              h("div", msgData, msgChild)
            );
          }
          const child = [
            h("div", { class: meta.contentClass }, mainChild)
          ];
          notif.progress === true && child.push(
            h("div", {
              key: `${meta.uid}|p|${meta.badge}`,
              class: meta.progressClass,
              style: meta.progressStyle
            })
          );
          notif.actions !== void 0 && child.push(
            h("div", {
              class: meta.actionsClass
            }, notif.actions.map((props2) => h(QBtn, props2)))
          );
          meta.badge > 1 && child.push(
            h("div", {
              key: `${meta.uid}|${meta.badge}`,
              class: notif.meta.badgeClass,
              style: notif.badgeStyle
            }, [meta.badge])
          );
          return h("div", {
            ref: (el) => {
              notifRefs["" + meta.uid] = el;
            },
            key: meta.uid,
            class: meta.class,
            ...meta.attrs
          }, [
            h("div", { class: meta.wrapperClass }, child)
          ]);
        }));
      }));
    }
  });
}
const Notify = {
  setDefaults(opts) {
    {
      isObject$2(opts) === true && Object.assign(defaults$2, opts);
    }
  },
  registerType(typeName, typeOpts) {
    if (isObject$2(typeOpts) === true) {
      notifTypes[typeName] = typeOpts;
    }
  },
  install({ $q, parentApp }) {
    $q.notify = this.create = (opts) => addNotification(opts, $q);
    $q.notify.setDefaults = this.setDefaults;
    $q.notify.registerType = this.registerType;
    if ($q.config.notify !== void 0) {
      this.setDefaults($q.config.notify);
    }
    if (this.__installed !== true) {
      positionList.forEach((pos) => {
        notificationsList[pos] = ref([]);
        const vert = ["left", "center", "right"].includes(pos) === true ? "center" : pos.indexOf("top") > -1 ? "top" : "bottom", align = pos.indexOf("left") > -1 ? "start" : pos.indexOf("right") > -1 ? "end" : "center", classes = ["left", "right"].includes(pos) ? `items-${pos === "left" ? "start" : "end"} justify-center` : pos === "center" ? "flex-center" : `items-${align}`;
        positionClass$1[pos] = `q-notifications__list q-notifications__list--${vert} fixed column no-wrap ${classes}`;
      });
      const el = createGlobalNode("q-notify");
      createChildApp(getComponent(), parentApp).mount(el);
    }
  }
};
const Storage = {
  initialize() {
    this.useProxy = _$1.get(config, "storage.useProxy", false);
  },
  createService(context2) {
    let service2 = api.getServiceInstance("storage", context2, { create: false });
    if (!service2) {
      service2 = getClientService(api, {
        servicePath: api.getServicePath("storage", context2),
        transport: api.transporter,
        fetch: window.fetch.bind(window),
        useProxy: this.useProxy
      });
      service2 = api.createService("storage", {
        service: service2,
        context: context2,
        methods: ["create", "get", "find", "remove", "createMultipartUpload", "completeMultipartUpload", "uploadPart", "putObject"]
      });
    }
    return service2;
  },
  getService(context2) {
    return api.getServiceInstance("storage", context2);
  },
  async upload(options, params) {
    const { file, key, blob, context: context2 } = options;
    const service2 = this.getService(context2);
    const dismiss = Notify.create({
      type: "ongoing",
      message: i18n.t("storage.UPLOADING_FILE", { file }),
      timeout: 0
    });
    try {
      const response = await service2.upload(key, blob, { expiresIn: 60 }, params);
      dismiss();
      Events.emit("file-uploaded", { name: file, key, type: blob.type, context: context2 });
      return response;
    } catch (error) {
      dismiss();
      logger$1.error(`[KDK] Cannot upload ${file} with key '${key}'`, error);
      throw error;
    }
  },
  async download(options, params) {
    const { file, key, context: context2, asDataUrl } = options;
    const service2 = this.getService(context2);
    const dismiss = Notify.create({
      type: "ongoing",
      message: i18n.t("storage.DOWNLOADING_FILE", { file }),
      color: "info",
      timeout: 0
    });
    try {
      const response = await service2.download(key, { expiresIn: 60 }, params);
      Events.emit("file-downloaded", { name: file, key, type: response.type, context: context2 });
      dismiss();
      return new Promise((resolve, reject) => {
        if (asDataUrl) {
          const reader = new FileReader();
          reader.onload = (event) => {
            delete response.buffer;
            response.uri = event.target.result;
            resolve(response);
          };
          reader.readAsDataURL(new Blob([response.buffer], { type: response.type }));
        } else {
          resolve(response);
        }
      });
    } catch (error) {
      dismiss();
      logger$1.error(`[KDK] Cannot download '${file}' with key '${key}'`, error);
      throw error;
    }
  },
  async export(options) {
    const { file, key, context: context2 } = options;
    const service2 = this.getService(context2);
    const response = await service2.create({
      id: key,
      command: "GetObject",
      expiresIn: 60,
      ResponseContentDisposition: `attachment; filename="${file}"`
    });
    if (response.SignedUrl) {
      let iframe = document.getElementById("export-hidden-frame");
      if (!iframe) {
        iframe = document.createElement("iframe");
        iframe.id = "export-hidden-frame";
        iframe.style.display = "none";
        document.body.appendChild(iframe);
      }
      iframe.src = response.SignedUrl;
    } else {
      logger$1.error(`[KDK] Cannot export ${file} with key '${key}'`);
    }
  },
  async remove(options) {
    const { file, key, context: context2 } = options;
    const service2 = this.getService(context2);
    try {
      await service2.remove(key);
      Events.emit("file-removed", { name: file, key, context: context2 });
    } catch (error) {
      logger$1.error(`[KDK] Cannot remove ${file} with key '${key}'`, error);
      throw error;
    }
  },
  async getObjectUrl(options) {
    const { key, context: context2 } = options;
    const service2 = this.getService(context2);
    let url = api.getConfig("domain") + config.apiPath;
    if (service2.context) url += `/${context2}`;
    url += `/storage-objects/${key}`;
    const query = _$1.get(options, "query", {});
    const jwt = await api.get("storage").getItem(config.apiJwt);
    query.jwt = jwt;
    url += `?${new URLSearchParams(query)}`;
    return url;
  },
  async getPresignedUrl(options) {
    const { key, context: context2 } = options;
    const service2 = this.getService(context2);
    const { SignedUrl } = await service2.create({ id: key, command: "GetObject", ..._$1.omit(options, ["key", "context"]) });
    return SignedUrl;
  }
};
const { store, set, get, unset, has } = useStore("template-context");
const TemplateContext = Object.assign(store, {
  get,
  has,
  unset,
  // Override write methods to send events
  set(path2, value) {
    const previousValue = get(path2);
    set(path2, value);
    Events.emit("template-context-changed", path2, value, previousValue);
  }
});
const Time = {
  initialize() {
    this.timer = null;
    moment$1.locale(getLocale());
    const now = moment$1.utc();
    const start = now.clone().subtract(1, "months").startOf("day");
    const end = now.clone().endOf("day");
    const timezone = moment$1.tz.guess() || "";
    Store.set("time", _$1.defaultsDeep(config.time || {}, {
      range: {
        start,
        end,
        field: "createdAt",
        query: { createdAt: { $gte: start.toISOString(), $lte: end.toISOString() } }
      },
      format: {
        time: {
          short: "H[h]",
          long: "HH:mm"
        },
        date: {
          short: "DD/MM",
          long: "dddd D"
        },
        year: {
          short: "YY",
          long: "YYYY"
        },
        timezone
      },
      currentTime: now,
      realtime: false,
      step: 60,
      // 1H
      interval: 60
      // 1m
    }));
  },
  convertToMoment(datetime) {
    if (moment$1.isMoment(datetime)) {
      return moment$1.utc(datetime.valueOf());
    } else {
      if (typeof datetime === "string" && !datetime.endsWith("Z")) return moment$1(datetime).utc();
      else return moment$1.utc(datetime);
    }
  },
  get() {
    return Store.get("time");
  },
  getRange() {
    return this.get().range;
  },
  patchRange(range) {
    if (this.getRange().start.isSame(range.start) && this.getRange().end.isSame(range.end)) return;
    const query = { [this.getRange().field]: { $gte: range.start.toISOString(), $lte: range.end.toISOString() } };
    Store.patch("time.range", Object.assign({ query }, range));
  },
  patchField(field) {
    if (this.getRange().field === field) return;
    const query = { [field]: { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() } };
    Store.patch("time.range", { field, query });
  },
  getRangeQuery() {
    return Store.get("time.range.query");
  },
  // Build sort query
  updateTimeRangeQuery() {
    const query = {};
    query[this.getRange().field] = { $gte: this.getRange().start.toISOString(), $lte: this.getRange().end.toISOString() };
    this.getRange().query = query;
  },
  getFormat() {
    return this.get().format;
  },
  getFormatTimezone() {
    return this.getFormat().timezone;
  },
  convertToLocal(datetime) {
    let currentTime = this.convertToMoment(datetime);
    if (this.getFormatTimezone()) {
      currentTime = moment$1.tz(currentTime.toISOString(), this.getFormatTimezone());
    }
    return currentTime;
  },
  format(datetime, format, options = { year: "numeric", month: "numeric", day: "numeric", hour: "2-digit", minute: "2-digit" }) {
    const localDatetime = this.convertToLocal(datetime);
    if (format === "iso") return localDatetime.toISOString();
    else if (format === "locale") return localDatetime.toDate().toLocaleString(getLocale(), options);
    else return localDatetime.format(_$1.get(this.getFormat(), format));
  },
  getCurrentTime() {
    return this.get().currentTime;
  },
  setCurrentTime(datetime) {
    if (this.isRealtime()) this.stopRealtime();
    const momentDatetime = this.convertToMoment(datetime);
    if (this.getCurrentTime().isSame(momentDatetime)) return;
    Store.patch("time.currentTime", momentDatetime);
  },
  setNow() {
    this.setCurrentTime(moment$1.utc());
  },
  isRealtime() {
    return this.get().realtime;
  },
  startRealtime() {
    if (this.isRealtime()) {
      logger$1.warn("[KDK] Realtime mode is already active");
      return;
    }
    Store.patch("time", { realtime: true });
    Store.patch("time.currentTime", moment$1.utc());
    this.timer = setInterval(() => {
      Store.patch("time.currentTime", moment$1.utc());
    }, 1e3 * this.get().interval);
  },
  stopRealtime() {
    if (!this.isRealtime()) {
      logger$1.warn("[KDK] Realtime mode is alrady inactive");
      return;
    }
    Store.patch("time", { realtime: false });
    clearInterval(this.timer);
    this.timer = null;
  },
  getCurrentFormattedTime() {
    const currentTime = this.getCurrentTime();
    return {
      time: {
        short: this.format(currentTime, "time.short"),
        long: this.format(currentTime, "time.long")
      },
      date: {
        short: this.format(currentTime, "date.short"),
        long: this.format(currentTime, "date.long")
      },
      year: {
        short: this.format(currentTime, "year.short"),
        long: this.format(currentTime, "year.long")
      },
      iso: this.format(currentTime, "iso")
    };
  },
  getStep() {
    return this.get().step;
  },
  setStep(step) {
    if (this.getStep() === step) return;
    Store.patch("time", { step });
  },
  // Round hours to expected interval, e.g. using 6 hourly interval 00 || 06 || 12 || 18
  roundHours(hours, interval) {
    return Math.floor(hours / interval) * interval;
  }
};
const length$1 = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  mi: {
    symbol: "units.MILE_SYMBOL",
    label: "units.MILE_LABEL"
  },
  NM: {
    symbol: "units.NAUTICAL_MILE_SYMBOL",
    label: "units.NAUTICAL_MILE_LABEL",
    definition: "1852 m"
  }
};
const altitude = {
  m: {
    symbol: "units.METER_SYMBOL",
    label: "units.METER_LABEL"
  },
  ft: {
    symbol: "units.FEET_SYMBOL",
    label: "units.FEET_LABEL"
  }
};
const area = {
  "m^2": {
    symbol: "units.SQUARED_METER_SYMBOL",
    label: "units.SQUARED_METER_LABEL"
  },
  "km^2": {
    symbol: "units.SQUARED_KILOMETER_SYMBOL",
    label: "units.SQUARED_KILOMETER_LABEL"
  },
  acre: {
    symbol: "units.ACRE_SYMBOL",
    label: "units.ACRE_LABEL"
  },
  hectare: {
    symbol: "units.HECTARE_SYMBOL",
    label: "units.HECTARE_LABEL"
  }
};
const velocity = {
  "m/s": {
    symbol: "units.METER_PER_SECOND_SYMBOL",
    label: "units.METER_PER_SECOND_LABEL"
  },
  "km/h": {
    symbol: "units.KILOMETER_PER_HOUR_SYMBOL",
    label: "units.KILOMETER_PER_HOUR_LABEL"
  },
  "mi/h": {
    symbol: "units.MILES_PER_HOUR_SYMBOL",
    label: "units.MILES_PER_HOUR_LABEL"
  },
  kt: {
    symbol: "units.KNOT_SYMBOL",
    label: "units.KNOT_LABEL",
    definition: "0.514444 m/s",
    override: true
    // because kt can be kilo ton :(
  }
};
const temperature = {
  degC: {
    symbol: "units.CELSIUS_SYMBOL",
    label: "units.CELSIUS_LABEL"
  },
  degF: {
    symbol: "units.FAHRENHEIT_SYMBOL",
    label: "units.FAHRENHEIT_LABEL"
  },
  K: {
    symbol: "units.KELVIN_SYMBOL",
    label: "units.KELVIN_LABEL"
  }
};
const angle = {
  deg: {
    symbol: "units.DEGREE_SYMBOL",
    label: "units.DEGREE_LABEL"
  },
  rad: {
    symbol: "units.RADIAN_SYMBOL",
    label: "units.RADIAN_LABEL"
  }
};
const fraction = {
  ppm: {
    symbol: "units.PPM_SYMBOL",
    label: "units.PPM_LABEL"
  }
};
const density = {
  "ug/m^3": {
    symbol: "units.MICROGRAM_PER_M3_SYMBOL",
    label: "units.MICROGRAM_PER_M3_LABEL"
  }
};
const volumeVelocity = {
  "m^3/s": {
    symbol: "units.CUBIC_METER_PER_SECOND_SYMBOL",
    label: "units.CUBIC_METER_PER_SECOND_LABEL"
  }
};
const radioactivity = {
  bq: {
    symbol: "units.BEQUEREL_SYMBOL",
    label: "units.BEQUEREL_LABEL",
    baseName: "radioactivity"
  }
};
const radioactivityDensity = {
  "bq/m^2": {
    symbol: "units.BEQUEREL_PER_M2_SYMBOL",
    label: "units.BEQUEREL_PER_M2_LABEL"
  },
  "bq/m^3": {
    symbol: "units.BEQUEREL_PER_M3_SYMBOL",
    label: "units.BEQUEREL_PER_M3_LABEL"
  }
};
const equivalentDose = {
  sv: {
    symbol: "units.SIEVERT_SYMBOL",
    label: "units.SIEVERT_LABEL",
    baseName: "equivalentDose",
    aliases: ["sievert"]
  },
  msv: {
    symbol: "units.MILLISIEVERT_SYMBOL",
    label: "units.MILLISIEVERT_LABEL",
    definition: "0.001 sv"
  },
  usv: {
    symbol: "units.MICROSIEVERT_SYMBOL",
    label: "units.MICROSIEVERT_LABEL",
    definition: "0.000001 sv"
  },
  nsv: {
    symbol: "units.NANOSIEVERT_SYMBOL",
    label: "units.NANOSIEVERT_LABEL",
    definition: "0.000000001 sv"
  }
};
const equivalentDoseRate = {
  svs: {
    symbol: "units.SIEVERT_PER_SECOND_SYMBOL",
    label: "units.SIEVERT_PER_SECOND_LABEL",
    baseName: "equivalentDoseRate"
  },
  msvs: {
    symbol: "units.MILLISIEVERT_PER_SECOND_SYMBOL",
    label: "units.MILLISIEVERT_PER_SECOND_LABEL",
    definition: "0.001 svs"
  },
  usvs: {
    symbol: "units.MICROSIEVERT_PER_SECOND_SYMBOL",
    label: "units.MICROSIEVERT_PER_SECOND_LABEL",
    definition: "0.000001 svs"
  },
  nsvs: {
    symbol: "units.NANOSIEVERT_PER_SECOND_SYMBOL",
    label: "units.NANOSIEVERT_PER_SECOND_LABEL",
    definition: "0.000000001 svs"
  },
  svh: {
    symbol: "units.SIEVERT_PER_HOUR_SYMBOL",
    label: "units.SIEVERT_PER_HOUR_LABEL",
    definition: "0.000277778 svs"
  },
  msvh: {
    symbol: "units.MILLISIEVERT_PER_HOUR_SYMBOL",
    label: "units.MILLISIEVERT_PER_HOUR_LABEL",
    definition: "0.000000277778 svs"
  },
  usvh: {
    symbol: "units.MICROSIEVERT_PER_HOUR_SYMBOL",
    label: "units.MICROSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000277778 svs"
  },
  nsvh: {
    symbol: "units.NANOSIEVERT_PER_HOUR_SYMBOL",
    label: "units.NANOSIEVERT_PER_HOUR_LABEL",
    definition: "0.000000000000277778 svs"
  }
};
const quantities = {
  length: length$1,
  altitude,
  area,
  velocity,
  temperature,
  angle,
  fraction,
  density,
  volumeVelocity,
  radioactivity,
  radioactivityDensity,
  equivalentDose,
  equivalentDoseRate
};
const Units = {
  initialize() {
    Store.set("units", _$1.defaultsDeep(
      config.units || {},
      quantities,
      {
        default: {
          length: "m",
          altitude: "m",
          area: "m^2",
          velocity: "m/s",
          temperature: "degC",
          angle: "deg",
          radioactivity: "bq",
          equivalentDose: "usv",
          equivalentDoseRate: "usvh",
          notation: "auto",
          precision: 3
        }
      }
    ));
    this.getQuantities().forEach((quantity) => {
      this.createUnits(quantity);
    });
  },
  createUnits(quantity) {
    const units = _$1.sortBy(this.getUnits(quantity), [(unit) => unit.baseName ? 0 : 1]);
    units.forEach((unit) => {
      if (math.Unit.isValuelessUnit(unit.name)) {
        if (!unit.override) return;
      }
      if (unit.definition || unit.baseName) {
        math.createUnit(unit.name, _$1.omit(unit, ["label", "override"]), { override: _$1.get(unit, "override", false) });
      }
    });
  },
  get() {
    return Store.get("units");
  },
  getDefaultNotation() {
    return Store.get("units.default.notation", "auto");
  },
  getDefaultPrecision() {
    return Store.get("units.default.precision", 3);
  },
  getQuantities() {
    return _$1.keys(_$1.omit(this.get(), ["default"]));
  },
  setUnits(quantity, units) {
    Store.set(`units.${quantity}`, units);
    this.createUnits(quantity);
  },
  getUnits(quantity) {
    if (quantity) {
      const units = Store.get(`units.${quantity}`, {});
      return _$1.values(_$1.mapValues(units, (value, key) => Object.assign({ name: key, quantity }, value)));
    } else {
      let units = [];
      this.getQuantities().forEach((quantity2) => {
        units = units.concat(this.getUnits(quantity2));
      });
      return units;
    }
  },
  // Get unit definition by name
  getUnit(unit) {
    let definition;
    _$1.forOwn(this.get(), (units, quantity) => {
      if (!definition && _$1.has(units, unit)) definition = Object.assign({ name: unit, quantity }, _$1.get(units, unit));
    });
    if (!definition) {
      definition = { name: unit, symbol: unit, label: unit };
    }
    return definition;
  },
  // Get unit symbol by unit name/definition
  getUnitSymbol(unit) {
    const definition = typeof unit === "object" ? unit : this.getUnit(unit);
    return definition && definition.symbol ? i18n.tie(definition.symbol) : unit;
  },
  // Get default unit definition (if any) for a given quantity/unit name/definition
  getDefaultUnit(quantityOrUnit) {
    if (!quantityOrUnit) return null;
    if (typeof quantityOrUnit === "object") quantityOrUnit = quantityOrUnit.name;
    let defaultUnit = Store.get(`units.default.${quantityOrUnit}`);
    if (!defaultUnit) {
      const baseUnit = this.getUnit(quantityOrUnit);
      if (baseUnit) defaultUnit = this.getDefaultUnit(baseUnit.quantity);
    } else {
      defaultUnit = this.getUnit(defaultUnit);
    }
    return defaultUnit;
  },
  // Set default unit name for a quantity
  setDefaultUnit(quantity, unit) {
    Store.set(`units.default.${quantity}`, unit);
  },
  // Get symbol of default unit (if any) for a given quantity/unit name/definition
  getDefaultUnitSymbol(quantityOrUnit) {
    return this.getUnitSymbol(this.getDefaultUnit(quantityOrUnit));
  },
  // Get target unit definition for a source unit name/definition, will be default unit (if any) or source unit
  getTargetUnit(sourceUnit) {
    return this.getDefaultUnit(sourceUnit) || (typeof sourceUnit === "object" ? sourceUnit : this.getUnit(sourceUnit));
  },
  // Get target unit symbol for a source unit name/definition, will be default unit symbol (if any) or source unit symbol
  getTargetUnitSymbol(sourceUnit) {
    return this.getUnitSymbol(this.getTargetUnit(sourceUnit));
  },
  // Convert between units by names/definitions
  // If target unit is not specified will use default unit (if any) for source unit
  convert(value, sourceUnit, targetUnit) {
    if (_$1.isNil(value) || !_$1.isFinite(value)) return value;
    if (value === Number.MIN_VALUE || value === Number.MAX_VALUE) return value;
    const sourceUnitDef = typeof sourceUnit === "string" ? this.getUnit(sourceUnit) : sourceUnit;
    let targetUnitDef = typeof targetUnit === "string" ? this.getUnit(targetUnit) : targetUnit;
    if (!targetUnitDef && sourceUnitDef) targetUnitDef = this.getDefaultUnit(sourceUnitDef);
    if (!sourceUnitDef || !targetUnitDef) return value;
    if (targetUnitDef.name === sourceUnitDef.name) return value;
    const sourceName = sourceUnitDef.name.replace("^", "");
    const targetName = targetUnitDef.name.replace("^", "");
    if (!math.Unit.isValuelessUnit(sourceName) || !math.Unit.isValuelessUnit(targetName)) return value;
    let n = math.unit(value, sourceName);
    n = n.toNumber(targetName);
    n = targetName === "deg" ? n < 0 ? n + 360 : n : n;
    return n;
  },
  // Format display of source value in target unit, converting from source unit
  // If target unit is not specified will use default unit (if any) for source unit
  // options are mathjs format options
  format(value, sourceUnit, targetUnit, options) {
    if (_$1.isNil(value)) {
      logger$1.warn("[KDK] cannot format a nil value");
      return;
    }
    if (!targetUnit) targetUnit = this.getDefaultUnit(sourceUnit);
    const n = targetUnit ? this.convert(value, sourceUnit, targetUnit) : value;
    options = Object.assign({
      symbol: true,
      notation: this.getDefaultNotation(),
      precision: this.getDefaultPrecision(),
      lowerExp: -this.getDefaultPrecision(),
      upperExp: this.getDefaultPrecision()
    }, options);
    let output = math.format(n, options);
    if (options.symbol) {
      output += ` ${targetUnit ? this.getUnitSymbol(targetUnit) : this.getUnitSymbol(sourceUnit)}`;
    }
    return output;
  }
};
const Handlers = ["handler", "visible", "hidden", "disabled", "on.listener"];
const ReservedBindings = ["content", "visible", "hidden", "route"];
function hasProperty(object, path2) {
  const keys = path2.split(".");
  let currentObject = object;
  for (const key of keys) {
    if (!currentObject || !(key in currentObject)) {
      return false;
    }
    currentObject = currentObject[key];
  }
  return true;
}
function filterContent(content, filter) {
  if (typeof content !== "object") return content;
  const isArray = Array.isArray(content);
  const modes = _$1.keys(content);
  let filteredContent = content;
  if (!isArray) {
    if (filteredContent.content) {
      filteredContent.content = filterContent(filteredContent.content, filter);
    } else {
      modes.forEach((mode) => {
        const contentForMode = filteredContent[mode];
        filteredContent[mode] = filterContent(contentForMode, filter);
      });
    }
    filteredContent = [filteredContent];
  } else {
    filteredContent.forEach((item) => {
      if (item.content) {
        item.content = filterContent(item.content, filter);
      }
    });
  }
  filteredContent = filteredContent.filter(sift(filter));
  return isArray ? filteredContent : filteredContent[0];
}
function bindContent(content, context2, omit = []) {
  const components2 = _$1.flatMapDeep(content);
  _$1.forEach(components2, (component) => {
    Handlers.forEach((handler) => bindHandler(component, handler, context2));
    bindProperties(component, context2, omit);
    if (component.content) bindContent(component.content, context2, omit);
  });
  return content;
}
function bindProperties(item, context2, omit = []) {
  if (Array.isArray(item)) {
    for (let i = 0; i < item.length; i++) {
      item[i] = bindProperties(item[i], context2);
    }
  } else if (typeof item === "object") {
    _$1.forOwn(item, (value, key) => {
      if (!ReservedBindings.includes(key) && !omit.includes(key)) {
        if (typeof value === "string") {
          item[key] = getBoundValue(value, context2);
        } else {
          item[key] = bindProperties(value, context2);
        }
      }
    });
  }
  return item;
}
function bindHandler(component, path2, context2) {
  const handler = _$1.get(component, path2);
  if (Array.isArray(handler)) {
    const handlers2 = handler.map((h2) => generateHandler(context2, h2.name || h2, h2.params));
    _$1.set(component, path2, (...args) => handlers2.reduce((result, h2) => result && h2(...args), true));
  } else if (handler && typeof handler === "object") {
    if (handler.name) {
      if (!handler.name.startsWith(":")) {
        _$1.set(component, path2, generateHandler(context2, handler.name, handler.params));
      }
    } else {
      logger$1.debug(`[KDK] invalid handler binding for ${handler}: you must provide the name to the function to be called`);
    }
  } else if (typeof handler === "string" && !handler.startsWith(":")) {
    _$1.set(component, path2, generateHandler(context2, handler));
  }
  return _$1.get(component, path2);
}
function generateHandler(context2, name, params) {
  const isNot = name.startsWith("!");
  if (isNot) name = name.substring(1);
  return (...args) => {
    let result;
    const handler = _$1.get(context2, name);
    if (typeof handler === "function") {
      result = params ? handler(...bindParams(params, context2, args)) : handler(...args);
    } else {
      result = handler;
    }
    return isNot ? !result : result;
  };
}
function bindParams(params, context2, args) {
  if (_$1.isNil(params)) return params;
  if (Array.isArray(params)) return params.map((param) => bindParams(param, context2, args));
  if (typeof params === "object") return _$1.mapValues(params, (value, key) => bindParams(value, context2, args));
  return getBoundValue(params, context2, args);
}
function getBoundValue(value, context2, args) {
  if (typeof value === "string" && value.startsWith(":")) {
    if (value.startsWith(":store.")) {
      const path2 = value.replace(":store.", "");
      if (Store.has(path2)) return Store.get(path2);
    } else if (value.startsWith(":storeRef.")) {
      const path2 = value.replace(":storeRef.", "");
      if (hasProperty(Store, path2)) return Store.getRef(path2);
    } else {
      const path2 = value.substring(1);
      const n = _$1.toNumber(path2);
      if (_$1.isFinite(n)) return args[n];
      if (hasProperty(context2, path2)) return _$1.get(context2, path2);
    }
    return void 0;
  }
  return value;
}
const DefaultZIndex = {
  drawer: 3e3,
  // see Quasar css variables
  panes: 1e3,
  fab: 1e3,
  stickies: 980,
  focus: 1010
};
const layoutPath = "layout";
const contentDefaults = { content: void 0, filter: {}, mode: void 0, visible: false };
const paneDefaults = { opener: false, size: [0, 0], zIndex: DefaultZIndex.panes };
const windowDefaultControls = { menu: true, pin: true, unpin: true, maximize: true, restore: true, close: true, resize: true };
const windowDefaults = { state: void 0, position: void 0, size: void 0, current: void 0, controls: windowDefaultControls, controlsMenuBreakpoint: "xs", zIndex: 980 };
const hWindowDefaultSizePolicy = {
  minSize: [300, 200],
  floating: { position: [0, 0], size: [300, 200] },
  pinned: { xs: [100, 30], sm: [90, 30], md: [80, 30], lg: [70, 30], xl: [60, 30] }
};
const vWindowDefaultSizePolicy = {
  minSize: [200, 300],
  floating: { position: [0, 0], size: [200, 300] },
  pinned: { xs: [50, 90], sm: [40, 80], md: [30, 75], lg: [25, 75], xl: [20, 75] }
};
const defaults$1 = {
  view: "lHh LpR lFf",
  padding: true,
  mode: void 0,
  header: { ...contentDefaults, size: [void 0, 0] },
  footer: { ...contentDefaults, size: [void 0, 0] },
  page: { ...contentDefaults, size: [0, 0] },
  stickies: { ...contentDefaults, zIndex: DefaultZIndex.stickies },
  fab: { ...contentDefaults, icon: "las la-ellipsis-v", position: "bottom-right", offset: [16, 16], zIndex: DefaultZIndex.fab },
  panes: {
    left: { ...contentDefaults, ...paneDefaults, sizes: 300, zIndex: DefaultZIndex.drawer },
    top: { ...contentDefaults, ...paneDefaults, sizes: void 0 },
    right: { ...contentDefaults, ...paneDefaults, sizes: { xs: [85, 75], sm: [360, 75], md: [440, 80], lg: [500, 80], xl: [500, 85] } },
    bottom: { ...contentDefaults, ...paneDefaults, sizes: void 0 }
  },
  windows: {
    left: { ...contentDefaults, ...windowDefaults, sizePolicy: vWindowDefaultSizePolicy },
    top: { ...contentDefaults, ...windowDefaults, sizePolicy: hWindowDefaultSizePolicy },
    right: { ...contentDefaults, ...windowDefaults, sizePolicy: vWindowDefaultSizePolicy },
    bottom: { ...contentDefaults, ...windowDefaults, sizePolicy: hWindowDefaultSizePolicy }
  },
  focus: {
    element: null,
    zIndex: DefaultZIndex.focus
  }
};
const Layout = {
  placements: ["top", "right", "bottom", "left"],
  paths: {
    layout: layoutPath,
    view: layoutPath + ".view",
    padding: layoutPath + ".padding",
    mode: layoutPath + ".mode",
    header: layoutPath + ".header",
    footer: layoutPath + ".footer",
    page: layoutPath + ".page",
    stickies: layoutPath + ".stickies",
    fab: layoutPath + ".fab",
    panes: {
      left: layoutPath + ".panes.left",
      top: layoutPath + ".panes.top",
      right: layoutPath + ".panes.right",
      bottom: layoutPath + ".panes.bottom"
    },
    windows: {
      left: layoutPath + ".windows.left",
      top: layoutPath + ".windows.top",
      right: layoutPath + ".windows.right",
      bottom: layoutPath + ".windows.bottom"
    },
    focus: layoutPath + ".focus"
  },
  defaults: defaults$1,
  initialize() {
    Store.set(this.paths.view, this.getElementDefaults("view"));
    Store.set(this.paths.padding, this.getElementDefaults("padding"));
    Store.set(this.paths.header, this.getElementDefaults("header"));
    Store.set(this.paths.footer, this.getElementDefaults("footer"));
    Store.set(this.paths.page, this.getElementDefaults("page"));
    Store.set(this.paths.stickies, this.getElementDefaults("stickies"));
    Store.set(this.paths.fab, this.getElementDefaults("fab"));
    this.placements.forEach((placement) => {
      Store.set(_$1.get(this.paths.panes, placement), this.getElementDefaults(`panes.${placement}`));
      Store.set(_$1.get(this.paths.windows, placement), this.getElementDefaults(`windows.${placement}`));
    });
    Store.set(this.paths.focus, this.getElementDefaults("focus"));
    logger$1.debug("[KDK] Layout initialized with configuration:", this.get());
  },
  get() {
    return Store.get(this.paths.layout);
  },
  set(layout) {
    if (_$1.has(layout, "view")) this.setView(layout.view);
    if (_$1.has(layout, "padding")) this.setPadding(layout.padding);
    if (_$1.has(layout, "header")) this.setHeader(layout.header);
    if (_$1.has(layout, "footer")) this.setFooter(layout.footer);
    if (_$1.has(layout, "page")) this.setPage(layout.page);
    if (_$1.has(layout, "stickies")) this.setStickies(layout.stickies);
    if (_$1.has(layout, "fab")) this.setFab(layout.fab);
    this.placements.forEach((placement) => {
      if (_$1.has(layout, `panes.${placement}`)) this.setPane(placement, _$1.get(layout, `panes.${placement}`));
      if (_$1.has(layout, `windows.${placement}`)) this.setWindow(placement, _$1.get(layout, `windows.${placement}`));
    });
    if (_$1.has(layout, "mode")) this.setMode(layout.mode);
    if (_$1.has(layout, "focus")) this.setFocus(layout.focus);
  },
  setView(view) {
    if (_$1.isNil(view)) {
      logger$1.warn("[KDK] Undefined 'view' argument");
      return;
    }
    Store.patch(this.paths.layout, { view });
  },
  clearView() {
    Store.patch(this.paths.layout, { view: this.getElementDefaults("view") });
  },
  getPadding() {
    return this.get().padding;
  },
  setPadding(padding) {
    if (_$1.isNil(padding)) {
      logger$1.warn("[KDK] Undefined 'padding' argument");
      return;
    }
    Store.patch(this.paths.layout, { padding });
  },
  clearPadding() {
    Store.patch(this.paths.layout, { padding: this.getElementDefaults("padding") });
  },
  getMode() {
    return this.get().mode;
  },
  setMode(mode) {
    if (this.getMode() === mode) return;
    this.setHeaderMode(mode);
    this.setFooterMode(mode);
    this.setPageMode(mode);
    this.setFabMode(mode);
    this.setStickiesMode(mode);
    this.placements.forEach((placement) => {
      this.setPaneMode(placement, mode);
      this.setWindowMode(placement, mode);
    });
    Store.patch(this.paths.layout, { mode });
  },
  clearMode() {
    Store.patch(this.paths.layout, { mode: void 0 });
  },
  getElement(element) {
    return Store.get(this.getElementPath(element));
  },
  getElementPath(element) {
    return _$1.get(this.paths, element);
  },
  getElementDefaults(element) {
    const elementPath = this.getElementPath(element);
    const elementDefaults = _$1.get(defaults$1, element);
    const elementConfig = _$1.get(config, elementPath);
    if (elementConfig) return _$1.defaultsDeep(_$1.cloneDeep(elementConfig), elementDefaults);
    return _$1.cloneDeep(elementDefaults);
  },
  setElement(element, options, context2, omit = []) {
    const props2 = _$1.defaultsDeep(_$1.cloneDeep(options), this.getElementDefaults(element));
    const { content, mode } = props2;
    if (!_$1.isEmpty(content) && context2) props2.content = bindContent(content, context2, omit);
    if (Array.isArray(content)) props2.components = content.filter(sift(props2.filter));
    else props2.components = _$1.get(content, mode, []).filter(sift(props2.filter));
    Store.patch(this.getElementPath(element), props2);
  },
  setElementMode(element, mode) {
    const props2 = this.getElement(element);
    if (props2.mode === mode) return;
    let components2;
    if (Array.isArray(props2.content)) components2 = props2.content.filter(sift(props2.filter));
    else components2 = _$1.get(props2.content, mode, []).filter(sift(props2.filter));
    Store.patch(this.getElementPath(element), { mode, components: components2 });
  },
  setElementFilter(element, filter) {
    const props2 = this.getElement(element);
    if (_$1.isEqual(props2.filter, filter)) return;
    let components2;
    if (Array.isArray(props2.content)) components2 = props2.content.filter(sift(props2.filter));
    else components2 = _$1.get(props2.content, props2.mode, []).filter(sift(props2.filter));
    Store.patch(this.getElementPath(element), { filter, components: components2 });
  },
  setElementVisible(element, visible) {
    const props2 = this.getElement(element);
    if (props2.visible === visible) return;
    Store.patch(this.getElementPath(element), { visible });
  },
  setElementSize(element, size) {
    if (!Array.isArray(size) && size.length !== 2) {
      logger$1.warn(`[KDK] Invalid size ${size}`);
      return;
    }
    const props2 = this.getElement(element);
    if (_$1.isEqual(props2.size, size)) return;
    Store.patch(this.getElementPath(element), { size });
  },
  clearElement(element) {
    this.setElement(element, this.getElementDefaults(element));
  },
  getHeader() {
    return this.getElement("header");
  },
  setHeader(options, context2) {
    this.setElement("header", options, context2);
  },
  setHeaderMode(mode) {
    this.setElementMode("header", mode);
  },
  setHeaderFilter(filter) {
    this.setElementFilter("header", filter);
  },
  setHeaderVisible(visible) {
    this.setElementVisible("header", visible);
  },
  setHeaderSize(size) {
    this.setElementSize("header", size);
  },
  clearHeader() {
    this.clearElement("header");
  },
  getFooter() {
    return this.getElement("footer");
  },
  setFooter(options, context2) {
    this.setElement("footer", options, context2);
  },
  setFooterMode(mode) {
    this.setElementMode("footer", mode);
  },
  setFooterFilter(filter) {
    this.setElementFilter("footer", filter);
  },
  setFooterVisible(visible) {
    this.setElementVisible("footer", visible);
  },
  setFooterSize(size) {
    this.setElementSize("footer", size);
  },
  clearFooter() {
    this.clearElement("footer");
  },
  getPage() {
    return this.getElement("page");
  },
  setPage(options, context2) {
    this.setElement("page", options, context2);
  },
  setPageMode(mode) {
    this.setElementMode("page", mode);
  },
  setPageFilter(filter) {
    this.setElementFilter("page", filter);
  },
  setPageVisible(visible) {
    this.setElementVisible("page", visible);
  },
  clearPage() {
    this.clearElement("page");
  },
  getStickies() {
    return this.getElement("stickies");
  },
  setStickies(options, context2) {
    this.setElement("stickies", options, context2);
  },
  setStickiesMode(mode) {
    this.setElementMode("stickies", mode);
  },
  setStickiesFilter(filter) {
    this.setElementFilter("stickies", filter);
  },
  setStickiesVisible(visible) {
    this.setElementVisible("stickies", visible);
  },
  clearStickies() {
    this.clearElement("stickies");
  },
  findSticky(stickyId) {
    return _$1.find(this.getStickies().components, { id: stickyId });
  },
  showSticky(stickyId) {
    const sticky = this.findSticky(stickyId);
    if (!sticky) {
      logger$1.error(`[KDK] Cannot find sticky with id '${stickyId}'`);
      return;
    }
    _$1.set(sticky, "visible", true);
  },
  hideSticky(stickyId) {
    const sticky = this.findSticky(stickyId);
    if (!sticky) {
      logger$1.error(`[KDK] Cannot find sticky with id '${stickyId}'`);
      return;
    }
    _$1.set(sticky, "visible", false);
  },
  getFab() {
    return this.getElement("fab");
  },
  setFab(options, context2) {
    this.setElement("fab", options, context2);
  },
  setFabMode(mode) {
    this.setElementMode("fab", mode);
  },
  setFabFilter(filter) {
    this.setElementFilter("fab", filter);
  },
  setFabVisible(visible) {
    this.setElementVisible("fab", visible);
  },
  setFabIcon(icon) {
    const props2 = this.getElement("fab");
    if (props2.icon === icon) return;
    Store.patch(this.getElementPath("fab"), { icon });
  },
  setFabPosition(position2) {
    if (!["top-left", "top-right", "bottom-left", "bottom-right"].includes(position2)) {
      logger$1.warn(`[KDK] Invalid position ${position2}`);
      return;
    }
    const props2 = this.getElement("fab");
    if (props2.position === position2) return;
    Store.patch(this.getElementPath("fab"), { position: position2 });
  },
  setFabOffset(offset) {
    if (!Array.isArray(offset) && offset.length !== 2) {
      logger$1.warn(`[KDK] Invalid offset ${offset}`);
      return;
    }
    const props2 = this.getElement("fab");
    if (props2.offset === offset) return;
    Store.patch(this.getElementPath("fab"), { offset });
  },
  clearFab() {
    this.clearElement("fab");
  },
  getPane(placement) {
    return this.getElement(`panes.${placement}`);
  },
  setPane(placement, options, context2) {
    this.setElement(`panes.${placement}`, options, context2);
  },
  setPaneMode(placement, mode) {
    this.setElementMode(`panes.${placement}`, mode);
  },
  setPaneFilter(placement, filter) {
    this.setElementFilter(`panes.${placement}`, filter);
  },
  setPaneVisible(placement, visible) {
    this.setElementVisible(`panes.${placement}`, visible);
  },
  setPaneOpener(placement, opener) {
    const props2 = this.getElement(`panes.${placement}`);
    if (props2.opener === opener) return;
    Store.patch(this.getElementPath(`panes.${placement}`), { opener });
  },
  setPaneSizes(placement, sizes) {
    const props2 = this.getElement(`panes.${placement}`);
    if (_$1.isEqual(props2.sizes, sizes)) return;
    Store.patch(this.getElementPath(`panes.${placement}`), { sizes });
  },
  clearPane(placement) {
    this.clearElement(`panes.${placement}`);
  },
  getWindow(placement) {
    return this.getElement(`windows.${placement}`);
  },
  setWindow(placement, options, context2) {
    this.setElement(`windows.${placement}`, options, context2, ["header", "fab"]);
  },
  setWindowMode(placement, mode) {
    this.setElementMode(`windows.${placement}`, mode);
  },
  setWindowFilter(placement, filter) {
    this.setElementFilter(`windows.${placement}`, filter);
  },
  setWindowVisible(placement, visible) {
    this.setElementVisible(`windows.${placement}`, visible);
  },
  setWindowControls(placement, controls) {
    for (const key of _$1.keys(windowDefaultControls)) {
      if (!_$1.has(controls, key)) {
        logger$1.warn(`[KDK] Invalid window control key ${key}`);
        return;
      }
    }
    const props2 = this.getElement(`windows.${placement}`);
    if (_$1.isEqual(props2.controls, controls)) return;
    Store.patch(this.getElementPath(`windows.${placement}`), { controls });
  },
  setWindowState(placement, state) {
    if (!["pinned", "floating", "maximized"].includes(state)) {
      logger$1.warn(`[KDK] Invalid window state ${state}`);
      return;
    }
    const props2 = this.getElement(`windows.${placement}`);
    if (props2.state === state) return;
    Store.patch(this.getElementPath(`windows.${placement}`), { state });
  },
  setWindowPosition(placement, position2) {
    if (!Array.isArray(position2) && position2.length !== 2) {
      logger$1.warn(`[KDK] Invalid position ${position2}`);
      return;
    }
    const props2 = this.getElement(`windows.${placement}`);
    if (_$1.isEqual(props2.position, position2)) return;
    Store.patch(this.getElementPath(`windows.${placement}`), { position: position2 });
  },
  setWindowSize(placement, size) {
    this.setElementSize(`windows.${placement}`, size);
  },
  setWindowSizePolicy(placement, policy) {
    if (!policy.minSize || !policy.floating || !policy.pinned) {
      logger$1.warn(`[KDK] Invalid window sizePolicy ${policy}`);
      return;
    }
    const props2 = this.getElement(`windows.${placement}`);
    if (_$1.isEqual(props2.sizePolicy, policy)) return;
    Store.patch(this.getElementPath(`windows.${placement}`), { sizePolicy: policy });
  },
  setWindowCurrent(placement, current) {
    const props2 = this.getElement(`windows.${placement}`);
    if (props2.current === current) return;
    const widget = _$1.find(props2.components, { id: current });
    if (!widget) current = _$1.get(props2.components, "[0].id");
    Store.patch(this.getElementPath(`windows.${placement}`), { current });
  },
  clearWindow(placement) {
    this.clearElement(`windows.${placement}`);
  },
  findWindow(widgetId) {
    for (const placement of this.placements) {
      const window2 = this.getWindow(placement);
      if (_$1.find(window2.components, { id: widgetId })) {
        return { placement, window: window2 };
      }
    }
    logger$1.debug(`[KDK] Unable to find the widget ${widgetId}`);
    return { placement: void 0, window: void 0 };
  },
  openWidget(widgetId, focus = true) {
    const { placement, window: window2 } = this.findWindow(widgetId);
    if (!placement) return;
    if (window2.current !== "current") this.setWindowCurrent(placement, widgetId);
    if (!window2.visible) this.setWindowVisible(placement, true);
    if (focus) Layout.setFocus(`windows.${placement}`);
  },
  closeWidget(widgetId) {
    const { placement, window: window2 } = this.findWindow(widgetId);
    if (!placement) return;
    if (window2.visible) this.setWindowVisible(placement, false);
  },
  setFocus(element) {
    const focus = this.getElement("focus");
    if (focus.element) {
      if (focus.element === element) return;
      Store.patch(this.getElementPath(focus.element.path), { zIndex: focus.element.zIndex });
    }
    const props2 = this.getElement(element);
    Store.patch(this.getElementPath("focus"), { element: { path: element, zIndex: props2.zIndex } });
    Store.patch(this.getElementPath(element), { zIndex: focus.zIndex });
  },
  clearFocus() {
    this.clearElement("focus");
  }
};
const Filter = {
  initialize() {
    Store.set("filter", { fields: "name", pattern: "", items: [], query: {} });
    Events.on("filter-changed", () => this.updateFilterQuery());
  },
  get() {
    return Store.get("filter");
  },
  getItems() {
    return Store.get("filter.items");
  },
  getFields() {
    const fields = Store.get("filter.fields");
    if (typeof fields === "string") return [fields];
    return fields;
  },
  getPattern() {
    return Store.get("filter.pattern");
  },
  getQuery() {
    return Store.get("filter.query");
  },
  clear() {
    Store.patch("filter", { fields: "name", pattern: "", items: [], query: {} });
  },
  // Build query from filter pattern and/or items
  updateFilterQuery() {
    const query = {};
    const pattern = this.getPattern();
    const fields = this.getFields();
    const items = this.getItems();
    if (pattern !== "") {
      query.$or = _$1.map(fields, (field) => {
        return { [field]: { $search: pattern } };
      });
    }
    items.forEach((item) => {
      const itemQuery = { [item.field]: item[item.field] };
      if (item.baseQuery) Object.assign(itemQuery, item.baseQuery);
      Object.assign(query, { [item.service]: { $elemMatch: itemQuery } });
    });
    if (!_$1.isEqual(query, this.getQuery())) Store.patch("filter", { query });
  }
};
const Sorter = {
  initialize() {
    Store.set("sorter", { field: "name", order: "1", query: {} });
    Events.on("sorter-changed", () => this.updateSorterQuery());
  },
  get() {
    return Store.get("sorter");
  },
  getField() {
    return this.get().field;
  },
  getOrder() {
    return this.get().order;
  },
  getQuery() {
    return Store.get("sorter.query");
  },
  // Build sort query
  updateSorterQuery() {
    const query = { $sort: { [this.getField()]: this.getOrder() } };
    if (!_$1.isEqual(query, this.getQuery())) Store.patch("sorter", { query });
  }
};
const Document = {
  initialize() {
    this.options = _$1.defaultsDeep(_$1.get(config, "document"), {
      viewers: {
        htm: "document/KHtml",
        html: "document/KHtml",
        "text/html": "document/KHtml",
        txt: "document/KHtml",
        "text/plain": "document/KHtml",
        csv: "document/KCsv",
        "text/csv": "document/KCsv",
        md: "document/KMarkdown",
        "text/markdown": "document/KMarkdown",
        pdf: "document/KPdf",
        "application/pdf": "document/KPdf",
        jpg: "document/KImage",
        jpeg: "document/KImage",
        "image/jpeg": "document/KImage",
        png: "document/KImage",
        "image/png": "document/KImage",
        apng: "document/KImage",
        "image/apng": "document/KImage",
        gif: "document/KImage",
        "image/gif": "document/KImage",
        svg: "document/KImage",
        "image/svg+xml": "document/KImage",
        webp: "document/KImage",
        "image/webp": "document/KImage",
        mp4: "document/KVideo",
        "video/mp4": "document/KVideo",
        mkv: "document/KVideo",
        "video/x-matroska": "document/KVideo",
        mov: "document/KVideo",
        "video/quicktime": "document/KVideo",
        webm: "document/KVideo",
        "video/webm": "document/KVideo"
      },
      browser: {
        scrollableViewers: ["document/KHtml", "document/KMarkdown", "document/KCsv"]
      },
      htmlSanitizer: {
        allowedTags: sanitize.defaults.allowedTags.concat(["img", "strike"]),
        allowedAttributes: _$1.assign(sanitize.defaults.allowedAttributes, { div: ["style"] })
      },
      mdConverter: {}
    });
    logger$1.debug("[KDK] Document initialized with options:", this.options);
  },
  register(types, viewer) {
    if (!_$1.isArray(types)) types = [types];
    _$1.forEach(types, (type) => {
      _$1.set(this.options, `viewers.${type}`, viewer);
    });
  },
  getViewer(type) {
    return _$1.get(this.options, `viewers.${type}`);
  },
  hasViewer(type) {
    return !_$1.isNil(this.getViewer(type));
  },
  sanitizeHtml(html) {
    if (_$1.isNil(html)) return null;
    return sanitize(html, this.options.htmlSanitizer);
  },
  async fetchUrl(url, localize) {
    if (_$1.isEmpty(url)) return null;
    let urls;
    if (localize) urls = i18n.localize(url);
    else urls = [url];
    let response;
    for (const url2 of urls) {
      try {
        response = await fetch(url2);
        if (response.ok) return response;
      } catch (error) {
      }
    }
    return null;
  }
};
function useHistory(showing, hide, hideOnRouteChange) {
  let historyEntry;
  function removeFromHistory() {
    if (historyEntry !== void 0) {
      History.remove(historyEntry);
      historyEntry = void 0;
    }
  }
  onBeforeUnmount(() => {
    showing.value === true && removeFromHistory();
  });
  return {
    removeFromHistory,
    addToHistory() {
      historyEntry = {
        condition: () => hideOnRouteChange.value === true,
        handler: hide
      };
      History.add(historyEntry);
    }
  };
}
function useTimeout() {
  let timer = null;
  const vm2 = getCurrentInstance();
  function removeTimeout() {
    if (timer !== null) {
      clearTimeout(timer);
      timer = null;
    }
  }
  onDeactivated(removeTimeout);
  onBeforeUnmount(removeTimeout);
  return {
    removeTimeout,
    registerTimeout(fn, delay) {
      removeTimeout();
      if (vmIsDestroyed(vm2) === false) {
        timer = setTimeout(fn, delay);
      }
    }
  };
}
function useTick() {
  let tickFn;
  const vm2 = getCurrentInstance();
  function removeTick() {
    tickFn = void 0;
  }
  onDeactivated(removeTick);
  onBeforeUnmount(removeTick);
  return {
    removeTick,
    registerTick(fn) {
      tickFn = fn;
      nextTick(() => {
        if (tickFn === fn) {
          vmIsDestroyed(vm2) === false && tickFn();
          tickFn = void 0;
        }
      });
    }
  };
}
const useModelToggleProps = {
  modelValue: {
    type: Boolean,
    default: null
  },
  "onUpdate:modelValue": [Function, Array]
};
const useModelToggleEmits = [
  "beforeShow",
  "show",
  "beforeHide",
  "hide"
];
function useModelToggle({
  showing,
  canShow,
  // optional
  hideOnRouteChange,
  // optional
  handleShow,
  // optional
  handleHide,
  // optional
  processOnMount
  // optional
}) {
  const vm2 = getCurrentInstance();
  const { props: props2, emit: emit2, proxy } = vm2;
  let payload;
  function toggle(evt) {
    if (showing.value === true) {
      hide(evt);
    } else {
      show(evt);
    }
  }
  function show(evt) {
    if (props2.disable === true || evt !== void 0 && evt.qAnchorHandled === true || canShow !== void 0 && canShow(evt) !== true) {
      return;
    }
    const listener = props2["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", true);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props2.modelValue === null || listener === false || false) {
      processShow(evt);
    }
  }
  function processShow(evt) {
    if (showing.value === true) {
      return;
    }
    showing.value = true;
    emit2("beforeShow", evt);
    if (handleShow !== void 0) {
      handleShow(evt);
    } else {
      emit2("show", evt);
    }
  }
  function hide(evt) {
    if (props2.disable === true) {
      return;
    }
    const listener = props2["onUpdate:modelValue"] !== void 0;
    if (listener === true && true) {
      emit2("update:modelValue", false);
      payload = evt;
      nextTick(() => {
        if (payload === evt) {
          payload = void 0;
        }
      });
    }
    if (props2.modelValue === null || listener === false || false) {
      processHide(evt);
    }
  }
  function processHide(evt) {
    if (showing.value === false) {
      return;
    }
    showing.value = false;
    emit2("beforeHide", evt);
    if (handleHide !== void 0) {
      handleHide(evt);
    } else {
      emit2("hide", evt);
    }
  }
  function processModelChange(val) {
    if (props2.disable === true && val === true) {
      if (props2["onUpdate:modelValue"] !== void 0) {
        emit2("update:modelValue", false);
      }
    } else if (val === true !== showing.value) {
      const fn = val === true ? processShow : processHide;
      fn(payload);
    }
  }
  watch(() => props2.modelValue, processModelChange);
  if (hideOnRouteChange !== void 0 && vmHasRouter(vm2) === true) {
    watch(() => proxy.$route.fullPath, () => {
      if (hideOnRouteChange.value === true && showing.value === true) {
        hide();
      }
    });
  }
  onMounted(() => {
    processModelChange(props2.modelValue);
  });
  const publicMethods = { show, hide, toggle };
  Object.assign(proxy, publicMethods);
  return publicMethods;
}
const useTransitionProps = {
  transitionShow: {
    type: String,
    default: "fade"
  },
  transitionHide: {
    type: String,
    default: "fade"
  },
  transitionDuration: {
    type: [String, Number],
    default: 300
  }
};
function useTransition(props2, defaultShowFn = () => {
}, defaultHideFn = () => {
}) {
  return {
    transitionProps: computed(() => {
      const show = `q-transition--${props2.transitionShow || defaultShowFn()}`;
      const hide = `q-transition--${props2.transitionHide || defaultHideFn()}`;
      return {
        appear: true,
        enterFromClass: `${show}-enter-from`,
        enterActiveClass: `${show}-enter-active`,
        enterToClass: `${show}-enter-to`,
        leaveFromClass: `${hide}-leave-from`,
        leaveActiveClass: `${hide}-leave-active`,
        leaveToClass: `${hide}-leave-to`
      };
    }),
    transitionStyle: computed(() => `--q-transition-duration: ${props2.transitionDuration}ms`)
  };
}
let queue = [];
let waitFlags = [];
function clearFlag(flag) {
  waitFlags = waitFlags.filter((entry) => entry !== flag);
}
function addFocusWaitFlag(flag) {
  clearFlag(flag);
  waitFlags.push(flag);
}
function removeFocusWaitFlag(flag) {
  clearFlag(flag);
  if (waitFlags.length === 0 && queue.length !== 0) {
    queue[queue.length - 1]();
    queue = [];
  }
}
function addFocusFn(fn) {
  if (waitFlags.length === 0) {
    fn();
  } else {
    queue.push(fn);
  }
}
function removeFocusFn(fn) {
  queue = queue.filter((entry) => entry !== fn);
}
const portalProxyList = [];
function isOnGlobalDialog(vm2) {
  vm2 = vm2.parent;
  while (vm2 !== void 0 && vm2 !== null) {
    if (vm2.type.name === "QGlobalDialog") {
      return true;
    }
    if (vm2.type.name === "QDialog" || vm2.type.name === "QMenu") {
      return false;
    }
    vm2 = vm2.parent;
  }
  return false;
}
function usePortal(vm2, innerRef, renderPortalContent, type) {
  const portalIsActive = ref(false);
  const portalIsAccessible = ref(false);
  let portalEl = null;
  const focusObj = {};
  const onGlobalDialog = isOnGlobalDialog(vm2);
  function showPortal(isReady) {
    if (isReady === true) {
      removeFocusWaitFlag(focusObj);
      portalIsAccessible.value = true;
      return;
    }
    portalIsAccessible.value = false;
    if (portalIsActive.value === false) {
      if (onGlobalDialog === false && portalEl === null) {
        portalEl = createGlobalNode(false, type);
      }
      portalIsActive.value = true;
      portalProxyList.push(vm2.proxy);
      addFocusWaitFlag(focusObj);
    }
  }
  function hidePortal(isReady) {
    portalIsAccessible.value = false;
    if (isReady !== true) {
      return;
    }
    removeFocusWaitFlag(focusObj);
    portalIsActive.value = false;
    const index2 = portalProxyList.indexOf(vm2.proxy);
    if (index2 !== -1) {
      portalProxyList.splice(index2, 1);
    }
    if (portalEl !== null) {
      removeGlobalNode(portalEl);
      portalEl = null;
    }
  }
  onUnmounted(() => {
    hidePortal(true);
  });
  vm2.proxy.__qPortal = true;
  injectProp(vm2.proxy, "contentEl", () => innerRef.value);
  return {
    showPortal,
    hidePortal,
    portalIsActive,
    portalIsAccessible,
    renderPortal: () => onGlobalDialog === true ? renderPortalContent() : portalIsActive.value === true ? [h(Teleport, { to: portalEl }, renderPortalContent())] : void 0
  };
}
function getVerticalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : scrollTarget.scrollTop;
}
function getHorizontalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : scrollTarget.scrollLeft;
}
function hasScrollbar(el, onY = true) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-y"])) : el.scrollWidth > el.clientWidth && (el.classList.contains("scroll") || el.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(el)["overflow-x"]));
}
let registered = 0, scrollPositionX, scrollPositionY, maxScrollTop, vpPendingUpdate = false, bodyLeft, bodyTop, href, closeTimer = null;
function onWheel(e) {
  if (shouldPreventScroll(e)) {
    stopAndPrevent(e);
  }
}
function shouldPreventScroll(e) {
  if (e.target === document.body || e.target.classList.contains("q-layout__backdrop")) {
    return true;
  }
  const path2 = getEventPath(e), shift = e.shiftKey && !e.deltaX, scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY), delta = shift || scrollY ? e.deltaY : e.deltaX;
  for (let index2 = 0; index2 < path2.length; index2++) {
    const el = path2[index2];
    if (hasScrollbar(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }
  return true;
}
function onAppleScroll(e) {
  if (e.target === document) {
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop;
  }
}
function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }
  vpPendingUpdate = true;
  requestAnimationFrame(() => {
    vpPendingUpdate = false;
    const { height } = evt.target, { clientHeight, scrollTop } = document.scrollingElement;
    if (maxScrollTop === void 0 || height !== window.innerHeight) {
      maxScrollTop = clientHeight - height;
      document.scrollingElement.scrollTop = scrollTop;
    }
    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}
function apply(action) {
  const body = document.body, hasViewport = window.visualViewport !== void 0;
  if (action === "add") {
    const { overflowY, overflowX } = window.getComputedStyle(body);
    scrollPositionX = getHorizontalScrollPosition(window);
    scrollPositionY = getVerticalScrollPosition(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    href = window.location.href;
    body.style.left = `-${scrollPositionX}px`;
    body.style.top = `-${scrollPositionY}px`;
    if (overflowX !== "hidden" && (overflowX === "scroll" || body.scrollWidth > window.innerWidth)) {
      body.classList.add("q-body--force-scrollbar-x");
    }
    if (overflowY !== "hidden" && (overflowY === "scroll" || body.scrollHeight > window.innerHeight)) {
      body.classList.add("q-body--force-scrollbar-y");
    }
    body.classList.add("q-body--prevent-scroll");
    document.qScrollPrevented = true;
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
  }
  if (client.is.desktop === true && client.is.mac === true) {
    window[`${action}EventListener`]("wheel", onWheel, listenOpts.notPassive);
  }
  if (action === "remove") {
    if (client.is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture);
        window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture);
      } else {
        window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture);
      }
    }
    body.classList.remove("q-body--prevent-scroll");
    body.classList.remove("q-body--force-scrollbar-x");
    body.classList.remove("q-body--force-scrollbar-y");
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;
    if (window.location.href === href) {
      window.scrollTo(scrollPositionX, scrollPositionY);
    }
    maxScrollTop = void 0;
  }
}
function preventScroll(state) {
  let action = "add";
  if (state === true) {
    registered++;
    if (closeTimer !== null) {
      clearTimeout(closeTimer);
      closeTimer = null;
      return;
    }
    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }
    registered--;
    if (registered > 0) {
      return;
    }
    action = "remove";
    if (client.is.ios === true && client.is.nativeMobile === true) {
      closeTimer !== null && clearTimeout(closeTimer);
      closeTimer = setTimeout(() => {
        apply(action);
        closeTimer = null;
      }, 100);
      return;
    }
  }
  apply(action);
}
function usePreventScroll() {
  let currentState;
  return {
    preventBodyScroll(state) {
      if (state !== currentState && (currentState !== void 0 || state === true)) {
        currentState = state;
        preventScroll(state);
      }
    }
  };
}
const handlers$1 = [];
let escDown;
function onKeydown(evt) {
  escDown = evt.keyCode === 27;
}
function onBlur() {
  if (escDown === true) {
    escDown = false;
  }
}
function onKeyup(evt) {
  if (escDown === true) {
    escDown = false;
    if (isKeyCode(evt, 27) === true) {
      handlers$1[handlers$1.length - 1](evt);
    }
  }
}
function update(action) {
  window[action]("keydown", onKeydown);
  window[action]("blur", onBlur);
  window[action]("keyup", onKeyup);
  escDown = false;
}
function addEscapeKey(fn) {
  if (client.is.desktop === true) {
    handlers$1.push(fn);
    if (handlers$1.length === 1) {
      update("addEventListener");
    }
  }
}
function removeEscapeKey(fn) {
  const index2 = handlers$1.indexOf(fn);
  if (index2 > -1) {
    handlers$1.splice(index2, 1);
    if (handlers$1.length === 0) {
      update("removeEventListener");
    }
  }
}
const handlers = [];
function trigger(e) {
  handlers[handlers.length - 1](e);
}
function addFocusout(fn) {
  if (client.is.desktop === true) {
    handlers.push(fn);
    if (handlers.length === 1) {
      document.body.addEventListener("focusin", trigger);
    }
  }
}
function removeFocusout(fn) {
  const index2 = handlers.indexOf(fn);
  if (index2 > -1) {
    handlers.splice(index2, 1);
    if (handlers.length === 0) {
      document.body.removeEventListener("focusin", trigger);
    }
  }
}
let maximizedModals = 0;
const positionClass = {
  standard: "fixed-full flex-center",
  top: "fixed-top justify-center",
  bottom: "fixed-bottom justify-center",
  right: "fixed-right items-center",
  left: "fixed-left items-center"
};
const defaultTransitions = {
  standard: ["scale", "scale"],
  top: ["slide-down", "slide-up"],
  bottom: ["slide-up", "slide-down"],
  right: ["slide-left", "slide-right"],
  left: ["slide-right", "slide-left"]
};
const QDialog = createComponent({
  name: "QDialog",
  inheritAttrs: false,
  props: {
    ...useModelToggleProps,
    ...useTransitionProps,
    transitionShow: String,
    // override useTransitionProps
    transitionHide: String,
    // override useTransitionProps
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: "standard",
      validator: (val) => val === "standard" || ["top", "bottom", "left", "right"].includes(val)
    }
  },
  emits: [
    ...useModelToggleEmits,
    "shake",
    "click",
    "escapeKey"
  ],
  setup(props2, { slots, emit: emit2, attrs }) {
    const vm2 = getCurrentInstance();
    const innerRef = ref(null);
    const showing = ref(false);
    const animating = ref(false);
    let shakeTimeout = null, refocusTarget = null, isMaximized, avoidAutoClose;
    const hideOnRouteChange = computed(
      () => props2.persistent !== true && props2.noRouteDismiss !== true && props2.seamless !== true
    );
    const { preventBodyScroll } = usePreventScroll();
    const { registerTimeout } = useTimeout();
    const { registerTick, removeTick } = useTick();
    const { transitionProps, transitionStyle } = useTransition(
      props2,
      () => defaultTransitions[props2.position][0],
      () => defaultTransitions[props2.position][1]
    );
    const { showPortal, hidePortal, portalIsAccessible, renderPortal } = usePortal(
      vm2,
      innerRef,
      renderPortalContent,
      "dialog"
    );
    const { hide } = useModelToggle({
      showing,
      hideOnRouteChange,
      handleShow,
      handleHide,
      processOnMount: true
    });
    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange);
    const classes = computed(
      () => `q-dialog__inner flex no-pointer-events q-dialog__inner--${props2.maximized === true ? "maximized" : "minimized"} q-dialog__inner--${props2.position} ${positionClass[props2.position]}` + (animating.value === true ? " q-dialog__inner--animating" : "") + (props2.fullWidth === true ? " q-dialog__inner--fullwidth" : "") + (props2.fullHeight === true ? " q-dialog__inner--fullheight" : "") + (props2.square === true ? " q-dialog__inner--square" : "")
    );
    const useBackdrop = computed(() => showing.value === true && props2.seamless !== true);
    const onEvents = computed(() => props2.autoClose === true ? { onClick: onAutoClose } : {});
    const rootClasses = computed(() => [
      `q-dialog fullscreen no-pointer-events q-dialog--${useBackdrop.value === true ? "modal" : "seamless"}`,
      attrs.class
    ]);
    watch(() => props2.maximized, (state) => {
      showing.value === true && updateMaximized(state);
    });
    watch(useBackdrop, (val) => {
      preventBodyScroll(val);
      if (val === true) {
        addFocusout(onFocusChange);
        addEscapeKey(onEscapeKey);
      } else {
        removeFocusout(onFocusChange);
        removeEscapeKey(onEscapeKey);
      }
    });
    function handleShow(evt) {
      addToHistory();
      refocusTarget = props2.noRefocus === false && document.activeElement !== null ? document.activeElement : null;
      updateMaximized(props2.maximized);
      showPortal();
      animating.value = true;
      if (props2.noFocus !== true) {
        document.activeElement !== null && document.activeElement.blur();
        registerTick(focus);
      } else {
        removeTick();
      }
      registerTimeout(() => {
        if (vm2.proxy.$q.platform.is.ios === true) {
          if (props2.seamless !== true && document.activeElement) {
            const { top, bottom } = document.activeElement.getBoundingClientRect(), { innerHeight } = window, height = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;
            if (top > 0 && bottom > height / 2) {
              document.scrollingElement.scrollTop = Math.min(
                document.scrollingElement.scrollHeight - height,
                bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2)
              );
            }
            document.activeElement.scrollIntoView();
          }
          avoidAutoClose = true;
          innerRef.value.click();
          avoidAutoClose = false;
        }
        showPortal(true);
        animating.value = false;
        emit2("show", evt);
      }, props2.transitionDuration);
    }
    function handleHide(evt) {
      removeTick();
      removeFromHistory();
      cleanup(true);
      animating.value = true;
      hidePortal();
      if (refocusTarget !== null) {
        ((evt && evt.type.indexOf("key") === 0 ? refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || refocusTarget).focus();
        refocusTarget = null;
      }
      registerTimeout(() => {
        hidePortal(true);
        animating.value = false;
        emit2("hide", evt);
      }, props2.transitionDuration);
    }
    function focus(selector) {
      addFocusFn(() => {
        let node = innerRef.value;
        if (node === null || node.contains(document.activeElement) === true) {
          return;
        }
        node = (selector !== "" ? node.querySelector(selector) : null) || node.querySelector("[autofocus][tabindex], [data-autofocus][tabindex]") || node.querySelector("[autofocus] [tabindex], [data-autofocus] [tabindex]") || node.querySelector("[autofocus], [data-autofocus]") || node;
        node.focus({ preventScroll: true });
      });
    }
    function shake(focusTarget) {
      if (focusTarget && typeof focusTarget.focus === "function") {
        focusTarget.focus({ preventScroll: true });
      } else {
        focus();
      }
      emit2("shake");
      const node = innerRef.value;
      if (node !== null) {
        node.classList.remove("q-animate--scale");
        node.classList.add("q-animate--scale");
        shakeTimeout !== null && clearTimeout(shakeTimeout);
        shakeTimeout = setTimeout(() => {
          shakeTimeout = null;
          if (innerRef.value !== null) {
            node.classList.remove("q-animate--scale");
            focus();
          }
        }, 170);
      }
    }
    function onEscapeKey() {
      if (props2.seamless !== true) {
        if (props2.persistent === true || props2.noEscDismiss === true) {
          props2.maximized !== true && props2.noShake !== true && shake();
        } else {
          emit2("escapeKey");
          hide();
        }
      }
    }
    function cleanup(hiding) {
      if (shakeTimeout !== null) {
        clearTimeout(shakeTimeout);
        shakeTimeout = null;
      }
      if (hiding === true || showing.value === true) {
        updateMaximized(false);
        if (props2.seamless !== true) {
          preventBodyScroll(false);
          removeFocusout(onFocusChange);
          removeEscapeKey(onEscapeKey);
        }
      }
      if (hiding !== true) {
        refocusTarget = null;
      }
    }
    function updateMaximized(active) {
      if (active === true) {
        if (isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add("q-body--dialog");
          maximizedModals++;
          isMaximized = true;
        }
      } else if (isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove("q-body--dialog");
        }
        maximizedModals--;
        isMaximized = false;
      }
    }
    function onAutoClose(e) {
      if (avoidAutoClose !== true) {
        hide(e);
        emit2("click", e);
      }
    }
    function onBackdropClick(e) {
      if (props2.persistent !== true && props2.noBackdropDismiss !== true) {
        hide(e);
      } else if (props2.noShake !== true) {
        shake();
      }
    }
    function onFocusChange(evt) {
      if (props2.allowFocusOutside !== true && portalIsAccessible.value === true && childHasFocus(innerRef.value, evt.target) !== true) {
        focus('[tabindex]:not([tabindex="-1"])');
      }
    }
    Object.assign(vm2.proxy, {
      // expose public methods
      focus,
      shake,
      // private but needed by QSelect
      __updateRefocusTarget(target2) {
        refocusTarget = target2 || null;
      }
    });
    onBeforeUnmount(cleanup);
    function renderPortalContent() {
      return h("div", {
        role: "dialog",
        "aria-modal": useBackdrop.value === true ? "true" : "false",
        ...attrs,
        class: rootClasses.value
      }, [
        h(Transition, {
          name: "q-transition--fade",
          appear: true
        }, () => useBackdrop.value === true ? h("div", {
          class: "q-dialog__backdrop fixed-full",
          style: transitionStyle.value,
          "aria-hidden": "true",
          tabindex: -1,
          onClick: onBackdropClick
        }) : null),
        h(
          Transition,
          transitionProps.value,
          () => showing.value === true ? h("div", {
            ref: innerRef,
            class: classes.value,
            style: transitionStyle.value,
            tabindex: -1,
            ...onEvents.value
          }, hSlot(slots.default)) : null
        )
      ]);
    }
    return renderPortal;
  }
});
const useDarkProps = {
  dark: {
    type: Boolean,
    default: null
  }
};
function useDark(props2, $q) {
  return computed(() => props2.dark === null ? $q.dark.isActive : props2.dark);
}
const QCard = createComponent({
  name: "QCard",
  props: {
    ...useDarkProps,
    tag: {
      type: String,
      default: "div"
    },
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  setup(props2, { slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const isDark = useDark(props2, $q);
    const classes = computed(
      () => "q-card" + (isDark.value === true ? " q-card--dark q-dark" : "") + (props2.bordered === true ? " q-card--bordered" : "") + (props2.square === true ? " q-card--square no-border-radius" : "") + (props2.flat === true ? " q-card--flat no-shadow" : "")
    );
    return () => h(props2.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardSection = createComponent({
  name: "QCardSection",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    horizontal: Boolean
  },
  setup(props2, { slots }) {
    const classes = computed(
      () => `q-card__section q-card__section--${props2.horizontal === true ? "horiz row no-wrap" : "vert"}`
    );
    return () => h(props2.tag, { class: classes.value }, hSlot(slots.default));
  }
});
const QCardActions = createComponent({
  name: "QCardActions",
  props: {
    ...useAlignProps,
    vertical: Boolean
  },
  setup(props2, { slots }) {
    const alignClass = useAlign(props2);
    const classes = computed(
      () => `q-card__actions ${alignClass.value} q-card__actions--${props2.vertical === true ? "vert column" : "horiz row"}`
    );
    return () => h("div", { class: classes.value }, hSlot(slots.default));
  }
});
const insetMap = {
  true: "inset",
  item: "item-inset",
  "item-thumbnail": "item-thumbnail-inset"
};
const margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
const QSeparator = createComponent({
  name: "QSeparator",
  props: {
    ...useDarkProps,
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  setup(props2) {
    const vm2 = getCurrentInstance();
    const isDark = useDark(props2, vm2.proxy.$q);
    const orientation = computed(() => props2.vertical === true ? "vertical" : "horizontal");
    const orientClass = computed(() => ` q-separator--${orientation.value}`);
    const insetClass = computed(() => props2.inset !== false ? `${orientClass.value}-${insetMap[props2.inset]}` : "");
    const classes = computed(
      () => `q-separator${orientClass.value}${insetClass.value}` + (props2.color !== void 0 ? ` bg-${props2.color}` : "") + (isDark.value === true ? " q-separator--dark" : "")
    );
    const style2 = computed(() => {
      const acc = {};
      if (props2.size !== void 0) {
        acc[props2.vertical === true ? "width" : "height"] = props2.size;
      }
      if (props2.spaced !== false) {
        const size = props2.spaced === true ? `${margins.md}px` : props2.spaced in margins ? `${margins[props2.spaced]}px` : props2.spaced;
        const dir = props2.vertical === true ? ["Left", "Right"] : ["Top", "Bottom"];
        acc[`margin${dir[0]}`] = acc[`margin${dir[1]}`] = size;
      }
      return acc;
    });
    return () => h("hr", {
      class: classes.value,
      style: style2.value,
      "aria-orientation": orientation.value
    });
  }
});
function useFormChild({ validate, resetValidation, requiresQForm }) {
  const $form = inject(formKey, false);
  if ($form !== false) {
    const { props: props2, proxy } = getCurrentInstance();
    Object.assign(proxy, { validate, resetValidation });
    watch(() => props2.disable, (val) => {
      if (val === true) {
        typeof resetValidation === "function" && resetValidation();
        $form.unbindComponent(proxy);
      } else {
        $form.bindComponent(proxy);
      }
    });
    onMounted(() => {
      props2.disable !== true && $form.bindComponent(proxy);
    });
    onBeforeUnmount(() => {
      props2.disable !== true && $form.unbindComponent(proxy);
    });
  } else if (requiresQForm === true) {
    console.error("Parent QForm not found on useFormChild()!");
  }
}
const hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/, hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/, hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/, rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
const testPattern = {
  date: (v) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v),
  time: (v) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v),
  fulltime: (v) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v),
  timeOrFulltime: (v) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v),
  // -- RFC 5322 --
  // -- Added in v2.6.6 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  // eslint-disable-next-line
  email: (v) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v),
  hexColor: (v) => hex.test(v),
  hexaColor: (v) => hexa.test(v),
  hexOrHexaColor: (v) => hexOrHexa.test(v),
  rgbColor: (v) => rgb.test(v),
  rgbaColor: (v) => rgba.test(v),
  rgbOrRgbaColor: (v) => rgb.test(v) || rgba.test(v),
  hexOrRgbColor: (v) => hex.test(v) || rgb.test(v),
  hexaOrRgbaColor: (v) => hexa.test(v) || rgba.test(v),
  anyColor: (v) => hexOrHexa.test(v) || rgb.test(v) || rgba.test(v)
};
const lazyRulesValues = [true, false, "ondemand"];
const useValidateProps = {
  modelValue: {},
  error: {
    type: Boolean,
    default: null
  },
  errorMessage: String,
  noErrorIcon: Boolean,
  rules: Array,
  reactiveRules: Boolean,
  lazyRules: {
    type: [Boolean, String],
    validator: (v) => lazyRulesValues.includes(v)
  }
};
function useValidate(focused, innerLoading) {
  const { props: props2, proxy } = getCurrentInstance();
  const innerError = ref(false);
  const innerErrorMessage = ref(null);
  const isDirtyModel = ref(null);
  useFormChild({ validate, resetValidation });
  let validateIndex = 0, unwatchRules;
  const hasRules = computed(
    () => props2.rules !== void 0 && props2.rules !== null && props2.rules.length !== 0
  );
  const hasActiveRules = computed(
    () => props2.disable !== true && hasRules.value === true
  );
  const hasError = computed(
    () => props2.error === true || innerError.value === true
  );
  const errorMessage = computed(() => typeof props2.errorMessage === "string" && props2.errorMessage.length !== 0 ? props2.errorMessage : innerErrorMessage.value);
  watch(() => props2.modelValue, () => {
    validateIfNeeded();
  });
  watch(() => props2.reactiveRules, (val) => {
    if (val === true) {
      if (unwatchRules === void 0) {
        unwatchRules = watch(() => props2.rules, () => {
          validateIfNeeded(true);
        });
      }
    } else if (unwatchRules !== void 0) {
      unwatchRules();
      unwatchRules = void 0;
    }
  }, { immediate: true });
  watch(focused, (val) => {
    if (val === true) {
      if (isDirtyModel.value === null) {
        isDirtyModel.value = false;
      }
    } else if (isDirtyModel.value === false) {
      isDirtyModel.value = true;
      if (hasActiveRules.value === true && props2.lazyRules !== "ondemand" && innerLoading.value === false) {
        debouncedValidate();
      }
    }
  });
  function resetValidation() {
    validateIndex++;
    innerLoading.value = false;
    isDirtyModel.value = null;
    innerError.value = false;
    innerErrorMessage.value = null;
    debouncedValidate.cancel();
  }
  function validate(val = props2.modelValue) {
    if (hasActiveRules.value !== true) {
      return true;
    }
    const index2 = ++validateIndex;
    const setDirty = innerLoading.value !== true ? () => {
      isDirtyModel.value = true;
    } : () => {
    };
    const update2 = (err, msg) => {
      err === true && setDirty();
      innerError.value = err;
      innerErrorMessage.value = msg || null;
      innerLoading.value = false;
    };
    const promises = [];
    for (let i = 0; i < props2.rules.length; i++) {
      const rule = props2.rules[i];
      let res;
      if (typeof rule === "function") {
        res = rule(val, testPattern);
      } else if (typeof rule === "string" && testPattern[rule] !== void 0) {
        res = testPattern[rule](val);
      }
      if (res === false || typeof res === "string") {
        update2(true, res);
        return false;
      } else if (res !== true && res !== void 0) {
        promises.push(res);
      }
    }
    if (promises.length === 0) {
      update2(false);
      return true;
    }
    innerLoading.value = true;
    return Promise.all(promises).then(
      (res) => {
        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          index2 === validateIndex && update2(false);
          return true;
        }
        const msg = res.find((r) => r === false || typeof r === "string");
        index2 === validateIndex && update2(msg !== void 0, msg);
        return msg === void 0;
      },
      (e) => {
        if (index2 === validateIndex) {
          console.error(e);
          update2(true);
        }
        return false;
      }
    );
  }
  function validateIfNeeded(changedRules) {
    if (hasActiveRules.value === true && props2.lazyRules !== "ondemand" && (isDirtyModel.value === true || props2.lazyRules !== true && changedRules !== true)) {
      debouncedValidate();
    }
  }
  const debouncedValidate = debounce(validate, 0);
  onBeforeUnmount(() => {
    unwatchRules !== void 0 && unwatchRules();
    debouncedValidate.cancel();
  });
  Object.assign(proxy, { resetValidation, validate });
  injectProp(proxy, "hasError", () => hasError.value);
  return {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    validate,
    resetValidation
  };
}
const listenerRE = /^on[A-Z]/;
function useSplitAttrs(attrs, vnode) {
  const acc = {
    listeners: ref({}),
    attributes: ref({})
  };
  function update2() {
    const attributes = {};
    const listeners = {};
    for (const key in attrs) {
      if (key !== "class" && key !== "style" && listenerRE.test(key) === false) {
        attributes[key] = attrs[key];
      }
    }
    for (const key in vnode.props) {
      if (listenerRE.test(key) === true) {
        listeners[key] = vnode.props[key];
      }
    }
    acc.attributes.value = attributes;
    acc.listeners.value = listeners;
  }
  onBeforeUpdate(update2);
  update2();
  return acc;
}
function getTargetUid(val) {
  return val === void 0 ? `f_${uid$2()}` : val;
}
function fieldValueIsFilled(val) {
  return val !== void 0 && val !== null && ("" + val).length !== 0;
}
const useFieldProps = {
  ...useDarkProps,
  ...useValidateProps,
  label: String,
  stackLabel: Boolean,
  hint: String,
  hideHint: Boolean,
  prefix: String,
  suffix: String,
  labelColor: String,
  color: String,
  bgColor: String,
  filled: Boolean,
  outlined: Boolean,
  borderless: Boolean,
  standout: [Boolean, String],
  square: Boolean,
  loading: Boolean,
  labelSlot: Boolean,
  bottomSlots: Boolean,
  hideBottomSpace: Boolean,
  rounded: Boolean,
  dense: Boolean,
  itemAligned: Boolean,
  counter: Boolean,
  clearable: Boolean,
  clearIcon: String,
  disable: Boolean,
  readonly: Boolean,
  autofocus: Boolean,
  for: String,
  maxlength: [Number, String]
};
const useFieldEmits = ["update:modelValue", "clear", "focus", "blur", "popupShow", "popupHide"];
function useFieldState() {
  const { props: props2, attrs, proxy, vnode } = getCurrentInstance();
  const isDark = useDark(props2, proxy.$q);
  return {
    isDark,
    editable: computed(
      () => props2.disable !== true && props2.readonly !== true
    ),
    innerLoading: ref(false),
    focused: ref(false),
    hasPopupOpen: false,
    splitAttrs: useSplitAttrs(attrs, vnode),
    targetUid: ref(getTargetUid(props2.for)),
    rootRef: ref(null),
    targetRef: ref(null),
    controlRef: ref(null)
    /**
         * user supplied additionals:
    
         * innerValue - computed
         * floatingLabel - computed
         * inputRef - computed
    
         * fieldClass - computed
         * hasShadow - computed
    
         * controlEvents - Object with fn(e)
    
         * getControl - fn
         * getInnerAppend - fn
         * getControlChild - fn
         * getShadowControl - fn
         * showPopup - fn
         */
  };
}
function useField(state) {
  const { props: props2, emit: emit2, slots, attrs, proxy } = getCurrentInstance();
  const { $q } = proxy;
  let focusoutTimer = null;
  if (state.hasValue === void 0) {
    state.hasValue = computed(() => fieldValueIsFilled(props2.modelValue));
  }
  if (state.emitValue === void 0) {
    state.emitValue = (value) => {
      emit2("update:modelValue", value);
    };
  }
  if (state.controlEvents === void 0) {
    state.controlEvents = {
      onFocusin: onControlFocusin,
      onFocusout: onControlFocusout
    };
  }
  Object.assign(state, {
    clearValue,
    onControlFocusin,
    onControlFocusout,
    focus
  });
  if (state.computedCounter === void 0) {
    state.computedCounter = computed(() => {
      if (props2.counter !== false) {
        const len = typeof props2.modelValue === "string" || typeof props2.modelValue === "number" ? ("" + props2.modelValue).length : Array.isArray(props2.modelValue) === true ? props2.modelValue.length : 0;
        const max = props2.maxlength !== void 0 ? props2.maxlength : props2.maxValues;
        return len + (max !== void 0 ? " / " + max : "");
      }
    });
  }
  const {
    isDirtyModel,
    hasRules,
    hasError,
    errorMessage,
    resetValidation
  } = useValidate(state.focused, state.innerLoading);
  const floatingLabel = state.floatingLabel !== void 0 ? computed(() => props2.stackLabel === true || state.focused.value === true || state.floatingLabel.value === true) : computed(() => props2.stackLabel === true || state.focused.value === true || state.hasValue.value === true);
  const shouldRenderBottom = computed(
    () => props2.bottomSlots === true || props2.hint !== void 0 || hasRules.value === true || props2.counter === true || props2.error !== null
  );
  const styleType = computed(() => {
    if (props2.filled === true) {
      return "filled";
    }
    if (props2.outlined === true) {
      return "outlined";
    }
    if (props2.borderless === true) {
      return "borderless";
    }
    if (props2.standout) {
      return "standout";
    }
    return "standard";
  });
  const classes = computed(
    () => `q-field row no-wrap items-start q-field--${styleType.value}` + (state.fieldClass !== void 0 ? ` ${state.fieldClass.value}` : "") + (props2.rounded === true ? " q-field--rounded" : "") + (props2.square === true ? " q-field--square" : "") + (floatingLabel.value === true ? " q-field--float" : "") + (hasLabel.value === true ? " q-field--labeled" : "") + (props2.dense === true ? " q-field--dense" : "") + (props2.itemAligned === true ? " q-field--item-aligned q-item-type" : "") + (state.isDark.value === true ? " q-field--dark" : "") + (state.getControl === void 0 ? " q-field--auto-height" : "") + (state.focused.value === true ? " q-field--focused" : "") + (hasError.value === true ? " q-field--error" : "") + (hasError.value === true || state.focused.value === true ? " q-field--highlighted" : "") + (props2.hideBottomSpace !== true && shouldRenderBottom.value === true ? " q-field--with-bottom" : "") + (props2.disable === true ? " q-field--disabled" : props2.readonly === true ? " q-field--readonly" : "")
  );
  const contentClass = computed(
    () => "q-field__control relative-position row no-wrap" + (props2.bgColor !== void 0 ? ` bg-${props2.bgColor}` : "") + (hasError.value === true ? " text-negative" : typeof props2.standout === "string" && props2.standout.length !== 0 && state.focused.value === true ? ` ${props2.standout}` : props2.color !== void 0 ? ` text-${props2.color}` : "")
  );
  const hasLabel = computed(
    () => props2.labelSlot === true || props2.label !== void 0
  );
  const labelClass = computed(
    () => "q-field__label no-pointer-events absolute ellipsis" + (props2.labelColor !== void 0 && hasError.value !== true ? ` text-${props2.labelColor}` : "")
  );
  const controlSlotScope = computed(() => ({
    id: state.targetUid.value,
    editable: state.editable.value,
    focused: state.focused.value,
    floatingLabel: floatingLabel.value,
    modelValue: props2.modelValue,
    emitValue: state.emitValue
  }));
  const attributes = computed(() => {
    const acc = {
      for: state.targetUid.value
    };
    if (props2.disable === true) {
      acc["aria-disabled"] = "true";
    } else if (props2.readonly === true) {
      acc["aria-readonly"] = "true";
    }
    return acc;
  });
  watch(() => props2.for, (val) => {
    state.targetUid.value = getTargetUid(val);
  });
  function focusHandler() {
    const el = document.activeElement;
    let target2 = state.targetRef !== void 0 && state.targetRef.value;
    if (target2 && (el === null || el.id !== state.targetUid.value)) {
      target2.hasAttribute("tabindex") === true || (target2 = target2.querySelector("[tabindex]"));
      if (target2 && target2 !== el) {
        target2.focus({ preventScroll: true });
      }
    }
  }
  function focus() {
    addFocusFn(focusHandler);
  }
  function blur() {
    removeFocusFn(focusHandler);
    const el = document.activeElement;
    if (el !== null && state.rootRef.value.contains(el)) {
      el.blur();
    }
  }
  function onControlFocusin(e) {
    if (focusoutTimer !== null) {
      clearTimeout(focusoutTimer);
      focusoutTimer = null;
    }
    if (state.editable.value === true && state.focused.value === false) {
      state.focused.value = true;
      emit2("focus", e);
    }
  }
  function onControlFocusout(e, then) {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
    focusoutTimer = setTimeout(() => {
      focusoutTimer = null;
      if (document.hasFocus() === true && (state.hasPopupOpen === true || state.controlRef === void 0 || state.controlRef.value === null || state.controlRef.value.contains(document.activeElement) !== false)) {
        return;
      }
      if (state.focused.value === true) {
        state.focused.value = false;
        emit2("blur", e);
      }
      then !== void 0 && then();
    });
  }
  function clearValue(e) {
    stopAndPrevent(e);
    if ($q.platform.is.mobile !== true) {
      const el = state.targetRef !== void 0 && state.targetRef.value || state.rootRef.value;
      el.focus();
    } else if (state.rootRef.value.contains(document.activeElement) === true) {
      document.activeElement.blur();
    }
    if (props2.type === "file") {
      state.inputRef.value.value = null;
    }
    emit2("update:modelValue", null);
    emit2("clear", props2.modelValue);
    nextTick(() => {
      resetValidation();
      if ($q.platform.is.mobile !== true) {
        isDirtyModel.value = false;
      }
    });
  }
  function getContent() {
    const node = [];
    slots.prepend !== void 0 && node.push(
      h("div", {
        class: "q-field__prepend q-field__marginal row no-wrap items-center",
        key: "prepend",
        onClick: prevent
      }, slots.prepend())
    );
    node.push(
      h("div", {
        class: "q-field__control-container col relative-position row no-wrap q-anchor--skip"
      }, getControlContainer())
    );
    hasError.value === true && props2.noErrorIcon === false && node.push(
      getInnerAppendNode("error", [
        h(QIcon, { name: $q.iconSet.field.error, color: "negative" })
      ])
    );
    if (props2.loading === true || state.innerLoading.value === true) {
      node.push(
        getInnerAppendNode(
          "inner-loading-append",
          slots.loading !== void 0 ? slots.loading() : [h(QSpinner, { color: props2.color })]
        )
      );
    } else if (props2.clearable === true && state.hasValue.value === true && state.editable.value === true) {
      node.push(
        getInnerAppendNode("inner-clearable-append", [
          h(QIcon, {
            class: "q-field__focusable-action",
            tag: "button",
            name: props2.clearIcon || $q.iconSet.field.clear,
            tabindex: 0,
            type: "button",
            "aria-hidden": null,
            role: null,
            onClick: clearValue
          })
        ])
      );
    }
    slots.append !== void 0 && node.push(
      h("div", {
        class: "q-field__append q-field__marginal row no-wrap items-center",
        key: "append",
        onClick: prevent
      }, slots.append())
    );
    state.getInnerAppend !== void 0 && node.push(
      getInnerAppendNode("inner-append", state.getInnerAppend())
    );
    state.getControlChild !== void 0 && node.push(
      state.getControlChild()
    );
    return node;
  }
  function getControlContainer() {
    const node = [];
    props2.prefix !== void 0 && props2.prefix !== null && node.push(
      h("div", {
        class: "q-field__prefix no-pointer-events row items-center"
      }, props2.prefix)
    );
    if (state.getShadowControl !== void 0 && state.hasShadow.value === true) {
      node.push(
        state.getShadowControl()
      );
    }
    if (state.getControl !== void 0) {
      node.push(state.getControl());
    } else if (slots.rawControl !== void 0) {
      node.push(slots.rawControl());
    } else if (slots.control !== void 0) {
      node.push(
        h("div", {
          ref: state.targetRef,
          class: "q-field__native row",
          tabindex: -1,
          ...state.splitAttrs.attributes.value,
          "data-autofocus": props2.autofocus === true || void 0
        }, slots.control(controlSlotScope.value))
      );
    }
    hasLabel.value === true && node.push(
      h("div", {
        class: labelClass.value
      }, hSlot(slots.label, props2.label))
    );
    props2.suffix !== void 0 && props2.suffix !== null && node.push(
      h("div", {
        class: "q-field__suffix no-pointer-events row items-center"
      }, props2.suffix)
    );
    return node.concat(hSlot(slots.default));
  }
  function getBottom() {
    let msg, key;
    if (hasError.value === true) {
      if (errorMessage.value !== null) {
        msg = [h("div", { role: "alert" }, errorMessage.value)];
        key = `q--slot-error-${errorMessage.value}`;
      } else {
        msg = hSlot(slots.error);
        key = "q--slot-error";
      }
    } else if (props2.hideHint !== true || state.focused.value === true) {
      if (props2.hint !== void 0) {
        msg = [h("div", props2.hint)];
        key = `q--slot-hint-${props2.hint}`;
      } else {
        msg = hSlot(slots.hint);
        key = "q--slot-hint";
      }
    }
    const hasCounter = props2.counter === true || slots.counter !== void 0;
    if (props2.hideBottomSpace === true && hasCounter === false && msg === void 0) {
      return;
    }
    const main = h("div", {
      key,
      class: "q-field__messages col"
    }, msg);
    return h("div", {
      class: "q-field__bottom row items-start q-field__bottom--" + (props2.hideBottomSpace !== true ? "animated" : "stale"),
      onClick: prevent
    }, [
      props2.hideBottomSpace === true ? main : h(Transition, { name: "q-transition--field-message" }, () => main),
      hasCounter === true ? h("div", {
        class: "q-field__counter"
      }, slots.counter !== void 0 ? slots.counter() : state.computedCounter.value) : null
    ]);
  }
  function getInnerAppendNode(key, content) {
    return content === null ? null : h("div", {
      key,
      class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip"
    }, content);
  }
  let shouldActivate = false;
  onDeactivated(() => {
    shouldActivate = true;
  });
  onActivated(() => {
    shouldActivate === true && props2.autofocus === true && proxy.focus();
  });
  onMounted(() => {
    if (isRuntimeSsrPreHydration.value === true && props2.for === void 0) {
      state.targetUid.value = getTargetUid();
    }
    props2.autofocus === true && proxy.focus();
  });
  onBeforeUnmount(() => {
    focusoutTimer !== null && clearTimeout(focusoutTimer);
  });
  Object.assign(proxy, { focus, blur });
  return function renderField() {
    const labelAttrs = state.getControl === void 0 && slots.control === void 0 ? {
      ...state.splitAttrs.attributes.value,
      "data-autofocus": props2.autofocus === true || void 0,
      ...attributes.value
    } : attributes.value;
    return h("label", {
      ref: state.rootRef,
      class: [
        classes.value,
        attrs.class
      ],
      style: attrs.style,
      ...labelAttrs
    }, [
      slots.before !== void 0 ? h("div", {
        class: "q-field__before q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.before()) : null,
      h("div", {
        class: "q-field__inner relative-position col self-stretch"
      }, [
        h("div", {
          ref: state.controlRef,
          class: contentClass.value,
          tabindex: -1,
          ...state.controlEvents
        }, getContent()),
        shouldRenderBottom.value === true ? getBottom() : null
      ]),
      slots.after !== void 0 ? h("div", {
        class: "q-field__after q-field__marginal row no-wrap items-center",
        onClick: prevent
      }, slots.after()) : null
    ]);
  };
}
const NAMED_MASKS = {
  date: "####/##/##",
  datetime: "####/##/## ##:##",
  time: "##:##",
  fulltime: "##:##:##",
  phone: "(###) ### - ####",
  card: "#### #### #### ####"
};
const TOKENS = {
  "#": { pattern: "[\\d]", negate: "[^\\d]" },
  S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" },
  N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" },
  A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v) => v.toLocaleUpperCase() },
  a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (v) => v.toLocaleLowerCase() },
  X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v) => v.toLocaleUpperCase() },
  x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (v) => v.toLocaleLowerCase() }
};
const KEYS = Object.keys(TOKENS);
KEYS.forEach((key) => {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
const tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g"), escRegex = /[.*+?^${}()|[\]\\]/g;
const MARKER = String.fromCharCode(1);
const useMaskProps = {
  mask: String,
  reverseFillMask: Boolean,
  fillMask: [Boolean, String],
  unmaskedValue: Boolean
};
function useMask(props2, emit2, emitValue, inputRef) {
  let maskMarked, maskReplaced, computedMask, computedUnmask, pastedTextStart, selectionAnchor;
  const hasMask = ref(null);
  const innerValue = ref(getInitialMaskedValue());
  function getIsTypeText() {
    return props2.autogrow === true || ["textarea", "text", "search", "url", "tel", "password"].includes(props2.type);
  }
  watch(() => props2.type + props2.autogrow, updateMaskInternals);
  watch(() => props2.mask, (v) => {
    if (v !== void 0) {
      updateMaskValue(innerValue.value, true);
    } else {
      const val = unmaskValue(innerValue.value);
      updateMaskInternals();
      props2.modelValue !== val && emit2("update:modelValue", val);
    }
  });
  watch(() => props2.fillMask + props2.reverseFillMask, () => {
    hasMask.value === true && updateMaskValue(innerValue.value, true);
  });
  watch(() => props2.unmaskedValue, () => {
    hasMask.value === true && updateMaskValue(innerValue.value);
  });
  function getInitialMaskedValue() {
    updateMaskInternals();
    if (hasMask.value === true) {
      const masked = maskValue(unmaskValue(props2.modelValue));
      return props2.fillMask !== false ? fillWithMask(masked) : masked;
    }
    return props2.modelValue;
  }
  function getPaddedMaskMarked(size) {
    if (size < maskMarked.length) {
      return maskMarked.slice(-size);
    }
    let pad = "", localMaskMarked = maskMarked;
    const padPos = localMaskMarked.indexOf(MARKER);
    if (padPos > -1) {
      for (let i = size - localMaskMarked.length; i > 0; i--) {
        pad += MARKER;
      }
      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);
    }
    return localMaskMarked;
  }
  function updateMaskInternals() {
    hasMask.value = props2.mask !== void 0 && props2.mask.length !== 0 && getIsTypeText();
    if (hasMask.value === false) {
      computedUnmask = void 0;
      maskMarked = "";
      maskReplaced = "";
      return;
    }
    const localComputedMask = NAMED_MASKS[props2.mask] === void 0 ? props2.mask : NAMED_MASKS[props2.mask], fillChar = typeof props2.fillMask === "string" && props2.fillMask.length !== 0 ? props2.fillMask.slice(0, 1) : "_", fillCharEscaped = fillChar.replace(escRegex, "\\$&"), unmask = [], extract = [], mask = [];
    let firstMatch = props2.reverseFillMask === true, unmaskChar = "", negateChar = "";
    localComputedMask.replace(tokenRegexMask, (_2, char1, esc, token, char2) => {
      if (token !== void 0) {
        const c = TOKENS[token];
        mask.push(c);
        negateChar = c.negate;
        if (firstMatch === true) {
          extract.push("(?:" + negateChar + "+)?(" + c.pattern + "+)?(?:" + negateChar + "+)?(" + c.pattern + "+)?");
          firstMatch = false;
        }
        extract.push("(?:" + negateChar + "+)?(" + c.pattern + ")?");
      } else if (esc !== void 0) {
        unmaskChar = "\\" + (esc === "\\" ? "" : esc);
        mask.push(esc);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      } else {
        const c = char1 !== void 0 ? char1 : char2;
        unmaskChar = c === "\\" ? "\\\\\\\\" : c.replace(escRegex, "\\\\$&");
        mask.push(c);
        unmask.push("([^" + unmaskChar + "]+)?" + unmaskChar + "?");
      }
    });
    const unmaskMatcher = new RegExp(
      "^" + unmask.join("") + "(" + (unmaskChar === "" ? "." : "[^" + unmaskChar + "]") + "+)?" + (unmaskChar === "" ? "" : "[" + unmaskChar + "]*") + "$"
    ), extractLast = extract.length - 1, extractMatcher = extract.map((re, index2) => {
      if (index2 === 0 && props2.reverseFillMask === true) {
        return new RegExp("^" + fillCharEscaped + "*" + re);
      } else if (index2 === extractLast) {
        return new RegExp(
          "^" + re + "(" + (negateChar === "" ? "." : negateChar) + "+)?" + (props2.reverseFillMask === true ? "$" : fillCharEscaped + "*")
        );
      }
      return new RegExp("^" + re);
    });
    computedMask = mask;
    computedUnmask = (val) => {
      const unmaskMatch = unmaskMatcher.exec(props2.reverseFillMask === true ? val : val.slice(0, mask.length + 1));
      if (unmaskMatch !== null) {
        val = unmaskMatch.slice(1).join("");
      }
      const extractMatch = [], extractMatcherLength = extractMatcher.length;
      for (let i = 0, str = val; i < extractMatcherLength; i++) {
        const m = extractMatcher[i].exec(str);
        if (m === null) {
          break;
        }
        str = str.slice(m.shift().length);
        extractMatch.push(...m);
      }
      if (extractMatch.length !== 0) {
        return extractMatch.join("");
      }
      return val;
    };
    maskMarked = mask.map((v) => typeof v === "string" ? v : MARKER).join("");
    maskReplaced = maskMarked.split(MARKER).join(fillChar);
  }
  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {
    const inp = inputRef.value, end = inp.selectionEnd, endReverse = inp.value.length - end, unmasked = unmaskValue(rawVal);
    updateMaskInternalsFlag === true && updateMaskInternals();
    const preMasked = maskValue(unmasked), masked = props2.fillMask !== false ? fillWithMask(preMasked) : preMasked, changed = innerValue.value !== masked;
    inp.value !== masked && (inp.value = masked);
    changed === true && (innerValue.value = masked);
    document.activeElement === inp && nextTick(() => {
      if (masked === maskReplaced) {
        const cursor = props2.reverseFillMask === true ? maskReplaced.length : 0;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (inputType === "insertFromPaste" && props2.reverseFillMask !== true) {
        const maxEnd = inp.selectionEnd;
        let cursor = end - 1;
        for (let i = pastedTextStart; i <= cursor && i < maxEnd; i++) {
          if (maskMarked[i] !== MARKER) {
            cursor++;
          }
        }
        moveCursor.right(inp, cursor);
        return;
      }
      if (["deleteContentBackward", "deleteContentForward"].indexOf(inputType) > -1) {
        const cursor = props2.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
        inp.setSelectionRange(cursor, cursor, "forward");
        return;
      }
      if (props2.reverseFillMask === true) {
        if (changed === true) {
          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));
          if (cursor === 1 && end === 1) {
            inp.setSelectionRange(cursor, cursor, "forward");
          } else {
            moveCursor.rightReverse(inp, cursor);
          }
        } else {
          const cursor = masked.length - endReverse;
          inp.setSelectionRange(cursor, cursor, "backward");
        }
      } else {
        if (changed === true) {
          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
          moveCursor.right(inp, cursor);
        } else {
          const cursor = end - 1;
          moveCursor.right(inp, cursor);
        }
      }
    });
    const val = props2.unmaskedValue === true ? unmaskValue(masked) : masked;
    String(props2.modelValue) !== val && emitValue(val, true);
  }
  function moveCursorForPaste(inp, start, end) {
    const preMasked = maskValue(unmaskValue(inp.value));
    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
    pastedTextStart = start;
    inp.setSelectionRange(start, end, "forward");
  }
  const moveCursor = {
    left(inp, cursor) {
      const noMarkBefore = maskMarked.slice(cursor - 1).indexOf(MARKER) === -1;
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          noMarkBefore === true && cursor++;
          break;
        }
      }
      if (i < 0 && maskMarked[cursor] !== void 0 && maskMarked[cursor] !== MARKER) {
        return moveCursor.right(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    right(inp, cursor) {
      const limit = inp.value.length;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (maskMarked[i] === MARKER) {
          cursor = i;
          break;
        } else if (maskMarked[i - 1] === MARKER) {
          cursor = i;
        }
      }
      if (i > limit && maskMarked[cursor - 1] !== void 0 && maskMarked[cursor - 1] !== MARKER) {
        return moveCursor.left(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    },
    leftReverse(inp, cursor) {
      const localMaskMarked = getPaddedMaskMarked(inp.value.length);
      let i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          break;
        } else if (localMaskMarked[i] === MARKER) {
          cursor = i;
          if (i === 0) {
            break;
          }
        }
      }
      if (i < 0 && localMaskMarked[cursor] !== void 0 && localMaskMarked[cursor] !== MARKER) {
        return moveCursor.rightReverse(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, "backward");
    },
    rightReverse(inp, cursor) {
      const limit = inp.value.length, localMaskMarked = getPaddedMaskMarked(limit), noMarkBefore = localMaskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1;
      let i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (localMaskMarked[i - 1] === MARKER) {
          cursor = i;
          cursor > 0 && noMarkBefore === true && cursor--;
          break;
        }
      }
      if (i > limit && localMaskMarked[cursor - 1] !== void 0 && localMaskMarked[cursor - 1] !== MARKER) {
        return moveCursor.leftReverse(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, "forward");
    }
  };
  function onMaskedClick(e) {
    emit2("click", e);
    selectionAnchor = void 0;
  }
  function onMaskedKeydown(e) {
    emit2("keydown", e);
    if (shouldIgnoreKey(e) === true) {
      return;
    }
    const inp = inputRef.value, start = inp.selectionStart, end = inp.selectionEnd;
    if (!e.shiftKey) {
      selectionAnchor = void 0;
    }
    if (e.keyCode === 37 || e.keyCode === 39) {
      if (e.shiftKey && selectionAnchor === void 0) {
        selectionAnchor = inp.selectionDirection === "forward" ? start : end;
      }
      const fn = moveCursor[(e.keyCode === 39 ? "right" : "left") + (props2.reverseFillMask === true ? "Reverse" : "")];
      e.preventDefault();
      fn(inp, selectionAnchor === start ? end : start);
      if (e.shiftKey) {
        const cursor = inp.selectionStart;
        inp.setSelectionRange(Math.min(selectionAnchor, cursor), Math.max(selectionAnchor, cursor), "forward");
      }
    } else if (e.keyCode === 8 && props2.reverseFillMask !== true && start === end) {
      moveCursor.left(inp, start);
      inp.setSelectionRange(inp.selectionStart, end, "backward");
    } else if (e.keyCode === 46 && props2.reverseFillMask === true && start === end) {
      moveCursor.rightReverse(inp, end);
      inp.setSelectionRange(start, inp.selectionEnd, "forward");
    }
  }
  function maskValue(val) {
    if (val === void 0 || val === null || val === "") {
      return "";
    }
    if (props2.reverseFillMask === true) {
      return maskValueReverse(val);
    }
    const mask = computedMask;
    let valIndex = 0, output = "";
    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {
      const valChar = val[valIndex], maskDef = mask[maskIndex];
      if (typeof maskDef === "string") {
        output += maskDef;
        valChar === maskDef && valIndex++;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
        valIndex++;
      } else {
        return output;
      }
    }
    return output;
  }
  function maskValueReverse(val) {
    const mask = computedMask, firstTokenIndex = maskMarked.indexOf(MARKER);
    let valIndex = val.length - 1, output = "";
    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {
      const maskDef = mask[maskIndex];
      let valChar = val[valIndex];
      if (typeof maskDef === "string") {
        output = maskDef + output;
        valChar === maskDef && valIndex--;
      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
        do {
          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
          valIndex--;
          valChar = val[valIndex];
        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
      } else {
        return output;
      }
    }
    return output;
  }
  function unmaskValue(val) {
    return typeof val !== "string" || computedUnmask === void 0 ? typeof val === "number" ? computedUnmask("" + val) : val : computedUnmask(val);
  }
  function fillWithMask(val) {
    if (maskReplaced.length - val.length <= 0) {
      return val;
    }
    return props2.reverseFillMask === true && val.length !== 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);
  }
  return {
    innerValue,
    hasMask,
    moveCursorForPaste,
    updateMaskValue,
    onMaskedKeydown,
    onMaskedClick
  };
}
const useFormProps = {
  name: String
};
function useFormInject(formAttrs = {}) {
  return (child, action, className) => {
    child[action](
      h("input", {
        class: "hidden" + (className || ""),
        ...formAttrs.value
      })
    );
  };
}
function useFormInputNameAttr(props2) {
  return computed(() => props2.name || props2.for);
}
function useFileFormDomProps(props2, typeGuard) {
  function getFormDomProps() {
    const model = props2.modelValue;
    try {
      const dt = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
      if (Object(model) === model) {
        ("length" in model ? Array.from(model) : [model]).forEach((file) => {
          dt.items.add(file);
        });
      }
      return {
        files: dt.files
      };
    } catch (e) {
      return {
        files: void 0
      };
    }
  }
  return computed(() => {
    if (props2.type !== "file") {
      return;
    }
    return getFormDomProps();
  });
}
const isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
const isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
const isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
const isPlainText = /[a-z0-9_ -]$/i;
function useKeyComposition(onInput) {
  return function onComposition(e) {
    if (e.type === "compositionend" || e.type === "change") {
      if (e.target.qComposing !== true) {
        return;
      }
      e.target.qComposing = false;
      onInput(e);
    } else if (e.type === "compositionupdate" && e.target.qComposing !== true && typeof e.data === "string") {
      const isComposing = client.is.firefox === true ? isPlainText.test(e.data) === false : isJapanese.test(e.data) === true || isChinese.test(e.data) === true || isKorean.test(e.data) === true;
      if (isComposing === true) {
        e.target.qComposing = true;
      }
    }
  };
}
const QInput = createComponent({
  name: "QInput",
  inheritAttrs: false,
  props: {
    ...useFieldProps,
    ...useMaskProps,
    ...useFormProps,
    modelValue: { required: false },
    shadowText: String,
    type: {
      type: String,
      default: "text"
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  emits: [
    ...useFieldEmits,
    "paste",
    "change",
    "keydown",
    "click",
    "animationend"
  ],
  setup(props2, { emit: emit2, attrs }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const temp = {};
    let emitCachedValue = NaN, typedNumber, stopValueWatcher, emitTimer = null, emitValueFn;
    const inputRef = ref(null);
    const nameProp = useFormInputNameAttr(props2);
    const {
      innerValue,
      hasMask,
      moveCursorForPaste,
      updateMaskValue,
      onMaskedKeydown,
      onMaskedClick
    } = useMask(props2, emit2, emitValue, inputRef);
    const formDomProps = useFileFormDomProps(props2);
    const hasValue = computed(() => fieldValueIsFilled(innerValue.value));
    const onComposition = useKeyComposition(onInput);
    const state = useFieldState();
    const isTextarea = computed(
      () => props2.type === "textarea" || props2.autogrow === true
    );
    const isTypeText = computed(
      () => isTextarea.value === true || ["text", "search", "url", "tel", "password"].includes(props2.type)
    );
    const onEvents = computed(() => {
      const evt = {
        ...state.splitAttrs.listeners.value,
        onInput,
        onPaste,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        onChange,
        onBlur: onFinishEditing,
        onFocus: stop
      };
      evt.onCompositionstart = evt.onCompositionupdate = evt.onCompositionend = onComposition;
      if (hasMask.value === true) {
        evt.onKeydown = onMaskedKeydown;
        evt.onClick = onMaskedClick;
      }
      if (props2.autogrow === true) {
        evt.onAnimationend = onAnimationend;
      }
      return evt;
    });
    const inputAttrs = computed(() => {
      const attrs2 = {
        tabindex: 0,
        "data-autofocus": props2.autofocus === true || void 0,
        rows: props2.type === "textarea" ? 6 : void 0,
        "aria-label": props2.label,
        name: nameProp.value,
        ...state.splitAttrs.attributes.value,
        id: state.targetUid.value,
        maxlength: props2.maxlength,
        disabled: props2.disable === true,
        readonly: props2.readonly === true
      };
      if (isTextarea.value === false) {
        attrs2.type = props2.type;
      }
      if (props2.autogrow === true) {
        attrs2.rows = 1;
      }
      return attrs2;
    });
    watch(() => props2.type, () => {
      if (inputRef.value) {
        inputRef.value.value = props2.modelValue;
      }
    });
    watch(() => props2.modelValue, (v) => {
      if (hasMask.value === true) {
        if (stopValueWatcher === true) {
          stopValueWatcher = false;
          if (String(v) === emitCachedValue) {
            return;
          }
        }
        updateMaskValue(v);
      } else if (innerValue.value !== v) {
        innerValue.value = v;
        if (props2.type === "number" && temp.hasOwnProperty("value") === true) {
          if (typedNumber === true) {
            typedNumber = false;
          } else {
            delete temp.value;
          }
        }
      }
      props2.autogrow === true && nextTick(adjustHeight);
    });
    watch(() => props2.autogrow, (val) => {
      if (val === true) {
        nextTick(adjustHeight);
      } else if (inputRef.value !== null && attrs.rows > 0) {
        inputRef.value.style.height = "auto";
      }
    });
    watch(() => props2.dense, () => {
      props2.autogrow === true && nextTick(adjustHeight);
    });
    function focus() {
      addFocusFn(() => {
        const el = document.activeElement;
        if (inputRef.value !== null && inputRef.value !== el && (el === null || el.id !== state.targetUid.value)) {
          inputRef.value.focus({ preventScroll: true });
        }
      });
    }
    function select() {
      inputRef.value !== null && inputRef.value.select();
    }
    function onPaste(e) {
      if (hasMask.value === true && props2.reverseFillMask !== true) {
        const inp = e.target;
        moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }
      emit2("paste", e);
    }
    function onInput(e) {
      if (!e || !e.target) {
        return;
      }
      if (props2.type === "file") {
        emit2("update:modelValue", e.target.files);
        return;
      }
      const val = e.target.value;
      if (e.target.qComposing === true) {
        temp.value = val;
        return;
      }
      if (hasMask.value === true) {
        updateMaskValue(val, false, e.inputType);
      } else {
        emitValue(val);
        if (isTypeText.value === true && e.target === document.activeElement) {
          const { selectionStart, selectionEnd } = e.target;
          if (selectionStart !== void 0 && selectionEnd !== void 0) {
            nextTick(() => {
              if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                e.target.setSelectionRange(selectionStart, selectionEnd);
              }
            });
          }
        }
      }
      props2.autogrow === true && adjustHeight();
    }
    function onAnimationend(e) {
      emit2("animationend", e);
      adjustHeight();
    }
    function emitValue(val, stopWatcher) {
      emitValueFn = () => {
        emitTimer = null;
        if (props2.type !== "number" && temp.hasOwnProperty("value") === true) {
          delete temp.value;
        }
        if (props2.modelValue !== val && emitCachedValue !== val) {
          emitCachedValue = val;
          stopWatcher === true && (stopValueWatcher = true);
          emit2("update:modelValue", val);
          nextTick(() => {
            emitCachedValue === val && (emitCachedValue = NaN);
          });
        }
        emitValueFn = void 0;
      };
      if (props2.type === "number") {
        typedNumber = true;
        temp.value = val;
      }
      if (props2.debounce !== void 0) {
        emitTimer !== null && clearTimeout(emitTimer);
        temp.value = val;
        emitTimer = setTimeout(emitValueFn, props2.debounce);
      } else {
        emitValueFn();
      }
    }
    function adjustHeight() {
      requestAnimationFrame(() => {
        const inp = inputRef.value;
        if (inp !== null) {
          const parentStyle = inp.parentNode.style;
          const { scrollTop } = inp;
          const { overflowY, maxHeight } = $q.platform.is.firefox === true ? {} : window.getComputedStyle(inp);
          const changeOverflow = overflowY !== void 0 && overflowY !== "scroll";
          changeOverflow === true && (inp.style.overflowY = "hidden");
          parentStyle.marginBottom = inp.scrollHeight - 1 + "px";
          inp.style.height = "1px";
          inp.style.height = inp.scrollHeight + "px";
          changeOverflow === true && (inp.style.overflowY = parseInt(maxHeight, 10) < inp.scrollHeight ? "auto" : "hidden");
          parentStyle.marginBottom = "";
          inp.scrollTop = scrollTop;
        }
      });
    }
    function onChange(e) {
      onComposition(e);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      emit2("change", e.target.value);
    }
    function onFinishEditing(e) {
      e !== void 0 && stop(e);
      if (emitTimer !== null) {
        clearTimeout(emitTimer);
        emitTimer = null;
      }
      emitValueFn !== void 0 && emitValueFn();
      typedNumber = false;
      stopValueWatcher = false;
      delete temp.value;
      props2.type !== "file" && setTimeout(() => {
        if (inputRef.value !== null) {
          inputRef.value.value = innerValue.value !== void 0 ? innerValue.value : "";
        }
      });
    }
    function getCurValue() {
      return temp.hasOwnProperty("value") === true ? temp.value : innerValue.value !== void 0 ? innerValue.value : "";
    }
    onBeforeUnmount(() => {
      onFinishEditing();
    });
    onMounted(() => {
      props2.autogrow === true && adjustHeight();
    });
    Object.assign(state, {
      innerValue,
      fieldClass: computed(
        () => `q-${isTextarea.value === true ? "textarea" : "input"}` + (props2.autogrow === true ? " q-textarea--autogrow" : "")
      ),
      hasShadow: computed(
        () => props2.type !== "file" && typeof props2.shadowText === "string" && props2.shadowText.length !== 0
      ),
      inputRef,
      emitValue,
      hasValue,
      floatingLabel: computed(
        () => hasValue.value === true && (props2.type !== "number" || isNaN(innerValue.value) === false) || fieldValueIsFilled(props2.displayValue)
      ),
      getControl: () => {
        return h(isTextarea.value === true ? "textarea" : "input", {
          ref: inputRef,
          class: [
            "q-field__native q-placeholder",
            props2.inputClass
          ],
          style: props2.inputStyle,
          ...inputAttrs.value,
          ...onEvents.value,
          ...props2.type !== "file" ? { value: getCurValue() } : formDomProps.value
        });
      },
      getShadowControl: () => {
        return h("div", {
          class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (isTextarea.value === true ? "" : " text-no-wrap")
        }, [
          h("span", { class: "invisible" }, getCurValue()),
          h("span", props2.shadowText)
        ]);
      }
    });
    const renderFn = useField(state);
    Object.assign(proxy, {
      focus,
      select,
      getNativeElement: () => inputRef.value
      // deprecated
    });
    injectProp(proxy, "nativeEl", () => inputRef.value);
    return renderFn;
  }
});
function useRefocusTarget(props2, rootRef) {
  const refocusRef = ref(null);
  const refocusTargetEl = computed(() => {
    if (props2.disable === true) {
      return null;
    }
    return h("span", {
      ref: refocusRef,
      class: "no-outline",
      tabindex: -1
    });
  });
  function refocusTarget(e) {
    const root = rootRef.value;
    if (e !== void 0 && e.type.indexOf("key") === 0) {
      if (root !== null && document.activeElement !== root && root.contains(document.activeElement) === true) {
        root.focus();
      }
    } else if (refocusRef.value !== null && (e === void 0 || root !== null && root.contains(e.target) === true)) {
      refocusRef.value.focus();
    }
  }
  return {
    refocusTargetEl,
    refocusTarget
  };
}
const optionSizes = {
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
};
const svg = h("svg", {
  key: "svg",
  class: "q-radio__bg absolute non-selectable",
  viewBox: "0 0 24 24"
}, [
  h("path", {
    d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12"
  }),
  h("path", {
    class: "q-radio__check",
    d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6"
  })
]);
const QRadio = createComponent({
  name: "QRadio",
  props: {
    ...useDarkProps,
    ...useSizeProps,
    ...useFormProps,
    modelValue: { required: true },
    val: { required: true },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  emits: ["update:modelValue"],
  setup(props2, { slots, emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const isDark = useDark(props2, proxy.$q);
    const sizeStyle = useSize(props2, optionSizes);
    const rootRef = ref(null);
    const { refocusTargetEl, refocusTarget } = useRefocusTarget(props2, rootRef);
    const isTrue = computed(() => toRaw(props2.modelValue) === toRaw(props2.val));
    const classes = computed(
      () => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (props2.disable === true ? " disabled" : "") + (isDark.value === true ? " q-radio--dark" : "") + (props2.dense === true ? " q-radio--dense" : "") + (props2.leftLabel === true ? " reverse" : "")
    );
    const innerClass = computed(() => {
      const color = props2.color !== void 0 && (props2.keepColor === true || isTrue.value === true) ? ` text-${props2.color}` : "";
      return `q-radio__inner relative-position q-radio__inner--${isTrue.value === true ? "truthy" : "falsy"}${color}`;
    });
    const icon = computed(
      () => (isTrue.value === true ? props2.checkedIcon : props2.uncheckedIcon) || null
    );
    const tabindex = computed(() => props2.disable === true ? -1 : props2.tabindex || 0);
    const formAttrs = computed(() => {
      const prop = { type: "radio" };
      props2.name !== void 0 && Object.assign(prop, {
        // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
        ".checked": isTrue.value === true,
        "^checked": isTrue.value === true ? "checked" : void 0,
        name: props2.name,
        value: props2.val
      });
      return prop;
    });
    const injectFormInput = useFormInject(formAttrs);
    function onClick(e) {
      if (e !== void 0) {
        stopAndPrevent(e);
        refocusTarget(e);
      }
      if (props2.disable !== true && isTrue.value !== true) {
        emit2("update:modelValue", props2.val, e);
      }
    }
    function onKeydown2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        stopAndPrevent(e);
      }
    }
    function onKeyup2(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        onClick(e);
      }
    }
    Object.assign(proxy, { set: onClick });
    return () => {
      const content = icon.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-radio__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon, {
            class: "q-radio__icon",
            name: icon.value
          })
        ])
      ] : [svg];
      props2.disable !== true && injectFormInput(
        content,
        "unshift",
        " q-radio__native q-ma-none q-pa-none"
      );
      const child = [
        h("div", {
          class: innerClass.value,
          style: sizeStyle.value,
          "aria-hidden": "true"
        }, content)
      ];
      if (refocusTargetEl.value !== null) {
        child.push(refocusTargetEl.value);
      }
      const label = props2.label !== void 0 ? hMergeSlot(slots.default, [props2.label]) : hSlot(slots.default);
      label !== void 0 && child.push(
        h("div", {
          class: "q-radio__label q-anchor--skip"
        }, label)
      );
      return h("div", {
        ref: rootRef,
        class: classes.value,
        tabindex: tabindex.value,
        role: "radio",
        "aria-label": props2.label,
        "aria-checked": isTrue.value === true ? "true" : "false",
        "aria-disabled": props2.disable === true ? "true" : void 0,
        onClick,
        onKeydown: onKeydown2,
        onKeyup: onKeyup2
      }, child);
    };
  }
});
const useCheckboxProps = {
  ...useDarkProps,
  ...useSizeProps,
  ...useFormProps,
  modelValue: {
    required: true,
    default: null
  },
  val: {},
  trueValue: { default: true },
  falseValue: { default: false },
  indeterminateValue: { default: null },
  checkedIcon: String,
  uncheckedIcon: String,
  indeterminateIcon: String,
  toggleOrder: {
    type: String,
    validator: (v) => v === "tf" || v === "ft"
  },
  toggleIndeterminate: Boolean,
  label: String,
  leftLabel: Boolean,
  color: String,
  keepColor: Boolean,
  dense: Boolean,
  disable: Boolean,
  tabindex: [String, Number]
};
const useCheckboxEmits = ["update:modelValue"];
function useCheckbox(type, getInner) {
  const { props: props2, slots, emit: emit2, proxy } = getCurrentInstance();
  const { $q } = proxy;
  const isDark = useDark(props2, $q);
  const rootRef = ref(null);
  const { refocusTargetEl, refocusTarget } = useRefocusTarget(props2, rootRef);
  const sizeStyle = useSize(props2, optionSizes);
  const modelIsArray = computed(
    () => props2.val !== void 0 && Array.isArray(props2.modelValue)
  );
  const index2 = computed(() => {
    const val = toRaw(props2.val);
    return modelIsArray.value === true ? props2.modelValue.findIndex((opt) => toRaw(opt) === val) : -1;
  });
  const isTrue = computed(() => modelIsArray.value === true ? index2.value > -1 : toRaw(props2.modelValue) === toRaw(props2.trueValue));
  const isFalse = computed(() => modelIsArray.value === true ? index2.value === -1 : toRaw(props2.modelValue) === toRaw(props2.falseValue));
  const isIndeterminate = computed(
    () => isTrue.value === false && isFalse.value === false
  );
  const tabindex = computed(() => props2.disable === true ? -1 : props2.tabindex || 0);
  const classes = computed(
    () => `q-${type} cursor-pointer no-outline row inline no-wrap items-center` + (props2.disable === true ? " disabled" : "") + (isDark.value === true ? ` q-${type}--dark` : "") + (props2.dense === true ? ` q-${type}--dense` : "") + (props2.leftLabel === true ? " reverse" : "")
  );
  const innerClass = computed(() => {
    const state = isTrue.value === true ? "truthy" : isFalse.value === true ? "falsy" : "indet";
    const color = props2.color !== void 0 && (props2.keepColor === true || (type === "toggle" ? isTrue.value === true : isFalse.value !== true)) ? ` text-${props2.color}` : "";
    return `q-${type}__inner relative-position non-selectable q-${type}__inner--${state}${color}`;
  });
  const formAttrs = computed(() => {
    const prop = { type: "checkbox" };
    props2.name !== void 0 && Object.assign(prop, {
      // see https://vuejs.org/guide/extras/render-function.html#creating-vnodes (.prop)
      ".checked": isTrue.value,
      "^checked": isTrue.value === true ? "checked" : void 0,
      name: props2.name,
      value: modelIsArray.value === true ? props2.val : props2.trueValue
    });
    return prop;
  });
  const injectFormInput = useFormInject(formAttrs);
  const attributes = computed(() => {
    const attrs = {
      tabindex: tabindex.value,
      role: type === "toggle" ? "switch" : "checkbox",
      "aria-label": props2.label,
      "aria-checked": isIndeterminate.value === true ? "mixed" : isTrue.value === true ? "true" : "false"
    };
    if (props2.disable === true) {
      attrs["aria-disabled"] = "true";
    }
    return attrs;
  });
  function onClick(e) {
    if (e !== void 0) {
      stopAndPrevent(e);
      refocusTarget(e);
    }
    if (props2.disable !== true) {
      emit2("update:modelValue", getNextValue(), e);
    }
  }
  function getNextValue() {
    if (modelIsArray.value === true) {
      if (isTrue.value === true) {
        const val = props2.modelValue.slice();
        val.splice(index2.value, 1);
        return val;
      }
      return props2.modelValue.concat([props2.val]);
    }
    if (isTrue.value === true) {
      if (props2.toggleOrder !== "ft" || props2.toggleIndeterminate === false) {
        return props2.falseValue;
      }
    } else if (isFalse.value === true) {
      if (props2.toggleOrder === "ft" || props2.toggleIndeterminate === false) {
        return props2.trueValue;
      }
    } else {
      return props2.toggleOrder !== "ft" ? props2.trueValue : props2.falseValue;
    }
    return props2.indeterminateValue;
  }
  function onKeydown2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      stopAndPrevent(e);
    }
  }
  function onKeyup2(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      onClick(e);
    }
  }
  const getInnerContent = getInner(isTrue, isIndeterminate);
  Object.assign(proxy, { toggle: onClick });
  return () => {
    const inner = getInnerContent();
    props2.disable !== true && injectFormInput(
      inner,
      "unshift",
      ` q-${type}__native absolute q-ma-none q-pa-none`
    );
    const child = [
      h("div", {
        class: innerClass.value,
        style: sizeStyle.value,
        "aria-hidden": "true"
      }, inner)
    ];
    if (refocusTargetEl.value !== null) {
      child.push(refocusTargetEl.value);
    }
    const label = props2.label !== void 0 ? hMergeSlot(slots.default, [props2.label]) : hSlot(slots.default);
    label !== void 0 && child.push(
      h("div", {
        class: `q-${type}__label q-anchor--skip`
      }, label)
    );
    return h("div", {
      ref: rootRef,
      class: classes.value,
      ...attributes.value,
      onClick,
      onKeydown: onKeydown2,
      onKeyup: onKeyup2
    }, child);
  };
}
const bgNode = h("div", {
  key: "svg",
  class: "q-checkbox__bg absolute"
}, [
  h("svg", {
    class: "q-checkbox__svg fit absolute-full",
    viewBox: "0 0 24 24"
  }, [
    h("path", {
      class: "q-checkbox__truthy",
      fill: "none",
      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
    }),
    h("path", {
      class: "q-checkbox__indet",
      d: "M4,14H20V10H4"
    })
  ])
]);
const QCheckbox = createComponent({
  name: "QCheckbox",
  props: useCheckboxProps,
  emits: useCheckboxEmits,
  setup(props2) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props2.checkedIcon : isIndeterminate.value === true ? props2.indeterminateIcon : props2.uncheckedIcon) || null
      );
      return () => icon.value !== null ? [
        h("div", {
          key: "icon",
          class: "q-checkbox__icon-container absolute-full flex flex-center no-wrap"
        }, [
          h(QIcon, {
            class: "q-checkbox__icon",
            name: icon.value
          })
        ])
      ] : [bgNode];
    }
    return useCheckbox("checkbox", getInner);
  }
});
const QToggle = createComponent({
  name: "QToggle",
  props: {
    ...useCheckboxProps,
    icon: String,
    iconColor: String
  },
  emits: useCheckboxEmits,
  setup(props2) {
    function getInner(isTrue, isIndeterminate) {
      const icon = computed(
        () => (isTrue.value === true ? props2.checkedIcon : isIndeterminate.value === true ? props2.indeterminateIcon : props2.uncheckedIcon) || props2.icon
      );
      const color = computed(() => isTrue.value === true ? props2.iconColor : null);
      return () => [
        h("div", { class: "q-toggle__track" }),
        h(
          "div",
          {
            class: "q-toggle__thumb absolute flex flex-center no-wrap"
          },
          icon.value !== void 0 ? [
            h(QIcon, {
              name: icon.value,
              color: color.value
            })
          ] : void 0
        )
      ];
    }
    return useCheckbox("toggle", getInner);
  }
});
const components = {
  radio: QRadio,
  checkbox: QCheckbox,
  toggle: QToggle
};
const typeValues = Object.keys(components);
const QOptionGroup = createComponent({
  name: "QOptionGroup",
  props: {
    ...useDarkProps,
    modelValue: {
      required: true
    },
    options: {
      type: Array,
      validator: (opts) => opts.every((opt) => "value" in opt && "label" in opt)
    },
    name: String,
    type: {
      default: "radio",
      validator: (v) => typeValues.includes(v)
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  emits: ["update:modelValue"],
  setup(props2, { emit: emit2, slots }) {
    const { proxy: { $q } } = getCurrentInstance();
    const arrayModel = Array.isArray(props2.modelValue);
    if (props2.type === "radio") {
      if (arrayModel === true) {
        console.error("q-option-group: model should not be array");
      }
    } else if (arrayModel === false) {
      console.error("q-option-group: model should be array in your case");
    }
    const isDark = useDark(props2, $q);
    const component = computed(() => components[props2.type]);
    const classes = computed(
      () => "q-option-group q-gutter-x-sm" + (props2.inline === true ? " q-option-group--inline" : "")
    );
    const attrs = computed(() => {
      const attrs2 = { role: "group" };
      if (props2.type === "radio") {
        attrs2.role = "radiogroup";
        if (props2.disable === true) {
          attrs2["aria-disabled"] = "true";
        }
      }
      return attrs2;
    });
    function onUpdateModelValue(value) {
      emit2("update:modelValue", value);
    }
    return () => h("div", {
      class: classes.value,
      ...attrs.value
    }, props2.options.map((opt, i) => {
      const child = slots["label-" + i] !== void 0 ? () => slots["label-" + i](opt) : slots.label !== void 0 ? () => slots.label(opt) : void 0;
      return h("div", [
        h(component.value, {
          modelValue: props2.modelValue,
          val: opt.value,
          name: opt.name === void 0 ? props2.name : opt.name,
          disable: props2.disable || opt.disable,
          label: child === void 0 ? opt.label : null,
          leftLabel: opt.leftLabel === void 0 ? props2.leftLabel : opt.leftLabel,
          color: opt.color === void 0 ? props2.color : opt.color,
          checkedIcon: opt.checkedIcon,
          uncheckedIcon: opt.uncheckedIcon,
          dark: opt.dark || isDark.value,
          size: opt.size === void 0 ? props2.size : opt.size,
          dense: props2.dense,
          keepColor: opt.keepColor === void 0 ? props2.keepColor : opt.keepColor,
          "onUpdate:modelValue": onUpdateModelValue
        }, child)
      ]);
    }));
  }
});
const DialogPlugin = createComponent({
  name: "DialogPlugin",
  props: {
    ...useDarkProps,
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: "ok",
      validator: (v) => ["ok", "cancel", "none"].includes(v)
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  emits: ["ok", "hide"],
  setup(props2, { emit: emit2 }) {
    const { proxy } = getCurrentInstance();
    const { $q } = proxy;
    const isDark = useDark(props2, $q);
    const dialogRef = ref(null);
    const model = ref(
      props2.prompt !== void 0 ? props2.prompt.model : props2.options !== void 0 ? props2.options.model : void 0
    );
    const classes = computed(
      () => "q-dialog-plugin" + (isDark.value === true ? " q-dialog-plugin--dark q-dark" : "") + (props2.progress !== false ? " q-dialog-plugin--progress" : "")
    );
    const vmColor = computed(
      () => props2.color || (isDark.value === true ? "amber" : "primary")
    );
    const spinner = computed(() => props2.progress === false ? null : isObject$2(props2.progress) === true ? {
      component: props2.progress.spinner || QSpinner,
      props: { color: props2.progress.color || vmColor.value }
    } : {
      component: QSpinner,
      props: { color: vmColor.value }
    });
    const hasForm = computed(
      () => props2.prompt !== void 0 || props2.options !== void 0
    );
    const formProps = computed(() => {
      if (hasForm.value !== true) {
        return {};
      }
      const { model: model2, isValid, items, ...formProps2 } = props2.prompt !== void 0 ? props2.prompt : props2.options;
      return formProps2;
    });
    const okLabel = computed(() => isObject$2(props2.ok) === true ? $q.lang.label.ok : props2.ok === true ? $q.lang.label.ok : props2.ok);
    const cancelLabel = computed(() => isObject$2(props2.cancel) === true ? $q.lang.label.cancel : props2.cancel === true ? $q.lang.label.cancel : props2.cancel);
    const okDisabled = computed(() => {
      if (props2.prompt !== void 0) {
        return props2.prompt.isValid !== void 0 && props2.prompt.isValid(model.value) !== true;
      }
      if (props2.options !== void 0) {
        return props2.options.isValid !== void 0 && props2.options.isValid(model.value) !== true;
      }
      return false;
    });
    const okProps = computed(() => ({
      color: vmColor.value,
      label: okLabel.value,
      ripple: false,
      disable: okDisabled.value,
      ...isObject$2(props2.ok) === true ? props2.ok : { flat: true },
      "data-autofocus": props2.focus === "ok" && hasForm.value !== true || void 0,
      onClick: onOk
    }));
    const cancelProps = computed(() => ({
      color: vmColor.value,
      label: cancelLabel.value,
      ripple: false,
      ...isObject$2(props2.cancel) === true ? props2.cancel : { flat: true },
      "data-autofocus": props2.focus === "cancel" && hasForm.value !== true || void 0,
      onClick: onCancel
    }));
    watch(() => props2.prompt && props2.prompt.model, onUpdateModel);
    watch(() => props2.options && props2.options.model, onUpdateModel);
    function show() {
      dialogRef.value.show();
    }
    function hide() {
      dialogRef.value.hide();
    }
    function onOk() {
      emit2("ok", toRaw(model.value));
      hide();
    }
    function onCancel() {
      hide();
    }
    function onDialogHide() {
      emit2("hide");
    }
    function onUpdateModel(val) {
      model.value = val;
    }
    function onInputKeyup(evt) {
      if (okDisabled.value !== true && props2.prompt.type !== "textarea" && isKeyCode(evt, 13) === true) {
        onOk();
      }
    }
    function getSection(classes2, text) {
      return props2.html === true ? h(QCardSection, {
        class: classes2,
        innerHTML: text
      }) : h(QCardSection, { class: classes2 }, () => text);
    }
    function getPrompt() {
      return [
        h(QInput, {
          color: vmColor.value,
          dense: true,
          autofocus: true,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel,
          onKeyup: onInputKeyup
        })
      ];
    }
    function getOptions() {
      return [
        h(QOptionGroup, {
          color: vmColor.value,
          options: props2.options.items,
          dark: isDark.value,
          ...formProps.value,
          modelValue: model.value,
          "onUpdate:modelValue": onUpdateModel
        })
      ];
    }
    function getButtons() {
      const child = [];
      props2.cancel && child.push(
        h(QBtn, cancelProps.value)
      );
      props2.ok && child.push(
        h(QBtn, okProps.value)
      );
      return h(QCardActions, {
        class: props2.stackButtons === true ? "items-end" : "",
        vertical: props2.stackButtons,
        align: "right"
      }, () => child);
    }
    function getCardContent() {
      const child = [];
      props2.title && child.push(
        getSection("q-dialog__title", props2.title)
      );
      props2.progress !== false && child.push(
        h(
          QCardSection,
          { class: "q-dialog__progress" },
          () => h(spinner.value.component, spinner.value.props)
        )
      );
      props2.message && child.push(
        getSection("q-dialog__message", props2.message)
      );
      if (props2.prompt !== void 0) {
        child.push(
          h(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getPrompt
          )
        );
      } else if (props2.options !== void 0) {
        child.push(
          h(QSeparator, { dark: isDark.value }),
          h(
            QCardSection,
            { class: "scroll q-dialog-plugin__form" },
            getOptions
          ),
          h(QSeparator, { dark: isDark.value })
        );
      }
      if (props2.ok || props2.cancel) {
        child.push(getButtons());
      }
      return child;
    }
    function getContent() {
      return [
        h(QCard, {
          class: [
            classes.value,
            props2.cardClass
          ],
          style: props2.cardStyle,
          dark: isDark.value
        }, getCardContent)
      ];
    }
    Object.assign(proxy, { show, hide });
    return () => h(QDialog, {
      ref: dialogRef,
      onHide: onDialogHide
    }, getContent);
  }
});
function merge(target2, source) {
  for (const key in source) {
    if (key !== "spinner" && Object(source[key]) === source[key]) {
      target2[key] = Object(target2[key]) !== target2[key] ? {} : { ...target2[key] };
      merge(target2[key], source[key]);
    } else {
      target2[key] = source[key];
    }
  }
}
function globalDialog(DefaultComponent, supportsCustomComponent, parentApp) {
  return (pluginProps) => {
    let DialogComponent, props2;
    const isCustom = pluginProps.component !== void 0;
    if (isCustom === true) {
      const { component, componentProps } = pluginProps;
      DialogComponent = typeof component === "string" ? parentApp.component(component) : component;
      props2 = componentProps || {};
    } else {
      const { class: klass, style: style2, ...otherProps } = pluginProps;
      DialogComponent = DefaultComponent;
      props2 = otherProps;
      klass !== void 0 && (otherProps.cardClass = klass);
      style2 !== void 0 && (otherProps.cardStyle = style2);
    }
    let vm2, emittedOK = false;
    const dialogRef = ref(null);
    const el = createGlobalNode(false, "dialog");
    const applyState = (cmd) => {
      if (dialogRef.value !== null && dialogRef.value[cmd] !== void 0) {
        dialogRef.value[cmd]();
        return;
      }
      const target2 = vm2.$.subTree;
      if (target2 && target2.component) {
        if (target2.component.proxy && target2.component.proxy[cmd]) {
          target2.component.proxy[cmd]();
          return;
        }
        if (target2.component.subTree && target2.component.subTree.component && target2.component.subTree.component.proxy && target2.component.subTree.component.proxy[cmd]) {
          target2.component.subTree.component.proxy[cmd]();
          return;
        }
      }
      console.error("[Quasar] Incorrectly defined Dialog component");
    };
    const okFns = [], cancelFns = [], API = {
      onOk(fn) {
        okFns.push(fn);
        return API;
      },
      onCancel(fn) {
        cancelFns.push(fn);
        return API;
      },
      onDismiss(fn) {
        okFns.push(fn);
        cancelFns.push(fn);
        return API;
      },
      hide() {
        applyState("hide");
        return API;
      },
      update(componentProps) {
        if (vm2 !== null) {
          if (isCustom === true) {
            Object.assign(props2, componentProps);
          } else {
            const { class: klass, style: style2, ...cfg } = componentProps;
            klass !== void 0 && (cfg.cardClass = klass);
            style2 !== void 0 && (cfg.cardStyle = style2);
            merge(props2, cfg);
          }
          vm2.$forceUpdate();
        }
        return API;
      }
    };
    const onOk = (data) => {
      emittedOK = true;
      okFns.forEach((fn) => {
        fn(data);
      });
    };
    const onHide = () => {
      app2.unmount(el);
      removeGlobalNode(el);
      app2 = null;
      vm2 = null;
      if (emittedOK !== true) {
        cancelFns.forEach((fn) => {
          fn();
        });
      }
    };
    let app2 = createChildApp({
      name: "QGlobalDialog",
      setup: () => () => h(DialogComponent, {
        ...props2,
        ref: dialogRef,
        onOk,
        onHide,
        onVnodeMounted(...args) {
          if (typeof props2.onVnodeMounted === "function") {
            props2.onVnodeMounted(...args);
          }
          nextTick(() => applyState("show"));
        }
      })
    }, parentApp);
    vm2 = app2.mount(el);
    return API;
  };
}
const Dialog = {
  install({ $q, parentApp }) {
    $q.dialog = globalDialog(DialogPlugin, true, parentApp);
    if (this.__installed !== true) {
      this.create = $q.dialog;
    }
  }
};
const ExporterQueue = {
  initialize(maxConcurrentRequests) {
    this.maxConcurrentRequests = maxConcurrentRequests;
    this.pendingRequests = [];
    this.runningRequests = [];
    this.exportService = api.getService("import-export");
    this.exportService.on("export-created", (params) => this.onRequestCreated(params));
    this.exportService.on("export-completed", (params) => this.onRequestCompleted(params));
    logger$1.debug(`[KDK] Initialized 'Exporter' with '${maxConcurrentRequests}' maxConcurrentRequests`);
  },
  push(request) {
    this.pendingRequests.push(request);
    return this.triggerRequest();
  },
  triggerRequest() {
    if (this.runningRequests.length >= this.maxConcurrentRequests) return false;
    if (this.pendingRequests.length === 0) return true;
    const request = this.pendingRequests.shift();
    try {
      let filename = request.filename;
      if (!filename) {
        const timestamp = moment().toISOString().replace(/:/g, "-");
        filename = `${_$1.get(request, "basename", request.service)}_${timestamp}.${request.format}`;
      }
      let servicePath = api.getServicePath(request.service);
      if (servicePath.startsWith("/")) servicePath = servicePath.substring(1);
      const transform = _$1.get(request, "transform." + request.format);
      const options = Object.assign(
        _$1.omit(request, ["title", "service", "context", "formats"]),
        { method: "export", filename, servicePath, transform }
      );
      logger$1.debug(`[KDK] request export with options ${JSON.stringify(options, null, 2)}`);
      this.exportService.create(options);
    } catch (error) {
      Events.emit("error", { message: i18n.t("errors.NETWORK_ERROR") });
    }
    return true;
  },
  onRequestCreated(params) {
    logger$1.debug(`[KDK] export request ${params.uuid} created`);
    const request = {
      uuid: params.uuid,
      notification: Notify.create({
        icon: "las la-hourglass-half",
        message: i18n.t("exporter.EXPORTING"),
        color: "primary",
        timeout: 0,
        spinner: true
      })
    };
    this.runningRequests.push(request);
  },
  onRequestCompleted(params) {
    logger$1.debug(`[KDK] export request ${params.uuid} completed`);
    const request = _$1.head(_$1.remove(this.runningRequests, { uuid: params.uuid }));
    if (!request) {
      logger$1.warn(`[KDK] export request ${params.uuid} not found`);
      return;
    }
    request.notification();
    if (params.SignedUrl) {
      let iframe = document.getElementById("export-hidden-frame");
      if (!iframe) {
        iframe = document.createElement("iframe");
        iframe.id = "export-hidden-frame";
        iframe.style.display = "none";
        document.body.appendChild(iframe);
      }
      iframe.src = params.SignedUrl;
      Notify.create({
        type: "positive",
        message: i18n.t("exporter.SUCCEEDED", { filename: params.filename }),
        html: true
      });
    } else if (params.chunks === 0) {
      Notify.create({
        type: "warning",
        message: i18n.t("exporter.NO_DATA")
      });
    } else Notify.create({
      type: "negative",
      message: i18n.t("exporter.ERRORED")
    });
    this.triggerRequest();
  }
};
const Exporter = {
  initialize(options) {
    ExporterQueue.initialize(_$1.get(options, "maxConcurrentRequests", 3));
  },
  export(options) {
    if (!options.service) {
      logger$1.error("[KDK] invalid options: missing 'service' property");
      return;
    }
    const params = _$1.cloneDeep(options);
    if (options.formats.length > 1) {
      const dialog2 = {
        title: i18n.t(options.title ? options.title : "exporter.TITLE"),
        message: i18n.t("exporter.MESSAGE"),
        options: {
          type: "radio",
          model: options.formats[0].label,
          items: options.formats.map((format) => {
            return { label: format.label, value: format.label };
          })
        },
        cancel: {
          id: "cancel-button",
          label: i18n.t("CANCEL"),
          color: "primary",
          outline: true
        },
        ok: {
          id: "export-button",
          label: i18n.t("exporter.EXPORT"),
          color: "primary"
        },
        persistent: true
      };
      Dialog.create(dialog2).onOk((formatLabel) => {
        const format = _$1.find(options.formats, { label: formatLabel });
        if (!ExporterQueue.push(Object.assign(params, format))) {
          Notify.create({
            type: "negative",
            message: i18n.t("exporter.EXPORTS_LIMIT_REACHED")
          });
        }
      });
    } else {
      if (!ExporterQueue.push(Object.assign(params, options.formats[0]))) {
        Notify.create({
          type: "negative",
          message: i18n.t("exporter.EXPORTS_LIMIT_REACHED")
        });
      }
    }
  }
};
let app, vm, uid = 0, timeout = null, props = {}, activeGroups = {};
const originalDefaults = {
  group: "__default_quasar_group__",
  delay: 0,
  message: false,
  html: false,
  spinnerSize: 80,
  spinnerColor: "",
  messageColor: "",
  backgroundColor: "",
  boxClass: "",
  spinner: QSpinner,
  customClass: ""
};
const defaults = { ...originalDefaults };
function registerProps(opts) {
  if (opts && opts.group !== void 0 && activeGroups[opts.group] !== void 0) {
    return Object.assign(activeGroups[opts.group], opts);
  }
  const newProps = isObject$2(opts) === true && opts.ignoreDefaults === true ? { ...originalDefaults, ...opts } : { ...defaults, ...opts };
  activeGroups[newProps.group] = newProps;
  return newProps;
}
const Plugin$1 = defineReactivePlugin({
  isActive: false
}, {
  show(opts) {
    props = registerProps(opts);
    const { group } = props;
    Plugin$1.isActive = true;
    if (app !== void 0) {
      props.uid = uid;
      vm.$forceUpdate();
    } else {
      props.uid = ++uid;
      timeout !== null && clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const el = createGlobalNode("q-loading");
        app = createChildApp({
          name: "QLoading",
          setup() {
            onMounted(() => {
              preventScroll(true);
            });
            function onAfterLeave() {
              if (Plugin$1.isActive !== true && app !== void 0) {
                preventScroll(false);
                app.unmount(el);
                removeGlobalNode(el);
                app = void 0;
                vm = void 0;
              }
            }
            function getContent() {
              if (Plugin$1.isActive !== true) {
                return null;
              }
              const content = [
                h(props.spinner, {
                  class: "q-loading__spinner",
                  color: props.spinnerColor,
                  size: props.spinnerSize
                })
              ];
              props.message && content.push(
                h("div", {
                  class: "q-loading__message" + (props.messageColor ? ` text-${props.messageColor}` : ""),
                  [props.html === true ? "innerHTML" : "textContent"]: props.message
                })
              );
              return h("div", {
                class: "q-loading fullscreen flex flex-center z-max " + props.customClass.trim(),
                key: props.uid
              }, [
                h("div", {
                  class: "q-loading__backdrop" + (props.backgroundColor ? ` bg-${props.backgroundColor}` : "")
                }),
                h("div", {
                  class: "q-loading__box column items-center " + props.boxClass
                }, content)
              ]);
            }
            return () => h(Transition, {
              name: "q-transition--fade",
              appear: true,
              onAfterLeave
            }, getContent);
          }
        }, Plugin$1.__parentApp);
        vm = app.mount(el);
      }, props.delay);
    }
    return (paramProps) => {
      if (paramProps === void 0 || Object(paramProps) !== paramProps) {
        Plugin$1.hide(group);
        return;
      }
      Plugin$1.show({ ...paramProps, group });
    };
  },
  hide(group) {
    if (Plugin$1.isActive === true) {
      if (group === void 0) {
        activeGroups = {};
      } else if (activeGroups[group] === void 0) {
        return;
      } else {
        delete activeGroups[group];
        const keys = Object.keys(activeGroups);
        if (keys.length !== 0) {
          const lastGroup = keys[keys.length - 1];
          Plugin$1.show({ group: lastGroup });
          return;
        }
      }
      if (timeout !== null) {
        clearTimeout(timeout);
        timeout = null;
      }
      Plugin$1.isActive = false;
    }
  },
  setDefaults(opts) {
    {
      isObject$2(opts) === true && Object.assign(defaults, opts);
    }
  },
  install({ $q, parentApp }) {
    $q.loading = this;
    {
      Plugin$1.__parentApp = parentApp;
      if ($q.config.loading !== void 0) {
        this.setDefaults($q.config.loading);
      }
    }
  }
});
const Reader = {
  readers: {},
  register(mimeTypes, reader) {
    if (!_$1.isArray(mimeTypes)) mimeTypes = [mimeTypes];
    _$1.forEach(mimeTypes, (mimeType) => {
      this.readers[mimeType] = reader;
      reader.mimeType = mimeType;
    });
  },
  filter(filelist) {
    const acceptedFiles = [];
    const additionnalFiles = [];
    for (let i = 0; i < filelist.length; ++i) {
      const file = filelist[i];
      const fileExt = path.extname(file.name).toLowerCase();
      let reader = this.readers[fileExt];
      if (reader) {
        acceptedFiles.push({ reader: fileExt, name: file.name, files: [file] });
      } else {
        reader = _$1.find(this.readers, (reader2) => reader2.getAdditionalFiles().includes(fileExt));
        if (reader) {
          additionnalFiles.push({ reader: reader.mimeType, file });
        } else {
          const error = { message: i18n.t("errors.UNSUPPORTED_FILE_FORMAT", { file: file.name }) };
          Events.emit("error", error);
        }
      }
    }
    _$1.forEach(additionnalFiles, (additionnalFile) => {
      const group = _$1.find(acceptedFiles, (acceptedFile) => acceptedFile.reader === additionnalFile.reader);
      if (group) group.files.push(additionnalFile.file);
      else {
        const error = { message: i18n.t("errors.UNSUPPORTED_FILE_FORMAT", { file: additionnalFile.name }) };
        Events.emit("error", error);
      }
    });
    return acceptedFiles;
  },
  async read(file, options) {
    const reader = this.readers[file.reader];
    Plugin$1.show({ message: i18n.t("reader.READING_FILE", { file: file.name }), html: true });
    try {
      const content = await reader.read(file.files, options);
      Plugin$1.hide();
      return content;
    } catch (error) {
      Plugin$1.hide();
      Events.emit("error", error);
    }
  },
  getSupportedFormats() {
    return Object.keys(this.readers);
  }
};
function LocalSettingsService(name, api2, options) {
  const mapping = options.propertyMapping;
  const rootPaths = _$1.uniq(_$1.values(mapping).map((path2) => path2.split(".")[0]));
  const settingsKey = options.settingsKey || "settings";
  return {
    async get(id) {
      const data = {};
      _$1.forOwn(mapping, (value, key) => {
        if (value) {
          _$1.set(data, key, Store.get(value));
        }
      });
      return data;
    },
    async patch(id, data) {
      const previousRootValues = rootPaths.map((rootPath) => Store.get(rootPath));
      _$1.forOwn(data, (value, key) => {
        if (_$1.get(mapping, key)) {
          Store.set(mapping[key], value);
        }
      });
      rootPaths.forEach((rootPath, index2) => {
        const eventName = _$1.kebabCase(`${rootPath}-changed`);
        Events.emit(eventName, Store.get(rootPath), previousRootValues[index2]);
      });
      this.saveSettings();
    },
    saveSettings() {
      const data = {};
      _$1.forOwn(mapping, (value, key) => {
        if (value && Store.has(value)) {
          _$1.set(data, key, Store.get(value));
        }
      });
      LocalStorage.set(settingsKey, data);
    },
    restoreSettings() {
      let settings = LocalStorage.get(settingsKey);
      if (!settings) return;
      if (_$1.get(settings, "utc") && _$1.has(mapping, "timezone") && !_$1.get(settings, "timezone")) {
        _$1.set(settings, "timezone", "UTC");
      }
      _$1.forOwn(mapping, (value, key) => {
        if (value && _$1.has(settings, key)) {
          Store.set(value, _$1.get(settings, key));
        }
      });
    },
    getSchema() {
      return options.settingsSchema;
    },
    getSettingsMapping() {
      return mapping;
    }
  };
}
function init$1() {
  const api2 = this;
  api2.createService("users");
  api2.createService("authorisations");
  api2.createService("import-export");
  api2.createService("account", { methods: ["create", "verifyEmail"] });
  const propertyMapping = _$1.get(config, "settings.propertyMapping", {
    shortTime: "time.format.time.short",
    longTime: "time.format.time.long",
    shortDate: "time.format.date.short",
    longDate: "time.format.date.long",
    shortYear: "time.format.year.short",
    longYear: "time.format.year.long",
    timezone: "time.format.timezone",
    timelineStep: "time.step",
    timelineInterval: "time.interval",
    timeseriesSpan: "timeseries.span",
    timeseriesGroupBy: "timeseries.groupBy",
    location: "locationFormat",
    navigator: "navigator",
    restoreView: "restore.view",
    restoreLayers: "restore.layers",
    defaultLength: "units.default.length",
    defaultAltitude: "units.default.altitude",
    defaultArea: "units.default.area",
    defaultVelocity: "units.default.velocity",
    defaultTemperature: "units.default.temperature",
    defaultAngle: "units.default.angle",
    defaultEquivalentDoseRate: "units.default.equivalentDoseRate",
    defaultNotation: "units.default.notation",
    defaultPrecision: "units.default.precision"
  });
  const settingsSchema = _$1.get(config, "settings.schema", "settings.update");
  api2.createService("settings", {
    service: LocalSettingsService,
    propertyMapping,
    settingsSchema
  });
}
function clean(link) {
  setTimeout(() => {
    window.URL.revokeObjectURL(link.href);
  }, 1e4);
  link.remove();
}
function exportFile(fileName, rawData, opts = {}) {
  const { mimeType, byteOrderMark, encoding } = typeof opts === "string" ? { mimeType: opts } : opts;
  const data = encoding !== void 0 ? new TextEncoder(encoding).encode([rawData]) : rawData;
  const blobData = byteOrderMark !== void 0 ? [byteOrderMark, data] : [data];
  const blob = new Blob(blobData, { type: mimeType || "application/octet-stream" });
  const link = document.createElement("a");
  link.href = window.URL.createObjectURL(blob);
  link.setAttribute("download", fileName);
  if (typeof link.download === "undefined") {
    link.setAttribute("target", "_blank");
  }
  link.classList.add("hidden");
  link.style.position = "fixed";
  document.body.appendChild(link);
  try {
    link.click();
    clean(link);
    return true;
  } catch (err) {
    clean(link);
    return err;
  }
}
async function verifyEmail(email) {
  const response = await api.getService("account").verifyEmail({ email });
  return response.status === 200;
}
function resendVerifySignup(email) {
  return api.getService("account").create({
    action: "resendVerifySignup",
    value: { email }
  });
}
function verifySignup(token, email) {
  return api.getService("account").create({
    action: "verifySignupShort",
    value: { user: { email }, token }
  });
}
function sendResetPassword(email) {
  return api.getService("account").create({
    action: "sendResetPwd",
    value: { email }
  });
}
function resetPassword(email, token, password) {
  return api.getService("account").create({
    action: "resetPwdShort",
    value: { user: { email }, token, password }
  });
}
function changePassword(email, oldPassword, password) {
  return api.getService("account").create({
    action: "passwordChange",
    value: { user: { email }, oldPassword, password }
  });
}
function sendChangeIdentity(oldEmail, email, password) {
  return api.getService("account").create({
    action: "identityChange",
    value: { user: { email: oldEmail }, changes: { email }, password }
  });
}
function changeIdentity(token) {
  return verifySignup(token);
}
const actionProps = {
  id: {
    type: String,
    required: true
  },
  label: {
    type: String,
    default: null
  },
  icon: {
    type: String,
    default: void 0
  },
  iconRight: {
    type: Boolean,
    default: false
  },
  color: {
    type: String,
    default: "grey-9"
  },
  size: {
    type: String,
    default: "md"
  },
  flat: {
    type: Boolean,
    default: true
  },
  outline: {
    type: Boolean,
    default: false
  },
  badge: {
    type: Object,
    default: () => null
  },
  tooltip: {
    type: String,
    default: ""
  },
  disabled: {
    type: [Boolean, Function],
    default: false
  },
  toggled: {
    type: Boolean,
    default: false
  },
  toggle: {
    type: Object,
    default: () => {
    }
  },
  stack: {
    type: Boolean,
    default: false
  },
  loading: {
    type: Boolean,
    default: false
  },
  propagate: {
    type: Boolean,
    default: true
  },
  context: {
    type: Object,
    default: () => null
  },
  handler: {
    type: Function,
    default: null
  },
  closePopup: {
    type: [Boolean, Number, String],
    default: false
  },
  dialog: {
    type: Object,
    default: null
  },
  route: {
    type: Object,
    default: () => null
  },
  url: {
    type: String,
    default: null
  },
  renderer: {
    type: String,
    default: "button",
    validator: (value) => {
      return ["button", "form-button", "item", "fab", "fab-action", "tab"].includes(value);
    }
  }
};
function getCollectionService(name, context2) {
  return api.getService(name, context2);
}
async function listItems(service2, fields, filter = {}, limit = 50) {
  return service2.find({ query: _$1.merge({}, filter, { $limit: limit, $select: fields }) });
}
async function getOldestItem(service2, field = "createdAt", filter = {}) {
  const response = await service2.find({ query: _$1.merge({}, filter, { $sort: { [field]: 1 }, $limit: 1 }) });
  return _$1.get(response, "data[0]");
}
async function getOldestTime(service2, field = "createdAt", filter = {}) {
  const oldestItem = await getOldestItem(service2, field, filter);
  return _$1.get(oldestItem, field);
}
async function getLatestItem(service2, field = "createdAt", filter = {}) {
  const response = await service2.find({ query: _$1.merge({}, filter, { $sort: { [field]: -1 }, $limit: 1 }) });
  return _$1.get(response, "data[0]");
}
async function getLatestTime(service2, field = "createdAt", filter = {}) {
  const latestItem = await getLatestItem(service2, field, filter);
  return _$1.get(latestItem, field);
}
async function getDistinctValues(service2, field, filter = {}) {
  const query = _$1.merge({}, filter, { $distinct: field });
  const values = await service2.find({ query });
  if (Array.isArray(values)) return values;
  return [values];
}
async function searchText(service2, text, caseSensitive = false, diacriticSensitive = false) {
  const query = {
    $text: {
      $search: text,
      $caseSensitive: caseSensitive,
      $diacriticSensitive: diacriticSensitive
    }
  };
  return service2.find({ query });
}
async function containsText(service2, field, text, caseSensitive = false, diacriticSensitive = false) {
  const response = await searchText(service2, text, caseSensitive, diacriticSensitive);
  for (const item of response.data) {
    const value = _$1.get(item, field);
    if (value) {
      if (_$1.size(text) === _$1.size(value)) {
        let target2 = text;
        let other = value;
        if (!diacriticSensitive) {
          target2 = _$1.deburr(target2);
          other = _$1.deburr(other);
        }
        if (!caseSensitive) {
          target2 = _$1.toUpper(target2);
          other = _$1.toUpper(other);
        }
        if (target2 === other) return true;
      }
    }
  }
  return false;
}
const HtmlColors = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
};
const Colors = {
  white: "#fff",
  dark: "#333",
  red: "#f44336",
  pink: "#e91e63",
  purple: "#9c27b0",
  "deep-purple": "#673ab7",
  indigo: "#3f51b5",
  blue: "#2196f3",
  "light-blue": "#03a9f4",
  cyan: "#00bcd4",
  teal: "#009688",
  green: "#4caf50",
  "light-green": "#8bc34a",
  lime: "#cddc39",
  yellow: "#ffeb3b",
  amber: "#ffc107",
  orange: "#ff9800",
  "deep-orange": "#ff5722",
  brown: "#795548",
  grey: "#9e9e9e",
  "blue-grey": "#607d8b"
};
function getHtmlColor(color, defaultColor2) {
  if (!color) return defaultColor2;
  if (color.startsWith("#")) return color;
  if (color.startsWith("hsl")) return color;
  if (color.startsWith("rgb")) return color;
  if (_$1.has(HtmlColors, color)) return HtmlColors[color];
  return colors.getPaletteColor(color);
}
function getColorFromPalette(color) {
  if (color.startsWith("#")) return color;
  else return Colors[color] || "#ffffff";
}
function getPaletteFromColor(color, nearestIfNotFound = false) {
  if (Colors[color]) return color;
  const colorName = _$1.findKey(Colors, (item) => item === color);
  if (colorName) return colorName;
  if (nearestIfNotFound) return findClosestColor(color) || "white";
  return "white";
}
function findClosestColor(color) {
  let minDistance = Number.MAX_VALUE;
  let closestColor = null;
  for (const key in Colors) {
    const d = chroma.deltaE(color, Colors[key]);
    if (d < minDistance) {
      minDistance = d;
      closestColor = key;
    }
  }
  return closestColor;
}
function getContrastColor(color, light = "white", dark = "black") {
  const htmlColor = getHtmlColor(color);
  return colors.luminosity(htmlColor) < 0.5 ? light : dark;
}
function buildColorScale(options) {
  if (!options) {
    logger$1.warn(`[KDK] buildColorScale: 'options' argument must be defined`);
    return;
  }
  let colors2 = options.colors;
  if (!colors2) {
    if (options.scale) {
      logger$1.warn(`[KDK] buildColorScale: please update 'scale' property to 'colors'`);
      colors2 = options.scale;
    } else {
      logger$1.warn(`[KDK] buildColorScale: no colors defined, using default default colors 'Spectral'`);
      colors2 = "Spectral";
    }
  }
  let scale2 = chroma.scale(colors2);
  if (options.classes) {
    if (Array.isArray(options.classes)) {
      scale2 = scale2.classes(options.classes);
    } else {
      if (options.domain) scale2 = scale2.domain(options.domain).classes(options.classes);
      else scale2 = scale2.classes(options.classes);
    }
  } else {
    if (options.domain) scale2 = scale2.domain(options.domain);
  }
  return scale2;
}
function getFileName(filePath) {
  return path.basename(filePath);
}
function getExtension(filePath) {
  return path.extname(filePath);
}
function getBaseName(filePath) {
  return path.basename(filePath, getExtension(filePath));
}
function getDir(filePath) {
  return path.dirname(filePath);
}
const CardSectionProps = {
  title: {
    type: String,
    default: ""
  },
  item: {
    type: Object,
    default: () => null
  },
  actions: {
    type: Array,
    default: () => null
  },
  actionsFilter: {
    type: [String, Array],
    default: () => null
  },
  hideSeparator: {
    type: Boolean,
    default: false
  },
  hideHeader: {
    type: Boolean,
    default: false
  },
  dense: {
    type: Boolean,
    default: false
  }
};
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function easeOut(t, linearity = 0.5) {
  return 1 - Math.pow(1 - t, 1 / linearity);
}
function linear(t, initial = 0, final = 1) {
  return initial + t * final;
}
function cubicBezier(t, x1 = 0.42, y1 = 0, x2 = 0.58, y2 = 1) {
  return (1 - t) * (1 - t) * (1 - t) * y1 + 3 * (1 - t) * (1 - t) * t * x1 + 3 * (1 - t) * t * t * x2 + t * t * t * y2;
}
const maths = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clamp,
  cubicBezier,
  easeOut,
  linear
}, Symbol.toStringTag, { value: "Module" }));
class PermissionDeniedNotifications extends FeathersError {
  constructor(message, data) {
    super(message, "PermissionDeniedNotifications", 499, "permission-denied-notifications", data);
  }
}
class NotificationsNotSupported extends FeathersError {
  constructor(message, data) {
    super(message, "NotificationsNotSupported", 498, "notifications-not-supported", data);
  }
}
async function checkPrerequisites() {
  if (!("PushManager" in window)) throw new NotificationsNotSupported("Push isn't supported on this browser");
  if (!("Notification" in window)) throw new NotificationsNotSupported("This browser does not support notifications");
  return true;
}
async function requestNotificationPermission() {
  if (window.Notification.permission === "default") {
    try {
      return await window.Notification.requestPermission();
    } catch (err) {
      throw new PermissionDeniedNotifications("Denied permission to send notifications");
    }
  } else if (window.Notification.permission === "denied") throw new PermissionDeniedNotifications("Denied permission to send notifications");
}
async function getPushSubscription() {
  const registration = await navigator.serviceWorker.ready;
  return await registration.pushManager.getSubscription();
}
async function subscribePushNotifications(publicVapidKey) {
  const registration = await navigator.serviceWorker.getRegistration();
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: publicVapidKey
  });
  return JSON.parse(JSON.stringify(subscription));
}
async function addSubscription(subscription, currentSubscription, subscriptionProperty) {
  if (_$1.has(subscription, subscriptionProperty)) {
    if (_$1.find(_$1.get(subscription, subscriptionProperty), (subscription2) => subscription2.endpoint === currentSubscription.endpoint)) {
      return _$1.get(subscription, subscriptionProperty);
    } else {
      return _$1.get(subscription, subscriptionProperty).push(currentSubscription);
    }
  } else {
    return _$1.set(subscription, subscriptionProperty, [currentSubscription]);
  }
}
async function subscribeToPushNotifications() {
  const mode = _$1.get(Platform.getData("application"), "mode");
  if (mode !== "PWA") {
    logger$1.error("[KDK] Cannot subscribe to push notification: the application must run in PWA mode");
    return;
  }
  try {
    await checkPrerequisites();
    await requestNotificationPermission();
  } catch (error) {
    Notify.create({ type: "negative", message: i18n.t(`errors.${error.code}`) });
    return;
  }
  const userService = api.service("api/users");
  const date = moment.utc().toISOString();
  const currentSubscription = await getPushSubscription();
  const user = Store.get("user");
  if (!user) {
    logger$1.error(`[KDK] User must be authenticated before calling 'subscribeToPushNotifications'`);
  }
  if (currentSubscription && _$1.find(_$1.get(user, "subscriptions", []), (subscription2) => subscription2.endpoint === currentSubscription.endpoint)) {
    const subscriptions = _$1.map(user.subscriptions, (subscription2) => {
      if (subscription2.endpoint === currentSubscription.endpoint) subscription2.lastActivity = date;
      return subscription2;
    });
    userService.patch(user._id, { subscriptions });
    logger$1.debug(`[KDK] New connection with subscription endpoint: ${currentSubscription.endpoint}`);
    return;
  }
  const subscription = await subscribePushNotifications(Store.get("capabilities.api.vapidPublicKey"));
  subscription.fingerprint = Platform.fingerprint;
  subscription.browser = _$1.pick(Platform.getData("browser"), ["name", "version"]);
  subscription.system = _$1.pick(Platform.getData("system"), ["os"]);
  subscription.lastActivity = date;
  await addSubscription(user, subscription, "subscriptions");
  userService.patch(user._id, { subscriptions: user.subscriptions });
  logger$1.debug(`[KDK] New webpush subscription registered with endpoint: ${subscription.endpoint}`);
}
let InstallPwaPrompt = null;
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  InstallPwaPrompt = e;
});
function installDefaultPrompt() {
  Dialog.create({
    title: i18n.t("utils.pwa.INSTALL_TITLE"),
    message: i18n.t("utils.pwa.INSTALL_MESSAGE"),
    cancel: {
      id: "ignore-button",
      label: i18n.t("utils.pwa.IGNORE"),
      color: "primary",
      outline: true
    },
    ok: {
      id: "install-button",
      label: i18n.t("utils.pwa.INSTALL"),
      color: "primary"
    },
    persistent: true,
    position: "bottom",
    html: true
  }).onOk(async () => {
    InstallPwaPrompt.prompt();
    const { outcome } = await InstallPwaPrompt.userChoice;
    if (outcome === "accepted") location.reload();
  });
}
function installSafariPrompt() {
  Dialog.create({
    title: i18n.t("utils.pwa.INSTALL_TITLE"),
    message: i18n.t("utils.pwa.IOS_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: true,
    position: "bottom",
    html: true
  });
}
function installFFDesktopPrompt() {
  Dialog.create({
    title: i18n.t("utils.pwa.INSTALL_TITLE"),
    message: i18n.t("utils.pwa.FIREFOX_DESKTOP_INSTALL_MESSAGE"),
    ok: {
      color: "primary"
    },
    persistent: true,
    position: "bottom",
    html: true
  });
}
const prefixes = {};
function assignFn(fn) {
  Object.assign(Plugin, {
    request: fn,
    exit: fn,
    toggle: fn
  });
}
function getFullscreenElement() {
  return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null;
}
function updateEl() {
  const newEl = Plugin.activeEl = Plugin.isActive === false ? null : getFullscreenElement();
  changeGlobalNodesTarget(
    newEl === null || newEl === document.documentElement ? document.body : newEl
  );
}
function togglePluginState() {
  Plugin.isActive = Plugin.isActive === false;
  updateEl();
}
function promisify(target2, fn) {
  try {
    const res = target2[fn]();
    return res === void 0 ? Promise.resolve() : res;
  } catch (err) {
    return Promise.reject(err);
  }
}
const Plugin = defineReactivePlugin({
  isActive: false,
  activeEl: null
}, {
  isCapable: false,
  install({ $q }) {
    $q.fullscreen = this;
  }
});
{
  prefixes.request = [
    "requestFullscreen",
    "msRequestFullscreen",
    "mozRequestFullScreen",
    "webkitRequestFullscreen"
  ].find((request) => document.documentElement[request] !== void 0);
  Plugin.isCapable = prefixes.request !== void 0;
  if (Plugin.isCapable === false) {
    assignFn(() => Promise.reject("Not capable"));
  } else {
    Object.assign(Plugin, {
      request(target2) {
        const el = target2 || document.documentElement;
        const { activeEl } = Plugin;
        if (el === activeEl) {
          return Promise.resolve();
        }
        const queue2 = activeEl !== null && el.contains(activeEl) === true ? Plugin.exit() : Promise.resolve();
        return queue2.finally(() => promisify(el, prefixes.request));
      },
      exit() {
        return Plugin.isActive === true ? promisify(document, prefixes.exit) : Promise.resolve();
      },
      toggle(target2) {
        return Plugin.isActive === true ? Plugin.exit() : Plugin.request(target2);
      }
    });
    prefixes.exit = [
      "exitFullscreen",
      "msExitFullscreen",
      "mozCancelFullScreen",
      "webkitExitFullscreen"
    ].find((exit) => document[exit]);
    Plugin.isActive = Boolean(getFullscreenElement());
    Plugin.isActive === true && updateEl();
    [
      "onfullscreenchange",
      "onmsfullscreenchange",
      "onwebkitfullscreenchange"
    ].forEach((evt) => {
      document[evt] = togglePluginState;
    });
  }
}
const Fullscreen = toRef(Plugin, "isActive");
function computeResponsiveWidth(width) {
  if (_$1.isNumber(width)) {
    if (width > 100) return width;
    return Screen.width * width / 100;
  }
  if (!_$1.isObject(width)) {
    logger$1.warn(`[KDK] Invalid width parameter ${width}`);
    return void 0;
  }
  let breakpointWidth = _$1.get(width, Screen.name);
  if (!breakpointWidth) {
    logger$1.warn(`[KDK] Cannot find width value for breakpoint ${Screen.name}`);
    return void 0;
  }
  if (!_$1.isNumber(breakpointWidth)) {
    logger$1.warn(`[KDK] Invalid width value ${breakpointWidth} for breakpoint ${Screen.name}`);
    return void 0;
  }
  return computeResponsiveWidth(breakpointWidth);
}
function computeResponsiveHeight(height) {
  if (_$1.isNumber(height)) {
    if (height > 100) return height;
    return Screen.height * height / 100;
  }
  if (!_$1.isObject(height)) {
    logger$1.warn(`[KDK] Invalid height parameter ${height}`);
    return void 0;
  }
  let breakpointHeight = _$1.get(height, Screen.name);
  if (!breakpointHeight) {
    logger$1.warn(`[KDK] Cannot find height value for breakpoint ${Screen.name}`);
    return void 0;
  }
  if (!_$1.isNumber(breakpointHeight)) {
    logger$1.warn(`[KDK] Invalid height value ${breakpointHeight} for breakpoint ${Screen.name}`);
    return void 0;
  }
  return computeResponsiveHeight(breakpointHeight);
}
function computeResponsiveSize(size) {
  if (_$1.isArray(size)) {
    if (size.length === 2) {
      logger$1.warn(`[KDK] Invalid size parameter ${size}`);
      return void 0;
    }
    return size;
  }
  if (!_$1.isObject(size)) {
    logger$1.warn(`[KDK] Invalid size parameter ${size}`);
    return void 0;
  }
  let breakpointSize = _$1.get(size, Screen.name);
  return [computeResponsiveWidth(breakpointSize[0]), computeResponsiveHeight(breakpointSize[1])];
}
function getOrientation() {
  return Screen.width > Screen.height ? "portrait" : "landscape";
}
async function toggleFullscreen() {
  return new Promise((resolve, reject) => {
    Plugin.toggle().then(() => {
      resolve(true);
    }).catch((err) => {
      logger$1.warn(`[KDK] Cannot toggle fullscreen mode: ${err}`);
      reject(false);
    });
  });
}
async function lockOrientation(orientation) {
  if (screen.orientation && screen.orientation.lock && typeof screen.orientation.lock === "function") await screen.orientation.lock(orientation);
}
function listenToServiceEvents(service2, {
  context: context2 = null,
  created = null,
  updated = null,
  patched = null,
  removed = null,
  all = null
} = {}, listeners) {
  unlistenToServiceEvents(listeners);
  if (typeof service2 === "string") service2 = api.getService(service2, context2);
  const generateListenerForEvent = (listener, event) => listener ? (object) => listener(object, event) : null;
  if (service2) {
    if (created || all) {
      created = generateListenerForEvent(created || all, "created");
      service2.on("created", created);
    }
    if (updated || all) {
      updated = generateListenerForEvent(updated || all, "updated");
      service2.on("updated", updated);
    }
    if (patched || all) {
      patched = generateListenerForEvent(patched || all, "patched");
      service2.on("patched", patched);
    }
    if (removed || all) {
      removed = generateListenerForEvent(removed || all, "removed");
      service2.on("removed", removed);
    }
  }
  return { service: service2, created, updated, patched, removed };
}
function unlistenToServiceEvents(listeners) {
  if (!listeners) return;
  const { service: service2, created, updated, patched, removed } = listeners;
  if (created) service2.off("created", created);
  if (updated) service2.off("updated", updated);
  if (patched) service2.off("patched", patched);
  if (removed) service2.off("removed", removed);
}
const defaultSize = { width: 24, height: 24 };
const defaultColor = "black";
const defaultIconSize = 12;
const defaultTextSize = 12;
function defaultRadiusToSize(r) {
  return { width: r * 2, height: r * 2 };
}
const Shapes = {
  circle: {
    viewBox: [0, 0, 100, 100],
    content: '<circle cx="50" cy="50" r="50" />'
  },
  rect: {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 0.9), height: Math.round(r * 2 * 0.9) };
    }
  },
  "rounded-rect": {
    viewBox: [0, 0, 100, 100],
    content: '<rect cx="0" cy="0" width="100" height="100" rx="20" ry="20" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 0.9), height: Math.round(r * 2 * 0.9) };
    }
  },
  diamond: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 50, 50 100, 0 50" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.2), height: Math.round(r * 2 * 1.2) };
    }
  },
  triangle: {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="50 0, 100 100, 0 100" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.125), height: Math.round(r * 2 * 1.025) };
    }
  },
  "triangle-down": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 0, 50 100" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.125), height: Math.round(r * 2 * 1.025) };
    }
  },
  "triangle-left": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 50, 100 0, 100 100" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.025), height: Math.round(r * 2 * 1.125) };
    }
  },
  "triangle-right": {
    viewBox: [0, 0, 100, 100],
    content: '<polygon points="0 0, 100 50, 0 100" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.025), height: Math.round(r * 2 * 1.125) };
    }
  },
  star: {
    viewBox: [0, 0, 48, 48],
    content: '<path d="m24,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z" />',
    radiusToSize: (r) => {
      return { width: Math.round(r * 2 * 1.4), height: Math.round(r * 2 * 1.4) };
    }
  },
  "marker-pin": {
    viewBox: [0, 0, 384, 512],
    content: '<path d="M384 192c0 87.4-117 243-168.3 307.2c-12.3 15.3-35.1 15.3-47.4 0C117 435 0 279.4 0 192C0 86 86 0 192 0s192 86 192 192z" />',
    icon: {
      translation: ["-50%", "-70%"]
    },
    text: {
      translation: ["-50%", "-70%"]
    },
    anchor: "bottom-center"
  },
  "square-pin": {
    viewBox: [0, 0, 56, 56],
    content: '<path d="M 27.9532 52.3633 C 29.0079 52.3633 29.9923 51.9180 30.9298 50.3008 L 35.2657 43.0586 L 43.0938 43.0586 C 50.0783 43.0586 53.8280 39.1914 53.8280 32.3242 L 53.8280 14.3711 C 53.8280 7.5039 50.0783 3.6367 43.0938 3.6367 L 12.9064 3.6367 C 5.9454 3.6367 2.1720 7.4805 2.1720 14.3711 L 2.1720 32.3242 C 2.1720 39.2148 5.9454 43.0586 12.9064 43.0586 L 20.6407 43.0586 L 24.9766 50.3008 C 25.9142 51.9180 26.8985 52.3633 27.9532 52.3633 Z"/>',
    icon: {
      translation: ["-50%", "-75%"]
    },
    text: {
      translation: ["-50%", "-60%"]
    },
    anchor: "bottom-center"
  }
};
function addTagAttribute(tag, attribute, value) {
  return tag.slice(0, -1) + ` ${attribute}="${value}">`;
}
function addSvgAttribute(svg2, attribute, value) {
  return svg2.slice(0, -2) + ` ${attribute}="${value}" />`;
}
function getSize(size) {
  if (!Array.isArray(size)) return { width: _$1.toNumber(size), height: _$1.toNumber(size) };
  return { width: _$1.toNumber(size[0]), height: _$1.toNumber(size[1]) };
}
function createShape(options) {
  if (!options) {
    logger$1.warn(`[KDK] 'options' argument is required`);
    return;
  }
  let anchor = "middle-center";
  let shape;
  if (options.shape && options.shape !== "none") {
    if (typeof options.shape === "object") shape = options.shape;
    else {
      shape = Shapes[options.shape];
      if (!shape) {
        logger$1.warn(`[KDK] unknown shape '${options.shape}'. Using default shape 'circle'`);
        shape = Shapes["circle"];
      }
    }
    anchor = shape.anchor || anchor;
  }
  let size = defaultSize;
  if (options.size) {
    size = getSize(options.size);
  } else {
    if (options.radius) {
      const radiusToSize = _$1.get(shape, "radiusToSize", defaultRadiusToSize);
      size = radiusToSize(options.radius);
    }
  }
  const extraStyle = _$1.get(options, "extraStyle", "");
  const idAttr = _$1.get(options, "id") ? `id=${options.id}` : "";
  const beginDivTag = `<div ${idAttr} style="position: relative; width: ${size.width}px; height: ${size.height}px; ${extraStyle}">`;
  const endDivTag = "</div>";
  let beginSvgTag = "";
  let svgShapeContent = "";
  let svgClipPath = "";
  let endSvgTag = "";
  if (shape) {
    const extraShapeStyle = shape.extraStyle || "";
    const translation = shape.translation || [0, 0];
    const rotation = shape.rotation || 0;
    beginSvgTag = `<svg xmlns="http://www.w3.org/2000/svg" width="${size.width}" height="${size.height}" preserveAspectRatio="none"
                   style="transform: translate(${translation[0]},${translation[1]}) rotate(${rotation}deg); ${extraShapeStyle}">`;
    beginSvgTag = addTagAttribute(beginSvgTag, "viewBox", _$1.join(shape.viewBox, " "));
    svgShapeContent = shape.content;
    svgClipPath = "";
    endSvgTag = "</svg>";
    const color = options.color ? getHtmlColor(options.color) : "none";
    svgShapeContent = addSvgAttribute(svgShapeContent, "fill", color);
    if (!_$1.isNil(options.opacity)) svgShapeContent = addSvgAttribute(svgShapeContent, "fill-opacity", options.opacity);
    if (options.stroke) {
      const strokeColor = getHtmlColor(options.stroke.color, defaultColor);
      if (strokeColor !== "transparent") {
        svgShapeContent = addSvgAttribute(svgShapeContent, "stroke", strokeColor);
        const strokeWidth = options.stroke.width || 1;
        svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-width", strokeWidth * 2);
        svgShapeContent = addSvgAttribute(svgShapeContent, "vector-effect", "non-scaling-stroke");
        if (options.stroke.cap) svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-linecap", options.stroke.cap);
        if (options.stroke.join) svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-linejoin", options.stroke.join);
        if (options.stroke.dashArray) svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-dasharray", options.stroke.dashArray);
        if (options.stroke.dashOffset) svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-dashoffset", options.stroke.dashOffset);
        if (_$1.has(options, "stroke.opacity")) svgShapeContent = addSvgAttribute(svgShapeContent, "stroke-opacity", options.stroke.opacity);
        const clipId = uid$2();
        const clipPath = _$1.get(shape, "clipPath", true);
        if (clipPath) {
          svgShapeContent = addSvgAttribute(svgShapeContent, "clip-path", `url(#${clipId})`);
          svgClipPath = `<clipPath id="${clipId}">${_$1.clone(shape.content)}</clipPath>`;
        }
      }
    }
  }
  let iconTag = "";
  if (options.icon) {
    if (!_$1.isNil(options.icon.classes) || !_$1.isNil(options.icon.url)) {
      if (!_$1.isEmpty(options.icon.classes) || !_$1.isEmpty(options.icon.url)) {
        let specificStyle = "";
        if (options.icon.url) {
          let iconSize = options.icon.size ? getSize(options.icon.size) : size;
          iconTag = `<img src="${options.icon.url}" `;
          iconTag += `width=${iconSize.width} height=${iconSize.height} `;
        } else {
          iconTag += `<i class="${options.icon.classes}" `;
          const color = getHtmlColor(options.icon.color, defaultColor);
          specificStyle += `color: ${color};`;
          let iconSize = options.icon.size || defaultIconSize;
          specificStyle += `font-size: ${iconSize}px;`;
        }
        const opacity = options.icon.opacity || 1;
        const translation = options.icon.translation || _$1.get(shape, "icon.translation", ["-50%", "-50%"]);
        const rotation = options.icon.rotation || _$1.get(shape, "icon.rotation", 0);
        iconTag += `style="position: absolute; top: 50%; left: 50%; transform: translate(${translation[0]},${translation[1]}) rotate(${rotation}deg); opacity: ${opacity}; ${specificStyle}"`;
        iconTag += "/>";
      }
    } else {
      logger$1.warn(`[KDK] icon must contain either the 'classes' property or the 'url' property`);
    }
  }
  let textTag = "";
  if (options.text) {
    if (!_$1.isNil(options.text.label)) {
      if (!_$1.isEmpty(options.text.label)) {
        textTag = "<span ";
        if (options.text.classes) textTag += `classes="${options.text.classes}" `;
        const color = getHtmlColor(options.text.color, defaultColor);
        const textSize = options.text.size || defaultTextSize;
        const translation = options.text.translation || _$1.get(shape, "text.translation", ["-50%", "-50%"]);
        const rotation = options.text.rotation || _$1.get(shape, "icon.rotation", 0);
        const extraTextStyle = options.text.extraStyle || "";
        textTag += `style="position: absolute; 5px; top: 50%; left: 50%; transform: translate(${translation[0]},${translation[1]}) rotate(${rotation}deg); color: ${color}; font-size: ${textSize}px; ${extraTextStyle}"`;
        textTag += ">";
        textTag += options.text.label;
        textTag += "</span>";
      }
    } else {
      logger$1.warn(`[KDK] text must contain the 'label' property`);
    }
  }
  let htmlTag = "";
  if (options.html) {
    htmlTag = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">';
    htmlTag += options.html;
    htmlTag += "</div>";
  }
  return {
    html: beginDivTag + beginSvgTag + svgClipPath + svgShapeContent + endSvgTag + iconTag + textTag + htmlTag + endDivTag,
    size,
    anchor
  };
}
async function authenticate(authentication) {
  let user = Store.get("user");
  if (user) return;
  await LocalCache.setItem("authentication", authentication);
  user = authentication.user ? authentication.user : { name: i18n.t("composables.ANONYMOUS"), anonymous: true };
  Store.set("user", user);
  await updateAbilities();
}
async function login(email, password) {
  const payload = {
    strategy: "local",
    email,
    password
  };
  const authentication = await api.authenticate(payload);
  await authenticate(authentication);
}
async function register(user) {
  delete user.confirmPassword;
  await api.getService("users").create(user);
  await login(user.email, user.password);
}
async function logout() {
  try {
    await LocalCache.removeItem("authentication");
    await api.logout();
    Store.set("user", null);
  } catch (error) {
    Store.set("user", null);
    await api.authentication.removeAccessToken();
    throw error;
  }
}
async function restoreSession() {
  try {
    let authentication;
    if (api.isDisconnected) {
      authentication = await LocalCache.getItem("authentication");
      if (authentication) {
        api.emit("login", authentication);
        api.emit("authenticated", authentication);
      }
    }
    if (!authentication) {
      authentication = await api.reAuthenticate();
    }
    await authenticate(authentication);
  } catch (error) {
    await api.authentication.removeAccessToken();
    throw error;
  }
}
async function updateAbilities() {
  const user = Store.get("user");
  if (!user) return;
  const abilities = await defineAbilities(user, api);
  const previousAbilities = Store.get("user.abilities");
  const rules = _$1.get(abilities, "rules");
  const previousRules = _$1.get(previousAbilities, "rules");
  if (!_$1.isEqual(rules, previousRules)) {
    Store.set("user.abilities", abilities);
    makeDebug.debug("[KDK] New user abilities: ", abilities.rules);
  }
}
async function updateUser(user) {
  if (user._id === Store.get("user._id")) {
    Store.patch("user", user);
    await updateAbilities();
  }
}
async function logoutUser(user) {
  await LocalCache.removeItem("authentication");
  await api.authentication.removeAccessToken();
  await api.authentication.reset();
  Store.set("user", null);
  api.emit("logout", user);
}
function subscribeToUserChanges() {
  const users = api.getService("users");
  users.on("patched", updateUser);
  users.on("logout", logoutUser);
}
function unsubscribeToUserChanges() {
  const users = api.getService("users");
  users.off("patched", updateUser);
  users.off("logout", logoutUser);
}
async function getTagsFilterOptions(service2) {
  const tagsService = api.getService("tags");
  if (!tagsService) {
    logger$1.warn("[KDK] Tags service not found");
    return [];
  }
  const tags = (await tagsService.find({ service: service2 })).data;
  for (const tag of tags) {
    tag.label = tag.name;
  }
  return tags;
}
function getTimezoneLabel(timezone) {
  const offset = moment().tz(timezone).format("Z");
  return `${timezone} (${offset})`;
}
function toLocalTimezone(datetime, timezone) {
  return timezone ? moment.tz(datetime, timezone) : moment(datetime).local();
}
function toQuasarDate(date, format) {
  return Time.convertToLocal(date).format(format);
}
function toQuasarTime(time, format) {
  return Time.convertToLocal(time).format(format);
}
function fromQuasarDate(date, format) {
  return Time.getFormatTimezone() ? moment.tz(date, format, Time.getFormatTimezone()) : moment(date, format);
}
function fromQuasarTime(time, format) {
  return Time.getFormatTimezone() ? moment.tz(time, format, Time.getFormatTimezone()) : moment(time, format);
}
Notify.setDefaults({
  position: "bottom-left",
  timeout: 5e3,
  textColor: "white"
});
Plugin$1.setDefaults({
  spinnerColor: "primary",
  spinnerSize: 140,
  messageColor: "white",
  customClass: "full-width"
});
function createQuerablePromise(promiseOrExecutor) {
  let promise = promiseOrExecutor;
  if (typeof promiseOrExecutor === "function") {
    promise = new Promise(promiseOrExecutor);
  }
  if (promise.isResolved) return promise;
  let isPending = true;
  let isRejected = false;
  let isFulfilled = false;
  const result = promise.then(
    (value) => {
      isFulfilled = true;
      isPending = false;
      return value;
    },
    (error) => {
      isRejected = true;
      isPending = false;
      throw error;
    }
  );
  result.isFulfilled = () => {
    return isFulfilled;
  };
  result.isPending = () => {
    return isPending;
  };
  result.isRejected = () => {
    return isRejected;
  };
  return result;
}
function getInitials(name) {
  const initials = name.toUpperCase().match(/\b\w/g) || [];
  return initials.join("");
}
function isEmailValid(email) {
  return emailValidator.validate(email);
}
function createThumbnail(imageDataUri, width, height, quality, callback) {
  const image2 = document.createElement("img");
  image2.onload = function() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(this, 0, 0, width, height);
    callback(canvas.toDataURL("image/jpeg", quality));
  };
  image2.src = imageDataUri;
}
function dataUriToBlob(dataUri) {
  const byteString = atob(dataUri.split(",")[1]);
  const mimeType = dataUri.split(",")[0].split(":")[1].split(";")[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeType });
}
const base64Encode = function(bytes) {
  bytes = new Uint8Array(bytes);
  const CHUNK_SIZE = 32768;
  const array = [];
  for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
    array.push(String.fromCharCode.apply(null, bytes.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(array.join(""));
};
function downloadAsBlob(data, filename, mimeType) {
  const blob = new Blob([data], { type: mimeType });
  exportFile(filename, blob);
}
async function dialog(options) {
  return new Promise((resolve, reject) => {
    Dialog.create(options).onOk((data) => resolve({ ok: true, data })).onCancel(() => resolve({ cancel: true })).onDismiss(() => resolve({ dismiss: true }));
  });
}
function getIconName(object, path2 = "icon.name") {
  const icon = typeof object === "object" ? _$1.get(object, path2, "") : object;
  if (typeof icon === "object") return "";
  return icon.startsWith("fa-") ? `fas ${icon}` : icon;
}
function processIcon(object, path2 = "icon.name") {
  _$1.set(object, path2, getIconName(object, path2));
}
function mapIconFunction(iconName) {
  if (iconName.startsWith("kdk:") === true) {
    const name = iconName.substring(4);
    return { icon: "img:kdk/" + name };
  }
}
function dotify(object) {
  const dotifiedObject = {};
  function recurse(object2, current) {
    _$1.forOwn(object2, (value, key) => {
      const newKey = current ? current + "." + key : key;
      if (value && typeof value === "object") {
        recurse(value, newKey);
      } else {
        dotifiedObject[newKey] = value;
      }
    });
  }
  recurse(object);
  return dotifiedObject;
}
const checkForHexRegExp = /^[0-9a-fA-F]{24}$/;
function isObjectID(id) {
  return id.length === 24 && checkForHexRegExp.test(id);
}
async function loadSchema(schemaName) {
  try {
    const schemaModule = await import(`@schemas/${schemaName}.json`);
    return schemaModule.default;
  } catch (error) {
    logger$1.error(error);
  }
}
function loadComponent(componentName) {
  try {
    return markRaw(defineAsyncComponent(() => import(`@components/${componentName}.vue`)));
  } catch (error) {
    logger$1.error(error);
  }
}
const index$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CardSectionProps,
  Colors,
  Fullscreen,
  get InstallPwaPrompt() {
    return InstallPwaPrompt;
  },
  Shapes,
  actionProps,
  base64Encode,
  bindContent,
  bindHandler,
  bindParams,
  bindProperties,
  buildColorScale,
  changeIdentity,
  changePassword,
  clamp,
  computeResponsiveHeight,
  computeResponsiveSize,
  computeResponsiveWidth,
  containsText,
  createQuerablePromise,
  createShape,
  createThumbnail,
  cubicBezier,
  dataUriToBlob,
  dialog,
  dotify,
  downloadAsBlob,
  easeOut,
  filterContent,
  findClosestColor,
  fromQuasarDate,
  fromQuasarTime,
  generateHandler,
  getBaseName,
  getBoundValue,
  getBrowserLocale,
  getCollectionService,
  getColorFromPalette,
  getContrastColor,
  getDir,
  getDistinctValues,
  getExtension,
  getFallbackLocale,
  getFileName,
  getHtmlColor,
  getIconName,
  getInitials,
  getLatestItem,
  getLatestTime,
  getLocale,
  getOldestItem,
  getOldestTime,
  getOrientation,
  getPaletteFromColor,
  getTagsFilterOptions,
  getTimezoneLabel,
  installDefaultPrompt,
  installFFDesktopPrompt,
  installSafariPrompt,
  isEmailValid,
  isObjectID,
  linear,
  listItems,
  listenToServiceEvents,
  loadComponent,
  loadSchema,
  lockOrientation,
  login,
  logout,
  logoutUser,
  mapIconFunction,
  processIcon,
  register,
  resendVerifySignup,
  resetPassword,
  restoreSession,
  searchText,
  sendChangeIdentity,
  sendResetPassword,
  subscribeToPushNotifications,
  subscribeToUserChanges,
  toLocalTimezone,
  toQuasarDate,
  toQuasarTime,
  toggleFullscreen,
  unlistenToServiceEvents,
  unsubscribeToUserChanges,
  updateAbilities,
  updateUser,
  verifyEmail,
  verifySignup
}, Symbol.toStringTag, { value: "Module" }));
const vDropFile = {
  mounted(el, binding) {
    el.__state = {
      dropCallback: _$1.get(binding.value, "dropCallback"),
      acceptedTypes: _$1.get(binding.value, "mimeTypes"),
      maxFiles: _$1.get(binding.value, "maxFiles"),
      fontSize: _$1.get(binding.value, "fontSize", "2rem"),
      enabled: _$1.get(binding.value, "enabled", true)
    };
    el.style.position = "relative";
    const overlay = document.createElement("div");
    overlay.className = "drag-overlay";
    overlay.innerHTML = `<div class="drag-overlay-box" />`;
    el.appendChild(overlay);
    const style2 = document.createElement("style");
    style2.textContent = `
      .drag-overlay {
        display: none;
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        justify-content: center;
        align-items: center;
        font-size: ${el.__state.fontSize};
        z-index: 9999;
        pointer-events: none;
      }
      .drag-overlay-box {
        display: flex;
        border: 3px dashed;
        width: 95%; height: 95%;
        border-radius: 5px;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }
    `;
    document.head.appendChild(style2);
    const showOverlay = () => overlay.style.display = "flex";
    const hideOverlay = () => overlay.style.display = "none";
    let dragCounter = 0;
    let canDrop = false;
    const onDragEnter = (e) => {
      if (!el.__state.enabled) return;
      e.preventDefault();
      const items = e.dataTransfer.items;
      let rejectedItems = [];
      let acceptedItems = [];
      let color, message;
      if (el.__state.maxFiles && _$1.size(items) > el.__state.maxFiles) {
        color = colors.getPaletteColor("negative");
        message = i18n.tc("directives.MAX_FILES_REACHED", el.__state.maxFiles);
      } else {
        for (const item of items) {
          if (item.kind === "file" && _$1.includes(el.__state.acceptedTypes, item.type)) acceptedItems.push(item);
          else rejectedItems.push(item);
        }
        if (_$1.isEmpty(acceptedItems)) {
          color = colors.getPaletteColor("negative");
          message = i18n.tc("directives.ALL_FILES_ARE_UNSUPPORTED", rejectedItems.length);
        } else if (_$1.isEmpty(rejectedItems)) {
          color = colors.getPaletteColor("positive");
          message = i18n.tc("directives.DROP_FILES", acceptedItems.length);
        } else {
          color = colors.getPaletteColor("warning");
          message = i18n.t("directives.SOME_FILES_ARE_UNSUPPORTED");
        }
      }
      canDrop = _$1.size(acceptedItems) > 0;
      overlay.style.background = "#0007";
      const overlayBox = overlay.querySelector(".drag-overlay-box");
      overlayBox.textContent = message;
      overlayBox.style.borderColor = color;
      overlayBox.style.color = "white";
      overlayBox.style.textShadow = "-2px -2px 0 black, 2px -2px 0 black, -2px 2px 0 black, 2px 2px 0 black";
      overlayBox.style.padding = "20px;";
      dragCounter++;
      showOverlay();
    };
    const onDragOver = (e) => {
      e.preventDefault();
    };
    const onDragLeave = (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) hideOverlay();
    };
    const onDrop = async (e) => {
      e.preventDefault();
      dragCounter = 0;
      hideOverlay();
      if (!canDrop) return;
      const files = Array.from(e.dataTransfer.files);
      if (el.__state.dropCallback && typeof el.__state.dropCallback === "function") {
        const acceptedFiles = Reader.filter(files);
        for (const file of acceptedFiles) {
          const content = await Reader.read(file);
          await el.__state.dropCallback(content);
        }
      } else logger$1.warn(`[KDK] Missing 'dropCallback' argument in 'v-drop-file' directive`);
    };
    el.__handlers = { onDragEnter, onDragOver, onDragLeave, onDrop };
    el.addEventListener("dragenter", onDragEnter);
    el.addEventListener("dragover", onDragOver);
    el.addEventListener("dragleave", onDragLeave);
    el.addEventListener("drop", onDrop);
  },
  updated(el, binding) {
    if (binding.value !== binding.oldValue) {
      el.__state = {
        dropCallback: _$1.get(binding.value, "dropCallback"),
        acceptedTypes: _$1.get(binding.value, "mimeTypes"),
        maxFiles: _$1.get(binding.value, "maxFiles"),
        fontSize: _$1.get(binding.value, "fontSize", "2rem"),
        enabled: _$1.get(binding.value, "enabled", true)
      };
    }
  },
  beforeUnmount(el, binding) {
    const { onDragEnter, onDragOver, onDragLeave, onDrop } = el.__handlers;
    el.removeEventListener("dragenter", onDragEnter);
    el.removeEventListener("dragover", onDragOver);
    el.removeEventListener("dragleave", onDragLeave);
    el.removeEventListener("drop", onDrop);
    delete el.__handlers;
    delete el.__state;
  }
};
const vHover = {
  mounted(el, binding) {
    if (Platform.touch) return;
    el.__vHoverEnter__ = binding.value.enter || (() => {
    });
    el.__vHoverOver__ = binding.value.over || (() => {
    });
    el.__vHoverLeave__ = binding.value.leave || (() => {
    });
    el.addEventListener("mouseenter", el.__vHoverEnter__);
    el.addEventListener("mouseover", el.__vHoverOver__);
    el.addEventListener("mouseleave", el.__vHoverLeave__);
  },
  beforeUnmount(el, binding) {
    el.removeEventListener("mouseenter", el.__vHoverEnter__);
    el.removeEventListener("mouseover", el.__vHoverOver__);
    el.removeEventListener("mouseleave", el.__vHoverLeave__);
    delete el.__vHoverEnter__;
    delete el.__vHoverOver__;
    delete el.__vHoverLeave__;
  }
};
const index$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vDropFile,
  vHover
}, Symbol.toStringTag, { value: "Module" }));
function useSelection$1(name, options = {}) {
  const comparator = options.matches || _$1.matches;
  const { store: store2, set: set2, get: get2, has: has2 } = useStore(`selections.${name}`);
  function clearSelection() {
    if (!isSelectionEnabled()) return;
    if (hasSelectedItem()) set2("items", []);
  }
  function getSelectionMode() {
    return get2("mode");
  }
  function setSelectionMode(mode) {
    return set2("mode", mode);
  }
  function isSingleSelectionMode() {
    return get2("mode") === "single";
  }
  function isMultipleSelectionMode() {
    return get2("mode") !== "single";
  }
  function setSelectionEnabled(enabled = true) {
    return set2("enabled", enabled);
  }
  function isSelectionEnabled() {
    return get2("enabled");
  }
  function getSelectionFilter() {
    return get2("filter");
  }
  function setSelectionFilter(filter) {
    return set2("filter", filter);
  }
  function selectItem(item) {
    if (!isSelectionEnabled()) return;
    const filter = getSelectionFilter();
    if (filter && !filter(item)) return;
    const items = get2("items");
    const selected = _$1.find(items, comparator(item));
    if (!selected) set2("items", items.concat([item]));
  }
  function unselectItem(item) {
    if (!isSelectionEnabled()) return;
    const items = get2("items");
    _$1.remove(items, comparator(item));
    set2("items", _$1.clone(items));
  }
  function hasSelectedItem() {
    return has2("items") && get2("items").length > 0;
  }
  function hasSelectedItems() {
    return hasSelectedItem();
  }
  function getSelectedItem() {
    return _$1.last(get2("items"));
  }
  function getSelectedItems() {
    return get2("items");
  }
  if (!has2("items")) {
    set2("items", []);
    set2("mode", "single");
    set2("enabled", true);
  }
  return {
    selection: store2,
    clearSelection,
    getSelectionMode,
    setSelectionMode,
    isSingleSelectionMode,
    isMultipleSelectionMode,
    setSelectionEnabled,
    isSelectionEnabled,
    getSelectionFilter,
    setSelectionFilter,
    selectItem,
    unselectItem,
    hasSelectedItem,
    hasSelectedItems,
    getSelectedItem,
    getSelectedItems
  };
}
const CurrentActivityContext = shallowReactive({
  activity: null,
  name: null,
  state: null,
  config: null
});
const CurrentActivity = shallowRef(null);
const ActivityComposables$1 = {};
function useActivity$1(name, options = {}) {
  _$1.defaults(options, { selection: true });
  CurrentActivityContext.name = name;
  CurrentActivityContext.state = useStore(`store.${name}.state`, options.state).store;
  CurrentActivityContext.config = useStore(`store.${name}.options`, config[name]).store;
  function setCurrentActivity(activity2) {
    if (CurrentActivityContext.activity === activity2) return;
    if (activity2) {
      CurrentActivityContext.activity = activity2;
      CurrentActivity.value = activity2;
      logger$1.debug("[KDK] Current activity set to", activity2);
    } else {
      CurrentActivityContext.activity = null;
      CurrentActivity.value = null;
      logger$1.debug("[KDK] Current activity cleared");
    }
  }
  onBeforeUnmount(() => {
    CurrentActivityContext.name = null;
    CurrentActivityContext.state = null;
    CurrentActivityContext.config = null;
    setCurrentActivity(null);
  });
  const expose = {
    CurrentActivityContext,
    setCurrentActivity
  };
  if (options.selection) {
    Object.assign(expose, {
      ...useSelection$1(name)
    });
  }
  _$1.set(ActivityComposables$1, name, expose);
  return expose;
}
function useCurrentActivity$1(options = {}) {
  _$1.defaults(options, { selection: true });
  const expose = {
    CurrentActivityContext,
    CurrentActivity,
    kActivity: readonly(CurrentActivity),
    kActivityName: readonly(toRef(CurrentActivityContext, "name"))
  };
  if (CurrentActivityContext.name) {
    Object.assign(expose, _$1.get(ActivityComposables$1, CurrentActivityContext.name));
  }
  return expose;
}
function useCollectionCounter(options = {}) {
  const counter = ref(0);
  watchEffect(() => refresh());
  function getService() {
    const service2 = api.getService(options.service.value, options.contextId ? options.contextId.value : null);
    if (!service2) {
      throw new Error("[KDK] Cannot retrieve target service " + options.service.value);
    }
    return service2;
  }
  function getBaseQuery() {
    return options.baseQuery ? options.baseQuery.value : {};
  }
  function getFilterQuery() {
    return options.filterQuery ? options.filterQuery.value : {};
  }
  async function refresh() {
    const query = _$1.merge(getBaseQuery(), getFilterQuery(), { $limit: 0 });
    logger$1.debug(`[KDK] Count service '${options.service.value}' with query`, query);
    const response = await getService().find({ query });
    counter.value = response.total;
  }
  onBeforeMount(async () => {
    const service2 = getService();
    service2.on("created", refresh);
    service2.on("removed", refresh);
  });
  onBeforeUnmount(() => {
    const service2 = getService();
    service2.off("created", refresh);
    service2.off("removed", refresh);
  });
  return {
    counter
  };
}
function useCollectionFilter(options = {}) {
  const { CurrentActivityContext: CurrentActivityContext2 } = useCurrentActivity$1();
  const tagsFilter = CurrentActivityContext2.state.tagsFilter;
  const timeFilter = CurrentActivityContext2.state.timeFilter;
  const filterQuery = ref({});
  let listeners;
  const selectedTags = computed(() => {
    return _$1.get(tagsFilter, "selection", []);
  });
  const hasTagsSelection = computed(() => {
    return !_$1.isEmpty(selectedTags.value);
  });
  const selectedTime = computed(() => {
    return _$1.cloneDeep(timeFilter);
  });
  const hasTimeSelection = computed(() => {
    const start = _$1.get(timeFilter, "start");
    const end = _$1.get(timeFilter, "end");
    return start && end && start !== end;
  });
  watch(selectedTags, () => refreshFilterQuery(), { immediate: true });
  watch(selectedTime, (newTimeRange, oldTimeRange) => {
    if (oldTimeRange && oldTimeRange.start !== null && oldTimeRange.end !== null) refreshFilterQuery();
  }, { deep: true });
  function getService() {
    return getCollectionService(options.service.value, options.context ? options.context.value : null);
  }
  function getBaseQuery() {
    return _$1.get(options, "baseQuery.value", {});
  }
  function getTimeField() {
    return _$1.get(options, "timeField.value", "createdAt");
  }
  function getTagFields() {
    return _$1.get(options, "tagFields", []);
  }
  async function refreshOptions() {
    const timeField = getTimeField();
    const min = await getOldestTime(getService(), timeField, getBaseQuery());
    if (min) _$1.set(timeFilter, "min", min);
    const max = await getLatestTime(getService(), timeField, getBaseQuery());
    if (max) _$1.set(timeFilter, "max", max);
    const tagFields = getTagFields();
    let tagsOptions = [];
    _$1.forEach(tagFields, (values, property) => {
      const propertyOptions = _$1.map(values, (state, key) => {
        return _$1.merge({ scope: property, name: key }, state);
      });
      if (_$1.size(propertyOptions) > 1) tagsOptions = _$1.concat(tagsOptions, propertyOptions);
    });
    _$1.set(tagsFilter, "options", tagsOptions);
  }
  function refreshFilterQuery() {
    const query = {};
    if (hasTagsSelection.value) {
      const tagFields = getTagFields();
      _$1.forEach(tagFields, (values, property) => {
        const tagsProperty = _$1.map(_$1.filter(selectedTags.value, { scope: property }), (tag) => {
          return tag.name;
        });
        if (!_$1.isEmpty(tagsProperty)) {
          _$1.merge(query, { [property]: { $in: tagsProperty } });
        }
      });
    }
    if (hasTimeSelection.value) {
      _$1.merge(query, {
        [getTimeField()]: {
          $gte: selectedTime.value.start,
          $lte: selectedTime.value.end
        }
      });
    }
    filterQuery.value = query;
  }
  onMounted(async () => {
    await refreshOptions();
    listeners = listenToServiceEvents(getService(), {
      created: () => refreshOptions(),
      updated: () => refreshOptions(),
      patched: () => refreshOptions(),
      removed: () => refreshOptions()
    });
  });
  onBeforeUnmount(() => {
    unlistenToServiceEvents(listeners);
  });
  return {
    filterQuery,
    hasTagsSelection,
    hasTimeSelection
  };
}
function useCollectionTimeRange(options = {}) {
  const timeRange = ref(null);
  let serviceEventListeners;
  watchEffect(() => refresh());
  function getService() {
    const service2 = api.getService(options.service.value, options.contextId ? options.contextId.value : null);
    if (!service2) {
      throw new Error("[KDK] Cannot retrieve target service " + options.service.value);
    }
    return service2;
  }
  function getBaseQuery() {
    return options.baseQuery ? options.baseQuery.value : {};
  }
  function getFilterQuery() {
    return options.filterQuery ? options.filterQuery.value : {};
  }
  async function refresh() {
    let start, end;
    const timeProperty = options.property ? options.property.value : "createdAt";
    const startQuery = { $sort: { [timeProperty]: 1 }, $limit: 1 };
    logger$1.debug(`[KDK] Get min timestamp on service '${options.service.value}' with query`, startQuery);
    const startResponse = await getService().find({ query: _$1.merge({}, getBaseQuery(), getFilterQuery(), startQuery) });
    if (_$1.size(startResponse.data) > 0) start = startResponse.data[0];
    const endQuery = { $sort: { [timeProperty]: -1 }, $limit: 1 };
    logger$1.debug(`[KDK] Get max timestamp on service '${options.service.value}' with query`, endQuery);
    const endResponse = await getService().find({ query: _$1.merge({}, getBaseQuery(), getFilterQuery(), endQuery) });
    if (_$1.size(endResponse.data) > 0) end = endResponse.data[0];
    timeRange.value = { start: _$1.get(start, timeProperty), end: _$1.get(end, timeProperty) };
  }
  onBeforeMount(() => {
    serviceEventListeners = listenToServiceEvents(getService(), { all: refresh });
  });
  onBeforeUnmount(() => {
    unlistenToServiceEvents(serviceEventListeners);
  });
  return {
    timeRange
  };
}
function useCollection(options) {
  _$1.defaults(options, {
    // This value can be overriden in activities if they want to manage pagination by themselves
    // nbItemsPerPage = 0 means that the client does not handle pagination and server defaults will be used
    nbItemsPerPage: ref(12),
    // This value indicate if items of each page replace or are appended to previous ones
    appendItems: ref(false),
    // Only invoke refresh at most once per every refreshThrottle milliseconds
    refreshThrottle: ref(500),
    // Refresh strategy to be used
    listStrategy: ref("smart"),
    // Item processor to be used
    processor: ref()
  });
  const items = ref(null);
  const nbTotalItems = ref(0);
  const currentPage = ref(1);
  let itemListener = null;
  let serviceEventListeners;
  const nbPages = computed(() => {
    return options.nbItemsPerPage.value > 0 ? Math.ceil(nbTotalItems.value / options.nbItemsPerPage.value) : 1;
  });
  function getService() {
    const service2 = api.getService(options.service.value, options.contextId ? options.contextId.value : null);
    if (!service2) {
      throw new Error("Cannot retrieve target service " + options.service.value);
    }
    return service2;
  }
  function getCollectionBaseQuery() {
    return options.baseQuery ? options.baseQuery.value : {};
  }
  function getCollectionFilterQuery() {
    return options.filterQuery ? options.filterQuery.value : {};
  }
  function getCollectionPaginationQuery() {
    return options.nbItemsPerPage.value > 0 ? {
      $limit: options.nbItemsPerPage.value,
      $skip: (currentPage.value - 1) * options.nbItemsPerPage.value
    } : {};
  }
  function setCollectionItems(newItems) {
    if (typeof options.processor.value === "function") {
      newItems = options.processor.value(newItems);
    }
    items.value = newItems;
  }
  function subscribe(query) {
    unsubscribe();
    itemListener = getService().watch({ listStrategy: options.listStrategy.value }).find({ query }).subscribe((response) => {
      if (response.type === "FeatureCollection") {
        setCollectionItems(response.features);
      } else if (options.appendItems.value) {
        const newItems = _$1.unionBy(response.data, items.value, "_id");
        const sortQuery = _$1.get(getCollectionBaseQuery(), "$sort");
        if (sortQuery) {
          setCollectionItems(_$1.orderBy(
            newItems,
            // Sort function for each sort property
            _$1.map(_$1.keys(sortQuery), (property) => {
              return (item) => {
                const value = _$1.get(item, property);
                return typeof value === "string" ? value.toLowerCase() : value;
              };
            }),
            // Sort order for each sort property
            _$1.map(_$1.values(sortQuery), (value) => {
              return value > 0 ? "asc" : "desc";
            })
          ));
        } else {
          setCollectionItems(newItems);
        }
      } else {
        setCollectionItems(response.data);
      }
      nbTotalItems.value = response.total;
    }, (error) => {
      logger$1.error(error);
    });
  }
  function unsubscribe() {
    if (itemListener) {
      itemListener.unsubscribe();
      itemListener = null;
    }
  }
  const refreshCollection = _$1.throttle(() => {
    const fullQuery = {
      $locale: getLocale(),
      ...getCollectionBaseQuery(),
      ...getCollectionFilterQuery(),
      ...getCollectionPaginationQuery()
    };
    subscribe(fullQuery);
  }, options.refreshThrottle.value, { leading: false });
  function resetCollection() {
    if (_$1.isNil(items.value)) return;
    if (options.appendItems.value) setCollectionItems([]);
    currentPage.value = 1;
    refreshCollection();
  }
  function onItemsUpdated(updatedItems) {
    updatedItems = Array.isArray(updatedItems) ? updatedItems : [updatedItems];
    updatedItems = _$1.intersectionWith(items.value, updatedItems, (item1, item2) => item1._id && item2._id && item1._id.toString() === item2._id.toString());
    if (updatedItems.length > 0) resetCollection();
  }
  watch(options.service, resetCollection);
  watch(options.listStrategy, resetCollection);
  watch(options.nbItemsPerPage, resetCollection);
  watch(options.appendItems, resetCollection);
  if (options.contextId) watch(options.contextId, resetCollection);
  if (options.baseQuery) watch(options.baseQuery, resetCollection);
  if (options.filterQuery) watch(options.filterQuery, resetCollection);
  onBeforeMount(() => {
    if (options.appendItems.value) {
      serviceEventListeners = listenToServiceEvents(getService(), {
        patched: onItemsUpdated,
        updated: onItemsUpdated,
        removed: onItemsUpdated
      });
    }
  });
  onBeforeUnmount(() => {
    unsubscribe();
    if (options.appendItems.value) {
      unlistenToServiceEvents(serviceEventListeners);
    }
  });
  return {
    items,
    nbTotalItems,
    currentPage,
    nbPages,
    setCollectionItems,
    subscribe,
    unsubscribe,
    getCollectionBaseQuery,
    getCollectionFilterQuery,
    getCollectionPaginationQuery,
    resetCollection,
    refreshCollection
  };
}
function useContext(options) {
  const router = useRouter();
  const fallbackRoute = options?.fallbackRoute || "home";
  let serviceEventListeners;
  function getService() {
    return Context.getService();
  }
  async function setContext(objectOrId) {
    let context2 = Context.get();
    if (context2) untrack();
    if (_.isString(objectOrId)) {
      const service2 = Context.getService();
      try {
        logger$1.debug(`[KDK] Setting context to '${objectOrId}'`);
        context2 = await service2.get(objectOrId);
      } catch (error) {
        logger$1.debug(`[KDK] cannot get event with id ${objectOrId}: ${error}`);
        setTimeout(() => router.push({ name: fallbackRoute }), 2e3);
      }
    } else if (_.isObject(objectOrId)) {
      logger$1.debug(`[KDK] Setting context to '${objectOrId._id}'`);
      context2 = objectOrId;
    } else {
      logger$1.error("[KDK] Setting context: invalid parameter", objectOrId);
      return;
    }
    Context.set(context2);
    track();
  }
  function clearContext() {
    if (Context.get()) untrack();
    Context.set(null);
  }
  function track() {
    serviceEventListeners = listenToServiceEvents(Context.getService(), {
      patched: onPatched,
      removed: onRemoved
    });
  }
  function untrack() {
    unlistenToServiceEvents(serviceEventListeners);
  }
  function onPatched(data) {
    const context2 = Context.get();
    if (context2._id === data._id) {
      Object.assign(context2, _.omit(data, ["_id"]));
    }
  }
  function onRemoved(data) {
    const context2 = Context.get();
    if (context2._id === data._id) {
      Dialog.create({
        title: i18n.t("ALERT"),
        message: i18n.t("composables.context.REMOVED_MESSAGE"),
        persistent: true,
        position: "bottom",
        html: true,
        backdropFilter: "blur(4px)",
        ok: {
          label: i18n.t("OK"),
          flat: true
        }
      }).onOk(async () => {
        router.push({ name: fallbackRoute });
      });
    }
  }
  return {
    Context: readonly(Context.getRef("store")),
    getService,
    setContext,
    clearContext
  };
}
function useQuasar() {
  return inject(quasarKey);
}
function useErrors() {
  const $q = useQuasar();
  const Route = useRoute();
  function showError(error) {
    if (error.ignore) {
      logger$1.error(error);
      return;
    }
    const notification = { type: "negative", message: error.message || error.error_message || error.error, html: true };
    if (error.retryHandler) {
      notification.actions = [{
        label: this.$t("RETRY"),
        handler: error.retryHandler
      }];
      notification.timeout = 2e4;
    }
    $q.notify(notification);
  }
  function showRouteError(route) {
    if (route.query && (route.query.error_message || route.query.error)) {
      showError(route.query);
    } else if (route.params && route.params.token && route.params.token.startsWith("error=")) {
      showError({ message: route.params.token.split("=")[1] });
    }
  }
  watch(Route, (to, from) => showRouteError(to));
  onMounted(() => {
    showRouteError(Route);
    Events.on("error-hook", (hook) => {
      if (_$1.get(hook.error, "data.name") !== "TokenExpiredError") {
        Events.emit("error", hook.error);
      }
    });
    Events.on("error", (error) => {
      const translation = _$1.get(error, "data.translation");
      if (translation) {
        error.message = i18n.tie("errors." + translation.key, translation.params);
        if (translation.keys) {
          translation.keys.forEach((key) => {
            error.message += "<br/>" + i18n.tie("errors." + key, translation.params);
          });
        }
      } else {
        if (error.code) {
          error.message = i18n.tie("errors." + error.code);
        }
      }
      showError(error);
    });
  });
  return {
    showError,
    showRouteError
  };
}
function useLayout() {
  function configureLayout(configuration, context2) {
    if (_.has(configuration, "view")) Layout.setView(configuration.view);
    if (_.has(configuration, "padding")) Layout.setPadding(configuration.padding);
    if (_.has(configuration, "header")) Layout.setHeader(configuration.header, context2);
    if (_.has(configuration, "footer")) Layout.setFooter(configuration.footer, context2);
    if (_.has(configuration, "page")) Layout.setPage(configuration.page, context2);
    if (_.has(configuration, "stickies")) Layout.setStickies(configuration.stickies, context2);
    if (_.has(configuration, "fab")) Layout.setFab(configuration.fab, context2);
    Layout.placements.forEach((placement) => {
      if (_.has(configuration, `panes.${placement}`)) Layout.setPane(placement, _.get(configuration, `panes.${placement}`), context2);
      if (_.has(configuration, `windows.${placement}`)) Layout.setWindow(placement, _.get(configuration, `windows.${placement}`), context2);
    });
    if (_.has(configuration, "leftPane")) Layout.setPane("left", configuration.leftPane, context2);
    if (_.has(configuration, "rightPane")) Layout.setPane("right", configuration.rightPane, context2);
    if (_.has(configuration, "topPane")) Layout.setPane("top", configuration.topPane, context2);
    if (_.has(configuration, "bottomPane")) Layout.setPane("bottom", configuration.bottomPane, context2);
    if (_.has(configuration, "mode")) Layout.setMode(configuration.mode);
  }
  function clearLayout() {
    Layout.clearFocus();
    Layout.clearView();
    Layout.clearPadding();
    Layout.clearHeader();
    Layout.clearFooter();
    Layout.clearPage();
    Layout.clearStickies();
    Layout.clearFab();
    Layout.placements.forEach((placement) => {
      Layout.clearPane(placement);
      Layout.clearWindow(placement);
    });
    Layout.clearMode();
  }
  function setLayoutMode(mode) {
    if (mode) Layout.setMode(mode);
  }
  const additionalFunctions = {};
  Layout.placements.forEach((placement) => {
    additionalFunctions[`set${_.upperFirst(placement)}Pane`] = (options, context2) => {
      Layout.setPane(placement, options, context2);
    };
    additionalFunctions[`set${_.upperFirst(placement)}PaneMode`] = (mode) => {
      Layout.setPaneMode(placement, mode);
    };
    additionalFunctions[`set${_.upperFirst(placement)}PaneFilter`] = (filter) => {
      Layout.setPaneFilter(placement, filter);
    };
    additionalFunctions[`set${_.upperFirst(placement)}PaneVisible`] = (visible) => {
      Layout.setPaneVisible(placement, visible);
    };
    additionalFunctions[`set${_.upperFirst(placement)}PaneOpener`] = (opener) => {
      Layout.setPaneOpener(placement, opener);
    };
    additionalFunctions[`clear${_.upperFirst(placement)}Pane`] = () => {
      Layout.clearPane(placement);
    };
  });
  return {
    Layout,
    configureLayout,
    clearLayout,
    setLayoutMode,
    ...additionalFunctions
  };
}
function useMessages() {
  const messagesService = api.getService("messages");
  async function createMessage(message, query) {
    return messagesService.create(message, { query });
  }
  return {
    createMessage
  };
}
function usePwa(options = { updateTimeout: 5e3 }) {
  const $q = useQuasar();
  const installKey = "install";
  function install() {
    const isNotPWA = config.buildMode !== "pwa";
    const isPWAInstalled = window.matchMedia("(display-mode: standalone)").matches;
    const withinIframe = _$1.get(Platform, "within.iframe", false);
    if (isNotPWA || isPWAInstalled || withinIframe) return;
    if (!LocalStorage.get(installKey, true)) return;
    if (InstallPwaPrompt) installDefaultPrompt();
    if ($q.platform.is.ios) installSafariPrompt();
    if ($q.platform.is.firefox && $q.platform.is.desktop) installFFDesktopPrompt();
  }
  function update2(registration) {
    registration.waiting.addEventListener("statechange", (event) => {
      if (event.target.state === "activated") {
        window.location.reload();
      }
    });
    $q.notify({
      message: i18n.t("composables.pwa.UPDATE_MESSAGE"),
      type: "info",
      html: true,
      timeout: options.updateTimeout,
      spinner: true
    });
    setTimeout(() => {
      registration.waiting.postMessage({ type: "SKIP_WAITING" });
    }, options.updateTimeout);
  }
  onMounted(() => {
    Events.on("pwa-updated", update2);
  });
  onBeforeUnmount(() => {
    Events.off("pwa-updated", update2);
  });
  return {
    installPwa: install
  };
}
let guards = [];
function authenticationGuard(user, to, from) {
  if (to.path.startsWith("/oauth/")) return true;
  if (_$1.get(to, "meta.authenticated") && _$1.get(to, "meta.unauthenticated") || _$1.get(to, "meta.public")) {
    if (to.path === "/") return "home";
    return true;
  }
  if (_$1.get(to, "meta.authenticated")) {
    if (user) return true;
    else return "login";
  }
  if (_$1.get(to, "meta.unauthenticated")) {
    if (user) return "home";
    if (to.path === "/") return "login";
    return true;
  }
}
function permissionsGuard(user, to, from) {
  if (_$1.has(to, "meta.can")) {
    if (!user) return "login";
    let args = _$1.get(to, "meta.can");
    args = args.map((arg) => {
      if (typeof arg === "string" && arg.startsWith(":")) {
        const param = arg.substring(1);
        return _$1.get(to, `query.${param}`, _$1.get(to, `params.${param}`));
      } else {
        return arg;
      }
    });
    return api.can(...args, user) || _$1.get(to, "meta.redirect", "home");
  } else return true;
}
function publicRouteGuard(user, to, from) {
  const matchedRoute = _$1.get(to, "matched", []);
  const lastMatchedRoute = matchedRoute[matchedRoute.length - 1];
  if (lastMatchedRoute.name === "not-found") return false;
  if (lastMatchedRoute.name === "index") return false;
  return true;
}
function beforeGuard(to, from, next) {
  const user = Store.get("user");
  for (const guard of guards) {
    const result = guard(user, to, from);
    if (typeof result === "string") {
      logger$1.debug("[KDK] Navigation guard would redirect to route " + result);
      if (typeof next === "function") {
        return next({ name: result });
      } else {
        return result;
      }
    } else if (!result) {
      logger$1.debug("[KDK] Navigation aborted by guard");
      if (typeof next === "function") {
        return next(false);
      } else {
        return false;
      }
    }
  }
  logger$1.debug("[KDK] Navigation guards passed");
  if (typeof next === "function") {
    return next();
  } else {
    return true;
  }
}
beforeGuard.registerGuard = function(guard) {
  if (!guards.includes(guard)) {
    guards.push(guard);
  }
};
beforeGuard.unregisterGuard = function(guard) {
  guards = guards.filter((registeredGuard) => registeredGuard !== guard);
};
function useSession(options = {}) {
  const disconnectKey = "disconnect-dialog";
  const reconnectKey = "reconnect-dialog";
  const router = useRouter();
  const route = useRoute();
  const $q = useQuasar();
  const isInitialized2 = ref(false);
  let pendingReconnection = null;
  let pendingReload = null;
  let ignoreReconnectionError = false;
  const User = Store.getRef("user");
  function getRedirectKey() {
    return "redirect";
  }
  async function redirect() {
    let result = beforeGuard(route);
    if (typeof options.redirect === "function") result = await options.redirect(route, result, User.value);
    if (typeof result === "string") {
      if (result === "login") {
        if (route.path !== "/") LocalStorage.set(getRedirectKey(), _$1.pick(route, ["name", "query", "params"]));
        await router.push({ name: "login" });
      } else {
        const targetRoute = LocalStorage.get(getRedirectKey());
        if (targetRoute) {
          LocalStorage.clear(getRedirectKey());
          await router.push(targetRoute);
        } else {
          await router.push({ name: result });
        }
      }
    } else {
      LocalStorage.clear(getRedirectKey());
      if (typeof result === "object") {
        await router.push(result);
      } else if (!result) {
        await router.push({ name: User.value ? "home" : "login" });
      }
    }
    if (!isInitialized2.value) {
      if (router) router.beforeEach(beforeGuard);
      isInitialized2.value = true;
    }
  }
  function onReconnectError() {
    if (pendingReload) {
      pendingReload.hide();
      pendingReload = null;
    }
    if (!pendingReconnection && !ignoreReconnectionError) {
      Plugin$1.hide();
      if (!LocalStorage.get(disconnectKey, true)) {
        pendingReconnection = true;
        return;
      }
      pendingReconnection = $q.dialog({
        title: i18n.t("composables.session.ALERT"),
        message: i18n.t("composables.session.DISCONNECT"),
        html: true,
        persistent: true,
        cancel: {
          id: "ignore-button",
          label: i18n.t("composables.session.IGNORE"),
          color: "primary",
          outline: true
        },
        ok: {
          id: "close-button",
          label: i18n.t("CLOSE"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        pendingReconnection = null;
        ignoreReconnectionError = false;
      }).onCancel(() => {
        pendingReconnection = null;
        ignoreReconnectionError = true;
      });
    }
  }
  function onReconnect() {
    if (pendingReconnection) {
      if (typeof pendingReconnection.hide === "function") pendingReconnection.hide();
      pendingReconnection = null;
    }
    ignoreReconnectionError = false;
    if (!pendingReload) {
      if (!LocalStorage.get(reconnectKey, true)) return;
      pendingReload = $q.dialog({
        title: i18n.t("composables.session.INFORMATION"),
        message: i18n.t("composables.session.RECONNECT"),
        html: true,
        cancel: {
          id: "ignore-button",
          label: i18n.t("composables.session.IGNORE"),
          color: "primary",
          outline: true
        },
        ok: {
          id: "update-button",
          label: i18n.t("composables.session.RELOAD"),
          color: "primary"
        },
        position: "bottom"
      }).onOk(() => {
        window.location.reload();
      }).onCancel(() => {
        pendingReload = null;
      });
    }
  }
  function onRateLimit() {
    $q.dialog({
      title: i18n.t("composables.session.ALERT"),
      message: i18n.t("composables.session.REFUSED"),
      html: true,
      ok: {
        label: i18n.t("composables.session.RETRY"),
        flat: true
      },
      position: "bottom"
    }).onOk(() => window.location.reload());
  }
  onMounted(async () => {
    if (api.socket) {
      api.socket.io.on("reconnect_error", onReconnectError);
      api.socket.io.on("reconnect", onReconnect);
      api.socket.on("rate-limit", onRateLimit);
    }
    Events.on("user-abilities-changed", redirect);
    api.on("logout", () => {
      router.push({ name: "logout" });
    });
    try {
      await restoreSession();
    } catch (error) {
      await redirect();
    }
  });
  onBeforeUnmount(() => {
    if (api.socket) {
      api.socket.off("reconnect_error", onReconnectError);
      api.socket.off("reconnect", onReconnect);
      api.socket.off("rate-limit", onRateLimit);
    }
    Events.off("user-abilities-changed", redirect);
  });
  return {
    User,
    redirect,
    isInitialized: isInitialized2,
    onReconnectError,
    onReconnect,
    onRateLimit
  };
}
const locale = getLocale();
function useSchema() {
  const validator = ref(null);
  const schema = ref(null);
  async function compile(schemaNameOrObject, propertiesFilter) {
    if (typeof schemaNameOrObject === "string") {
      logger$1.trace("[KDK] Loading schema ", schemaNameOrObject);
      const schemaModule = await import(`@schemas/${schemaNameOrObject}.json`);
      schema.value = _$1.cloneDeep(schemaModule.default);
    } else {
      logger$1.trace("[KDK] setting schema ", schemaNameOrObject.$id);
      schema.value = _$1.cloneDeep(schemaNameOrObject);
    }
    if (propertiesFilter) {
      let properties = propertiesFilter;
      if (typeof propertiesFilter === "string") properties = _$1.split(propertiesFilter, ",");
      logger$1.trace("[KDK] Filtering schema with ", properties);
      _$1.forOwn(schema.value.properties, (value, key) => {
        if (!properties.includes(key)) delete schema.value.properties[key];
      });
      schema.value.$id += properties.join();
      schema.value.required = _$1.intersection(schema.value.required, properties);
    }
    logger$1.trace("[KDK] Compiling schema ", schema.value.$id);
    validator.value = Schema.register(schema.value);
  }
  function validate(values) {
    if (!validator.value) {
      logger$1.error("[KDK] schema 'validator' not instantiated");
      return;
    }
    const result = validator.value(values);
    if (!result) {
      if (AjvLocalize[locale]) {
        AjvLocalize[locale](validator.value.errors);
      }
    }
    return { isValid: result, errors: validator.value.errors };
  }
  return {
    schema: readonly(schema),
    compile,
    validate
  };
}
ref(null);
function useScreen(options = {}) {
  const $q = useQuasar();
  const denseBreakpoint = _$1.get(options, "dense", "sm");
  const wideBreakpoint = _$1.get(options, "wide", "sm");
  const dense = computed(() => {
    return $q.screen.lt[denseBreakpoint];
  });
  const wide = computed(() => {
    return $q.screen.gt[wideBreakpoint];
  });
  const orientation = computed(() => {
    return $q.screen.width >= $q.screen.height ? "landscape" : "portrait";
  });
  return {
    Screen: readonly($q.screen),
    dense,
    wide,
    orientation,
    Fullscreen: readonly(Fullscreen),
    toggleFullscreen,
    lockOrientation
  };
}
const Version = ref({
  client: {
    number: _$1.get(config, "version"),
    buildNumber: _$1.get(config, "buildNumber")
  },
  api: {
    number: void 0,
    buildNumber: void 0
  },
  flavor: _$1.get(config, "flavor")
});
let isInitialized = false;
function useVersion() {
  const clientVersionName = computed(() => {
    const clientVersion = Version.value.client;
    let version = clientVersion.number;
    if (clientVersion.buildNumber) version += ` (${clientVersion.buildNumber})`;
    return version;
  });
  const apiVersionName = computed(() => {
    const apiVersion = Version.value.api;
    let version = apiVersion.number;
    if (apiVersion.buildNumber) version += ` (${apiVersion.buildNumber})`;
    return version;
  });
  if (!isInitialized) {
    isInitialized = true;
    Version.value.api.number = Capabilities.get("version");
    Version.value.api.buildNumber = Capabilities.get("buildNumber");
  }
  return {
    Version: readonly(Version),
    clientVersionName,
    apiVersionName
  };
}
const index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActivity: useActivity$1,
  useCollection,
  useCollectionCounter,
  useCollectionFilter,
  useCollectionTimeRange,
  useContext,
  useCurrentActivity: useCurrentActivity$1,
  useErrors,
  useLayout,
  useMessages,
  usePwa,
  useSchema,
  useScreen,
  useSelection: useSelection$1,
  useSession,
  useStore,
  useVersion
}, Symbol.toStringTag, { value: "Module" }));
function baseActivity(name) {
  return {
    methods: {
      getAppName() {
        return config.appName;
      },
      configurePadding() {
        if (_$1.has(this.activityOptions, "padding")) Layout.setPadding(_$1.get(this.activityOptions, "padding"));
      },
      clearPadding() {
        Layout.setPadding(true);
      },
      configureHeader() {
        if (_$1.has(this.activityOptions, "header")) Layout.setHeader(_$1.get(this.activityOptions, "header"), this);
      },
      clearHeader() {
        Layout.setHeader(null);
      },
      configureFooter() {
        if (_$1.has(this.activityOptions, "footer")) Layout.setFooter(_$1.get(this.activityOptions, "footer"), this);
      },
      clearFooter() {
        Layout.setFooter(null);
      },
      getTopPane() {
        return Layout.getPane("top");
      },
      getTopPaneMode() {
        return Layout.getPane("top").mode;
      },
      isTopPaneVisible() {
        return Layout.getPane("top").visible;
      },
      setTopPane(content, mode, filter) {
        Layout.setPane("top", { content, mode, filter }, this);
      },
      setTopPaneMode(mode) {
        Layout.setPaneMode("top", mode);
      },
      setTopPaneVisible(visible) {
        Layout.setPaneVisible("top", visible);
      },
      configureTopPane() {
        if (_$1.has(this.activityOptions, "topPane")) Layout.setPane("top", _$1.get(this.activityOptions, "topPane"), this);
      },
      clearTopPane() {
        Layout.setPane("top", null);
      },
      getLeftPane() {
        return Layout.getPane("left");
      },
      getLeftPaneMode() {
        return Layout.getPane("left").mode;
      },
      isLeftPaneVisible() {
        return Layout.getPane("left").visible;
      },
      setLeftPane(content, mode, filter) {
        Layout.setPane("left", { content, mode, filter }, this);
      },
      setLeftPaneMode(mode) {
        Layout.setPaneMode("left", mode);
      },
      setLeftPaneVisible(visible) {
        Layout.setPaneVisible("left", visible);
      },
      configureLeftPane() {
        if (_$1.has(this.activityOptions, "leftPane")) Layout.setPane("left", _$1.get(this.activityOptions, "leftPane"), this);
      },
      clearLeftPane() {
        Layout.setPane("left", null);
      },
      getBottomPane() {
        return Layout.getPane("bottom");
      },
      getBottomPaneMode() {
        return Layout.getPane("bottom").mode;
      },
      isBottomPaneVisible() {
        return Layout.getPane("bottom").visible;
      },
      setBottomPane(content, mode, filter) {
        Layout.setPane("bottom", { content, mode, filter }, this);
      },
      setBottomPaneMode(mode) {
        Layout.setPaneMode("bottom", mode);
      },
      setBottomPaneVisible(visible) {
        Layout.setPaneMode("bottom", visible);
      },
      configureBottomPane() {
        if (_$1.has(this.activityOptions, "bottomPane")) Layout.setPane("bottom", _$1.get(this.activityOptions, "bottomPane"), this);
      },
      clearBottomPane() {
        Layout.setPane("bottom", null);
      },
      getRightPane() {
        return Layout.getPane("right");
      },
      getRightPaneMode() {
        return this.getRightPane().mode;
      },
      isRightPaneVisible() {
        return this.getRightPane().visible;
      },
      setRightPane(content, mode, filter) {
        Layout.setPane("right", { content, mode, filter }, this);
      },
      setRightPaneMode(mode) {
        Layout.setPaneMode("right", mode);
      },
      setRightPaneVisible(visible) {
        Layout.setPaneMode("right", visible);
      },
      configureRightPane() {
        if (_$1.has(this.activityOptions, "rightPane")) Layout.setPane("right", _$1.get(this.activityOptions, "rightPane"), this);
      },
      clearRightPane() {
        Layout.setPane("right", null);
      },
      getPage() {
        return Layout.getPage();
      },
      setPage(content, mode, filter, sticky) {
        Layout.setPage({ content, mode, filter, sticky }, this);
      },
      setPageMode(mode) {
        Layout.setPageMode(mode);
      },
      configurePage() {
        if (_$1.has(this.activityOptions, "page")) Layout.setPage(_$1.get(this.activityOptions, "page"), this);
      },
      clearPage() {
        Layout.setPage(null);
      },
      getStickies() {
        return Layout.getPage();
      },
      setStickies(content, mode, filter, sticky) {
        Layout.setStickies({ content, mode, filter, sticky }, this);
      },
      setStickiesMode(mode) {
        Layout.setStickiesMode(mode);
      },
      configureStickies() {
        if (_$1.has(this.activityOptions, "stickies")) Layout.setStickies(_$1.get(this.activityOptions, "stickies"), this);
      },
      clearStickies() {
        Layout.clearStickies();
      },
      getFab() {
        return Layout.getFab();
      },
      setFab(content, mode, filter) {
        Layout.setFab({ content, mode, filter }, this);
      },
      configureFab() {
        if (_$1.has(this.activityOptions, "fab")) Layout.setFab(_$1.get(this.activityOptions, "fab"), this);
      },
      clearFab() {
        Layout.setFab(null);
      },
      configureWindows() {
        if (!_$1.has(this.activityOptions, "windows")) return;
        const windows = _$1.get(this.activityOptions, "windows", null);
        _$1.forOwn(windows, (window2, placement) => {
          Layout.setWindow(placement, window2, this);
        });
      },
      clearWindows() {
        const windows = _$1.get(this.activityOptions, "windows", null);
        _$1.forOwn(windows, (window2, placement) => {
          Layout.setWindow(placement, null);
        });
      },
      openWindow(placement) {
        Layout.setWindowVisible(placement, true);
      },
      closeWindow(placement) {
        Layout.setWindowVisible(placement, false);
      },
      findWindow(widget) {
        return Layout.findWindow(widget);
      },
      isWidgetWindowVisible(widget) {
        const { window: window2 } = this.findWindow(widget);
        return window2 && window2.visible;
      },
      openWidget(widget) {
        Layout.openWidget(widget);
      },
      closeWidget(widget) {
        Layout.closeWidget(widget);
      },
      clearFocus() {
        Layout.clearFocus();
      },
      clearMode() {
        Layout.clearMode();
      },
      clearActivity() {
        this.clearPadding();
        this.clearFocus();
        this.clearHeader();
        this.clearFooter();
        this.clearTopPane();
        this.clearBottomPane();
        this.clearLeftPane();
        this.clearRightPane();
        this.clearPage();
        this.clearStickies();
        this.clearFab();
        this.clearWindows();
        this.clearMode();
      },
      configureActivity() {
        this.configurePadding();
        this.configureHeader();
        this.configureFooter();
        this.configureTopPane();
        this.configureLeftPane();
        this.configureBottomPane();
        this.configureRightPane();
        this.configurePage();
        this.configureStickies();
        this.configureFab();
        this.configureWindows();
      },
      goBack() {
        this.$router.back();
      },
      refresh() {
        window.location.reload();
      },
      launchTour(name2) {
        if (!name2) {
          const routeName = this.$route.name;
          let tourName = routeName;
          if (_$1.has(this.$route, "params.page")) {
            tourName += "/" + _$1.get(this.$route, "params.page");
          }
          name2 = tourName;
        }
        Store.patch("tours.current", { name: name2 });
      }
    },
    beforeCreate() {
      this.activityName = name || _$1.camelCase(this.$options.name);
      this.activityOptions = config[this.activityName];
    },
    mounted() {
      this.configureActivity();
      Events.on("user-abilities-changed", this.configureActivity);
    },
    beforeUnmount() {
      Events.off("user-abilities-changed", this.configureActivity);
      this.clearActivity();
    }
  };
}
const baseEditor = {
  emits: ["applied"],
  props: {
    baseObject: {
      type: Object,
      default: () => {
      }
    },
    baseQuery: {
      type: Object,
      default: () => {
      }
    },
    schemaName: {
      type: String,
      default: void 0
    },
    perspective: {
      type: String,
      default: ""
    },
    // Indicates if the stored object in-memory is only the perspective part (default)
    // or the full structure, ie { perspective: { xxx } }
    // Note: the full structure is always retrieved/sent from/to the service anyway but sometimes
    // it is easier to manipulate a full-object and edit a nested property seen as a perspective on the front side
    perspectiveAsObject: {
      type: Boolean,
      default: true
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    editorTitle() {
      if (this.getSchema()) {
        const schemaTitle = this.getSchema().title;
        const objectName = _$1.get(this.getObject(), "name");
        return i18n.tie(schemaTitle, { name: objectName, interpolation: { escapeValue: false } });
      }
      return "";
    },
    editorMode() {
      return this.objectId ? "update" : "create";
    },
    applyButton() {
      return this.editorMode === "update" ? this.$t("UPDATE") : this.$t("CREATE");
    }
  },
  data() {
    return {
      isFormReady: false,
      applyInProgress: false
    };
  },
  methods: {
    getBaseObject() {
      const object = {};
      const baseObject = this.getObject() || this.baseObject;
      if (this.perspective !== "") {
        if (this.perspectiveAsObject) {
          Object.assign(object, _$1.get(baseObject, this.perspective));
        } else {
          _$1.set(object, this.perspective, _$1.get(baseObject, this.perspective));
        }
        if (baseObject._id) object._id = baseObject._id;
      } else {
        Object.assign(object, baseObject);
      }
      return object;
    },
    getBaseQuery() {
      const query = {};
      Object.assign(query, this.baseQuery);
      if (this.editorMode === "update" && this.perspective && this.perspectiveAsObject) {
        Object.assign(query, { $select: ["_id", this.perspective] });
      }
      return query;
    },
    getSchemaName() {
      if (this.schemaName) return this.schemaName;
      let schemaName = _$1.get(this.$route, "meta.schemaName");
      if (schemaName) return schemaName;
      schemaName = this.service + (this.objectId ? ".update" : ".create");
      if (this.perspective) {
        schemaName += "-" + this.perspective;
      }
      return schemaName;
    },
    onFormReferenceCreated(reference) {
      if (reference) {
        this.form = reference;
      }
    },
    onFormReady() {
      this.isFormReady = true;
      this.fillEditor();
    },
    fillEditor() {
      if (!this.isFormReady) throw new Error("Cannot fill the editor with a non-ready form");
      if (this.getObject()) {
        if (this.perspective !== "") {
          this.form.fill(_$1.get(this.getObject(), this.perspective));
        } else {
          this.form.fill(this.getObject());
        }
      }
    },
    clearEditor() {
      if (!this.isFormReady) throw new Error("Cannot clear the editor with a non-ready form");
      this.form.clear();
    },
    resetEditor() {
      if (!this.isFormReady) throw new Error("Cannot reset the editor with a non-ready form");
      this.fillEditor();
    },
    async apply() {
      if (!this.getService()) throw new Error("Cannot apply the editor with undefined service");
      if (!this.form) throw new Error("Cannot apply the editor with a non-ready form");
      if (!this.form.validate().isValid) return;
      const object = this.getBaseObject();
      await this.form.apply(object);
      const onServiceResponse = async (response) => {
        await this.form.submitted(response);
        this.$emit("applied", response);
      };
      const query = this.getBaseQuery(object);
      this.applyInProgress = true;
      try {
        if (this.editorMode === "update") {
          if (this.perspective !== "") {
            const data = {};
            if (this.perspectiveAsObject) {
              _$1.set(data, this.perspective, _$1.omit(object, ["_id"]));
            } else {
              _$1.set(data, this.perspective, _$1.get(object, this.perspective));
            }
            const response = await this.getService().patch(this.objectId, data, { query });
            if (object._id) response._id = object._id;
            onServiceResponse(response);
          } else {
            const response = await this.getService().patch(this.objectId, object, { query });
            onServiceResponse(response);
          }
        } else if (this.editorMode === "create") {
          const response = await this.getService().create(object, { query });
          onServiceResponse(response);
        } else {
          logger$1.warn("[KDK] Invalid editor mode");
        }
      } catch (error) {
        logger$1.error(error);
        return false;
      }
      this.applyInProgress = false;
      return true;
    },
    async refresh() {
      this.form = null;
      await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]);
      if (this.isFormReady) this.fillEditor();
    }
  }
};
const baseItem = {
  emits: [
    "item-selected",
    "item-toggled",
    "item-expanded"
  ],
  props: {
    service: {
      type: String,
      required: true
    },
    item: {
      type: Object,
      required: true
    },
    actions: {
      type: [Object, Array],
      default: () => null
    },
    filter: {
      type: Object,
      default: () => {
      }
    },
    handlerContext: {
      type: Object,
      default: () => null
    },
    options: {
      type: Object,
      default: function() {
        return {};
      }
    },
    bindActions: {
      type: Boolean,
      default: true
    }
  },
  watch: {
    // Make configured actions reactive as item actions are built from
    item: function() {
      this.configureActions();
    },
    actions: function() {
      this.configureActions();
    }
  },
  data() {
    return {
      itemActions: null
    };
  },
  computed: {
    name() {
      return _$1.get(this.item, this.options.nameField || "name", "");
    },
    description() {
      return _$1.get(this.item, this.options.descriptionField || "description", "");
    },
    avatar() {
      return _$1.get(this.options, "avatar", true);
    }
  },
  methods: {
    setActions(actions) {
      this.itemActions = this.bindActions ? bindContent(_$1.cloneDeep(actions), this.handlerContext || this) : actions;
    },
    clearActions() {
      this.itemActions = null;
    },
    filteredActions() {
      return this.actions ? filterContent(this.actions, this.filter || {}) : [];
    },
    // This method should be overridden in items
    configureActions() {
      const actions = this.filteredActions();
      if (actions && actions.length > 0) this.setActions(actions);
      else this.clearActions();
    },
    onItemToggled(toggled) {
      this.$emit("item-toggled", this.item, toggled);
    },
    onItemSelected(section) {
      this.$emit("item-selected", this.item, section);
    },
    onItemExpanded(expanded) {
      this.$emit("item-expanded", this.item, expanded);
    },
    canViewItem() {
      return api.can("read", this.service, this.item);
    },
    viewItem() {
      const path2 = this.$route.fullPath + `/view/${this.item._id}`;
      this.$router.push(path2);
    },
    canEditItem() {
      return api.can("update", this.service, this.item);
    },
    editItem(scope = void 0, properties = void 0) {
      const route = this.$route;
      let subPath = "edit/" + this.item._id;
      if (!route.path.endsWith("/")) subPath = `/${subPath}`;
      if (scope) {
        if (properties) subPath += `/${properties}`;
        else subPath += `/${scope}`;
      }
      this.$router.push({
        path: route.path + subPath,
        params: route.params,
        query: route.query
      });
    },
    canRemoveItem() {
      return api.can("remove", this.service, this.item);
    },
    removeItem(prompt, nameField = "name") {
      if (prompt === "confirm" || prompt === "input") {
        const name = _$1.get(this.item, nameField);
        const input = {
          type: "text",
          model: "",
          isValid: (val) => val === name
        };
        Dialog.create({
          title: this.$t("mixins.baseItem.REMOVE_ITEM_TITLE", { name }),
          message: prompt === "input" ? this.$t("mixins.baseItem.REMOVE_ITEM_MESSAGE") : "",
          html: true,
          prompt: prompt === "input" ? input : void 0,
          persistent: true,
          ok: {
            label: this.$t("YES"),
            flat: true
          },
          cancel: {
            label: this.$t("NO"),
            flat: true
          }
        }).onOk(() => {
          api.getService(this.service).remove(this.item._id);
        });
      } else {
        api.getService(this.service).remove(this.item._id);
      }
    },
    exportItem() {
      const name = this.name;
      const file = name + ".json";
      if (exportFile(file, JSON.stringify(this.item))) {
        Notify.create({ type: "positive", message: this.$t("mixins.baseItem.ITEM_EXPORTED", { name, file }) });
      } else {
        Notify.create({ type: "negative", message: this.$t("mixins.baseItme.CANNOT_EXPORT_ITEM") });
      }
    }
  },
  created() {
    this.configureActions();
    Events.on("user-abilities-changed", this.configureActions);
  },
  beforeUnmount() {
    Events.off("user-abilities-changed", this.configureActions);
  }
};
function parseFeatures(winFeatures) {
  const cfg = Object.assign({ noopener: true }, winFeatures);
  const feat = [];
  for (const key in cfg) {
    const value = cfg[key];
    if (value === true) {
      feat.push(key);
    } else if (isNumber$1(value) || typeof value === "string" && value !== "") {
      feat.push(key + "=" + value);
    }
  }
  return feat.join(",");
}
function openWindow(url, reject, windowFeatures) {
  let open = window.open;
  if (Platform$1.is.cordova === true) {
    if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0) {
      open = cordova.InAppBrowser.open;
    } else if (navigator !== void 0 && navigator.app !== void 0) {
      return navigator.app.loadUrl(url, {
        openExternal: true
      });
    }
  }
  const win = open(url, "_blank", parseFeatures(windowFeatures));
  if (win) {
    Platform$1.is.desktop && win.focus();
    return win;
  }
}
const openURL = (url, reject, windowFeatures) => {
  if (Platform$1.is.ios === true && window.SafariViewController !== void 0) {
    window.SafariViewController.isAvailable((available) => {
      if (available) {
        window.SafariViewController.show(
          { url },
          noop,
          reject
        );
      } else {
        openWindow(url, reject, windowFeatures);
      }
    });
    return;
  }
  return openWindow(url, reject, windowFeatures);
};
const baseField = {
  props: {
    values: {
      type: Object,
      default: () => null
    },
    properties: {
      type: Object,
      required: true
    },
    required: {
      type: Boolean,
      default: false
    },
    readOnly: {
      type: Boolean,
      default: false
    },
    dense: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    label() {
      const description = _$1.get(this.properties, "description", "");
      return i18n.tie(_$1.get(this.properties.field, "label", description));
    },
    hasHelper() {
      return !_$1.isEmpty(_$1.get(this.properties.field, "helper", {}));
    },
    helperLabel() {
      return _$1.get(this.properties.field.helper, "label", null);
    },
    helperIcon() {
      return _$1.get(this.properties.field.helper, "icon", void 0);
    },
    helperTooltip() {
      return _$1.get(this.properties.field.helper, "tooltip", "");
    },
    helperUrl() {
      return _$1.get(this.properties.field.helper, "url", null);
    },
    helperDialog() {
      return _$1.get(this.properties.field.helper, "dialog", null);
    },
    helperContext() {
      return _$1.get(this.properties.field.helper, "context", null);
    },
    hasError() {
      return !_$1.isEmpty(this.error);
    },
    errorLabel() {
      let error = _$1.get(this.properties.field, "errorLabel", "");
      if (!error) error = this.error;
      return i18n.tie(error);
    },
    disabled() {
      return _$1.get(this.properties.field, "disabled", false);
    }
  },
  data() {
    return {
      // The model to used for data binding with the field
      model: this.emptyModel(),
      // The error message
      error: ""
    };
  },
  watch: {
    values: function() {
      if (this.values) this.updateValue(_$1.get(this.values, this.properties.name));
      else this.clear();
    }
  },
  methods: {
    updateValue(value) {
      if (_$1.isNil(value)) this.clear();
      else this.fill(value);
    },
    emptyModel() {
      return null;
    },
    isEmpty() {
      return _$1.isEqual(this.model, this.emptyModel());
    },
    value() {
      return this.model;
    },
    fill(value) {
      this.model = value;
      this.error = "";
    },
    clear() {
      this.fill(_$1.get(this.properties, "default", this.emptyModel()));
    },
    validate() {
      this.error = "";
    },
    invalidate(error) {
      this.error = error;
    },
    async onChanged() {
      const nullable = _$1.get(this.properties, "nullable", false);
      if (_$1.isNil(this.model) && !nullable) {
        this.clear();
      }
      await this.$nextTick();
      this.$emit("field-changed", this.properties.name, this.model);
    },
    apply(object, field) {
      _$1.set(object, field, this.value());
    },
    submitted(object, field) {
    },
    onHelperDialogConfirmed(context2) {
      if (context2.url) openURL(context2.url);
    }
  },
  created() {
    if (this.values) this.updateValue(_$1.get(this.values, this.properties.name));
  }
};
const baseViewer = {
  props: {
    perspective: {
      type: String,
      default: ""
    },
    clearButton: {
      type: String,
      default: ""
    },
    resetButton: {
      type: String,
      default: ""
    }
  },
  computed: {
    viewerTitle() {
      if (this.getSchema()) {
        const schemaTitle = this.getSchema().title;
        return this.$t(schemaTitle, { object: this.getObject() });
      }
      return "";
    }
  },
  methods: {
    getSchemaName() {
      let schemaName = this.service + ".get";
      if (this.perspective) {
        schemaName += "-" + this.perspective;
      }
      return schemaName;
    },
    async refresh() {
      await Promise.all([
        this.loadSchema(this.getSchemaName()),
        this.loadObject()
      ]);
    }
  }
};
const baseModal = {
  emits: ["opened", "closed"],
  props: {
    routerMode: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      isModalOpened: false,
      isModalMaximized: false
    };
  },
  methods: {
    openModal(maximized = false) {
      this.isModalMaximized = maximized;
      this.isModalOpened = true;
      this.$emit("opened");
    },
    closeModal() {
      this.isModalOpened = false;
      if (this.routerMode) {
        this.$router.push(this.previousRoute);
      }
      this.$emit("closed");
    }
  },
  created() {
    if (this.routerMode) {
      this.previousRoute = this.$router.options.history.state.back;
      this.openModal();
    }
  }
};
const objectProxy = {
  props: {
    objectId: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      object: null
    };
  },
  methods: {
    getObject() {
      return this.object;
    },
    getObjectId() {
      return this.object ? this.object._id : "";
    },
    loadObject() {
      if (!this.objectId) {
        this.object = null;
        return Promise.resolve(null);
      }
      const objectChanged = this.getObjectId() !== this.objectId;
      if (!this.objectPromise || objectChanged) {
        this.objectPromise = createQuerablePromise((resolve, reject) => {
          this.getService().get(this.objectId).then((object) => {
            this.object = object;
            resolve(object);
          }).catch((error) => {
            reject(error);
          });
        });
      }
      return this.objectPromise;
    }
  }
};
const schemaProxy = {
  props: {
    schemaJson: {
      type: String,
      default: ""
    },
    schemaFunction: {
      type: Function,
      default: null
    },
    schemaProperties: {
      type: [String, Array],
      default: () => []
    }
  },
  data() {
    return {
      schema: null
    };
  },
  methods: {
    getSchema() {
      return this.schema;
    },
    getSchemaId() {
      return _$1.get(this.schema, "$id", "");
    },
    filterSchema() {
      const properties = this.schema.properties;
      let propertiesFilter = typeof this.schemaProperties === "string" ? _$1.split(this.schemaProperties, ",") : this.schemaProperties;
      if (typeof propertiesFilter === "string") propertiesFilter = [propertiesFilter];
      if (propertiesFilter.length > 0) {
        Object.keys(properties).forEach((property) => {
          if (!propertiesFilter.includes(property)) delete properties[property];
        });
        this.schema.$id += propertiesFilter.join();
        this.schema.required = _$1.intersection(this.schema.required, propertiesFilter);
      }
    },
    async loadSchemaFromResource(schemaName) {
      try {
        this.schema = await loadSchema(schemaName);
        this.schema = _$1.cloneDeep(this.schema);
        this.filterSchema();
        return this.schema;
      } catch (error) {
        Events.emit("error", error);
        throw error;
      }
    },
    async loadSchemaFromJson(json) {
      try {
        this.schema = JSON.parse(json);
        this.filterSchema();
        return this.schema;
      } catch (error) {
        Events.emit("error", error);
        throw error;
      }
    },
    async loadSchemaFromFunction(f) {
      try {
        this.schema = await f();
        this.filterSchema();
        return this.schema;
      } catch (error) {
        Events.emit("error", error);
        throw error;
      }
    },
    loadSchema(schemaName) {
      const schemaChanged = schemaName && !this.getSchemaId().includes(schemaName + ".json");
      if (!this.schemaPromise || schemaChanged) {
        this.schemaPromise = createQuerablePromise(this.schemaJson ? this.loadSchemaFromJson(this.schemaJson) : this.schemaFunction ? this.loadSchemaFromFunction(this.schemaFunction) : this.loadSchemaFromResource(schemaName));
      }
      return this.schemaPromise;
    }
  }
};
const service = {
  props: {
    service: {
      type: String,
      default: ""
    }
  },
  methods: {
    getService() {
      const service2 = api.getService(this.service);
      if (!service2) {
        throw new Error("Cannot retrieve target service " + this.service);
      }
      return service2;
    }
  }
};
const index$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  baseActivity,
  baseEditor,
  baseField,
  baseItem,
  baseModal,
  baseViewer,
  objectProxy,
  schemaProxy,
  service
}, Symbol.toStringTag, { value: "Module" }));
const JSONReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`[KDK] reading JSON file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        let content = reader.result;
        try {
          content = JSON.parse(content);
        } catch (error) {
          logger$1.debug(error);
          reject(new Error(i18n.t("errors.INVALID_JSON_FILE", { file }), { errors: error }));
        }
        resolve(content);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file }), { errors: error }));
      };
      reader.readAsText(file);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
const CSVReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`[KDK] reading CSV file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        let content = reader.result;
        const papaParseOptions = Object.assign({ skipEmptyLines: true }, options);
        content = Papa.parse(content, papaParseOptions);
        if (content.errors.length > 0) {
          logger$1.debug(content.errors);
          reject(new Error(i18n.t("errors.INVALID_CSV_FILE", { file: file.name }), { errors: content.errors }));
          return;
        }
        resolve(content.data);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: file.name }), { errors: error }));
      };
      reader.readAsText(file);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
const BLOBReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("[KDK] invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`[KDK] reading Blob file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const content = reader.result;
        if (!content) {
          reject(new Error(i18n.t("errors.INVALID_BLOB_FILE", { file: file.name })));
          return;
        }
        resolve(content);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: file.name }), { errors: error }));
      };
      const expectedType = _$1.get(options, "type", "arrayBuffer");
      if (expectedType === "dataUrl") {
        reader.readAsDataURL(file);
      } else {
        if (expectedType !== "arrayBuffer") logger$1.error(`[KDK] Undefined expected type ${expectedType}. Read as Array buffer.`);
        reader.readAsArrayBuffer(file);
      }
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
const readers$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BLOBReader,
  CSVReader,
  JSONReader
}, Symbol.toStringTag, { value: "Module" }));
const Search = {
  async query(services, pattern) {
    const results = [];
    if (!Array.isArray(services)) services = [services];
    const requests = _$1.map(services, (serviceDescriptor) => {
      const service2 = api.getService(serviceDescriptor.service, serviceDescriptor.context);
      const query = Object.assign({}, serviceDescriptor.baseQuery);
      query[serviceDescriptor.field] = { $search: pattern };
      return service2.find({ query });
    });
    const responses = await Promise.all(requests);
    for (let i = 0; i < responses.length; i++) {
      const response = responses[i];
      const serviceDescriptor = services[i];
      if (response.total > 0) {
        response.data.forEach((data) => {
          data.service = serviceDescriptor.service;
          data.context = serviceDescriptor.context;
          data.field = serviceDescriptor.field;
          const icon = getIconName(data);
          if (_$1.isEmpty(icon) && _$1.has(serviceDescriptor, "icon")) {
            data.icon = serviceDescriptor.icon;
            processIcon(data);
          }
          results.push(data);
        });
      }
    }
    return results;
  }
};
async function initialize() {
  const api2 = this;
  logger$1.debug("[KDK] Initializing Core module...");
  Store.set("kdk", { core: { initialized: false }, map: { initialized: false } });
  LocalStorage.initialize();
  LocalCache.initialize();
  await Platform.initialize();
  await Capabilities.initialize();
  Broadcaster.initialize();
  Storage.initialize();
  Theme.initialize();
  Time.initialize();
  Units.initialize();
  Context.initialize();
  api2.configure(init$1);
  Layout.initialize();
  Filter.initialize();
  Sorter.initialize();
  Document.initialize();
  Exporter.initialize(_$1.get(config, "exporter"));
  Schema.initialize(_$1.get(config, "schema"));
  subscribeToUserChanges();
  _$1.forEach(_$1.get(config, "readers.core", []), (entry) => {
    logger$1.debug(`[KDK] Registering reader ${entry.reader} for [${entry.mimeTypes}] mime types`);
    Reader.register(entry.mimeTypes, readers$1[entry.reader]);
  });
  Store.set("kdk.core.initialized", true);
  logger$1.debug("[KDK] Core module initialized");
}
const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Broadcaster,
  Capabilities,
  Context,
  Document,
  Events,
  Exporter,
  Filter,
  Layout,
  LocalCache,
  LocalStorage,
  Platform,
  Reader,
  Schema,
  Search,
  Sorter,
  Storage,
  Store,
  TemplateContext,
  Theme,
  Time,
  Units,
  addQueryParameter,
  get api() {
    return api;
  },
  authenticationGuard,
  beforeGuard,
  buildEncodedUrl,
  buildUrl,
  composables: index$5,
  createClient,
  default: initialize,
  directives: index$6,
  errors: errors$1,
  hooks: index$8,
  i18n,
  initializeApi,
  makeDiacriticPattern,
  makeServiceSnapshot,
  mixins: index$4,
  permissions: permissions$1,
  permissionsGuard,
  publicRouteGuard,
  services: init$1,
  utils: index$7
}, Symbol.toStringTag, { value: "Module" }));
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(geom, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function point(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  var geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygon(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
    var ring = coordinates_1[_i];
    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }
    for (var j = 0; j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  var geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function lineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be an array of two or more positions");
  }
  var geom = {
    type: "LineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function featureCollection(features, options) {
  if (options === void 0) {
    options = {};
  }
  var fc = { type: "FeatureCollection" };
  if (options.id) {
    fc.id = options.id;
  }
  if (options.bbox) {
    fc.bbox = options.bbox;
  }
  fc.features = features;
  return fc;
}
function multiLineString(coordinates, properties, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = {
    type: "MultiLineString",
    coordinates
  };
  return feature(geom, properties, options);
}
function radiansToLength(radians, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function lengthToRadians(distance2, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}
function radiansToDegrees(radians) {
  var degrees = radians % (2 * Math.PI);
  return degrees * 180 / Math.PI;
}
function degreesToRadians(degrees) {
  var radians = degrees % 360;
  return radians * Math.PI / 180;
}
function convertLength(length2, originalUnit, finalUnit) {
  if (originalUnit === void 0) {
    originalUnit = "kilometers";
  }
  if (finalUnit === void 0) {
    finalUnit = "kilometers";
  }
  if (!(length2 >= 0)) {
    throw new Error("length must be a positive number");
  }
  return radiansToLength(lengthToRadians(length2, originalUnit), finalUnit);
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject$1(input) {
  return !!input && input.constructor === Object;
}
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null) return;
  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop2; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function featureEach(geojson, callback) {
  if (geojson.type === "Feature") {
    callback(geojson, 0);
  } else if (geojson.type === "FeatureCollection") {
    for (var i = 0; i < geojson.features.length; i++) {
      if (callback(geojson.features[i], i) === false) break;
    }
  }
}
function geomEach(geojson, callback) {
  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop2; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(
              geometry.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox: bbox2, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry) return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint") return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}
function centroid(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var xSum = 0;
  var ySum = 0;
  var len = 0;
  coordEach(geojson, function(coord) {
    xSum += coord[0];
    ySum += coord[1];
    len++;
  }, true);
  return point([xSum / len, ySum / len], options.properties);
}
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return coord.geometry.coordinates;
    }
    if (coord.type === "Point") {
      return coord.coordinates;
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return coord;
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
  if (Array.isArray(coords)) {
    return coords;
  }
  if (coords.type === "Feature") {
    if (coords.geometry !== null) {
      return coords.geometry.coordinates;
    }
  } else {
    if (coords.coordinates) {
      return coords.coordinates;
    }
  }
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}
function getType(geojson, _name) {
  if (geojson.type === "FeatureCollection") {
    return "FeatureCollection";
  }
  if (geojson.type === "GeometryCollection") {
    return "GeometryCollection";
  }
  if (geojson.type === "Feature" && geojson.geometry !== null) {
    return geojson.geometry.type;
  }
  return geojson.type;
}
function destination(origin, distance2, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(origin);
  var longitude1 = degreesToRadians(coordinates1[0]);
  var latitude1 = degreesToRadians(coordinates1[1]);
  var bearingRad = degreesToRadians(bearing2);
  var radians = lengthToRadians(distance2, options.units);
  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
  var lng = radiansToDegrees(longitude2);
  var lat = radiansToDegrees(latitude2);
  return point([lng, lat], options.properties);
}
function circle(center2, radius, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var properties = options.properties ? options.properties : !Array.isArray(center2) && center2.type === "Feature" && center2.properties ? center2.properties : {};
  var coordinates = [];
  for (var i = 0; i < steps; i++) {
    coordinates.push(destination(center2, radius, i * -360 / steps, options).geometry.coordinates);
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}
function bboxPolygon(bbox2, options) {
  if (options === void 0) {
    options = {};
  }
  var west = Number(bbox2[0]);
  var south = Number(bbox2[1]);
  var east = Number(bbox2[2]);
  var north = Number(bbox2[3]);
  if (bbox2.length === 6) {
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  }
  var lowLeft = [west, south];
  var topLeft = [west, north];
  var topRight = [east, north];
  var lowRight = [east, south];
  return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox2, id: options.id });
}
function booleanPointInPolygon(point2, polygon2, options) {
  if (options === void 0) {
    options = {};
  }
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  var pt = getCoord(point2);
  var geom = getGeom(polygon2);
  var type = geom.type;
  var bbox2 = polygon2.bbox;
  var polys = geom.coordinates;
  if (bbox2 && inBBox(pt, bbox2) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  var insidePoly = false;
  for (var i = 0; i < polys.length && !insidePoly; i++) {
    if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
      var inHole = false;
      var k = 1;
      while (k < polys[i].length && !inHole) {
        if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
          inHole = true;
        }
        k++;
      }
      if (!inHole) {
        insidePoly = true;
      }
    }
  }
  return insidePoly;
}
function inRing(pt, ring, ignoreBoundary) {
  var isInside = false;
  if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
    ring = ring.slice(0, ring.length - 1);
  }
  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    var xi = ring[i][0];
    var yi = ring[i][1];
    var xj = ring[j][0];
    var yj = ring[j][1];
    var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
    if (onBoundary) {
      return !ignoreBoundary;
    }
    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside = !isInside;
    }
  }
  return isInside;
}
function inBBox(pt, bbox2) {
  return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
}
function lineSegment(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  var results = [];
  flattenEach(geojson, function(feature2) {
    lineSegmentFeature(feature2, results);
  });
  return featureCollection(results);
}
function lineSegmentFeature(geojson, results) {
  var coords = [];
  var geometry = geojson.geometry;
  if (geometry !== null) {
    switch (geometry.type) {
      case "Polygon":
        coords = getCoords(geometry);
        break;
      case "LineString":
        coords = [getCoords(geometry)];
    }
    coords.forEach(function(coord) {
      var segments = createSegments(coord, geojson.properties);
      segments.forEach(function(segment) {
        segment.id = results.length;
        results.push(segment);
      });
    });
  }
}
function createSegments(coords, properties) {
  var segments = [];
  coords.reduce(function(previousCoords, currentCoords) {
    var segment = lineString([previousCoords, currentCoords], properties);
    segment.bbox = bbox(previousCoords, currentCoords);
    segments.push(segment);
    return currentCoords;
  });
  return segments;
}
function bbox(coords1, coords2) {
  var x1 = coords1[0];
  var y1 = coords1[1];
  var x2 = coords2[0];
  var y2 = coords2[1];
  var west = x1 < x2 ? x1 : x2;
  var south = y1 < y2 ? y1 : y2;
  var east = x1 > x2 ? x1 : x2;
  var north = y1 > y2 ? y1 : y2;
  return [west, south, east, north];
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var geojsonRbush = { exports: {} };
var rbush_min$1 = { exports: {} };
var rbush_min = rbush_min$1.exports;
var hasRequiredRbush_min;
function requireRbush_min() {
  if (hasRequiredRbush_min) return rbush_min$1.exports;
  hasRequiredRbush_min = 1;
  (function(module, exports) {
    !function(t, i) {
      module.exports = i();
    }(rbush_min, function() {
      function t(t2, r2, e2, a2, h3) {
        !function t3(n2, r3, e3, a3, h4) {
          for (; a3 > e3; ) {
            if (a3 - e3 > 600) {
              var o2 = a3 - e3 + 1, s2 = r3 - e3 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e3, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
              t3(n2, r3, m2, c2, h4);
            }
            var p2 = n2[r3], d2 = e3, x = a3;
            for (i(n2, e3, r3), h4(n2[a3], p2) > 0 && i(n2, e3, a3); d2 < x; ) {
              for (i(n2, d2, x), d2++, x--; h4(n2[d2], p2) < 0; ) d2++;
              for (; h4(n2[x], p2) > 0; ) x--;
            }
            0 === h4(n2[e3], p2) ? i(n2, e3, x) : i(n2, ++x, a3), x <= r3 && (e3 = x + 1), r3 <= x && (a3 = x - 1);
          }
        }(t2, r2, e2 || 0, a2 || t2.length - 1, h3 || n);
      }
      function i(t2, i2, n2) {
        var r2 = t2[i2];
        t2[i2] = t2[n2], t2[n2] = r2;
      }
      function n(t2, i2) {
        return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
      }
      var r = function(t2) {
        void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
      };
      function e(t2, i2, n2) {
        if (!n2) return i2.indexOf(t2);
        for (var r2 = 0; r2 < i2.length; r2++) if (n2(t2, i2[r2])) return r2;
        return -1;
      }
      function a(t2, i2) {
        h2(t2, 0, t2.children.length, i2, t2);
      }
      function h2(t2, i2, n2, r2, e2) {
        e2 || (e2 = p(null)), e2.minX = 1 / 0, e2.minY = 1 / 0, e2.maxX = -1 / 0, e2.maxY = -1 / 0;
        for (var a2 = i2; a2 < n2; a2++) {
          var h3 = t2.children[a2];
          o(e2, t2.leaf ? r2(h3) : h3);
        }
        return e2;
      }
      function o(t2, i2) {
        return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
      }
      function s(t2, i2) {
        return t2.minX - i2.minX;
      }
      function l(t2, i2) {
        return t2.minY - i2.minY;
      }
      function f(t2) {
        return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
      }
      function u(t2) {
        return t2.maxX - t2.minX + (t2.maxY - t2.minY);
      }
      function m(t2, i2) {
        return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
      }
      function c(t2, i2) {
        return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
      }
      function p(t2) {
        return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function d(i2, n2, r2, e2, a2) {
        for (var h3 = [n2, r2]; h3.length; ) if (!((r2 = h3.pop()) - (n2 = h3.pop()) <= e2)) {
          var o2 = n2 + Math.ceil((r2 - n2) / e2 / 2) * e2;
          t(i2, o2, n2, r2, a2), h3.push(n2, o2, o2, r2);
        }
      }
      return r.prototype.all = function() {
        return this._all(this.data, []);
      }, r.prototype.search = function(t2) {
        var i2 = this.data, n2 = [];
        if (!c(t2, i2)) return n2;
        for (var r2 = this.toBBox, e2 = []; i2; ) {
          for (var a2 = 0; a2 < i2.children.length; a2++) {
            var h3 = i2.children[a2], o2 = i2.leaf ? r2(h3) : h3;
            c(t2, o2) && (i2.leaf ? n2.push(h3) : m(t2, o2) ? this._all(h3, n2) : e2.push(h3));
          }
          i2 = e2.pop();
        }
        return n2;
      }, r.prototype.collides = function(t2) {
        var i2 = this.data;
        if (!c(t2, i2)) return false;
        for (var n2 = []; i2; ) {
          for (var r2 = 0; r2 < i2.children.length; r2++) {
            var e2 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e2) : e2;
            if (c(t2, a2)) {
              if (i2.leaf || m(t2, a2)) return true;
              n2.push(e2);
            }
          }
          i2 = n2.pop();
        }
        return false;
      }, r.prototype.load = function(t2) {
        if (!t2 || !t2.length) return this;
        if (t2.length < this._minEntries) {
          for (var i2 = 0; i2 < t2.length; i2++) this.insert(t2[i2]);
          return this;
        }
        var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
        if (this.data.children.length) if (this.data.height === n2.height) this._splitRoot(this.data, n2);
        else {
          if (this.data.height < n2.height) {
            var r2 = this.data;
            this.data = n2, n2 = r2;
          }
          this._insert(n2, this.data.height - n2.height - 1, true);
        }
        else this.data = n2;
        return this;
      }, r.prototype.insert = function(t2) {
        return t2 && this._insert(t2, this.data.height - 1), this;
      }, r.prototype.clear = function() {
        return this.data = p([]), this;
      }, r.prototype.remove = function(t2, i2) {
        if (!t2) return this;
        for (var n2, r2, a2, h3 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h3 || s2.length; ) {
          if (h3 || (h3 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h3.leaf) {
            var f2 = e(t2, h3.children, i2);
            if (-1 !== f2) return h3.children.splice(f2, 1), s2.push(h3), this._condense(s2), this;
          }
          a2 || h3.leaf || !m(h3, o2) ? r2 ? (n2++, h3 = r2.children[n2], a2 = false) : h3 = null : (s2.push(h3), l2.push(n2), n2 = 0, r2 = h3, h3 = h3.children[0]);
        }
        return this;
      }, r.prototype.toBBox = function(t2) {
        return t2;
      }, r.prototype.compareMinX = function(t2, i2) {
        return t2.minX - i2.minX;
      }, r.prototype.compareMinY = function(t2, i2) {
        return t2.minY - i2.minY;
      }, r.prototype.toJSON = function() {
        return this.data;
      }, r.prototype.fromJSON = function(t2) {
        return this.data = t2, this;
      }, r.prototype._all = function(t2, i2) {
        for (var n2 = []; t2; ) t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
        return i2;
      }, r.prototype._build = function(t2, i2, n2, r2) {
        var e2, h3 = n2 - i2 + 1, o2 = this._maxEntries;
        if (h3 <= o2) return a(e2 = p(t2.slice(i2, n2 + 1)), this.toBBox), e2;
        r2 || (r2 = Math.ceil(Math.log(h3) / Math.log(o2)), o2 = Math.ceil(h3 / Math.pow(o2, r2 - 1))), (e2 = p([])).leaf = false, e2.height = r2;
        var s2 = Math.ceil(h3 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
        d(t2, i2, n2, l2, this.compareMinX);
        for (var f2 = i2; f2 <= n2; f2 += l2) {
          var u2 = Math.min(f2 + l2 - 1, n2);
          d(t2, f2, u2, s2, this.compareMinY);
          for (var m2 = f2; m2 <= u2; m2 += s2) {
            var c2 = Math.min(m2 + s2 - 1, u2);
            e2.children.push(this._build(t2, m2, c2, r2 - 1));
          }
        }
        return a(e2, this.toBBox), e2;
      }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
        for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
          for (var e2 = 1 / 0, a2 = 1 / 0, h3 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
            var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
            u2 < a2 ? (a2 = u2, e2 = l2 < e2 ? l2 : e2, h3 = s2) : u2 === a2 && l2 < e2 && (e2 = l2, h3 = s2);
          }
          i2 = h3 || i2.children[0];
        }
        var m2, c2;
        return i2;
      }, r.prototype._insert = function(t2, i2, n2) {
        var r2 = n2 ? t2 : this.toBBox(t2), e2 = [], a2 = this._chooseSubtree(r2, this.data, i2, e2);
        for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e2[i2].children.length > this._maxEntries; ) this._split(e2, i2), i2--;
        this._adjustParentBBoxes(r2, e2, i2);
      }, r.prototype._split = function(t2, i2) {
        var n2 = t2[i2], r2 = n2.children.length, e2 = this._minEntries;
        this._chooseSplitAxis(n2, e2, r2);
        var h3 = this._chooseSplitIndex(n2, e2, r2), o2 = p(n2.children.splice(h3, n2.children.length - h3));
        o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
      }, r.prototype._splitRoot = function(t2, i2) {
        this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
        for (var r2, e2, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
          var d2 = h2(t2, 0, p2, this.toBBox), x = h2(t2, p2, n2, this.toBBox), v = (e2 = d2, a2 = x, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e2.minX, a2.minX), s2 = Math.max(e2.minY, a2.minY), l2 = Math.min(e2.maxX, a2.maxX), u2 = Math.min(e2.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x);
          v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
        }
        return r2 || n2 - i2;
      }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
        var r2 = t2.leaf ? this.compareMinX : s, e2 = t2.leaf ? this.compareMinY : l;
        this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e2) && t2.children.sort(r2);
      }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
        t2.children.sort(r2);
        for (var e2 = this.toBBox, a2 = h2(t2, 0, i2, e2), s2 = h2(t2, n2 - i2, n2, e2), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
          var m2 = t2.children[f2];
          o(a2, t2.leaf ? e2(m2) : m2), l2 += u(a2);
        }
        for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
          var p2 = t2.children[c2];
          o(s2, t2.leaf ? e2(p2) : p2), l2 += u(s2);
        }
        return l2;
      }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
        for (var r2 = n2; r2 >= 0; r2--) o(i2[r2], t2);
      }, r.prototype._condense = function(t2) {
        for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--) 0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
      }, r;
    });
  })(rbush_min$1);
  return rbush_min$1.exports;
}
var js$1 = {};
var hasRequiredJs$1;
function requireJs$1() {
  if (hasRequiredJs$1) return js$1;
  hasRequiredJs$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.earthRadius = 63710088e-1;
    exports.factors = {
      centimeters: exports.earthRadius * 100,
      centimetres: exports.earthRadius * 100,
      degrees: exports.earthRadius / 111325,
      feet: exports.earthRadius * 3.28084,
      inches: exports.earthRadius * 39.37,
      kilometers: exports.earthRadius / 1e3,
      kilometres: exports.earthRadius / 1e3,
      meters: exports.earthRadius,
      metres: exports.earthRadius,
      miles: exports.earthRadius / 1609.344,
      millimeters: exports.earthRadius * 1e3,
      millimetres: exports.earthRadius * 1e3,
      nauticalmiles: exports.earthRadius / 1852,
      radians: 1,
      yards: exports.earthRadius * 1.0936
    };
    exports.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / exports.earthRadius,
      yards: 1.0936133
    };
    exports.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function feature2(geom, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
        feat.id = options.id;
      }
      if (options.bbox) {
        feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
    }
    exports.feature = feature2;
    function geometry(type, coordinates, _options) {
      switch (type) {
        case "Point":
          return point2(coordinates).geometry;
        case "LineString":
          return lineString2(coordinates).geometry;
        case "Polygon":
          return polygon2(coordinates).geometry;
        case "MultiPoint":
          return multiPoint(coordinates).geometry;
        case "MultiLineString":
          return multiLineString2(coordinates).geometry;
        case "MultiPolygon":
          return multiPolygon(coordinates).geometry;
        default:
          throw new Error(type + " is invalid");
      }
    }
    exports.geometry = geometry;
    function point2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (!coordinates) {
        throw new Error("coordinates is required");
      }
      if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
      }
      if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
      }
      var geom = {
        type: "Point",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.point = point2;
    function points(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection2(coordinates.map(function(coords) {
        return point2(coords, properties);
      }), options);
    }
    exports.points = points;
    function polygon2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      var geom = {
        type: "Polygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.polygon = polygon2;
    function polygons(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection2(coordinates.map(function(coords) {
        return polygon2(coords, properties);
      }), options);
    }
    exports.polygons = polygons;
    function lineString2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
      }
      var geom = {
        type: "LineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.lineString = lineString2;
    function lineStrings(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection2(coordinates.map(function(coords) {
        return lineString2(coords, properties);
      }), options);
    }
    exports.lineStrings = lineStrings;
    function featureCollection2(features, options) {
      if (options === void 0) {
        options = {};
      }
      var fc = { type: "FeatureCollection" };
      if (options.id) {
        fc.id = options.id;
      }
      if (options.bbox) {
        fc.bbox = options.bbox;
      }
      fc.features = features;
      return fc;
    }
    exports.featureCollection = featureCollection2;
    function multiLineString2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiLineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiLineString = multiLineString2;
    function multiPoint(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPoint",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPoint = multiPoint;
    function multiPolygon(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPolygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPolygon = multiPolygon;
    function geometryCollection(geometries, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "GeometryCollection",
        geometries
      };
      return feature2(geom, properties, options);
    }
    exports.geometryCollection = geometryCollection;
    function round(num, precision) {
      if (precision === void 0) {
        precision = 0;
      }
      if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
      }
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
    }
    exports.round = round;
    function radiansToLength2(radians, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return radians * factor;
    }
    exports.radiansToLength = radiansToLength2;
    function lengthToRadians2(distance2, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return distance2 / factor;
    }
    exports.lengthToRadians = lengthToRadians2;
    function lengthToDegrees(distance2, units) {
      return radiansToDegrees2(lengthToRadians2(distance2, units));
    }
    exports.lengthToDegrees = lengthToDegrees;
    function bearingToAzimuth(bearing2) {
      var angle2 = bearing2 % 360;
      if (angle2 < 0) {
        angle2 += 360;
      }
      return angle2;
    }
    exports.bearingToAzimuth = bearingToAzimuth;
    function radiansToDegrees2(radians) {
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
    }
    exports.radiansToDegrees = radiansToDegrees2;
    function degreesToRadians2(degrees) {
      var radians = degrees % 360;
      return radians * Math.PI / 180;
    }
    exports.degreesToRadians = degreesToRadians2;
    function convertLength2(length2, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "kilometers";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(length2 >= 0)) {
        throw new Error("length must be a positive number");
      }
      return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
    }
    exports.convertLength = convertLength2;
    function convertArea(area2, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "meters";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(area2 >= 0)) {
        throw new Error("area must be a positive number");
      }
      var startFactor = exports.areaFactors[originalUnit];
      if (!startFactor) {
        throw new Error("invalid original units");
      }
      var finalFactor = exports.areaFactors[finalUnit];
      if (!finalFactor) {
        throw new Error("invalid final units");
      }
      return area2 / startFactor * finalFactor;
    }
    exports.convertArea = convertArea;
    function isNumber2(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    exports.isNumber = isNumber2;
    function isObject2(input) {
      return !!input && input.constructor === Object;
    }
    exports.isObject = isObject2;
    function validateBBox(bbox2) {
      if (!bbox2) {
        throw new Error("bbox is required");
      }
      if (!Array.isArray(bbox2)) {
        throw new Error("bbox must be an Array");
      }
      if (bbox2.length !== 4 && bbox2.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      }
      bbox2.forEach(function(num) {
        if (!isNumber2(num)) {
          throw new Error("bbox must only contain numbers");
        }
      });
    }
    exports.validateBBox = validateBBox;
    function validateId(id) {
      if (!id) {
        throw new Error("id is required");
      }
      if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
      }
    }
    exports.validateId = validateId;
  })(js$1);
  return js$1;
}
var js = {};
var hasRequiredJs;
function requireJs() {
  if (hasRequiredJs) return js;
  hasRequiredJs = 1;
  Object.defineProperty(js, "__esModule", { value: true });
  var helpers = /* @__PURE__ */ requireJs$1();
  function coordEach2(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop2; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null) continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint") multiFeatureIndex++;
            }
            if (geomType === "LineString") multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString") multiFeatureIndex++;
              if (geomType === "Polygon") geometryIndex++;
            }
            if (geomType === "Polygon") multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach2(
      geojson,
      function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(
            previousValue,
            currentCoord,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      },
      excludeWrapCoord
    );
    return previousValue;
  }
  function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
      case "FeatureCollection":
        for (i = 0; i < geojson.features.length; i++) {
          if (callback(geojson.features[i].properties, i) === false) break;
        }
        break;
      case "Feature":
        callback(geojson.properties, 0);
        break;
    }
  }
  function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function(currentProperties, featureIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentProperties;
      else
        previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
  }
  function featureEach2(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false) break;
      }
    }
  }
  function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach2(geojson, function(currentFeature, featureIndex) {
      if (featureIndex === 0 && initialValue === void 0)
        previousValue = currentFeature;
      else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
  }
  function coordAll(geojson) {
    var coords = [];
    coordEach2(geojson, function(coord) {
      coords.push(coord);
    });
    return coords;
  }
  function geomEach2(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop2 = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop2; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach2(
      geojson,
      function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentGeometry;
        else
          previousValue = callback(
            previousValue,
            currentGeometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          );
      }
    );
    return previousValue;
  }
  function flattenEach2(geojson, callback) {
    geomEach2(geojson, function(geometry, featureIndex, properties, bbox2, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            helpers.feature(geometry, properties, { bbox: bbox2, id }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }
  function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach2(
      geojson,
      function(currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
          previousValue = currentFeature;
        else
          previousValue = callback(
            previousValue,
            currentFeature,
            featureIndex,
            multiFeatureIndex
          );
      }
    );
    return previousValue;
  }
  function segmentEach2(geojson, callback) {
    flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
      var segmentIndex = 0;
      if (!feature2.geometry) return;
      var type = feature2.geometry.type;
      if (type === "Point" || type === "MultiPoint") return;
      var previousCoords;
      var previousFeatureIndex = 0;
      var previousMultiIndex = 0;
      var prevGeomIndex = 0;
      if (coordEach2(
        feature2,
        function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
          if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = helpers.lineString(
            [previousCoords, currentCoord],
            feature2.properties
          );
          if (callback(
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          ) === false)
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false)
        return false;
    });
  }
  function segmentReduce2(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach2(
      geojson,
      function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0)
          previousValue = currentSegment;
        else
          previousValue = callback(
            previousValue,
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          );
        started = true;
      }
    );
    return previousValue;
  }
  function lineEach(geojson, callback) {
    if (!geojson) throw new Error("geojson is required");
    flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
      if (feature2.geometry === null) return;
      var type = feature2.geometry.type;
      var coords = feature2.geometry.coordinates;
      switch (type) {
        case "LineString":
          if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
            return false;
          break;
        case "Polygon":
          for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
            if (callback(
              helpers.lineString(coords[geometryIndex], feature2.properties),
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
          }
          break;
      }
    });
  }
  function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(
      geojson,
      function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === void 0)
          previousValue = currentLine;
        else
          previousValue = callback(
            previousValue,
            currentLine,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      }
    );
    return previousValue;
  }
  function findSegment(geojson, options) {
    options = options || {};
    if (!helpers.isObject(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;
    var properties = options.properties;
    var geometry;
    switch (geojson.type) {
      case "FeatureCollection":
        if (featureIndex < 0)
          featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
      case "Feature":
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        geometry = geojson;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
        return helpers.lineString(
          [coords[segmentIndex], coords[segmentIndex + 1]],
          properties,
          options
        );
      case "Polygon":
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (segmentIndex < 0)
          segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
        return helpers.lineString(
          [
            coords[geometryIndex][segmentIndex],
            coords[geometryIndex][segmentIndex + 1]
          ],
          properties,
          options
        );
      case "MultiLineString":
        if (multiFeatureIndex < 0)
          multiFeatureIndex = coords.length + multiFeatureIndex;
        if (segmentIndex < 0)
          segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
        return helpers.lineString(
          [
            coords[multiFeatureIndex][segmentIndex],
            coords[multiFeatureIndex][segmentIndex + 1]
          ],
          properties,
          options
        );
      case "MultiPolygon":
        if (multiFeatureIndex < 0)
          multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0)
          geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (segmentIndex < 0)
          segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
        return helpers.lineString(
          [
            coords[multiFeatureIndex][geometryIndex][segmentIndex],
            coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
          ],
          properties,
          options
        );
    }
    throw new Error("geojson is invalid");
  }
  function findPoint(geojson, options) {
    options = options || {};
    if (!helpers.isObject(options)) throw new Error("options is invalid");
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;
    var properties = options.properties;
    var geometry;
    switch (geojson.type) {
      case "FeatureCollection":
        if (featureIndex < 0)
          featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
      case "Feature":
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
      case "Point":
      case "MultiPoint":
        return null;
      case "LineString":
      case "Polygon":
      case "MultiLineString":
      case "MultiPolygon":
        geometry = geojson;
        break;
      default:
        throw new Error("geojson is invalid");
    }
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
      case "Point":
        return helpers.point(coords, properties, options);
      case "MultiPoint":
        if (multiFeatureIndex < 0)
          multiFeatureIndex = coords.length + multiFeatureIndex;
        return helpers.point(coords[multiFeatureIndex], properties, options);
      case "LineString":
        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
        return helpers.point(coords[coordIndex], properties, options);
      case "Polygon":
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (coordIndex < 0)
          coordIndex = coords[geometryIndex].length + coordIndex;
        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
      case "MultiLineString":
        if (multiFeatureIndex < 0)
          multiFeatureIndex = coords.length + multiFeatureIndex;
        if (coordIndex < 0)
          coordIndex = coords[multiFeatureIndex].length + coordIndex;
        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
      case "MultiPolygon":
        if (multiFeatureIndex < 0)
          multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0)
          geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (coordIndex < 0)
          coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
        return helpers.point(
          coords[multiFeatureIndex][geometryIndex][coordIndex],
          properties,
          options
        );
    }
    throw new Error("geojson is invalid");
  }
  js.coordAll = coordAll;
  js.coordEach = coordEach2;
  js.coordReduce = coordReduce;
  js.featureEach = featureEach2;
  js.featureReduce = featureReduce;
  js.findPoint = findPoint;
  js.findSegment = findSegment;
  js.flattenEach = flattenEach2;
  js.flattenReduce = flattenReduce;
  js.geomEach = geomEach2;
  js.geomReduce = geomReduce;
  js.lineEach = lineEach;
  js.lineReduce = lineReduce;
  js.propEach = propEach;
  js.propReduce = propReduce;
  js.segmentEach = segmentEach2;
  js.segmentReduce = segmentReduce2;
  return js;
}
var hasRequiredGeojsonRbush;
function requireGeojsonRbush() {
  if (hasRequiredGeojsonRbush) return geojsonRbush.exports;
  hasRequiredGeojsonRbush = 1;
  var rbush2 = requireRbush_min();
  var helpers = /* @__PURE__ */ requireJs$1();
  var meta = /* @__PURE__ */ requireJs();
  var turfBBox = bbox$1.default;
  var featureEach2 = meta.featureEach;
  meta.coordEach;
  helpers.polygon;
  var featureCollection2 = helpers.featureCollection;
  function geojsonRbush$1(maxEntries) {
    var tree = new rbush2(maxEntries);
    tree.insert = function(feature2) {
      if (feature2.type !== "Feature") throw new Error("invalid feature");
      feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
      return rbush2.prototype.insert.call(this, feature2);
    };
    tree.load = function(features) {
      var load = [];
      if (Array.isArray(features)) {
        features.forEach(function(feature2) {
          if (feature2.type !== "Feature") throw new Error("invalid features");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          load.push(feature2);
        });
      } else {
        featureEach2(features, function(feature2) {
          if (feature2.type !== "Feature") throw new Error("invalid features");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          load.push(feature2);
        });
      }
      return rbush2.prototype.load.call(this, load);
    };
    tree.remove = function(feature2, equals2) {
      if (feature2.type !== "Feature") throw new Error("invalid feature");
      feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
      return rbush2.prototype.remove.call(this, feature2, equals2);
    };
    tree.clear = function() {
      return rbush2.prototype.clear.call(this);
    };
    tree.search = function(geojson) {
      var features = rbush2.prototype.search.call(this, this.toBBox(geojson));
      return featureCollection2(features);
    };
    tree.collides = function(geojson) {
      return rbush2.prototype.collides.call(this, this.toBBox(geojson));
    };
    tree.all = function() {
      var features = rbush2.prototype.all.call(this);
      return featureCollection2(features);
    };
    tree.toJSON = function() {
      return rbush2.prototype.toJSON.call(this);
    };
    tree.fromJSON = function(json) {
      return rbush2.prototype.fromJSON.call(this, json);
    };
    tree.toBBox = function(geojson) {
      var bbox2;
      if (geojson.bbox) bbox2 = geojson.bbox;
      else if (Array.isArray(geojson) && geojson.length === 4) bbox2 = geojson;
      else if (Array.isArray(geojson) && geojson.length === 6) bbox2 = [geojson[0], geojson[1], geojson[3], geojson[4]];
      else if (geojson.type === "Feature") bbox2 = turfBBox(geojson);
      else if (geojson.type === "FeatureCollection") bbox2 = turfBBox(geojson);
      else throw new Error("invalid geojson");
      return {
        minX: bbox2[0],
        minY: bbox2[1],
        maxX: bbox2[2],
        maxY: bbox2[3]
      };
    };
    return tree;
  }
  geojsonRbush.exports = geojsonRbush$1;
  geojsonRbush.exports.default = geojsonRbush$1;
  return geojsonRbush.exports;
}
var geojsonRbushExports = requireGeojsonRbush();
const rbush = /* @__PURE__ */ getDefaultExportFromCjs(geojsonRbushExports);
function lineIntersect(line1, line2) {
  var unique = {};
  var results = [];
  if (line1.type === "LineString") {
    line1 = feature(line1);
  }
  if (line2.type === "LineString") {
    line2 = feature(line2);
  }
  if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
    var intersect = intersects(line1, line2);
    if (intersect) {
      results.push(intersect);
    }
    return featureCollection(results);
  }
  var tree = rbush();
  tree.load(lineSegment(line2));
  featureEach(lineSegment(line1), function(segment) {
    featureEach(tree.search(segment), function(match) {
      var intersect2 = intersects(segment, match);
      if (intersect2) {
        var key = getCoords(intersect2).join(",");
        if (!unique[key]) {
          unique[key] = true;
          results.push(intersect2);
        }
      }
    });
  });
  return featureCollection(results);
}
function intersects(line1, line2) {
  var coords1 = getCoords(line1);
  var coords2 = getCoords(line2);
  if (coords1.length !== 2) {
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  }
  if (coords2.length !== 2) {
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  }
  var x1 = coords1[0][0];
  var y1 = coords1[0][1];
  var x2 = coords1[1][0];
  var y2 = coords1[1][1];
  var x3 = coords2[0][0];
  var y3 = coords2[0][1];
  var x4 = coords2[1][0];
  var y4 = coords2[1][1];
  var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
  if (denom === 0) {
    if (numeA === 0 && numeB === 0) {
      return null;
    }
    return null;
  }
  var uA = numeA / denom;
  var uB = numeB / denom;
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    var x = x1 + uA * (x2 - x1);
    var y = y1 + uA * (y2 - y1);
    return point([x, y]);
  }
  return null;
}
function polygonToLine(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  if (!options.properties && poly.type === "Feature") {
    options.properties = poly.properties;
  }
  switch (geom.type) {
    case "Polygon":
      return polygonToLine$1(geom, options);
    case "MultiPolygon":
      return multiPolygonToLine(geom, options);
    default:
      throw new Error("invalid poly");
  }
}
function polygonToLine$1(poly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(poly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
  return coordsToLine(coords, properties);
}
function multiPolygonToLine(multiPoly, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(multiPoly);
  var coords = geom.coordinates;
  var properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
  var lines = [];
  coords.forEach(function(coord) {
    lines.push(coordsToLine(coord, properties));
  });
  return featureCollection(lines);
}
function coordsToLine(coords, properties) {
  if (coords.length > 1) {
    return multiLineString(coords, properties);
  }
  return lineString(coords[0], properties);
}
function booleanDisjoint(feature1, feature2) {
  var bool = true;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === false) {
        return false;
      }
      bool = disjoint(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}
function disjoint(geom1, geom2) {
  switch (geom1.type) {
    case "Point":
      switch (geom2.type) {
        case "Point":
          return !compareCoords(geom1.coordinates, geom2.coordinates);
        case "LineString":
          return !isPointOnLine(geom2, geom1);
        case "Polygon":
          return !booleanPointInPolygon(geom1, geom2);
      }
      break;
    case "LineString":
      switch (geom2.type) {
        case "Point":
          return !isPointOnLine(geom1, geom2);
        case "LineString":
          return !isLineOnLine(geom1, geom2);
        case "Polygon":
          return !isLineInPoly(geom2, geom1);
      }
      break;
    case "Polygon":
      switch (geom2.type) {
        case "Point":
          return !booleanPointInPolygon(geom2, geom1);
        case "LineString":
          return !isLineInPoly(geom1, geom2);
        case "Polygon":
          return !isPolyInPoly(geom2, geom1);
      }
  }
  return false;
}
function isPointOnLine(lineString2, pt) {
  for (var i = 0; i < lineString2.coordinates.length - 1; i++) {
    if (isPointOnLineSegment$1(lineString2.coordinates[i], lineString2.coordinates[i + 1], pt.coordinates)) {
      return true;
    }
  }
  return false;
}
function isLineOnLine(lineString1, lineString2) {
  var doLinesIntersect = lineIntersect(lineString1, lineString2);
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isLineInPoly(polygon2, lineString2) {
  for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
    var coord = _a[_i];
    if (booleanPointInPolygon(coord, polygon2)) {
      return true;
    }
  }
  var doLinesIntersect = lineIntersect(lineString2, polygonToLine(polygon2));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPolyInPoly(feature1, feature2) {
  for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {
    var coord1 = _a[_i];
    if (booleanPointInPolygon(coord1, feature2)) {
      return true;
    }
  }
  for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {
    var coord2 = _c[_b];
    if (booleanPointInPolygon(coord2, feature1)) {
      return true;
    }
  }
  var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));
  if (doLinesIntersect.features.length > 0) {
    return true;
  }
  return false;
}
function isPointOnLineSegment$1(lineSegmentStart, lineSegmentEnd, pt) {
  var dxc = pt[0] - lineSegmentStart[0];
  var dyc = pt[1] - lineSegmentStart[1];
  var dxl = lineSegmentEnd[0] - lineSegmentStart[0];
  var dyl = lineSegmentEnd[1] - lineSegmentStart[1];
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0) {
    return false;
  }
  if (Math.abs(dxl) >= Math.abs(dyl)) {
    if (dxl > 0) {
      return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
    } else {
      return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
    }
  } else if (dyl > 0) {
    return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
  } else {
    return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
  }
}
function compareCoords(pair1, pair2) {
  return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
function booleanIntersects(feature1, feature2) {
  var bool = false;
  flattenEach(feature1, function(flatten1) {
    flattenEach(feature2, function(flatten2) {
      if (bool === true) {
        return true;
      }
      bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);
    });
  });
  return bool;
}
function getNearestTime(time, times, sorted = false) {
  if (sorted) {
    let timeIndex = 0;
    for (; timeIndex < times.length; timeIndex++) {
      if (time.valueOf() < times[timeIndex].valueOf()) break;
    }
    if (timeIndex > 0) timeIndex--;
    return { index: timeIndex, difference: Math.abs(time.diff(times[timeIndex])) };
  } else {
    let timeIndex = -1;
    let minDiff = Infinity;
    times.forEach((currentTime, index2) => {
      const diff = Math.abs(time.diff(currentTime));
      if (diff < minDiff) {
        minDiff = diff;
        timeIndex = index2;
      }
    });
    return { index: timeIndex, difference: minDiff };
  }
}
function getTimeInterval(times, mode = "minimum") {
  let interval = mode === "minimum" ? Infinity : 0;
  times.forEach((currentTime, index2) => {
    if (index2 < times.length - 1) {
      const diff = Math.abs(currentTime.diff(times[index2 + 1]));
      if (mode === "minimum") {
        if (diff < interval) interval = diff;
      } else {
        if (diff > interval) interval = diff;
      }
    }
  });
  return interval;
}
function getFeatureId(feature2, layer2) {
  let featureId = _$1.get(layer2, "featureId");
  if (!featureId) featureId = "_id";
  featureId = Array.isArray(featureId) ? featureId : [featureId];
  return featureId.map((id) => _$1.get(feature2, "properties." + id, _$1.get(feature2, id))).join("-");
}
function getFeatureLabel(feature2, layer2) {
  let featureLabel = layer2.featureLabel || "name";
  featureLabel = Array.isArray(featureLabel) ? featureLabel : [featureLabel];
  return featureLabel.reduce((result, label) => {
    label = _$1.get(feature2, `properties.${label}`);
    return result ? result + ` - ${label}` : label;
  }, "");
}
function coordinatesToGeoJSON(lat, lon, format, options) {
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: [lon, lat]
    },
    properties: {
      name: formatcoords(lat, lon).format(format, options)
    }
  };
}
function getGeoJsonFeatures(geoJson) {
  return Array.isArray(geoJson) ? geoJson : geoJson.type === "FeatureCollection" ? geoJson.features : [geoJson];
}
const placements = ["right", "left", "top", "bottom", "top-left", "top-right", "bottom-right", "bottom-left"];
async function capture(values) {
  const { kActivity } = useCurrentActivity$1();
  const layers = kActivity.value.getContextParameters("layers").layers;
  const bbox2 = kActivity.value.getContextParameters("view");
  const endpoint = Store.get("capabilities.api.gateway") + "/capture";
  const options = {
    method: "POST",
    mode: "cors",
    headers: {
      "Content-Type": "application/json"
    }
  };
  const jwt = await api.get("storage").getItem(config.gatewayJwt);
  if (jwt) options.headers.Authorization = "Bearer " + jwt;
  let dismiss = null;
  dismiss = Notify.create({
    group: "capture",
    icon: "las la-hourglass-half",
    message: i18n.t("KCapture.PRINTING_VIEW"),
    color: "primary",
    timeout: 0,
    spinner: true
  });
  const results = [];
  const dateArray = generateDateArray(values.dateTime.start, values.dateTime.end);
  try {
    for (let index2 = 0; index2 < dateArray.length; index2++) {
      options.body = JSON.stringify({
        activity: kActivity.value.is3D() ? "globe" : "map",
        layers,
        bbox: [bbox2.west, bbox2.south, bbox2.east, bbox2.north],
        size: { width: +values.resolution.width, height: +values.resolution.height },
        layout: getLayout(values),
        time: dateArray[index2],
        basePath: _$1.has(values, "basePath") ? values.basePath : "/#/home/",
        lang: getLocale()
      });
      const response = await fetch(endpoint, options);
      if (response.ok) {
        const arrayBuffer = await response.arrayBuffer();
        results.push(arrayBuffer);
      } else {
        Events.emit("error", { message: i18n.t("errors." + response.status) });
      }
    }
    if (values.format === "pdf") {
      const pdf = await generatePdf(results, _$1.toNumber(values.resolution.width), _$1.toNumber(values.resolution.height));
      exportFile(i18n.t("utils.capture.CAPTURE_PDF_FILE", { time: _$1.get(dateArray, "[0]", "") }), pdf);
    } else {
      _$1.forEach(results, (result, index2) => {
        const time = dateArray[index2];
        exportFile(i18n.t("utils.capture.CAPTURE_IMAGE_FILE", { time: _$1.get(dateArray, `[${index2}]`, "") }), new Uint8Array(result));
      });
    }
    dismiss();
  } catch (error) {
    dismiss();
    logger$1.error(error);
    Events.emit("error", { message: i18n.t("errors.NETWORK_ERROR") });
  }
}
function getLayout(values) {
  const layout = {
    panes: {
      left: { opener: false, visible: false },
      top: { opener: false, visible: false },
      right: { opener: false, visible: false },
      bottom: { opener: false, visible: false }
    },
    fab: { visible: false }
  };
  if (_$1.has(values, "header") && !_$1.isEmpty(values.header)) _$1.set(layout, "header", headerFooterComponent(values.header, "header"));
  if (_$1.has(values, "footer") && !_$1.isEmpty(values.footer)) _$1.set(layout, "footer", headerFooterComponent(values.footer, "footer"));
  if (_$1.includes(placements, values.north)) _$1.set(layout, "stickies", northComponent(values.north));
  if (_$1.includes(placements, values.legend)) _$1.set(layout, `windows.${values.legend}`, legendComponent());
  return layout;
}
function headerFooterComponent(text, position2) {
  return { content: [{ component: _$1.get(config, `capture.${position2}.component`, "KCaptureTextArea"), text, position: position2 }], visible: true };
}
function northComponent(position2) {
  const northSticky = Layout.findSticky("north-sticky");
  return { content: [{ ...northSticky, position: position2, offset: [0, 5], visible: true }] };
}
function legendComponent() {
  return {
    content: [{ id: "legend-widget", label: "KLegend.LABEL", icon: "las la-list", scrollable: true, content: { component: "legend/KLegend" } }],
    current: "legend-widget",
    state: "pinned",
    controls: {
      pin: false,
      unpin: false,
      maximize: false,
      restore: false,
      close: false,
      resize: false
    },
    sizePolicy: {
      pinned: {
        xs: [35, 100],
        sm: [30, 100],
        md: [25, 100],
        lg: [20, 100],
        xl: [15, 100]
      }
    },
    visible: true
  };
}
function generateDateArray(startDateString, endDateString) {
  if (startDateString === endDateString) return [startDateString];
  const startDate = moment.utc(startDateString);
  const endDate = moment.utc(endDateString);
  const intervalMinutes = Store.get("time.interval");
  const dateArray = [];
  let currentDate = startDate.clone();
  while (currentDate.isSameOrBefore(endDate)) {
    dateArray.push(currentDate.toISOString());
    currentDate.add(intervalMinutes, "minutes");
  }
  return dateArray;
}
function getImageProperties(width, height) {
  const imageProperties = { type: "image", rotate: 0 };
  if (width > height) {
    imageProperties.width = 287;
    imageProperties.height = 287 * height / width;
    imageProperties.position = { x: 5, y: (210 - imageProperties.height) / 2 };
  } else {
    imageProperties.height = 200;
    imageProperties.width = 200 * width / height;
    imageProperties.position = { y: 5, x: (297 - imageProperties.width) / 2 };
  }
  return imageProperties;
}
async function generatePdf(imageArray, width, height) {
  const template = {
    schemas: [{ capture: getImageProperties(width, height) }],
    basePdf: "data:application/pdf;base64,JVBERi0xLjQKJeLjz9MKMSAwIG9iaiA8PC9UeXBlL1hPYmplY3QvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHRdL0ZvbnQgMiAwIFI+Pi9TdWJ0eXBlL0Zvcm0vQkJveFswIDAgMjk4IDQyMF0vTWF0cml4WzEgMCAwIDEgMCAwXS9MZW5ndGggNDQvRm9ybVR5cGUgMS9GaWx0ZXIvRmxhdGVEZWNvZGU+PnN0cmVhbQp4nDPQM1Qo5ypUMFAw0DNRMLI01zNXMDG01DNTKEpVCNdSyOMKVAAAiEAHjgplbmRzdHJlYW0KZW5kb2JqCjMgMCBvYmogPDwvTGVuZ3RoIDgxL0ZpbHRlci9GbGF0ZURlY29kZT4+c3RyZWFtCnicK+RyCuEyNlMwNbXUMzZVCEnhcg3hCuQqVDDQMzMwNDNUMABBKNvY2FDP2ETB2MBMz8xcITlXQT8izVDBJV8hkAukzFAhyJ0rmAsAxQ8Q1AplbmRzdHJlYW0KZW5kb2JqCjQgMCBvYmo8PC9UeXBlL1BhZ2VzL0NvdW50IDEvS2lkc1s1IDAgUl0+PgplbmRvYmoKNSAwIG9iajw8L1BhcmVudCA0IDAgUi9UeXBlL1BhZ2UvQ29udGVudHMgMyAwIFIvUmVzb3VyY2VzPDwvUHJvY1NldFsvUERGL1RleHQvSW1hZ2VCL0ltYWdlQy9JbWFnZUldL1hPYmplY3Q8PC9YZjEgMSAwIFI+Pj4+L01lZGlhQm94WzAgMCA4NDEuOTUgNTk1LjM1XT4+CmVuZG9iagoyIDAgb2JqPDw+PgplbmRvYmoKNiAwIG9iajw8L1R5cGUvQ2F0YWxvZy9QYWdlcyA0IDAgUj4+CmVuZG9iago3IDAgb2JqPDwvUHJvZHVjZXIoUERGaWxsOiBGcmVlIFBERiBXcml0ZXIgYW5kIFRvb2xzKS9Nb2REYXRlKEQ6MjAwOTEwMTgyMjMwMTArMDInMDAnKS9DcmVhdGlvbkRhdGUoRDoyMDA5MTAxODIyMzAxMCswMicwMCcpPj4KZW5kb2JqCnhyZWYKMCA4CjAwMDAwMDAwMDAgNjU1MzUgZiAKMDAwMDAwMDAxNSAwMDAwMCBuIAowMDAwMDAwNjAyIDAwMDAwIG4gCjAwMDAwMDAyNDQgMDAwMDAgbiAKMDAwMDAwMDM5MSAwMDAwMCBuIAowMDAwMDAwNDQxIDAwMDAwIG4gCjAwMDAwMDA2MjEgMDAwMDAgbiAKMDAwMDAwMDY2NSAwMDAwMCBuIAp0cmFpbGVyCjw8L1Jvb3QgNiAwIFIvSW5mbyA3IDAgUi9TaXplIDg+PgpzdGFydHhyZWYKNzk5CiUlRU9GCg=="
  };
  const plugins = { image };
  const inputs = [];
  _$1.forEach(imageArray, (value) => {
    inputs.push({ capture: `data:image/png;base64,${base64Encode(value)}` });
  });
  return await generate({ template, plugins, inputs });
}
function setUrlJwt(item, path2, baseUrl, jwtField, jwt) {
  const url = _$1.get(item, path2);
  if (!url) return;
  if (!url.startsWith(baseUrl)) return;
  if (path2 === "cesium.url" && _$1.get(item, "cesium.type") === "OpenStreetMap") {
    const ext = _$1.get(item, "cesium.fileExtension", "png");
    _$1.set(item, "cesium.fileExtension", ext + `?${jwtField}=${jwt}`);
  } else {
    _$1.set(item, path2, buildUrl(url, { [jwtField]: jwt }));
  }
}
async function setEngineJwt(layers, planetApi) {
  if (!planetApi) planetApi = api;
  let jwt = planetApi.hasConfig("gatewayJwt") ? await planetApi.get("storage").getItem(planetApi.getConfig("gatewayJwt")) : null;
  let jwtField = planetApi.getConfig("gatewayJwtField");
  const gatewayUrl = planetApi.hasConfig("gateway") ? planetApi.getConfig("gateway") : Store.get("capabilities.api.gateway");
  if (jwt) {
    layers.forEach((layer2) => {
      setUrlJwt(layer2, "iconUrl", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "leaflet.source", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "leaflet.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "opendap.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "geotiff.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "wfs.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "wcs.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "cesium.url", gatewayUrl, jwtField, jwt);
      setUrlJwt(layer2, "cesium.source", gatewayUrl, jwtField, jwt);
    });
  }
  jwt = planetApi.hasConfig("apiJwt") ? await planetApi.get("storage").getItem(planetApi.getConfig("apiJwt")) : null;
  jwtField = "jwt";
  const apiUrl = planetApi.getConfig("domain");
  if (jwt) {
    layers.forEach((layer2) => {
      setUrlJwt(layer2, "geotiff.url", apiUrl, jwtField, jwt);
    });
    layers.forEach((layer2) => {
      setUrlJwt(layer2, "geotiff.url", "/", jwtField, jwt);
    });
  }
  return layers;
}
function getLayersByCategory(layers, categories) {
  const categorizedLayers = _$1.clone(layers);
  const layersByCategory = {};
  _$1.forEach(categories, (category) => {
    let filter = null;
    if (_$1.has(category, "options.filter")) {
      filter = _$1.get(category, "options.filter");
    } else if (_$1.has(category, "layers")) {
      filter = { name: { $in: _$1.get(category, "layers") } };
    }
    layersByCategory[category.name] = filter ? _$1.remove(categorizedLayers, sift(filter)) : [];
    layersByCategory[category.name] = _$1.orderBy(
      layersByCategory[category.name],
      [(layer2) => _$1.get(layer2, _$1.get(category, "options.orderBy", "_id"))],
      [_$1.get(category, "options.order", "asc")]
    );
    if (layers.length > 0 && category?.layers) {
      layersByCategory[category.name] = category.layers.map((layerName) => layers.find((l) => l.name === layerName));
    }
  });
  return layersByCategory;
}
function getOrphanLayers(layers, layersByCategory) {
  const categories = _$1.flatten(_$1.values(layersByCategory));
  const orphanLayers = _$1.difference(layers, categories);
  return _$1.orderBy(orphanLayers, [(layer2) => _$1.get(layer2, "_id")], ["asc"]);
}
function processTranslations(item) {
  if (item.i18n) i18n.registerTranslation(item.i18n);
  if (!_$1.has(item, "label")) item.label = i18n.tie(item.name);
  if (_$1.has(item, "description")) item.description = i18n.tie(item.description);
}
async function getLayers(options = {}) {
  _$1.defaults(options, {
    query: {},
    context: "",
    planetApi: api
  });
  let layers = [];
  const catalogService = options.planetApi.getService("catalog", options.context);
  if (catalogService) {
    const response = await catalogService.find({ query: options.query });
    _$1.forEach(response.data, processTranslations);
    layers = layers.concat(response.data.map((layer2) => Object.assign(layer2, { getPlanetApi: () => options.planetApi })));
  }
  await setEngineJwt(layers, options.planetApi);
  return layers;
}
async function getCategories(options = {}) {
  _$1.defaults(options, {
    query: {},
    context: "",
    planetApi: api
  });
  let categories = [];
  const catalogService = options.planetApi.getService("catalog", options.context);
  if (catalogService) {
    const response = await catalogService.find({ query: Object.assign({ type: "Category" }, options.query) });
    _$1.forEach(response.data, processTranslations);
    categories = categories.concat(response.data);
  }
  return categories;
}
async function getSublegends(options = {}) {
  _$1.defaults(options, {
    query: {},
    context: "",
    planetApi: api
  });
  let sublegends = [];
  const catalogService = options.planetApi.getService("catalog", options.context);
  if (catalogService) {
    const response = await catalogService.find({ query: Object.assign({ type: "Sublegend" }, options.query) });
    _$1.forEach(response.data, processTranslations);
    sublegends = sublegends.concat(response.data);
  }
  return sublegends;
}
function getLayersBySublegend(layers, sublegends) {
  const categorizedLayers = _$1.clone(layers);
  const layersBySublegend = {};
  _$1.forEach(sublegends, (sublegend) => {
    let filter = null;
    if (_$1.has(sublegend, "options.filter")) {
      filter = _$1.get(sublegend, "options.filter");
    }
    layersBySublegend[sublegend.name] = filter ? _$1.remove(categorizedLayers, sift(filter)) : [];
  });
  return layersBySublegend;
}
async function getViews(options = {}) {
  _$1.defaults(options, {
    query: {},
    context: "",
    planetApi: api
  });
  let views = [];
  const catalogService = options.planetApi.getService("catalog", options.context);
  if (catalogService) {
    const response = await catalogService.find({ query: Object.assign({ type: "Context" }, options.query) });
    _$1.forEach(response.data, processTranslations);
    views = views.concat(response.data);
  }
  return views;
}
function explode(geojson) {
  var points = [];
  if (geojson.type === "FeatureCollection") {
    featureEach(geojson, function(feature2) {
      coordEach(feature2, function(coord) {
        points.push(point(coord, feature2.properties));
      });
    });
  } else {
    coordEach(geojson, function(coord) {
      points.push(point(coord, geojson.properties));
    });
  }
  return featureCollection(points);
}
function kinks(featureIn) {
  var coordinates;
  var feature2;
  var results = {
    type: "FeatureCollection",
    features: []
  };
  if (featureIn.type === "Feature") {
    feature2 = featureIn.geometry;
  } else {
    feature2 = featureIn;
  }
  if (feature2.type === "LineString") {
    coordinates = [feature2.coordinates];
  } else if (feature2.type === "MultiLineString") {
    coordinates = feature2.coordinates;
  } else if (feature2.type === "MultiPolygon") {
    coordinates = [].concat.apply([], feature2.coordinates);
  } else if (feature2.type === "Polygon") {
    coordinates = feature2.coordinates;
  } else {
    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
  }
  coordinates.forEach(function(line1) {
    coordinates.forEach(function(line2) {
      for (var i = 0; i < line1.length - 1; i++) {
        for (var k = i; k < line2.length - 1; k++) {
          if (line1 === line2) {
            if (Math.abs(i - k) === 1) {
              continue;
            }
            if (
              // segments are first and last segment of lineString
              i === 0 && k === line1.length - 2 && // lineString is closed
              line1[i][0] === line1[line1.length - 1][0] && line1[i][1] === line1[line1.length - 1][1]
            ) {
              continue;
            }
          }
          var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1], line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);
          if (intersection) {
            results.features.push(point([intersection[0], intersection[1]]));
          }
        }
      }
    });
  });
  return results;
}
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
  var denominator;
  var a;
  var b;
  var numerator1;
  var numerator2;
  var result = {
    x: null,
    y: null,
    onLine1: false,
    onLine2: false
  };
  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
  if (denominator === 0) {
    if (result.x !== null && result.y !== null) {
      return result;
    } else {
      return false;
    }
  }
  a = line1StartY - line2StartY;
  b = line1StartX - line2StartX;
  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
  a = numerator1 / denominator;
  b = numerator2 / denominator;
  result.x = line1StartX + a * (line1EndX - line1StartX);
  result.y = line1StartY + a * (line1EndY - line1StartY);
  if (a >= 0 && a <= 1) {
    result.onLine1 = true;
  }
  if (b >= 0 && b <= 1) {
    result.onLine2 = true;
  }
  if (result.onLine1 && result.onLine2) {
    return [result.x, result.y];
  } else {
    return false;
  }
}
function cleanCoords(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var mutate = typeof options === "object" ? options.mutate : options;
  if (!geojson)
    throw new Error("geojson is required");
  var type = getType(geojson);
  var newCoords = [];
  switch (type) {
    case "LineString":
      newCoords = cleanLine(geojson);
      break;
    case "MultiLineString":
    case "Polygon":
      getCoords(geojson).forEach(function(line) {
        newCoords.push(cleanLine(line));
      });
      break;
    case "MultiPolygon":
      getCoords(geojson).forEach(function(polygons) {
        var polyPoints = [];
        polygons.forEach(function(ring) {
          polyPoints.push(cleanLine(ring));
        });
        newCoords.push(polyPoints);
      });
      break;
    case "Point":
      return geojson;
    case "MultiPoint":
      var existing = {};
      getCoords(geojson).forEach(function(coord) {
        var key = coord.join("-");
        if (!Object.prototype.hasOwnProperty.call(existing, key)) {
          newCoords.push(coord);
          existing[key] = true;
        }
      });
      break;
    default:
      throw new Error(type + " geometry not supported");
  }
  if (geojson.coordinates) {
    if (mutate === true) {
      geojson.coordinates = newCoords;
      return geojson;
    }
    return { type, coordinates: newCoords };
  } else {
    if (mutate === true) {
      geojson.geometry.coordinates = newCoords;
      return geojson;
    }
    return feature({ type, coordinates: newCoords }, geojson.properties, {
      bbox: geojson.bbox,
      id: geojson.id
    });
  }
}
function cleanLine(line) {
  var points = getCoords(line);
  if (points.length === 2 && !equals(points[0], points[1]))
    return points;
  var newPoints = [];
  var secondToLast = points.length - 1;
  var newPointsLength = newPoints.length;
  newPoints.push(points[0]);
  for (var i = 1; i < secondToLast; i++) {
    var prevAddedPoint = newPoints[newPoints.length - 1];
    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1])
      continue;
    else {
      newPoints.push(points[i]);
      newPointsLength = newPoints.length;
      if (newPointsLength > 2) {
        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
          newPoints.splice(newPoints.length - 2, 1);
      }
    }
  }
  newPoints.push(points[points.length - 1]);
  newPointsLength = newPoints.length;
  if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)
    throw new Error("invalid polygon");
  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))
    newPoints.splice(newPoints.length - 2, 1);
  return newPoints;
}
function equals(pt1, pt2) {
  return pt1[0] === pt2[0] && pt1[1] === pt2[1];
}
function isPointOnLineSegment(start, end, point2) {
  var x = point2[0], y = point2[1];
  var startX = start[0], startY = start[1];
  var endX = end[0], endY = end[1];
  var dxc = x - startX;
  var dyc = y - startY;
  var dxl = endX - startX;
  var dyl = endY - startY;
  var cross = dxc * dyl - dyc * dxl;
  if (cross !== 0)
    return false;
  else if (Math.abs(dxl) >= Math.abs(dyl))
    return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
  else
    return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
}
function rhumbBearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }
  var bear360;
  if (options.final) {
    bear360 = calculateRhumbBearing(getCoord(end), getCoord(start));
  } else {
    bear360 = calculateRhumbBearing(getCoord(start), getCoord(end));
  }
  var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
  return bear180;
}
function calculateRhumbBearing(from, to) {
  var phi1 = degreesToRadians(from[1]);
  var phi2 = degreesToRadians(to[1]);
  var deltaLambda = degreesToRadians(to[0] - from[0]);
  if (deltaLambda > Math.PI) {
    deltaLambda -= 2 * Math.PI;
  }
  if (deltaLambda < -Math.PI) {
    deltaLambda += 2 * Math.PI;
  }
  var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var theta = Math.atan2(deltaLambda, deltaPsi);
  return (radiansToDegrees(theta) + 360) % 360;
}
function rhumbDistance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var origin = getCoord(from);
  var destination2 = getCoord(to);
  destination2[0] += destination2[0] - origin[0] > 180 ? -360 : origin[0] - destination2[0] > 180 ? 360 : 0;
  var distanceInMeters = calculateRhumbDistance(origin, destination2);
  var distance2 = convertLength(distanceInMeters, "meters", options.units);
  return distance2;
}
function calculateRhumbDistance(origin, destination2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var R = radius;
  var phi1 = origin[1] * Math.PI / 180;
  var phi2 = destination2[1] * Math.PI / 180;
  var DeltaPhi = phi2 - phi1;
  var DeltaLambda = Math.abs(destination2[0] - origin[0]) * Math.PI / 180;
  if (DeltaLambda > Math.PI) {
    DeltaLambda -= 2 * Math.PI;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda);
  var dist = delta * R;
  return dist;
}
function rhumbDestination(origin, distance2, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var wasNegativeDistance = distance2 < 0;
  var distanceInMeters = convertLength(Math.abs(distance2), options.units, "meters");
  if (wasNegativeDistance)
    distanceInMeters = -Math.abs(distanceInMeters);
  var coords = getCoord(origin);
  var destination2 = calculateRhumbDestination(coords, distanceInMeters, bearing2);
  destination2[0] += destination2[0] - coords[0] > 180 ? -360 : coords[0] - destination2[0] > 180 ? 360 : 0;
  return point(destination2, options.properties);
}
function calculateRhumbDestination(origin, distance2, bearing2, radius) {
  radius = radius === void 0 ? earthRadius : Number(radius);
  var delta = distance2 / radius;
  var lambda1 = origin[0] * Math.PI / 180;
  var phi1 = degreesToRadians(origin[1]);
  var theta = degreesToRadians(bearing2);
  var DeltaPhi = delta * Math.cos(theta);
  var phi2 = phi1 + DeltaPhi;
  if (Math.abs(phi2) > Math.PI / 2) {
    phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
  }
  var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
  var q = Math.abs(DeltaPsi) > 1e-11 ? DeltaPhi / DeltaPsi : Math.cos(phi1);
  var DeltaLambda = delta * Math.sin(theta) / q;
  var lambda2 = lambda1 + DeltaLambda;
  return [
    (lambda2 * 180 / Math.PI + 540) % 360 - 180,
    phi2 * 180 / Math.PI
  ];
}
function clone(geojson) {
  if (!geojson) {
    throw new Error("geojson is required");
  }
  switch (geojson.type) {
    case "Feature":
      return cloneFeature(geojson);
    case "FeatureCollection":
      return cloneFeatureCollection(geojson);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cloneGeometry(geojson);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function cloneFeature(geojson) {
  var cloned = { type: "Feature" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.properties = cloneProperties(geojson.properties);
  cloned.geometry = cloneGeometry(geojson.geometry);
  return cloned;
}
function cloneProperties(properties) {
  var cloned = {};
  if (!properties) {
    return cloned;
  }
  Object.keys(properties).forEach(function(key) {
    var value = properties[key];
    if (typeof value === "object") {
      if (value === null) {
        cloned[key] = null;
      } else if (Array.isArray(value)) {
        cloned[key] = value.map(function(item) {
          return item;
        });
      } else {
        cloned[key] = cloneProperties(value);
      }
    } else {
      cloned[key] = value;
    }
  });
  return cloned;
}
function cloneFeatureCollection(geojson) {
  var cloned = { type: "FeatureCollection" };
  Object.keys(geojson).forEach(function(key) {
    switch (key) {
      case "type":
      case "features":
        return;
      default:
        cloned[key] = geojson[key];
    }
  });
  cloned.features = geojson.features.map(function(feature2) {
    return cloneFeature(feature2);
  });
  return cloned;
}
function cloneGeometry(geometry) {
  var geom = { type: geometry.type };
  if (geometry.bbox) {
    geom.bbox = geometry.bbox;
  }
  if (geometry.type === "GeometryCollection") {
    geom.geometries = geometry.geometries.map(function(g) {
      return cloneGeometry(g);
    });
    return geom;
  }
  geom.coordinates = deepSlice(geometry.coordinates);
  return geom;
}
function deepSlice(coords) {
  var cloned = coords;
  if (typeof cloned[0] !== "object") {
    return cloned.slice();
  }
  return cloned.map(function(coord) {
    return deepSlice(coord);
  });
}
function transformRotate(geojson, angle2, options) {
  options = options || {};
  if (!isObject$1(options)) throw new Error("options is invalid");
  var pivot = options.pivot;
  var mutate = options.mutate;
  if (!geojson) throw new Error("geojson is required");
  if (angle2 === void 0 || angle2 === null || isNaN(angle2))
    throw new Error("angle is required");
  if (angle2 === 0) return geojson;
  if (!pivot) pivot = centroid(geojson);
  if (mutate === false || mutate === void 0) geojson = clone(geojson);
  coordEach(geojson, function(pointCoords) {
    var initialAngle = rhumbBearing(pivot, pointCoords);
    var finalAngle = initialAngle + angle2;
    var distance2 = rhumbDistance(pivot, pointCoords);
    var newCoords = getCoords(rhumbDestination(pivot, distance2, finalAngle));
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
  });
  return geojson;
}
function center(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  var ext = bbox$1(geojson);
  var x = (ext[0] + ext[2]) / 2;
  var y = (ext[1] + ext[3]) / 2;
  return point([x, y], options.properties, options);
}
function transformScale(geojson, factor, options) {
  options = options || {};
  if (!isObject$1(options)) throw new Error("options is invalid");
  var origin = options.origin;
  var mutate = options.mutate;
  if (!geojson) throw new Error("geojson required");
  if (typeof factor !== "number" || factor === 0)
    throw new Error("invalid factor");
  var originIsPoint = Array.isArray(origin) || typeof origin === "object";
  if (mutate !== true) geojson = clone(geojson);
  if (geojson.type === "FeatureCollection" && !originIsPoint) {
    featureEach(geojson, function(feature2, index2) {
      geojson.features[index2] = scale(feature2, factor, origin);
    });
    return geojson;
  }
  return scale(geojson, factor, origin);
}
function scale(feature2, factor, origin) {
  var isPoint = getType(feature2) === "Point";
  origin = defineOrigin(feature2, origin);
  if (factor === 1 || isPoint) return feature2;
  coordEach(feature2, function(coord) {
    var originalDistance = rhumbDistance(origin, coord);
    var bearing2 = rhumbBearing(origin, coord);
    var newDistance = originalDistance * factor;
    var newCoord = getCoords(rhumbDestination(origin, newDistance, bearing2));
    coord[0] = newCoord[0];
    coord[1] = newCoord[1];
    if (coord.length === 3) coord[2] *= factor;
  });
  return feature2;
}
function defineOrigin(geojson, origin) {
  if (origin === void 0 || origin === null) origin = "centroid";
  if (Array.isArray(origin) || typeof origin === "object")
    return getCoord(origin);
  var bbox2 = geojson.bbox ? geojson.bbox : bbox$1(geojson);
  var west = bbox2[0];
  var south = bbox2[1];
  var east = bbox2[2];
  var north = bbox2[3];
  switch (origin) {
    case "sw":
    case "southwest":
    case "westsouth":
    case "bottomleft":
      return point([west, south]);
    case "se":
    case "southeast":
    case "eastsouth":
    case "bottomright":
      return point([east, south]);
    case "nw":
    case "northwest":
    case "westnorth":
    case "topleft":
      return point([west, north]);
    case "ne":
    case "northeast":
    case "eastnorth":
    case "topright":
      return point([east, north]);
    case "center":
      return center(geojson);
    case void 0:
    case null:
    case "centroid":
      return centroid(geojson);
    default:
      throw new Error("invalid origin");
  }
}
function transformTranslate(geojson, distance2, direction, options) {
  options = options || {};
  if (!isObject$1(options)) throw new Error("options is invalid");
  var units = options.units;
  var zTranslation = options.zTranslation;
  var mutate = options.mutate;
  if (!geojson) throw new Error("geojson is required");
  if (distance2 === void 0 || distance2 === null || isNaN(distance2))
    throw new Error("distance is required");
  if (zTranslation && typeof zTranslation !== "number" && isNaN(zTranslation))
    throw new Error("zTranslation is not a number");
  zTranslation = zTranslation !== void 0 ? zTranslation : 0;
  if (distance2 === 0 && zTranslation === 0) return geojson;
  if (direction === void 0 || direction === null || isNaN(direction))
    throw new Error("direction is required");
  if (distance2 < 0) {
    distance2 = -distance2;
    direction = direction + 180;
  }
  if (mutate === false || mutate === void 0) geojson = clone(geojson);
  coordEach(geojson, function(pointCoords) {
    var newCoords = getCoords(
      rhumbDestination(pointCoords, distance2, direction, { units })
    );
    pointCoords[0] = newCoords[0];
    pointCoords[1] = newCoords[1];
    if (zTranslation && pointCoords.length === 3)
      pointCoords[2] += zTranslation;
  });
  return geojson;
}
function removeServerSideParameters(context2) {
  const params = context2.params;
  if (_$1.has(params, "query.east")) {
    _$1.set(params, "east", _$1.get(params, "query.east"));
    _$1.unset(params, "query.east");
  }
  if (_$1.has(params, "query.west")) {
    _$1.set(params, "west", _$1.get(params, "query.west"));
    _$1.unset(params, "query.west");
  }
  if (_$1.has(params, "query.north")) {
    _$1.set(params, "north", _$1.get(params, "query.north"));
    _$1.unset(params, "query.north");
  }
  if (_$1.has(params, "query.south")) {
    _$1.set(params, "south", _$1.get(params, "query.south"));
    _$1.unset(params, "query.south");
  }
}
async function updateReferenceCount(service2, id, increment) {
  const feature2 = await service2._get(id);
  const count = _$1.get(feature2, "referenceCount", 0) + increment;
  const data = await service2._patch(id, { referenceCount: count });
  return data;
}
async function referenceCountCreateHook(context2) {
  const service2 = context2.service;
  const features = Array.isArray(context2.data) ? context2.data : [context2.data];
  for (let i = 0; i < features.length; i++) {
    const feature2 = features[i];
    try {
      await updateReferenceCount(service2, feature2._id, 1);
    } catch (error) {
      feature2.referenceCount = 1;
      await service2._create(feature2);
    }
  }
  context2.result = context2.data;
}
async function referenceCountRemoveHook(context2) {
  const service2 = context2.service;
  if (!context2.id) {
    context2.result = await service2._find(Object.assign(context2.params, { paginate: false }));
    for (let i = 0; i < context2.result.length; i++) {
      const feature2 = context2.result[i];
      try {
        const { referenceCount } = await updateReferenceCount(service2, feature2._id, -1);
        if (referenceCount <= 0) await service2._remove(feature2._id);
      } catch (error) {
        logger$1.debug("[KDK] reference count update failed: ", error);
      }
    }
  } else {
    const feature2 = await updateReferenceCount(service2, context2.id, -1);
    if (feature2.referenceCount <= 0) await service2._remove(context2.id);
    context2.result = feature2;
  }
}
function geoJsonPaginationHook(context2) {
  const result = context2.result;
  const features = result.data;
  if (_$1.get(features, "[0].type") !== "Feature") return;
  context2.result = Object.assign({
    type: "FeatureCollection",
    features: result.data
  }, _$1.pick(result, ["total", "skip", "limit"]));
}
async function intersectBBoxHook(context2) {
  const params = context2.params;
  if (!_$1.has(params, "east") || !_$1.has(params, "west") || !_$1.has(params, "north") || !_$1.has(params, "south")) return context2;
  const service2 = context2.service;
  const query = await service2._find(_$1.omit(params, ["east", "west", "north", "south"]));
  const features = query.data;
  const bbox2 = polygon([[[params.east, params.south], [params.west, params.south], [params.west, params.north], [params.east, params.north], [params.east, params.south]]]);
  let result = [];
  for (let feature2 of features) {
    if (booleanIntersects(bbox2, feature2)) {
      result.push(feature2);
    }
  }
  _$1.set(context2, "result.data", result);
}
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geoJsonPaginationHook,
  intersectBBoxHook,
  referenceCountCreateHook,
  referenceCountRemoveHook,
  removeServerSideParameters
}, Symbol.toStringTag, { value: "Module" }));
const LISTENERS_KEY = Symbol.for("leaflet-event-listeners");
function bindLeafletEvents(object, events, component, options) {
  object[LISTENERS_KEY] = [];
  events.forEach((eventName) => {
    const listener = (...args) => {
      if (options) component.$engineEvents.emit(eventName, options, ...args);
      else component.$engineEvents.emit(eventName, ...args);
    };
    object[LISTENERS_KEY].push(listener);
    object.on(eventName, listener);
  });
}
function unbindLeafletEvents(object, events) {
  const listeners = object[LISTENERS_KEY];
  if (listeners) {
    events.forEach((eventName, index2) => {
      object.off(eventName, object[LISTENERS_KEY][index2]);
    });
    delete object[LISTENERS_KEY];
  }
}
const TouchEvents = ["touchstart", "touchmove", "touchend", "touchcancel"];
const LeafletEvents = {
  Map: [
    "baselayerchange",
    "overlayadd",
    "overlayremove",
    "layeradd",
    "layerremove",
    "zoomlevelschange",
    "resize",
    "unload",
    "viewreset",
    "load",
    "zoomstart",
    "boxzoomstart",
    "boxselectionstart",
    "movestart",
    "zoom",
    "move",
    "rotate",
    "zoomend",
    "boxzoomend",
    "boxselectionend",
    "moveend",
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "mousemove",
    "contextmenu",
    "keypress",
    "preclick",
    "moveend",
    "zoomanim",
    "fullscreenchange"
  ].concat(TouchEvents),
  Popup: ["add", "remove"],
  Tooltip: ["add", "remove"],
  Layer: ["add", "remove", "popupopen", "popupclose", "tooltipopen", "tooltipclose"],
  Feature: [
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mouseover",
    "mouseout",
    "contextmenu",
    "dragstart",
    "dragend",
    "drag",
    "movestart",
    "moveend",
    "move"
  ].concat(TouchEvents),
  Cluster: ["spiderfied", "unspiderfied"]
};
function buildSVGFromGradientPath(geojson) {
  const defs = [];
  const lines = [];
  const gradient = geojson.properties.gradient;
  const bbox2 = bbox$1(geojson);
  let width = bbox2[2] - bbox2[0];
  let height = bbox2[3] - bbox2[1];
  if (width === 0) width = 0.1;
  if (height === 0) height = 0.1;
  bbox2[0] -= width * 0.1;
  bbox2[1] -= height * 0.1;
  bbox2[2] += width * 0.1;
  bbox2[3] += height * 0.1;
  const b0 = L$1.Projection.SphericalMercator.project(L$1.GeoJSON.coordsToLatLng(bbox2.slice(0, 2)));
  const b1 = L$1.Projection.SphericalMercator.project(L$1.GeoJSON.coordsToLatLng(bbox2.slice(2, 4)));
  const min = { x: Math.min(b0.x, b1.x), y: Math.min(b0.y, b1.y) };
  const max = { x: Math.max(b0.x, b1.x), y: Math.max(b0.y, b1.y) };
  const delta = { x: max.x - min.x, y: max.y - min.y };
  const scale2 = { x: delta.x > delta.y ? 1 : delta.x / delta.y, y: delta.y > delta.x ? 1 : delta.y / delta.x };
  const rescalePoint = (point2) => [scale2.x * ((point2.x - min.x) / delta.x), scale2.y * (1 - (point2.y - min.y) / delta.y)];
  const idSuffix = `${bbox2.join("_")}_${gradient.length}`;
  const latlngs = L$1.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates);
  const coordinates = latlngs.map((latlng) => rescalePoint(L$1.Projection.SphericalMercator.project(latlng)));
  for (let i = 0; i < gradient.length - 1; ++i) {
    const p0 = coordinates[i];
    const p1 = coordinates[i + 1];
    defs.push(`<linearGradient gradientUnits="userSpaceOnUse" x1="${p0[0]}" y1="${p0[1]}" x2="${p1[0]}" y2="${p1[1]}" id="gradient${i}_${idSuffix}"><stop offset="0" stop-color="${gradient[i]}"/><stop offset="1" stop-color="${gradient[i + 1]}"/></linearGradient>`);
    lines.push(`<path d="M ${p0[0]} ${p0[1]} L ${p1[0]} ${p1[1]}" stroke="url(#gradient${i}_${idSuffix})" vector-effect="non-scaling-stroke" class="leaflet-interactive"/>`);
  }
  var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgElement.setAttribute("viewBox", `0 0 ${scale2.x} ${scale2.y}`);
  svgElement.innerHTML = `<g stroke-linecap="round" stroke-width="${geojson.properties.weight}"><defs>${defs.join("")}</defs>${lines.join("")}</g>`;
  return { svg: svgElement, bounds: L$1.latLngBounds(L$1.latLng(bbox2[1], bbox2[0]), L$1.latLng(bbox2[3], bbox2[2])) };
}
const SVGGradientPath = L$1.SVGOverlay.extend({
  initialize(geojson, options) {
    const path2 = buildSVGFromGradientPath(geojson);
    L$1.SVGOverlay.prototype.initialize.call(this, path2.svg, path2.bounds, Object.assign({ interactive: false }, options));
    const opacity = _$1.get(geojson.properties, "opacity");
    if (opacity !== void 0)
      this.setOpacity(opacity);
  },
  getCenter() {
    return this._bounds.getCenter();
  },
  // This method is called when source data changes
  setData(geojson) {
    this.onRemove();
    const path2 = buildSVGFromGradientPath(geojson);
    this._url = path2.svg;
    this._initImage();
    this.setBounds(path2.bounds);
    const opacity = _$1.get(geojson.properties, "opacity");
    if (opacity !== void 0)
      this.setOpacity(opacity);
    this.onAdd();
  },
  onAdd() {
    L$1.SVGOverlay.prototype.onAdd.call(this);
    this.addInteractiveTarget(this._image);
  }
});
const GradientPath = L$1.PixiOverlay.extend({
  initialize(geoJson, options) {
    L$1.setOptions(this, Object.assign({ stroke: "#FFFFFF", weight: 8 }, options));
    this.path = {
      geometry: null,
      bounds: null
    };
    this.rope = null;
    this.container = new PIXI.Container();
    Object.assign(this.container, {
      interactive: true,
      buttonMode: true
    });
    L$1.PixiOverlay.prototype.initialize.call(
      this,
      (utils) => this.render(utils),
      this.container,
      {
        autoPreventDefault: false,
        // see: https://github.com/kalisio/kdk/issues/424
        projectionZoom: () => {
          return 12;
        }
      }
    );
    this.currentZoom = -1;
    if (geoJson) this.setData(geoJson);
  },
  setData(geoJson) {
    const type = _$1.get(geoJson, "type");
    const geometryType = _$1.get(geoJson, "geometry.type");
    const coords = _$1.get(geoJson, "geometry.coordinates");
    if (type !== "Feature" || geometryType !== "LineString" || !Array.isArray(coords)) {
      logger$1.warn("Invalid/Unsupported GeoJson object for Gradient Path");
      return;
    }
    this.path.bounds = new L$1.LatLngBounds();
    coords.forEach((coord) => this.path.bounds.extend([coord[1], coord[0]]));
    const gradient = _$1.get(geoJson, "properties.gradient", _$1.get(geoJson, "properties.stroke", _$1.get(this.options, "stroke")));
    const weight = _$1.get(geoJson, "properties.weight", _$1.get(this.options, "weight"));
    this.path.geometry = { coords, gradient, weight };
    this.currentZoom = -1;
    this.redraw();
  },
  onAdd(map) {
    this.clickEventHandler = this.handleClickEvent.bind(this);
    map.on("click", this.clickEventHandler);
    this.moveEventHandler = this.handleMoveEvent.bind(this);
    map.on("mousemove", this.moveEventHandler);
    L$1.PixiOverlay.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    map.off("click", this.clickEventHandler);
    map.off("mousemove", this.moveEventHandler);
    if (this.rope) {
      this.container.removeChild(this.rope);
      this.rope.texture.destroy(true);
      this.rope.destroy(true);
      this.rope = null;
    }
    this.container.destroy(true);
    L$1.PixiOverlay.prototype.onRemove.call(this, map);
  },
  getBounds() {
    return this.path.bounds;
  },
  getCenter() {
    const mid = Math.floor(this.path.geometry.coords.length / 2);
    const center2 = this.path.geometry.coords[mid];
    return [center2[1], center2[0]];
  },
  getObjectUnderPointer(event) {
    const point2 = new PIXI.Point();
    this.renderer.events.mapPositionToPoint(point2, event.originalEvent.clientX, event.originalEvent.clientY);
    const boundary = new PIXI.EventBoundary(this.container);
    return boundary.hitTest(point2.x, point2.y);
  },
  handleClickEvent(event) {
    if (!this.getPopup()) return;
    const target2 = this.getObjectUnderPointer(event);
    if (target2) {
      if (this.isPopupOpen()) this.closePopup();
      else this.openPopup(event.latlng);
    } else {
      if (this.isPopupOpen()) this.closePopup();
    }
  },
  handleMoveEvent(event) {
    if (!this.getTooltip()) return;
    const target2 = this.getObjectUnderPointer(event);
    if (target2) {
      if (!this.isTooltipOpen()) this.openTooltip();
      this._moveTooltip(event);
    } else {
      if (this.isTooltipOpen()) this.closeTooltip();
    }
  },
  createSolidTexture(color, weight) {
    const canvas = document.createElement("canvas");
    canvas.width = 8;
    canvas.height = weight;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return PIXI.Texture.from(canvas);
  },
  createGradientTexture(gradient, weight) {
    const canvas = document.createElement("canvas");
    canvas.width = gradient.length;
    canvas.height = weight;
    const ctx = canvas.getContext("2d");
    const grd = ctx.createLinearGradient(0, 0, canvas.width, 1);
    for (let i = 0; i < gradient.length; i++) {
      grd.addColorStop(i / (gradient.length - 1), gradient[i]);
    }
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return PIXI.Texture.from(canvas);
  },
  render(utils) {
    const zoom = utils.getMap().getZoom();
    if (zoom !== this.currentZoom) {
      this.renderer = utils.getRenderer();
      let texture = null;
      const weight = Math.max(1, 2048 * this.path.geometry.weight / Math.pow(2, zoom));
      if (Array.isArray(this.path.geometry.gradient)) {
        texture = this.createGradientTexture(this.path.geometry.gradient, weight);
      } else {
        texture = this.createSolidTexture(this.path.geometry.gradient, weight);
      }
      const points = this.path.geometry.coords.map((coord) => utils.latLngToLayerPoint([coord[1], coord[0]]));
      if (this.rope) {
        this.container.removeChild(this.rope);
        this.rope.texture.destroy(true);
        this.rope.destroy(true);
      }
      this.rope = new PIXI.SimpleRope(texture, points);
      this.container.addChild(this.rope);
      this.currentZoom = zoom;
    }
    this.renderer.render(this.container);
  }
});
L$1.GradientPath = GradientPath;
L$1.SVGGradientPath = SVGGradientPath;
L$1.gradientPath = function(options) {
  return new L$1.GradientPath(options);
};
L$1.svgGradientPath = function(options) {
  return new L$1.SVGGradientPath(options);
};
function getObjectValues(object) {
  const values = [];
  const keys = Object.keys(object);
  keys.forEach((key) => values.push(object[key]));
  return values;
}
const Realtime = L$1.Realtime.extend({
  // Override default remove handler for leaflet-realtime due to
  // https://github.com/perliedman/leaflet-realtime/issues/177
  remove(geojson) {
    if (typeof geojson === "undefined") {
      return L$1.Layer.prototype.remove.call(this);
    } else {
      return L$1.Realtime.prototype.remove.call(this, geojson);
    }
  },
  // Add FeatureGroup interface so that layer edition works as well
  toGeoJSON() {
    return { type: "FeatureCollection", features: getObjectValues(this._features) };
  },
  clearLayers() {
    this._onNewData(true, { type: "FeatureCollection", features: [] });
  },
  getLayers() {
    return getObjectValues(this._featureLayers);
  },
  addLayer(geoJsonLayer) {
    this._onNewData(false, geoJsonLayer.toGeoJSON());
  },
  removeLayer(geoJsonLayer) {
    this.remove(geoJsonLayer.toGeoJSON());
  },
  // Additional missing features
  bringToFront() {
    if (this.options.pane !== "overlayPane") {
      L$1.DomUtil.toFront(this.getPane(this.options.pane));
    } else if (this._container) {
      this._container.bringToFront();
    }
  },
  bringToBack() {
    if (this.options.pane !== "overlayPane") {
      L$1.DomUtil.toBack(this.getPane(this.options.pane));
    } else if (this._container) {
      this._container.bringToBack();
    }
  }
});
L$1.realtime = function(src, options) {
  return new Realtime(src, options);
};
const MarkerClusterGroup = L$1.MarkerClusterGroup.extend({
  // Override invoke as used by eg bringToFront/bringToBack
  invoke(methodName, ...args) {
    L$1.MarkerClusterGroup.prototype.invoke.call(this, methodName, args);
    this._featureGroup.invoke(methodName, args);
    this._nonPointGroup.invoke(methodName, args);
    return this;
  }
});
L$1.markerClusterGroup = function(options) {
  return new MarkerClusterGroup(options);
};
const simplifyPoints = L$1.Polyline.prototype._simplifyPoints;
L$1.Polyline.include({
  _simplifyPoints: function() {
    simplifyPoints.call(this);
    if (this.options.offset) {
      const latitude = this.getBounds().getCenter().lat;
      const factor = 156543 / Math.pow(2, this._map.getZoom()) / Math.cos(latitude * Math.PI / 180);
      const offset = Math.max(1, this.options.offset * factor);
      for (let i = 0; i < this._parts.length; i++) {
        let latLngs = this._parts[i].map((point2) => this._map.layerPointToLatLng(point2));
        const coords = L$1.GeoJSON.latLngsToCoords(latLngs, 0, false, 12);
        const feature2 = lineOffset({ type: "LineString", coordinates: coords }, offset, { units: "meters" });
        latLngs = L$1.GeoJSON.coordsToLatLngs(feature2.geometry.coordinates, 0);
        this._parts[i] = latLngs.map((latlng) => this._map.latLngToLayerPoint(latlng));
      }
    }
  }
});
const geometryToLayer = L$1.GeoJSON.geometryToLayer;
L$1.GeoJSON.geometryToLayer = function(geojson, options) {
  const geometry = geojson.geometry;
  const properties = geojson.properties;
  if (geometry && properties && properties.geodesic) {
    if (geometry.type === "LineString") {
      return new L$1.Geodesic(
        [L$1.GeoJSON.coordsToLatLngs(geometry.coordinates, 0)],
        Object.assign({ steps: 4 }, options.style(geojson))
      );
    } else if (geometry.type === "MultiLineString") {
      const coords = geometry.coordinates.map((lineString2) => L$1.GeoJSON.coordsToLatLngs(lineString2, 0));
      return new L$1.Geodesic(coords, Object.assign({ steps: 4 }, options.style(geojson)));
    } else if (geometry.type === "Point") {
      const layer3 = new L$1.GeodesicCircle(
        L$1.GeoJSON.coordsToLatLng(geometry.coordinates),
        Object.assign({ fill: true, steps: 360, radius: properties.radius }, options.style(geojson))
      );
      return layer3;
    }
  }
  if (geometry && properties && properties.gradient) {
    const style2 = options.style(geojson);
    return properties.svg ? new SVGGradientPath(geojson, style2) : new GradientPath(geojson, style2);
  }
  if (geometry && properties && properties.mask) {
    if (geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
      return new MaskLayer(geojson, options.style(geojson));
    }
  }
  if (geometry && properties && properties.offset) {
    if (geometry.type === "LineString") {
      options = Object.assign({ offset: properties.offset }, options);
    }
  }
  const layer2 = geometryToLayer(geojson, options);
  if (geometry && (options.arrowheads || properties && properties.arrowheads)) {
    if (layer2 instanceof L$1.Polyline) layer2.arrowheads(options.arrowheads || properties.arrowheads);
  }
  return layer2;
};
function getUpdateFeatureFunction(leafletOptions) {
  const updateFeature = (feature2, oldLayer) => {
    if (!oldLayer) return;
    const oldType = _$1.get(oldLayer, "feature.geometry.type");
    const type = _$1.get(feature2, "geometry.type");
    const staticGeometry = _$1.get(leafletOptions, "staticGeometry", false);
    if (!staticGeometry && type !== oldType) return;
    if (staticGeometry) feature2.geometry = _$1.get(oldLayer, "feature.geometry");
    leafletOptions.onEachFeature(feature2, oldLayer);
    if (oldLayer.setStyle) {
      if (feature2.geometry.type === "Point") {
        return;
      } else {
        if (_$1.get(oldLayer.feature, "style.pane") !== _$1.get(feature2, "style.pane")) return;
        else oldLayer.setStyle(leafletOptions.style(feature2));
      }
    }
    _$1.defaultsDeep(feature2, _$1.pick(oldLayer.feature, ["time", "runTime"]));
    const oldProps = _$1.get(oldLayer.feature, "properties");
    if (oldProps) {
      if (!feature2.properties) feature2.properties = {};
      _$1.defaults(feature2.properties, oldProps);
    }
    if (oldLayer.setIcon) {
      return;
    }
    if (staticGeometry) return oldLayer;
    const coordinates = feature2.geometry.coordinates;
    switch (type) {
      case "Point":
        oldLayer.setLatLng(L$1.GeoJSON.coordsToLatLngs(coordinates));
        break;
      case "LineString":
      case "MultiLineString":
        if (typeof oldLayer.setData === "function") {
          oldLayer.setData(feature2);
        } else if (feature2.properties.geodesic) {
          const latlngs = type === "LineString" ? [L$1.GeoJSON.coordsToLatLngs(coordinates, 0)] : coordinates.map((linestring) => L$1.GeoJSON.coordsToLatLngs(linestring, 0));
          oldLayer.setLatLngs(latlngs);
        } else {
          oldLayer.setLatLngs(L$1.GeoJSON.coordsToLatLngs(coordinates, type === "LineString" ? 0 : 1));
        }
        break;
      case "Polygon":
      case "MultiPolygon":
        oldLayer.setLatLngs(L$1.GeoJSON.coordsToLatLngs(coordinates, type === "Polygon" ? 1 : 2));
        break;
    }
    return oldLayer;
  };
  return updateFeature;
}
const GeoJsonLeafletLayerFilters = {
  // Filter to identify layers that require an update at a given frequency
  TimeUpdate: {
    // Possible for realtime layers only
    "leaflet.type": "geoJson",
    "leaflet.realtime": true,
    $or: [
      // Supported by template URL or time-based features service
      { "leaflet.sourceTemplate": { $exists: true } },
      { service: { $exists: true } }
    ],
    // Skip layers powered by realtime service events
    serviceEvents: { $ne: true },
    // Skip invisible layers
    isVisible: true
  },
  // Filter to identify layers with variables affected by a unit change
  UnitUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": true,
    // Not sure why but this does not seem to work with sift
    //'variables': { $elemMatch: { unit: { $in: units } } },
    "variables": { $exists: true },
    isVisible: true,
    $or: [{
      "leaflet.style": { $exists: true },
      "leaflet.template": { $exists: true }
    }, {
      "leaflet.tooltip.template": { $exists: true }
    }]
  },
  // Filter to identify layers with tooltip defining a minZoom/maxZoom
  // thus affected by a zoom change
  TooltipUpdate: {
    "leaflet.type": "geoJson",
    "leaflet.realtime": true,
    isVisible: true,
    // Supported by permanent tooltips only
    "leaflet.tooltip.options.permanent": true,
    $or: [
      { "leaflet.tooltip.minZoom": { $exists: true } },
      { "leaflet.tooltip.maxZoom": { $exists: true } }
    ]
  }
};
function hasUnitInLeafletLayerTemplate(units, layer2) {
  const unit = _$1.intersection(units, _$1.map(layer2.variables, "unit"));
  if (_$1.isEmpty(unit)) return false;
  if (_$1.get(layer2, "leaflet.tooltip.template", "").includes("Units")) return true;
  for (const template of layer2.leaflet.template) {
    if (template.startsWith("style.")) {
      const style2 = _$1.get(layer2.leaflet, template);
      if (typeof style2 === "string" && style2.includes("Units")) return true;
    }
  }
  return false;
}
function getHtmlTable(properties) {
  properties = dotify(properties);
  properties = _$1.pickBy(properties, (value) => !_$1.isNil(value));
  const keys = _$1.keys(properties);
  let html;
  if (keys.length === 0) return null;
  else if (keys.length === 1) html = _$1.get(properties, keys[0]);
  else {
    const borderStyle = ' style="border: 1px solid black; border-collapse: collapse;"';
    html = "<table" + borderStyle + ">";
    html += keys.map((key) => "<tr" + borderStyle + "><th" + borderStyle + ">" + key + "</th><th>" + _$1.get(properties, key) + "</th></tr>").join("");
    html += "</table>";
  }
  return html;
}
const IconStyleToSimpleStyle = {
  size: "marker-size",
  color: "marker-color",
  url: "marker-symbol"
};
const PointStyleToSimpleStyle = {
  shape: "marker-symbol",
  size: "marker-size",
  color: "marker-color",
  "icon.url": "marker-symbol"
};
const SimpleStyleToPointStyle = {
  fill: "color",
  "fill-opacity": "opacity",
  radius: "radius",
  stroke: "stroke.color",
  "marker-symbol": "shape",
  "marker-size": "size",
  "marker-color": "color",
  "marker-anchor": "anchor",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  "icon": "icon.url",
  "icon-url": "icon.url",
  "icon-html": "html",
  "icon-color": "icon.color",
  "icon-size": "icon.size",
  "icon-anchor": "anchor",
  "icon-class": "icon.classes",
  "icon-opacity": "icon.opacity",
  "icon-classes": "icon.classes",
  "icon-translate": "icon.translate",
  "icon-rotate": "icon.rotate",
  "z-index": "pane",
  pane: "pane"
};
const PointStyleTemplateMappings = {
  stroke: "style.point.stroke.color",
  "stroke-color": "style.point.stroke.color",
  "stroke-opacity": "style.point.stroke.opacity",
  "stroke-width": "style.point.stroke.width",
  fill: "style.point.color",
  "fill-opacity": "style.point.opacity",
  "fill-color": "style.point.color",
  weight: "style.point.stroke.width",
  radius: "style.point.radius",
  "line-cap": "style.point.stroke.lineCap",
  "line-join": "style.point.stroke.lineJoin",
  "dash-array": "style.point.stroke.dashArray",
  "dash-offset": "style.point.stroke.dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-translate": "style.point.icon.translate",
  "z-index": "style.point.pane",
  pane: "style.point.pane"
};
const LineStyleToSimpleStyle = {
  color: "stroke",
  width: "stroke-width",
  opacity: "stroke-opacity"
};
const SimpleStyleToLineStyle = {
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "width",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  weight: "width",
  "z-index": "pane",
  pane: "pane"
};
const LineStyleTemplateMappings = {
  stroke: "style.line.color",
  "stroke-color": "style.line.color",
  "stroke-opacity": "style.line.opacity",
  "stroke-width": "style.line.width",
  weight: "style.line.width",
  "line-cap": "style.line.cap",
  "line-join": "style.line.join",
  "dash-array": "style.line.dashArray",
  "dash-offset": "style.line.dashOffset",
  "z-index": "style.line.pane",
  pane: "style.line.pane"
};
const PolygonStyleToSimpleStyle = {
  color: "fill",
  opacity: "fill-opacity"
};
const SimpleStyleToPolygonStyle = {
  stroke: "stroke.color",
  "stroke-color": "stroke.color",
  "stroke-opacity": "stroke.opacity",
  "stroke-width": "stroke.width",
  fill: "color",
  "fill-color": "color",
  "fill-opacity": "opacity",
  "z-index": "pane",
  pane: "pane"
};
const PolygonStyleTemplateMappings = {
  stroke: "style.polygon.stroke.color",
  "stroke-color": "style.polygon.stroke.color",
  "stroke-opacity": "style.polygon.stroke.opacity",
  "stroke-width": "style.polygon.stroke.width",
  fill: "style.polygon.color",
  "fill-opacity": "style.polygon.opacity",
  "fill-color": "style.polygon.color",
  weight: "style.polygon.stroke.width",
  "line-cap": "style.polygon.stroke.cap",
  "line-join": "style.polygon.stroke.join",
  "dash-array": "style.polygon.stroke.dashArray",
  "dash-offset": "style.polygon.stroke.dashOffset",
  "z-index": "style.polygon.pane",
  pane: "style.polygon.pane"
};
const SimpleStyleNumbers = ["marker-size", "stroke-width", "stroke-opacity", "fill-opacity"];
const DefaultStyle = {
  isVisible: true,
  isSelectable: true,
  point: {
    color: "red",
    opacity: 0.5,
    size: 24,
    shape: "circle",
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    },
    icon: {
      classes: "",
      color: "black",
      opacity: 1,
      size: 12
    }
  },
  line: {
    color: "red",
    width: 3,
    opacity: 1
  },
  polygon: {
    color: "red",
    opacity: 0.5,
    stroke: {
      color: "red",
      width: 3,
      opacity: 1
    }
  },
  leaflet: {
    cluster: { disableClusteringAtZoom: 18 }
  },
  cesium: {
    cluster: { pixelRange: 80 }
  }
};
function convertStyle(style2, mapping, asNumber = []) {
  let convertedStyle = {};
  _$1.forOwn(style2, (value, key) => {
    const mappedKey = _$1.get(mapping, key);
    if (mappedKey) _$1.set(convertedStyle, mappedKey, asNumber.includes(mappedKey) ? _$1.toNumber(value) : value);
  });
  return convertedStyle;
}
function convertSimpleStyleColors(style2) {
  _$1.forOwn(style2, (value, key) => {
    if (["stroke", "fill", "marker-color"].includes(key)) {
      const color = getCssVar(value);
      if (color) _$1.set(style2, key, color);
    }
  });
  return style2;
}
function convertPointStyleToSimpleStyle(style2) {
  return style2 ? Object.assign(convertStyle(style2.icon, IconStyleToSimpleStyle, SimpleStyleNumbers), convertStyle(style2, PointStyleToSimpleStyle, SimpleStyleNumbers)) : {};
}
function convertSimpleStyleToPointStyle(style2) {
  return style2 ? convertStyle(style2, SimpleStyleToPointStyle) : {};
}
function convertLineStyleToSimpleStyle(style2) {
  return style2 ? convertStyle(style2, LineStyleToSimpleStyle, SimpleStyleNumbers) : {};
}
function convertSimpleStyleToLineStyle(style2) {
  return style2 ? convertStyle(style2, SimpleStyleToLineStyle) : {};
}
function convertPolygonStyleToSimpleStyle(style2) {
  return style2 ? Object.assign(convertStyle(style2, PolygonStyleToSimpleStyle, SimpleStyleNumbers), convertLineStyleToSimpleStyle(style2.stroke)) : {};
}
function convertSimpleStyleToPolygonStyle(style2) {
  return style2 ? convertStyle(style2, SimpleStyleToPolygonStyle) : {};
}
function getShapeFromPointStyle(style2, size = [20, 20]) {
  let stroke = _$1.get(style2, "stroke");
  if (stroke) {
    let width = _$1.get(stroke, "width", 1);
    if (width > 1) width = width / 4;
    stroke = { stroke: { width } };
  }
  return _$1.merge({}, style2, { size }, stroke);
}
function getShapeFromLineStyle(style2, size = [20, 20]) {
  let width = _$1.get(style2, "width", 1);
  if (width > 1) width = width / 4;
  return { shape: "polyline", stroke: _$1.merge({}, style2, { width }), size };
}
function getShapeFromPolygonStyle(style2, size = [20, 20]) {
  let stroke = _$1.get(style2, "stroke");
  if (stroke) {
    let width = _$1.get(stroke, "width", 1);
    if (width > 1) width = width / 4;
    stroke = { stroke: { width } };
  }
  return _$1.merge({}, style2, { shape: "polygon" }, { size }, stroke);
}
function getDefaultStyleFromTemplates(options) {
  const out = {};
  options = dotify(options);
  _$1.forIn(options, (value, key) => {
    if (!_$1.isString(value)) {
      _$1.set(out, key, value);
      return;
    }
    const match = value.match(/} else { %>(.*)<% } %>/);
    if (match) {
      _$1.set(out, key, match[1]);
    } else {
      _$1.set(out, key, value);
    }
  });
  return out;
}
function generateStyleTemplates(defaultStyle, styles, dotify$1 = true) {
  const hasStyles = styles.length > 0;
  const options = {};
  const properties = _$1.keys(dotify(_$1.pick(DefaultStyle, ["point", "line", "polygon"])));
  const templates = properties.map((property) => "");
  styles.forEach((style2) => {
    let predicate = "";
    style2.conditions.forEach((condition, index2) => {
      const boolOp = index2 === 0 ? "" : condition.booleanOperator === "and" ? " && " : " || ";
      const name = typeof condition.value !== "number" ? `${condition.property}.toString()` : condition.property;
      if (["in", "nin"].includes(condition.comparisonOperator)) {
        const value = condition.value.map((v) => typeof v !== "number" ? `"${v}"` : v).join(",");
        const not = condition.comparisonOperator === "nin" ? "!" : "";
        predicate += `${boolOp}${not}[${value}].includes(properties.${name})`;
      } else {
        const compOp = { eq: "===", ne: "!==", gt: ">", gte: ">=", lt: "<", lte: "<=" }[condition.comparisonOperator];
        const value = typeof condition.value !== "number" ? `"${condition.value}"` : condition.value;
        predicate += `${boolOp}properties.${name} ${compOp} ${value}`;
      }
    });
    properties.forEach((property, index2) => {
      if (!_$1.has(style2.values, property)) return;
      const value = property.includes("color") ? getColorFromPalette(_$1.get(style2.values, property)) : _$1.get(style2.values, property);
      templates[index2] += `if (${predicate}) { %>${value}<% } else `;
    });
  });
  properties.forEach((property, index2) => {
    if (!_$1.has(defaultStyle, property)) return;
    const value = property.includes("color") ? getColorFromPalette(_$1.get(defaultStyle, property)) : _$1.get(defaultStyle, property);
    if (hasStyles) templates[index2] += `{ %>${value}<% }`;
    else templates[index2] = value;
  });
  properties.forEach((property, index2) => {
    if (!_$1.has(defaultStyle, property)) return;
    if (dotify$1) options[`style.${property}`] = hasStyles ? `<% ${templates[index2]} %>` : templates[index2];
    else _$1.set(options, `style.${property}`, hasStyles ? `<% ${templates[index2]} %>` : templates[index2]);
  });
  options.template = (hasStyles ? properties : []).map((property) => `style.${property}`);
  return options;
}
function filterQueryToConditions(query) {
  const deepParseQuery = (subquery, conditions2, nextBooleanOperator = null) => {
    if (!subquery) return;
    const nextBoolOp = _$1.keys(subquery)[0];
    let property;
    let comparisonOperator;
    let value;
    if (nextBoolOp === "$and" || nextBoolOp === "$or") {
      property = _$1.keys(subquery[nextBoolOp][0])[0];
      comparisonOperator = _$1.keys(subquery[nextBoolOp][0][property])[0];
      value = subquery[nextBoolOp][0][property][comparisonOperator];
    } else {
      property = _$1.keys(subquery)[0];
      if (!_$1.isObject(subquery[property])) {
        comparisonOperator = "$eq";
        value = subquery[property];
      } else {
        comparisonOperator = _$1.keys(subquery[property])[0];
        value = subquery[property][comparisonOperator];
      }
    }
    conditions2.push({
      index: conditions2.length,
      booleanOperator: nextBooleanOperator ? nextBooleanOperator.replace("$", "") : nextBooleanOperator,
      property: property.replace("properties.", ""),
      comparisonOperator: comparisonOperator.replace("$", ""),
      value
    });
    if (nextBoolOp === "$and" || nextBoolOp === "$or") {
      deepParseQuery(subquery[nextBoolOp][1], conditions2, nextBoolOp);
    }
  };
  const conditions = [];
  deepParseQuery(query, conditions);
  return conditions;
}
const ShapeMarker = L$1.Marker.extend({
  // Constructor
  initialize(latlng, options) {
    const markerOptions = _$1.get(options, "options", {});
    Object.assign(markerOptions, _$1.pick(options, ["interactive", "draggable", "pane", "shadowPane"]));
    if (options.icon instanceof L$1.Icon) {
      L$1.Marker.prototype.initialize.call(this, latlng, {
        icon: options.icon,
        ...markerOptions
      });
    } else {
      const shape = createShape(options);
      if (shape) {
        L$1.Marker.prototype.initialize.call(this, latlng, {
          icon: L$1.divIcon({
            iconSize: [shape.size.width, shape.size.height],
            iconAnchor: this.getAnchor(shape.anchor, shape.size),
            popupAnchor: [0, -shape.size.height / 2],
            html: shape.html,
            className: ""
          }),
          ...markerOptions
        });
      } else {
        logger$1.warn(`[KDK] unable to create the shape with the options: ${options}`);
      }
    }
  },
  getAnchor(position2, size) {
    if (position2 === "top-left") return [0, 0];
    if (position2 === "top-center") return [size.width / 2, 0];
    if (position2 === "top-right") return [size.width, 0];
    if (position2 === "middle-left") return [0, size.height / 2];
    if (position2 === "middle-right") return [size.width, size.height / 2];
    if (position2 === "middle-left") return [0, size.height / 2];
    if (position2 === "bottom-left") return [0, size.height];
    if (position2 === "bottom-center") return [size.width / 2, size.height];
    if (position2 === "bottom-right") return [size.width, size.height];
    return [size.width / 2, size.height / 2];
  },
  // Additional missing features
  bringToFront() {
    if (this._icon) L$1.DomUtil.toFront(this._icon);
    if (this._shadow) L$1.DomUtil.toFront(this._shadow);
  },
  bringToBack() {
    if (this._icon) L$1.DomUtil.toBack(this._icon);
    if (this._shadow) L$1.DomUtil.toBack(this._shadow);
  }
});
L$1.shapeMarker = function(latlng, options) {
  return new ShapeMarker(latlng, options);
};
const LeafletStyleMappings = {
  "z-index": "pane",
  pane: "pane",
  stroke: "color",
  "stroke-color": "color",
  "stroke-opacity": "opacity",
  "stroke-width": "weight",
  fill: "fillColor",
  "fill-opacity": "fillOpacity",
  "fill-color": "fillColor",
  weight: "weight",
  radius: "radius",
  "line-cap": "lineCap",
  "line-join": "lineJoin",
  "dash-array": "dashArray",
  "dash-offset": "dashOffset",
  "marker-symbol": "style.point.shape",
  "marker-size": "style.point.size",
  "marker-color": "style.point.color",
  "marker-anchor": "style.point.anchor",
  "icon-url": "style.point.icon.url",
  "icon-html": "style.point.html",
  "icon-color": "style.point.icon.color",
  "icon-size": "style.point.icon.size",
  "icon-anchor": "style.point.anchor",
  "icon-class": "style.point.icon.classes",
  "icon-opacity": "style.point.icon.opacity",
  "icon-classes": "style.point.icon.classes",
  "icon-x-offset": "style.point.icon.xOffset",
  "icon-y-offset": "style.point.icon.yOffset",
  "style-line-color": "color",
  "style-line-width": "weight",
  "style-line-opacity": "opacity",
  "style-line-cap": "lineCap",
  "style-line-join": "lineJoin",
  "style-line-dash-array": "dashArray",
  "style-line-dash-offset": "dashOffset",
  "style-polygon-color": "fillColor",
  "style-polygon-opacity": "fillOpacity",
  "style-polygon-rule": "fillRule",
  "style-polygon-stroke-color": "color",
  "style-polygon-stroke-width": "weight",
  "style-polygon-stroke-opacity": "opacity",
  "style-polygon-stroke-cap": "lineCap",
  "style-polygon-stroke-join": "lineJoin",
  "style-polygon-stroke-dash-array": "dashArray",
  "style-polygon-stroke-dash-offset": "dashOffset"
};
const LineStyleToLeafletPath = {
  color: "color",
  width: "weight",
  opacity: "opacity",
  cap: "lineCap",
  join: "lineJoin",
  dashArray: "dashArray",
  dashOffset: "dashOffset",
  pane: "pane"
};
const PolygonStyleToLeafletPath = {
  color: "fillColor",
  opacity: "fillOpacity",
  rule: "fillRule",
  pane: "pane"
};
function convertToLeafletFromSimpleStyleSpec(style2, inPlace) {
  if (!style2) return {};
  const leafletStyle = inPlace ? style2 : {};
  let isIconSpec = _$1.has(style2, "icon");
  if (isIconSpec) _$1.set(leafletStyle, "icon", _$1.get(style2, "icon"));
  _$1.forOwn(style2, (value, key) => {
    if (_$1.has(LeafletStyleMappings, key)) {
      const mapping = _$1.get(LeafletStyleMappings, key);
      switch (key) {
        case "marker-size":
        case "marker-anchor":
        case "icon-anchor":
          if (!Array.isArray(value)) value = [value, value];
          _$1.set(leafletStyle, mapping, value);
          break;
        default:
          _$1.set(leafletStyle, mapping, value);
      }
      if (inPlace) _$1.unset(style2, key);
      if (mapping.startsWith("icon")) isIconSpec = true;
    }
  });
  if (isIconSpec) {
    if (!_$1.has(style2, "marker.type")) {
      if (_$1.has(style2, "icon-url") || _$1.has(style2, "icon-html")) _$1.set(leafletStyle, "type", "marker");
      else if (_$1.has(style2, "icon-classes")) _$1.set(leafletStyle, "type", "shapeMarker");
    }
  }
  if (_$1.has(leafletStyle, "pane")) _$1.set(leafletStyle, "pane", _$1.get(leafletStyle, "pane").toString());
  if (_$1.has(leafletStyle, "shadowPane")) _$1.set(leafletStyle, "shadowPane", _$1.get(leafletStyle, "shadowPane").toString());
  return leafletStyle;
}
function createMarkerFromPointStyle(latlng, style2) {
  if (!latlng) {
    logger$1.warn(`[KDK] 'latlng' should be defined`);
    return;
  }
  const shape = _$1.get(style2, "shape", "circle");
  if (shape === "none" || _$1.has(Shapes, shape)) return L$1.shapeMarker(latlng, style2);
  return L$1[shape](latlng, style2);
}
function convertLineStyleToLeafletPath(style2) {
  if (!style2) return;
  let leafletStyle = convertStyle(style2, LineStyleToLeafletPath);
  leafletStyle.color = getHtmlColor(leafletStyle.color, "black");
  return leafletStyle;
}
function convertPolygonStyleToLeafletPath(style2) {
  if (!style2) return;
  let leafletStyle = convertStyle(style2, PolygonStyleToLeafletPath);
  if (style2.stroke) Object.assign(leafletStyle, convertLineStyleToLeafletPath(style2.stroke));
  else leafletStyle.stroke = false;
  leafletStyle.fillColor = getHtmlColor(leafletStyle.fillColor, "black");
  return leafletStyle;
}
function processStyle$1(style2, feature2, options, mappings, zoom) {
  if (!options) return;
  const leafletOptions = options.leaflet || options;
  const context2 = Object.assign({ properties: feature2.properties, feature: feature2, zoom, chroma, moment, Units, Time }, TemplateContext.get());
  if (leafletOptions.template) {
    if (options.variables) context2.variables = _$1.reduce(
      options.variables,
      (result, variable) => Object.assign(result, { [variable.name]: variable }),
      {}
    );
    leafletOptions.template.forEach((entry) => {
      _$1.set(style2, _$1.get(mappings, _$1.kebabCase(entry.property), entry.property), entry.compiler(context2));
    });
  }
  const type = getFeatureStyleType(feature2);
  let visibility = _$1.get(style2, `style.${type}.visibility`, _$1.get(style2, "style.visibility", true));
  if (typeof visibility === "string") visibility = visibility === "true";
  if (!visibility) _$1.set(style2, `style.${type}.pane`, "kdk-hidden-features");
  if (leafletOptions.pane && !_$1.has(style2, `style.${type}.pane`)) _$1.set(style2, `style.${type}.pane`, leafletOptions.pane);
  if (leafletOptions.shadowPane && !_$1.has(style2, `style.${type}.shadowPane`)) _$1.set(style2, `style.${type}.shadowPane`, leafletOptions.shadowPane);
  if (_$1.has(leafletOptions, "interactive") && !_$1.has(style2, `style.${type}.interactive`)) _$1.set(style2, `style.${type}.interactive`, leafletOptions.interactive);
  return style2;
}
function getDefaultPointStyle(feature2, options, engineStyle = {}, zoom) {
  const layerStyle = options ? _$1.get(options.leaflet || options, "layerPointStyle") : {};
  const templateStyle = processStyle$1({ style: { point: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, PointStyleTemplateMappings, zoom);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : feature2.style ? _$1.get(feature2, "style", {}) : convertSimpleStyleToPointStyle(feature2.properties);
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.point : {}, featureStyle);
  return style2;
}
function getDefaultLineStyle(feature2, options, engineStyle = {}, zoom) {
  const layerStyle = options ? _$1.get(options.leaflet || options, "layerLineStyle") : {};
  const templateStyle = processStyle$1({ style: { line: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, LineStyleTemplateMappings, zoom);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : feature2.style ? _$1.get(feature2, "style", {}) : convertSimpleStyleToLineStyle(feature2.properties);
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.line : {}, featureStyle);
  return convertLineStyleToLeafletPath(style2);
}
function getDefaultPolygonStyle(feature2, options, engineStyle = {}, zoom) {
  const layerStyle = options ? _$1.get(options.leaflet || options, "layerPolygonStyle") : {};
  const templateStyle = processStyle$1({ style: { polygon: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, PolygonStyleTemplateMappings, zoom);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : feature2.style ? _$1.get(feature2, "style", {}) : convertSimpleStyleToPolygonStyle(feature2.properties);
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.polygon : {}, featureStyle);
  return convertPolygonStyleToLeafletPath(style2);
}
function tile2key$1(coords) {
  return coords.x * 536870912 + coords.y * 32 + coords.z;
}
function key2tile$1(key) {
  const x = Math.floor(key / 536870912);
  const y = Math.floor((key - x * 536870912) / 32);
  const p = L.point(x, y);
  p.z = key - (x * 536870912 + y * 32);
  return p;
}
function tileSetContainsParent(tileset, coords) {
  const triplet = {
    x: coords.x,
    y: coords.y,
    z: coords.z
  };
  while (triplet.z > 1) {
    const tilekey = tile2key$1(triplet);
    if (tileset.has(tilekey)) return true;
    triplet.x = Math.floor(triplet.x / 2);
    triplet.y = Math.floor(triplet.y / 2);
    triplet.z -= 1;
  }
  return false;
}
function getParentTileInTileSet(tileset, coords) {
  const triplet = {
    x: coords.x,
    y: coords.y,
    z: coords.z
  };
  triplet.x = Math.floor(triplet.x / 2);
  triplet.y = Math.floor(triplet.y / 2);
  triplet.z -= 1;
  while (triplet.z > 1) {
    const tilekey = tile2key$1(triplet);
    if (tileset.has(tilekey)) return triplet;
    triplet.x = Math.floor(triplet.x / 2);
    triplet.y = Math.floor(triplet.y / 2);
    triplet.z -= 1;
  }
  return void 0;
}
function computeIdealMaxNativeZoom(gridLayer, dataSetBounds, dataSetTileSize) {
  const nw = dataSetBounds.getNorthWest();
  let z = 1;
  while (true) {
    const nwPoint = gridLayer._map.project(nw, z);
    const coords = nwPoint.unscaleBy(gridLayer.getTileSize());
    coords.x = Math.floor(coords.x);
    coords.y = Math.floor(coords.y);
    coords.z = z;
    const tileBounds = gridLayer._tileCoordsToBounds(coords);
    const tileWidth = tileBounds.getEast() - tileBounds.getWest();
    const tileHeight = tileBounds.getNorth() - tileBounds.getSouth();
    if (tileWidth < dataSetTileSize.lng || tileHeight < dataSetTileSize.lat) break;
    z += 1;
  }
  return Math.max(1, z - 1);
}
const InternalLayerProperties = ["actions", "label", "isVisible", "isDisabled"];
function isInMemoryLayer(layer2) {
  return layer2._id === void 0;
}
function isUserLayer(layer2) {
  return _$1.get(layer2, "scope") === "user";
}
function isFeatureLayer(layer2) {
  return _$1.get(layer2, "service") === "features";
}
function hasFeatureSchema(layer2) {
  return _$1.has(layer2, "schema");
}
function isLayerSelectable(layer2) {
  return _$1.get(layer2, "isSelectable", true);
}
function isLayerHighlightable(layer2) {
  return _$1.get(layer2, "isHighlightable", true);
}
function isLayerProbable(layer2) {
  return _$1.get(layer2, "isProbable", false);
}
function isLayerStorable(layer2) {
  if (layer2._id) return false;
  return _$1.get(layer2, "isStorable", isUserLayer(layer2));
}
function isLayerEditable(layer2) {
  return _$1.get(layer2, "isEditable", isUserLayer(layer2));
}
function isLayerCachable(layer2) {
  return _$1.get(layer2, "isCachable", layer2.type === "BaseLayer" || _$1.has(layer2, "service") || _$1.get(layer2, "leaflet.type") === "pmtiles" || _$1.get(layer2, "leaflet.type") === "geoJson");
}
async function isLayerCached(layer2) {
  const isCached = await LocalCache.has(_$1.get(layer2, "leaflet.source"));
  return isCached;
}
async function setLayerCached(layer2, options) {
  if (!isLayerCachable(layer2)) return;
  if (layer2.type === "BaseLayer") {
    await setBaseLayerCached(layer2, options);
  } else if (layer2.service) {
    await setServiceLayerCached(layer2, options);
  } else if (_$1.get(layer2, "leaflet.type") === "geoJson") {
    await setGeojsonLayerCached(layer2);
  } else if (_$1.get(layer2, "leaflet.type") === "pmtiles") {
    await setPMTilesLayerCached(layer2, options);
  }
}
async function cacheLayerTile(urlTemplate, x, y, z) {
  const url = urlTemplate.replace("{z}", z).replace("{x}", x).replace("{y}", y);
  const key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.set("layers", key.href, url);
}
async function setBaseLayerCached(layer2, options) {
  const bounds = options.bounds;
  const minZoom = options.minZoom || 3;
  const maxZoom = options.maxZoom || _$1.get(layer2, "leaflet.maxNativeZoom");
  const nbConcurrentRequests = options.nbConcurrentRequests || 10;
  const urlTemplate = _$1.get(layer2, "leaflet.source");
  let promises = [];
  for (let z = minZoom; z <= maxZoom; z++) {
    let sm = new SphericalMercator();
    let tilesBounds = sm.xyz([bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]], z, _$1.get(layer2, "leaflet.tms"));
    for (let y = tilesBounds.minY; y <= tilesBounds.maxY; y++) {
      for (let x = tilesBounds.minX; x <= tilesBounds.maxX; x++) {
        promises.push(cacheLayerTile(urlTemplate, x, y, z));
        if (promises.length === nbConcurrentRequests) {
          await Promise.all(promises);
          promises = [];
        }
      }
    }
  }
  promises.push(cacheLayerTile(urlTemplate, 0, 0, 0));
  if (layer2.iconUrl) promises.push(cacheLayerTile(layer2.iconUrl));
  await Promise.all(promises);
}
async function setServiceLayerCached(layer2, options) {
  await api.createOfflineFeaturesService(layer2.service, {
    baseQuery: {
      south: options.bounds[0][0],
      north: options.bounds[1][0],
      west: options.bounds[0][1],
      east: options.bounds[1][1]
    },
    clear: false
  });
}
async function setGeojsonLayerCached(layer2) {
  const url = _$1.get(layer2, "leaflet.source");
  let key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.set("layers", key.href, url);
}
async function getPMTileRange(pmtiles, x, y, z, directoryRanges) {
  const tileId = zxyToTileId(z, x, y);
  const header = await pmtiles.getHeader();
  let dO = header.rootDirectoryOffset;
  let dL = header.rootDirectoryLength;
  for (let depth = 0; depth <= 3; depth++) {
    directoryRanges.add(`${dO}-${dO + dL - 1}`);
    const directory = await pmtiles.cache.getDirectory(pmtiles.source, dO, dL, header);
    const entry = findTile(directory, tileId);
    if (entry) {
      if (entry.runLength > 0) {
        return {
          start: header.tileDataOffset + entry.offset,
          end: header.tileDataOffset + entry.offset + entry.length - 1
        };
      }
      dO = header.leafDirectoryOffset + entry.offset;
      dL = entry.length;
    } else {
      return;
    }
  }
}
async function cacheLayerPMTile(url, pmtiles, x, y, z, directoryRanges) {
  const key = new URL(url);
  key.searchParams.delete("jwt");
  const data = await pmtiles.getZxy(z, x, y);
  if (!data) return;
  const range = await getPMTileRange(pmtiles, x, y, z, directoryRanges);
  await LocalCache.set("layers", `${key.href}/${range.start}/${range.end}`, url, { headers: { Range: `bytes=${range.start}-${range.end}` } });
}
async function cachePMTilesHeaderAndDirectory(url, pmtiles, directory) {
  const key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.set("layers", `${key.href}/0/16383`, url, { headers: { Range: `bytes=0-16383` } });
  directory = Array.from(directory);
  for (let i = 0; i < directory.length; i++) {
    const entry = directory[i];
    await LocalCache.set("layers", `${key.href}/${entry.replace("-", "/")}`, url, { headers: { Range: `bytes=${entry}` } });
  }
}
async function setPMTilesLayerCached(layer2, options) {
  const bounds = options.bounds;
  const minZoom = options.minZoom || 3;
  const maxZoom = options.maxZoom || _$1.get(layer2, "leaflet.maxDataZoom");
  const nbConcurrentRequests = options.nbConcurrentRequests || 10;
  const url = _$1.get(layer2, "leaflet.url");
  const pmtiles = new PMTiles(url);
  const directory = /* @__PURE__ */ new Set();
  const views = sourcesToViews(layer2.leaflet);
  let promises = [];
  for (let z = minZoom; z <= maxZoom; z++) {
    let sm = new SphericalMercator();
    let tilesBounds = sm.xyz([bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]], z, _$1.get(layer2, "leaflet.tms"));
    for (let y = tilesBounds.minY; y <= tilesBounds.maxY; y++) {
      for (let x = tilesBounds.minX; x <= tilesBounds.maxX; x++) {
        for (const [k, v] of views) {
          const dt = v.dataTileForDisplayTile({ x, y, z });
          promises.push(cacheLayerPMTile(url, pmtiles, dt.dataTile.x, dt.dataTile.y, dt.dataTile.z, directory));
          if (promises.length === nbConcurrentRequests) {
            await Promise.all(promises);
            promises = [];
          }
        }
      }
    }
  }
  await cachePMTilesHeaderAndDirectory(url, pmtiles, directory);
  await Promise.all(promises);
}
async function setLayerUncached(layer2, options) {
  if (!isLayerCachable(layer2)) return;
  if (layer2.type === "BaseLayer") {
    await setBaseLayerUncached(layer2, options);
  } else if (layer2.service) {
    await setServiceLayerUncached(layer2, options);
  } else if (_$1.get(layer2, "leaflet.type") === "geoJson") {
    await setGeojsonLayerUncached(layer2);
  } else if (_$1.get(layer2, "leaflet.type") === "pmtiles") {
    await setPMTilesLayerUncached(layer2, options);
  }
}
async function uncacheLayerTile(urlTemplate, x, y, z) {
  const url = urlTemplate.replace("{z}", z).replace("{x}", x).replace("{y}", y);
  const key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.unset("layers", key.href);
}
async function setBaseLayerUncached(layer2, options) {
  const bounds = options.bounds;
  const minZoom = options.minZoom || 3;
  const maxZoom = options.maxZoom || _$1.get(layer2, "leaflet.maxNativeZoom");
  const urlTemplate = _$1.get(layer2, "leaflet.source");
  for (let z = minZoom; z <= maxZoom; z++) {
    let sm = new SphericalMercator();
    let tilesBounds = sm.xyz([bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]], z, _$1.get(layer2, "leaflet.tms"));
    for (let y = tilesBounds.minY; y <= tilesBounds.maxY; y++) {
      for (let x = tilesBounds.minX; x <= tilesBounds.maxX; x++) {
        await uncacheLayerTile(urlTemplate, x, y, z);
      }
    }
  }
  await uncacheLayerTile(urlTemplate, 0, 0, 0);
  if (layer2.iconUrl) await uncacheLayerTile(layer2.iconUrl);
}
async function setServiceLayerUncached(layer2, options) {
  const services = await LocalCache.getItem("services") || {};
  const serviceOptions = services[layer2.service];
  if (serviceOptions) {
    const offlineService = api.getOfflineService(layer2.service, serviceOptions.context);
    await offlineService.remove(null, {
      query: {
        south: options.bounds[0][0],
        north: options.bounds[1][0],
        west: options.bounds[0][1],
        east: options.bounds[1][1]
      }
    });
  }
}
async function setGeojsonLayerUncached(layer2) {
  const url = _$1.get(layer2, "leaflet.source");
  let key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.unset("layers", key.href);
}
async function uncacheLayerPMTile(url, pmtiles, x, y, z, directoryRanges) {
  const key = new URL(url);
  key.searchParams.delete("jwt");
  const data = await pmtiles.getZxy(z, x, y);
  if (!data) return;
  const range = await getPMTileRange(pmtiles, x, y, z, directoryRanges);
  await LocalCache.unset("layers", `${key.href}/${range.start}/${range.end}`);
}
async function uncachePMTilesHeaderAndDirectory(url, pmtiles, directory) {
  const key = new URL(url);
  key.searchParams.delete("jwt");
  await LocalCache.unset("layers", `${key.href}/0/16383`);
  directory = Array.from(directory);
  for (let i = 0; i < directory.length; i++) {
    const entry = directory[i];
    await LocalCache.unset("layers", `${key.href}/${entry.replace("-", "/")}`);
  }
}
async function setPMTilesLayerUncached(layer2, options) {
  const bounds = options.bounds;
  const minZoom = options.minZoom || 3;
  const maxZoom = options.maxZoom || _$1.get(layer2, "leaflet.maxDataZoom");
  const url = _$1.get(layer2, "leaflet.url");
  const pmtiles = new PMTiles(url);
  const directory = /* @__PURE__ */ new Set();
  const views = sourcesToViews(layer2.leaflet);
  for (let z = minZoom; z <= maxZoom; z++) {
    let sm = new SphericalMercator();
    let tilesBounds = sm.xyz([bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]], z, _$1.get(layer2, "leaflet.tms"));
    for (let y = tilesBounds.minY; y <= tilesBounds.maxY; y++) {
      for (let x = tilesBounds.minX; x <= tilesBounds.maxX; x++) {
        for (const [k, v] of views) {
          const dt = v.dataTileForDisplayTile({ x, y, z });
          await uncacheLayerPMTile(url, pmtiles, dt.dataTile.x, dt.dataTile.y, dt.dataTile.z, directory);
        }
      }
    }
  }
  await uncachePMTilesHeaderAndDirectory(url, pmtiles, directory);
}
function isLayerRemovable(layer2) {
  return _$1.get(layer2, "isRemovable", isUserLayer(layer2));
}
function isLayerStyleEditable(layer2) {
  return _$1.get(layer2, "isStyleEditable", isUserLayer(layer2));
}
function isLayerDataEditable(layer2) {
  return _$1.get(layer2, "isDataEditable", isUserLayer(layer2) && isFeatureLayer(layer2));
}
function isLayerFilterEditable(layer2) {
  return _$1.get(layer2, "isFilterEditable", isUserLayer(layer2) && isFeatureLayer(layer2));
}
function isTerrainLayer(layer2) {
  if (layer2.type === "TerrainLayer") return true;
  const cesiumOptions = layer2.cesium || layer2;
  return cesiumOptions.type === "Cesium" || cesiumOptions.type === "Ellipsoid";
}
function isMeasureLayer(layer2) {
  return layer2.variables && layer2.service;
}
async function parseFiltersFromLayer(layer2) {
  const filters = _$1.get(layer2, "filters", []);
  if (!filters.length) return [];
  const styleService = api.getService("styles");
  const styles = [];
  for (const filter of filters) {
    if (!filter.style) continue;
    styles.push({
      conditions: filterQueryToConditions(filter.active),
      values: _$1.isObject(filter.style) ? filter.style : await styleService.get(filter.style)
    });
  }
  return styles;
}
async function generateStyleFromFilters(layer2, defaultStyle) {
  const filters = await parseFiltersFromLayer(layer2);
  if (!filters.length) return;
  const templates = generateStyleTemplates(defaultStyle, filters);
  const result = Object.assign(
    {},
    _$1.mapKeys(templates, (value, key) => `leaflet.${key}`),
    _$1.mapKeys(templates, (value, key) => `cesium.${key}`)
  );
  return result;
}
async function editLayerStyle(layer2, style2, ignoreFeatureStyle = false) {
  style2 = _$1.pick(style2, ["point", "line", "polygon"]);
  if (layer2._id) {
    const result = await generateStyleFromFilters(layer2, style2);
    if (result) {
      Object.assign(result, await getUpdatedLayerLegend(Object.assign({}, layer2, result)));
      if (ignoreFeatureStyle) result.ignoreFeatureStyle = true;
      await api.getService("catalog").patch(layer2._id, result);
    } else {
      const legend = await getUpdatedLayerLegend(Object.assign({}, layer2, { "cesium.style": style2, "leaflet.style": style2 }));
      const patch = Object.assign({}, { "cesium.style": style2, "leaflet.style": style2 }, legend);
      if (ignoreFeatureStyle) patch.ignoreFeatureStyle = true;
      await api.getService("catalog").patch(layer2._id, patch);
    }
  } else {
    _$1.set(layer2, "cesium.style", style2);
    _$1.set(layer2, "leaflet.style", style2);
    Object.assign(layer2, await getUpdatedLayerLegend(layer2));
    if (ignoreFeatureStyle) layer2.ignoreFeatureStyle = true;
  }
  return layer2;
}
async function updateLayerWithFiltersStyle(layer2) {
  if (!layer2._id) return;
  const defaultStyle = getDefaultStyleFromTemplates(_$1.get(layer2, "leaflet.style", {}));
  const style2 = await generateStyleFromFilters(layer2, defaultStyle);
  if (!style2) return;
  await api.getService("catalog").patch(layer2._id, style2);
}
async function editFilterStyle(layer2, filter, engineStyle, style2, ignoreFeatureStyle = false) {
  if (!layer2._id) return;
  const layerDefaultStyle = getDefaultStyleFromTemplates(_$1.get(layer2, "leaflet.style", {}));
  const filters = await parseFiltersFromLayer(layer2);
  const targetFilterCondition = filterQueryToConditions(filter.active);
  _$1.forEach(filters, (f) => {
    if (_$1.isEqual(f.conditions, targetFilterCondition)) {
      f.values = style2;
    }
  });
  const templates = generateStyleTemplates(_$1.merge({}, DefaultStyle, engineStyle, layerDefaultStyle), filters);
  const layerFilters = _$1.cloneDeep(_$1.get(layer2, "filters", []));
  _$1.forEach(layerFilters, (f) => {
    if (_$1.isEqual(f.label, filter.label) && _$1.isEqual(f.active, filter.active)) {
      f.style = style2._id;
    }
  });
  const patch = Object.assign(
    {},
    _$1.mapKeys(templates, (value, key) => `leaflet.${key}`),
    _$1.mapKeys(templates, (value, key) => `cesium.${key}`),
    { filters: layerFilters }
  );
  if (ignoreFeatureStyle) patch.ignoreFeatureStyle = true;
  Object.assign(patch, await getUpdatedLayerLegend(Object.assign({}, layer2, { filters: layerFilters })));
  await api.getService("catalog").patch(layer2._id, patch);
}
async function getLayerFiltersWithStyle(layer2) {
  const filters = _$1.get(layer2, "filters", []);
  if (!filters.length) return [];
  const styleService = api.getService("styles");
  const filtersWithStyle = [];
  for (const filter of filters) {
    const filterWithStyle = _$1.cloneDeep(filter);
    if (filter.style) {
      filterWithStyle.linkedStyle = _$1.isObject(filter.style) ? filter.style : await styleService.get(filter.style);
    }
    filtersWithStyle.push(filterWithStyle);
  }
  return filtersWithStyle;
}
async function getUpdatedLayerLegend(layer2) {
  const updateOrGenerate = (root, style2) => {
    if (!_$1.has(root, "legend")) {
      const styles = [{ shape: "circle", type: "point" }, { shape: "polyline", type: "line" }, { shape: "rect", type: "polygon" }];
      root.legend = {
        type: "symbols",
        label: _$1.get(layer2, "label", _$1.get(layer2, "name")),
        content: {
          symbols: _$1.map(styles, (s) => {
            return {
              symbol: { "media/KShape": { options: _$1.merge({ shape: s.shape }, _$1.omit(_$1.get(style2, s.type), ["size"])) } },
              label: _$1.get(root, "label", _$1.get(root, "name"))
            };
          })
        }
      };
    } else {
      if (_$1.isArray(_$1.get(root, "legend"))) {
        _$1.forEach(root.legend, (legend) => {
          updateExisting(legend, style2);
        });
      } else {
        updateExisting(root.legend, style2);
      }
    }
  };
  const updateExisting = (legend, style2) => {
    if (legend.type === "symbols" && legend.content && legend.content.symbols) {
      _$1.forEach(legend.content.symbols, (symbol) => {
        if (symbol.symbol && symbol.symbol["media/KShape"] && symbol.symbol["media/KShape"].options) {
          switch (symbol.symbol["media/KShape"].options.shape) {
            case "rect":
              symbol.symbol["media/KShape"].options = _$1.omit(_$1.merge({ shape: "rect" }, _$1.get(style2, "polygon")), ["size"]);
              break;
            case "polyline":
              symbol.symbol["media/KShape"].options = _$1.omit(_$1.merge({ shape: "polyline" }, _$1.get(style2, "line")), ["size"]);
              break;
            default:
              symbol.symbol["media/KShape"].options = _$1.omit(_$1.merge({ shape: "circle" }, _$1.get(style2, "point")), ["size"]);
              break;
          }
        }
      });
    }
  };
  if (_$1.has(layer2, "filters") && !_$1.isEmpty(layer2.filters)) {
    const filtersWithStyle = await getLayerFiltersWithStyle(layer2);
    let hasFilterWithStyle = false;
    _$1.forEach(filtersWithStyle, (filter) => {
      if (!_$1.has(filter, "linkedStyle")) return;
      hasFilterWithStyle = true;
      updateOrGenerate(filter, filter.linkedStyle);
    });
    const legend = { filters: _$1.map(filtersWithStyle, (filter) => _$1.omit(filter, "linkedStyle")) };
    if (hasFilterWithStyle) Object.assign(legend, { $unset: { legend: "" } });
    return legend;
  } else {
    const layerStyle = getDefaultStyleFromTemplates(_$1.get(layer2, "leaflet.style", {}));
    updateOrGenerate(layer2, layerStyle);
    return { legend: layer2.legend };
  }
}
function generateLayerDefinition(layerSpec, geoJson) {
  if (geoJson.type !== "FeatureCollection" && geoJson.type !== "Feature") {
    logger$1.error("invalid geoJson content");
    return;
  }
  const engine = {
    type: "geoJson",
    isVisible: true,
    realtime: true
  };
  const defaultLayer = {
    type: "OverlayLayer",
    scope: "user",
    isDataEditable: true,
    leaflet: engine,
    // Avoid sharing reference to the same object although options are similar
    // otherwise updating one will automatically update the other one
    cesium: Object.assign({}, engine)
  };
  _$1.defaults(layerSpec, defaultLayer);
  if (!layerSpec.schema) {
    const schema = generatePropertiesSchema(geoJson, layerSpec.name);
    layerSpec.schema = { name: layerSpec.name, content: schema };
  }
  if (!layerSpec.featureId) {
    if (geoJson.type === "FeatureCollection") _$1.forEach(geoJson.features, (feature2) => {
      feature2._id = uid$2().toString();
    });
    else geoJson._id = uid$2().toString();
  }
  if (geoJson.type === "FeatureCollection") {
    _$1.defaultsDeep(layerSpec, _$1.omit(geoJson, ["type", "properties", "features"]));
    if (!_$1.has(layerSpec, "leaflet.panes")) {
      const panes = [];
      _$1.forEach(geoJson.features, (feature2) => {
        const pane = _$1.get(feature2, "style.pane");
        if (pane) {
          panes.push({
            name: pane
          });
        }
      });
      if (!_$1.isEmpty(panes)) _$1.set(layerSpec, "leaflet.panes", panes);
    }
  }
  return true;
}
async function saveGeoJsonLayer(layer2, geoJson, chunkSize = 5e3) {
  const check = checkFeatures(geoJson);
  if (check.kinks.length > 0) {
    const result = await dialog({
      title: i18n.t("utils.layers.INVALID_FEATURES_DIALOG_TITLE", { total: check.kinks.length }),
      message: i18n.t("utils.layers.INVALID_FEATURES_DIALOG_MESSAGE", { total: check.kinks.length }),
      options: {
        type: "toggle",
        model: [],
        items: [
          { label: i18n.t("utils.layers.DOWNLOAD_INVALID_FEATURES_LABEL"), value: "download" }
        ]
      },
      html: true,
      ok: {
        label: i18n.t("OK"),
        flat: true
      },
      cancel: {
        label: i18n.t("CANCEL"),
        flat: true
      }
    });
    if (!result.ok) return;
    if (_$1.get(result, "data", []).includes("download")) {
      downloadAsBlob(
        JSON.stringify({ type: "FeatureCollection", features: check.kinks }),
        i18n.t("utils.layers.INVALID_FEATURES_FILE"),
        "application/json;charset=utf-8;"
      );
    }
  }
  _$1.set(layer2, "service", "features");
  if (_$1.has(layer2, "leaflet")) _$1.set(layer2, "leaflet.source", "/api/features");
  if (_$1.has(layer2, "cesium")) _$1.set(layer2, "cesium.source", "/api/features");
  const features = getGeoJsonFeatures(geoJson);
  let nbPoints = 0;
  features.forEach((feature2) => {
    nbPoints += explode(feature2).features.length;
  });
  if (nbPoints > 5e3) {
    _$1.set(layer2, "leaflet.tiled", true);
    _$1.set(layer2, "leaflet.minZoom", 15);
  }
  Plugin$1.show({ message: i18n.t("utils.layers.SAVING_LABEL", { processed: 0, total: features.length }), html: true });
  let createdLayer;
  try {
    createdLayer = await api.getService("catalog").create(_$1.omit(layer2, InternalLayerProperties));
    let nbFeatures = 0;
    await createFeatures(geoJson, createdLayer, chunkSize, (i, chunk) => {
      nbFeatures += chunk.length;
      Plugin$1.show({
        message: i18n.t("utils.layers.SAVING_LABEL", { processed: nbFeatures, total: features.length }),
        html: true
      });
    });
    createdLayer = await api.getService("catalog").patch(createdLayer._id, { baseQuery: { layer: createdLayer._id } });
    if (_$1.get(layer2, "leaflet.tiled")) {
      Notify.create({ type: "positive", message: i18n.t("utils.layers.SAVE_DIALOG_MESSAGE"), timeout: 1e4, html: true });
    }
  } catch (error) {
    logger$1.error(`[KDK] ${error}`);
  }
  Plugin$1.hide();
  return createdLayer;
}
async function saveLayer(layer2) {
  layer2 = await api.getService("catalog").create(_$1.omit(layer2, InternalLayerProperties));
  return layer2;
}
async function removeLayer(layer2) {
  const result = await dialog({
    title: i18n.t("utils.layers.REMOVE_DIALOG_TITLE", { layer: layer2.label || layer2.name }),
    message: i18n.t("utils.layers.REMOVE_DIALOG_MESSAGE", { layer: layer2.label || layer2.name }),
    html: true,
    ok: {
      label: i18n.t("OK"),
      flat: true
    },
    cancel: {
      label: i18n.t("CANCEL"),
      flat: true
    }
  });
  if (!result.ok) return false;
  Plugin$1.show({ message: i18n.t("utils.layers.REMOVING_LABEL"), html: true });
  try {
    if (layer2._id) {
      if (isFeatureLayer(layer2)) {
        await removeFeatures(null, layer2);
      }
      await api.getService("catalog").remove(layer2._id);
    }
  } catch (error) {
    logger$1.error(`[KDK] ${error}`);
  }
  Plugin$1.hide();
  return true;
}
function processFeatures(geoJson, processor) {
  const features = getGeoJsonFeatures(geoJson);
  if (typeof processor === "function") {
    features.forEach((feature2) => processor(feature2));
  } else if (typeof processor === "string") {
    const compiler = _$1.template(processor);
    features.forEach((feature2) => compiler({ feature: feature2, properties: feature2.properties }));
  }
}
function transformFeatures(geoJson, transform) {
  const features = getGeoJsonFeatures(geoJson);
  features.forEach((feature2) => {
    const scaling = _$1.get(transform, "scale");
    const rotation = _$1.get(transform, "rotate");
    const translation = _$1.get(transform, "translate");
    if (scaling) {
      transformScale(
        feature2,
        scaling.factor,
        Object.assign(_$1.omit(scaling, ["factor"]), { mutate: true })
      );
    }
    if (rotation) {
      transformRotate(
        feature2,
        rotation.angle,
        Object.assign(_$1.omit(rotation, ["angle"]), { mutate: true })
      );
    }
    if (translation) {
      if (translation.point) {
        translation.distance = rhumbDistance(translation.pivot || [0, 0], translation.point);
        translation.direction = rhumbBearing(translation.pivot || [0, 0], translation.point);
        delete translation.pivot;
        delete translation.point;
      }
      transformTranslate(
        feature2,
        translation.distance,
        translation.direction,
        Object.assign(_$1.omit(translation, ["direction", "distance"]), { mutate: true })
      );
    }
  });
}
async function buildGradientPath(geoJson, options) {
  const variable = options.build.variable;
  if (!geoJson || geoJson.type !== "FeatureCollection") {
    console.error("Invalid GeoJSON, a FeatureCollection is required to build a gradient path");
    return;
  }
  if (!variable.chromajs.colors) {
    console.error(`Invalid chromajs on variable ${variable.name}, missing colors.`);
    return;
  }
  let scale2;
  if (variable.chromajs.domain) {
    scale2 = chroma.scale(variable.chromajs.colors).domain(variable.chromajs.domain);
  } else if (variable.chromajs.classes) {
    scale2 = chroma.scale(variable.chromajs.colors).classes(variable.chromajs.classes);
  }
  if (!scale2) {
    console.error(`Invalid chromajs on variable ${variable.name}, missing domain or classes.`);
    return;
  }
  geoJson.features = geoJson.features.map((feature2) => {
    const geometries = feature2.geometry.geometries.map((g) => g.coordinates);
    const values = feature2.properties[variable.name];
    const gradient = values.map((value) => scale2(value).hex());
    if (geometries.length < 2) {
      return {
        type: "Feature",
        geometry: {
          type: "LineString",
          coordinates: [geometries[0], geometries[0]]
        },
        properties: Object.assign({ gradient: [gradient[0], gradient[0]] }, _$1.omit(feature2.properties, variable.name), variable.gradientPath.properties)
      };
    }
    return {
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates: geometries
      },
      properties: Object.assign({ gradient }, _$1.omit(feature2.properties, variable.name), variable.gradientPath.properties)
    };
  });
  geoJson.total = geoJson.features.length;
}
async function checkBuildInstructions(options) {
  const knownInstructions = ["gradientPath"];
  if (!options.variables) return;
  for (const instr of knownInstructions) {
    const variable = _$1.find(options.variables, (variable2) => _$1.has(variable2, instr));
    if (variable) {
      return { instruct: instr, variable };
    }
  }
}
async function getBaseQueryForFeatures(options) {
  const baseQuery = {};
  if (options.baseQuery) {
    if (typeof options.baseQuery === "function") {
      const result = await options.baseQuery();
      if (!result) return;
      else Object.assign(baseQuery, result);
    } else {
      Object.assign(baseQuery, options.baseQuery);
    }
  }
  return baseQuery;
}
async function getFilterQueryForFeatures(options) {
  const filterQuery = {};
  if (options.filterQuery) {
    if (typeof options.filterQuery === "function") {
      const result = await options.filterQuery();
      Object.assign(filterQuery, result);
    } else {
      Object.assign(filterQuery, options.filterQuery);
    }
  }
  const filters = _$1.get(options, "filters", []);
  if (!_$1.isEmpty(filters)) {
    const filterOperators = _$1.get(options, "filterOperators", { active: "$or", inactive: "$and" });
    const activeFilters = filters.filter((filter) => filter.isActive).map((filter) => filter.active).filter((query) => !_$1.isEmpty(query));
    if (!_$1.isEmpty(activeFilters)) filterQuery[filterOperators.active] = activeFilters;
    const inactiveFilters = filters.filter((filter) => !filter.isActive).map((filter) => filter.inactive).filter((query) => !_$1.isEmpty(query));
    if (!_$1.isEmpty(inactiveFilters)) filterQuery[filterOperators.inactive] = inactiveFilters;
  }
  return filterQuery;
}
async function getSortQueryForFeatures(options) {
  const sortQuery = {};
  if (options.sortQuery) {
    if (typeof options.sortQuery === "function") {
      const result = await options.sortQuery();
      Object.assign(sortQuery, result);
    } else {
      Object.assign(sortQuery, options.sortQuery);
    }
  }
  return { $sort: sortQuery };
}
function getFeaturesUpdateInterval(options) {
  const interval = _$1.get(options, "every");
  return interval ? moment.duration(interval) : null;
}
function getFeaturesQueryInterval(options) {
  const interval = getFeaturesUpdateInterval(options);
  let queryInterval = _$1.get(options, "queryFrom");
  if (!queryInterval && interval) queryInterval = moment.duration(-2 * interval.asMilliseconds());
  return queryInterval ? moment.duration(queryInterval) : null;
}
function shouldSkipFeaturesUpdate(lastUpdateTime, options, interval) {
  if (!interval) {
    interval = getFeaturesUpdateInterval(options);
  }
  if (!interval) return true;
  const now = Time.getCurrentTime();
  const elapsed = moment.duration(now.diff(lastUpdateTime));
  return Math.abs(elapsed.asMilliseconds()) < interval.asMilliseconds();
}
async function getProbeFeatures(options) {
  const query = await getBaseQueryForFeatures(options);
  const filterQuery = await getFilterQueryForFeatures(options);
  const sortQuery = await getSortQueryForFeatures(options);
  Object.assign(query, filterQuery, sortQuery);
  const planetApi = typeof options.getPlanetApi === "function" ? options.getPlanetApi() : api;
  const response = await planetApi.getService(options.probeService).find(Object.assign({ query }, options.baseParams));
  if (options.processor) processFeatures(response, options.processor);
  if (options.transform) transformFeatures(response, options.transform);
  return response;
}
async function getFeaturesQuery(options, queryInterval, queryLevel) {
  if (!queryInterval) {
    queryInterval = getFeaturesQueryInterval(options);
  }
  let query = await getBaseQueryForFeatures(options);
  const instruct = await checkBuildInstructions(options);
  options.build = instruct;
  if (queryInterval) {
    if (instruct) {
      query = Object.assign({
        $groupBy: options.featureId,
        $aggregate: ["geometry", instruct.variable.name]
      }, query);
    } else if (options.variables) {
      query = Object.assign({
        $groupBy: options.featureId,
        // Take care we might have multiple variables targetting the same value name
        // but that differentiate using others properties (compound feature ID)
        $aggregate: _$1.uniq(options.variables.map((variable) => variable.name))
      }, query);
    } else if (options.featureId) {
      query = Object.assign({
        $groupBy: options.featureId,
        $aggregate: ["geometry"]
      }, query);
    }
    const now = Time.getCurrentTime();
    if (moment.isDuration(queryInterval)) {
      const gte = queryInterval.asMilliseconds() > 0 ? now.clone().subtract(queryInterval) : now.clone().add(queryInterval);
      const lte = now;
      Object.assign(query, {
        $sort: { time: -1, runTime: -1 },
        time: {
          $gte: gte.toISOString(),
          $lte: lte.toISOString()
        }
      });
      if (options.featureId && !instruct) query.$limit = 1;
    } else if (typeof queryInterval === "object") {
      query.time = queryInterval;
    } else {
      Object.assign(query, {
        $sort: { time: -1, runTime: -1 },
        time: { $lte: now.toISOString() }
      });
      if (options.featureId && !instruct) query.$limit = 1;
    }
  }
  if (!_$1.isNil(queryLevel)) {
    query.level = queryLevel;
  }
  const filterQuery = await getFilterQueryForFeatures(options);
  const sortQuery = await getSortQueryForFeatures(options);
  _$1.merge(query, filterQuery, sortQuery);
  return query;
}
function isFeatureInQueryInterval(feature2, options) {
  if (!feature2.time) return true;
  const queryInterval = getFeaturesQueryInterval(options);
  if (!moment.isDuration(queryInterval)) return true;
  const now = Time.getCurrentTime();
  const time = moment.utc(feature2.time);
  const gte = queryInterval.asMilliseconds() > 0 ? now.clone().subtract(queryInterval) : now.clone().add(queryInterval);
  const lte = now;
  if (Time.isRealtime()) lte.add(Time.get().interval, "s");
  return time.isSameOrAfter(gte) && time.isSameOrBefore(lte);
}
async function getFeaturesFromQuery(options, query) {
  const planetApi = typeof options.getPlanetApi === "function" ? options.getPlanetApi() : api;
  const response = await planetApi.getService(options.service).find(Object.assign({ query }, options.baseParams));
  if (options.processor) processFeatures(response, options.processor);
  if (options.transform) transformFeatures(response, options.transform);
  if (options.build) {
    switch (options.build.instruct) {
      case "gradientPath":
        await buildGradientPath(response, options);
        break;
    }
    delete options.build;
  }
  return response;
}
function getMeasureForFeatureBaseQuery(layer2, feature2) {
  let featureId = layer2.chronicleId || layer2.featureId;
  featureId = Array.isArray(featureId) ? featureId : [featureId];
  const query = featureId.reduce(
    (result, id) => Object.assign(result, { ["properties." + id]: _$1.get(feature2, "properties." + id) }),
    {}
  );
  query.$groupBy = featureId;
  return query;
}
async function getMeasureForFeatureQuery(layer2, feature2, startTime, endTime, level) {
  const query = await getFeaturesQuery(_$1.merge({
    baseQuery: getMeasureForFeatureBaseQuery(layer2, feature2)
  }, layer2), {
    $gte: startTime.toISOString(),
    $lte: endTime.toISOString()
  }, level);
  return query;
}
async function getMeasureForFeatureFromQuery(layer2, feature2, query) {
  const result = await getFeaturesFromQuery(layer2, query);
  return _$1.get(result, "features[0]");
}
async function getMeasureForFeature(layer2, feature2, startTime, endTime, level) {
  let probedLocation;
  try {
    const query = await getMeasureForFeatureQuery(layer2, feature2, startTime, endTime, level);
    probedLocation = await getMeasureForFeatureFromQuery(layer2, feature2, query);
  } catch (error) {
    logger$1.error(error);
  }
  return probedLocation;
}
function checkFeatures(geoJson, options = {
  kinks: true,
  redundantCoordinates: true
}) {
  const features = getGeoJsonFeatures(geoJson);
  if (options.redundantCoordinates) {
    features.forEach((feature2) => cleanCoords(feature2, { mutate: true }));
  }
  let kinksFeatures;
  if (options.kinks) {
    kinksFeatures = _$1.remove(features, (feature2) => {
      const type = getType(feature2);
      if (type === "MultiPolygon" || type === "Polygon") {
        const invalidFeatures = kinks(feature2);
        return _$1.get(invalidFeatures, "features", []).length > 0;
      } else {
        return false;
      }
    });
  }
  return { kinks: kinksFeatures };
}
async function createFeatures(geoJson, layer2, chunkSize = 5e3, processCallback) {
  if (!layer2) return;
  const features = getGeoJsonFeatures(geoJson);
  features.forEach((feature2) => {
    delete feature2._id;
    feature2.layer = layer2._id;
  });
  if (features.length === 1) {
    const feature2 = await api.getService(layer2.service).create(features[0]);
    return feature2;
  } else {
    const chunks = [];
    let chunkPoints = 0;
    let chunk = [];
    features.forEach((feature2) => {
      const explodedFeature = explode(feature2);
      const nbPoints = explodedFeature.features.length;
      if (chunkPoints + nbPoints <= chunkSize) {
        chunkPoints += nbPoints;
        chunk.push(feature2);
      } else {
        if (chunk.length > 0) {
          chunks.push(chunk);
        }
        chunk = [feature2];
        chunkPoints = nbPoints;
      }
    });
    if (chunk.length > 0) {
      chunks.push(chunk);
    }
    for (let i = 0; i < chunks.length; i++) {
      await api.getService(layer2.service).create(chunks[i]);
      if (typeof processCallback === "function") await processCallback(i, chunks[i]);
    }
  }
}
async function editFeaturesGeometry(geoJson, layer2) {
  const features = getGeoJsonFeatures(geoJson);
  const updatedFeatures = [];
  for (let i = 0; i < features.length; i++) {
    const feature2 = features[i];
    if (feature2._id) {
      const updatedFeature = await api.getService(layer2.service).patch(feature2._id, _$1.pick(feature2, ["geometry"]));
      updatedFeatures.push(updatedFeature);
    }
  }
  return geoJson.type === "FeatureCollection" ? Object.assign(geoJson, { features: updatedFeatures }) : updatedFeatures;
}
async function editFeaturesProperties(geoJson, layer2) {
  const features = getGeoJsonFeatures(geoJson);
  const updatedFeatures = [];
  for (let i = 0; i < features.length; i++) {
    const feature2 = features[i];
    if (feature2._id) {
      const updatedFeature = await api.getService(layer2.service).patch(feature2._id, _$1.pick(feature2, ["properties"]));
      updatedFeatures.push(updatedFeature);
    }
  }
  return geoJson.type === "FeatureCollection" ? Object.assign(geoJson, { features: updatedFeatures }) : updatedFeatures;
}
async function editFeaturesStyle(geoJson, layer2) {
  const features = getGeoJsonFeatures(geoJson);
  const updatedFeatures = [];
  for (let i = 0; i < features.length; i++) {
    const feature2 = features[i];
    if (layer2._id) {
      const updatedFeature = await api.getService(layer2.service).patch(feature2._id, _$1.pick(feature2, ["style"]));
      updatedFeatures.push(updatedFeature);
    }
  }
  return geoJson.type === "FeatureCollection" ? Object.assign(geoJson, { features: updatedFeatures }) : updatedFeatures;
}
async function removeFeatures(geoJson, layer2) {
  if (!geoJson) {
    await api.getService(layer2.service).remove(null, { query: { layer: layer2._id } });
  } else {
    const features = getGeoJsonFeatures(geoJson);
    for (let i = 0; i < features.length; i++) {
      const feature2 = features[i];
      if (feature2._id) await api.getService(layer2.service).remove(feature2._id);
    }
  }
}
async function fetchGeoJson(dataSource, options = {}) {
  const response = await fetch(dataSource);
  if (response.status !== 200) {
    throw new Error(`Impossible to fetch ${dataSource}: ` + response.status);
  }
  const data = await response.json();
  if (options.processor) processFeatures(data, options.processor);
  if (options.transform) transformFeatures(data, options.transform);
  return data;
}
function getFeatureStyleType(feature2) {
  const geometryType = _$1.get(feature2, "geometry.type");
  if (!geometryType) {
    logger$1.warn("[KDK] feature has undefined geometry");
    return;
  }
  if (["Point", "MultiPoint"].includes(geometryType)) return "point";
  if (["LineString", "MultiLineString"].includes(geometryType)) return "line";
  if (["Polygon", "MultiPolygon"].includes(geometryType)) return "polygon";
  logger$1.warn(`[KDK] unsupported geometry of type of ${geometryType}`);
  return;
}
function listenToFeaturesServiceEventsForLayer(layer2, {
  context: context2 = null,
  created = null,
  updated = null,
  patched = null,
  removed = null,
  all = null
} = {}, listeners) {
  if (!layer2.service || isInMemoryLayer(layer2)) return;
  if (!isFeatureLayer(layer2) && !layer2.serviceEvents) return;
  unlistenToFeaturesServiceEventsForLayer(layer2, listeners);
  const generateListenerForEvent = (listener, layer3) => {
    if (!listener) return null;
    else return (feature2, event) => {
      if (!getType(feature2) || !getGeom(feature2)) return;
      if (feature2.layer) {
        if (feature2.layer === layer3._id) {
          listener(feature2, layer3, event);
        }
      } else {
        listener(feature2, layer3, event);
      }
    };
  };
  return listenToServiceEvents(layer2.service, {
    context: context2,
    created: generateListenerForEvent(created, layer2),
    updated: generateListenerForEvent(updated, layer2),
    patched: generateListenerForEvent(patched, layer2),
    removed: generateListenerForEvent(removed, layer2),
    all: generateListenerForEvent(all, layer2)
  });
}
function unlistenToFeaturesServiceEventsForLayer(layer2, listeners) {
  unlistenToServiceEvents(listeners);
}
function parseCoordinates(str) {
  let longitude, latitude;
  const DDRegexp = /(-?\d+(?:\.\d+)?)°\s*([NSEW])\s+(-?\d+(?:\.\d+)?)°\s*([NSEW])/;
  let match = str.match(DDRegexp);
  if (match) {
    if (match[2] === "N" || match[2] === "S") {
      latitude = parseFloat(match[1]);
      if (match[2] === "S") latitude = -latitude;
      longitude = parseFloat(match[3]);
      if (match[4] === "W") longitude = -longitude;
      return { longitude, latitude };
    } else {
      longitude = parseFloat(match[1]);
      if (match[2] === "W") longitude = -longitude;
      latitude = parseFloat(match[3]);
      if (match[4] === "S") latitude = -latitude;
      return { longitude, latitude };
    }
  }
  const simpleRegexp = /(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)/;
  match = str.match(simpleRegexp);
  if (match) {
    longitude = parseFloat(match[1]);
    latitude = parseFloat(match[2]);
    return { longitude, latitude };
  }
}
function formatUserCoordinates(lat, lon, format, options) {
  if (format === "aeronautical") {
    const coords = formatcoords(lat, lon);
    const latDeg = coords.latValues.degreesInt.toString().padStart(2, "0");
    const latMin = Math.floor(coords.latValues.secondsTotal / 6).toString().padStart(3, "0");
    const latDir = coords.north ? "N" : "S";
    const lonDeg = coords.lonValues.degreesInt.toString().padStart(3, "0");
    const lonMin = Math.floor(coords.lonValues.secondsTotal / 6).toString().padStart(3, "0");
    const lonDir = coords.east ? "E" : "W";
    return `${latDeg}${latMin}${latDir} ${lonDeg}${lonMin}${lonDir}`;
  }
  return formatcoords(lat, lon).format(format, options);
}
function formatForwardGeocodingResult(result) {
  const properties = result.properties;
  if (!properties) {
    logger$1.warn("[KDK] invalid geocoding result: missing 'properties' property");
    return;
  }
  let label = properties.formattedAddress || "";
  if (!label) {
    if (properties.streetNumber) label += properties.streetNumber + ", ";
    if (properties.streetName) label += properties.streetName + " ";
    if (properties.city) label += properties.city + " ";
    if (properties.zipcode) label += " (" + properties.zipcode + ")";
  }
  if (!label) {
    if (!_$1.has(result, "geokoder.matchProp")) {
      logger$1.warn("[KDK] invalid geocoding result: missing 'geokoder.matchProp' property");
      return;
    }
    label = _$1.get(result, result.geokoder.matchProp, "");
  }
  return label;
}
function filterGeocoders(geocoders, project) {
  return geocoders.filter((geocoder) => {
    const id = geocoder.value || geocoder;
    if (project && id.includes("kano:")) {
      const service2 = _$1.replace(id, /^(.*:)?kano:/g, "");
      let layer2 = _$1.find(project.layers, { service: service2 });
      if (!layer2) layer2 = _$1.find(project.layers, { probeService: service2 });
      return layer2;
    }
    return true;
  });
}
async function createOfflineServices() {
  const services = await LocalCache.getItem("services");
  if (services) {
    const serviceNames = Object.keys(services);
    for (let i = 0; i < serviceNames.length; i++) {
      const serviceName = serviceNames[i];
      const serviceOptions = services[serviceName];
      if (serviceOptions.features) {
        await api.createOfflineFeaturesService(serviceName, { snapshot: false, ...serviceOptions });
      } else {
        await api.createOfflineService(serviceName, { snapshot: false, ...serviceOptions });
      }
    }
  }
}
async function cacheView(view, layers, options = {}) {
  const views = await LocalCache.getItem("views");
  if (views) {
    views[view._id] = options;
    await LocalCache.setItem("views", views);
  } else {
    await LocalCache.setItem("views", { [view._id]: options });
  }
  const catalogQueries = [{ type: { $nin: ["Context", "Service", "Category"] } }, { type: { $in: ["Context", "Service", "Category"] } }];
  await api.createOfflineService("catalog", {
    baseQueries: catalogQueries
  });
  if (options.contextId) {
    await api.createOfflineService("catalog", {
      baseQueries: catalogQueries,
      context: options.contextId
    });
  }
  const projectQuery = { populate: true };
  await api.createOfflineService("projects", {
    baseQuery: projectQuery
  });
  await api.createOfflineFeaturesService("features", {
    context: options.contextId
  });
  for (let i = 0; i < layers.length; i++) {
    const layer2 = layers[i];
    await setLayerCached(layer2, Object.assign({ bounds: [[view.south, view.west], [view.north, view.east]] }, options));
  }
}
async function uncacheView(view, layers, options = {}) {
  const views = await LocalCache.getItem("views") || {};
  if (!views[view._id]) return;
  Object.assign(options, views[view._id] || {});
  for (let i = 0; i < layers.length; i++) {
    const layer2 = layers[i];
    await setLayerUncached(layer2, Object.assign({ bounds: [[view.south, view.west], [view.north, view.east]] }, options));
  }
  delete views[view._id];
  if (_$1.isEmpty(views)) {
    await LocalCache.removeItem("views");
    const services = await LocalCache.getItem("services") || {};
    const serviceNames = Object.keys(services);
    for (let i = 0; i < serviceNames.length; i++) {
      const serviceName = serviceNames[i];
      const serviceOptions = services[serviceName];
      const offlineService = api.getOfflineService(serviceName, serviceOptions.context);
      await offlineService.remove(null, { query: {} });
      api.removeService(serviceName, serviceOptions.context);
    }
    await LocalCache.removeItem("services");
  } else {
    await LocalCache.setItem("views", views);
  }
}
function getCatalogProjectQuery(project) {
  const idQuery = { _id: { $in: _$1.map(_$1.filter(project.layers, "_id"), "_id") } };
  const nameQuery = { name: { $in: _$1.map(_$1.filter(project.layers, "name"), "name") } };
  return { $or: [idQuery, nameQuery] };
}
function generatePropertiesSchema(geoJson, name) {
  const schema = {
    $id: `http://www.kalisio.xyz/schemas/${_$1.kebabCase(name)}#`,
    title: name,
    $schema: "http://json-schema.org/draft-07/schema#",
    type: "object",
    properties: {}
  };
  const features = getGeoJsonFeatures(geoJson);
  features.forEach((feature2) => {
    const properties = feature2.properties ? dotify(feature2.properties) : {};
    _$1.forOwn(properties, (value, key) => {
      if (schema.properties["{key}"]) {
        const property = schema.properties[`${key}`];
        if (_$1.isNil(property)) schema.properties[`${key}`] = value;
      } else {
        schema.properties[`${key}`] = value;
      }
    });
  });
  _$1.forOwn(schema.properties, (value, key) => {
    let type = typeof value;
    if (type === "object" || type === "undefined") type = "string";
    schema.properties[`${key}`] = {
      type,
      nullable: true,
      field: {
        component: type === "number" ? "form/KNumberField" : type === "boolean" ? "form/KToggleField" : "form/KTextField",
        label: key
      }
    };
  });
  return schema;
}
async function getForecastForLocation({ longitude, latitude, startTime, endTime, forecastModel, forecastLevel, weacastApi }) {
  if (!forecastModel) return;
  const geometry = {
    type: "Point",
    coordinates: [longitude, latitude]
  };
  const query = {
    forecastTime: {
      $gte: startTime.format(),
      $lte: endTime.format()
    },
    geometry: {
      $geoIntersects: {
        $geometry: geometry
      }
    }
  };
  let probedLocation;
  try {
    let elements = forecastModel.elements.map((element) => element.name);
    if (forecastLevel) elements = elements.filter((element) => element.endsWith(forecastLevel.toString()));
    else {
      elements = elements.filter((element) => {
        const tokens = element.split("-");
        return tokens.length === 0 || !_$1.isFinite(_$1.toNumber(tokens[tokens.length - 1]));
      });
    }
    const response = await weacastApi.getService("probes").create({
      forecast: forecastModel.name,
      elements
    }, { query });
    if (response.features.length > 0) {
      probedLocation = response.features[0];
    } else throw new Error("Cannot find valid forecast at location");
  } catch (error) {
    logger$1.error(error);
  }
  return probedLocation;
}
async function getForecastProbe({ name, forecastModel, weacastApi }) {
  const results = await weacastApi.getService("probes").find({
    query: {
      name,
      forecast: forecastModel.name,
      $paginate: false,
      $select: ["elements", "forecast", "featureId"]
    }
  });
  if (results.length > 0) {
    const probe = results[0];
    return probe;
  } else {
    return null;
  }
}
async function getForecastForFeature({ probe, featureId, startTime, endTime, forecastModel, forecastLevel, weacastApi }) {
  let probedLocation;
  try {
    let elements = forecastModel.elements.map((element) => element.name);
    if (forecastLevel) {
      elements = elements.filter((element) => element.endsWith(forecastLevel.toString()));
    } else {
      elements = elements.filter((element) => {
        const tokens = element.split("-");
        return tokens.length === 0 || !_$1.isFinite(_$1.toNumber(tokens[tokens.length - 1]));
      });
    }
    const windDirection = forecastLevel ? `windDirection-${forecastLevel}` : "windDirection";
    const windSpeed = forecastLevel ? `windSpeed-${forecastLevel}` : "windSpeed";
    elements = elements.concat([windDirection, windSpeed]);
    const results = await weacastApi.getService("probe-results").find({
      query: {
        probeId: probe._id,
        forecastTime: {
          $gte: startTime.format(),
          $lte: endTime.format()
        },
        [probe.featureId]: featureId,
        $groupBy: probe.featureId,
        $aggregate: elements
      }
    });
    if (results.length > 0) {
      probedLocation = results[0];
    } else throw new Error("Cannot find valid forecast for feature");
  } catch (error) {
    logger$1.error(error);
  }
  return probedLocation;
}
async function getDataForVariable(data, variable, forecastLevel, runTime) {
  data = await data;
  const times = _$1.get(data, "time", _$1.get(data, "forecastTime", {}));
  const runTimes = _$1.get(data, "runTime", {});
  const properties = _$1.get(data, "properties", {});
  const name = forecastLevel ? `${variable.name}-${forecastLevel}` : variable.name;
  let values = [];
  if (properties[name] && Array.isArray(properties[name])) {
    values = properties[name].map((value, index2) => {
      value = Units.convert(value, variable.unit, variable.targetUnit);
      return { time: moment.utc(times[name][index2]).valueOf(), [name]: value };
    });
    if (variable.runTimes && runTime && !_$1.isEmpty(_$1.get(runTimes, name))) {
      values = values.filter((value, index2) => runTimes[name][index2] === runTime.toISOString());
    } else values = _$1.uniqBy(values, "time");
  }
  return values;
}
async function fetchDataForForecastSeries({
  feature: feature2,
  location: location2,
  layer: layer2,
  startTime,
  endTime,
  forecastModel,
  forecastLevel,
  weacastApi
}) {
  const { start, end } = Time.getRange();
  if (!startTime) startTime = start;
  if (!endTime) endTime = end;
  let data;
  if (!feature2) {
    data = await getForecastForLocation({ longitude: location2.lng, latitude: location2.lat, startTime, endTime, forecastModel, forecastLevel, weacastApi });
  } else if (layer2.probe) {
    const probe = await getForecastProbe({ name: layer2.probe, forecastModel, weacastApi });
    if (probe) {
      data = await getForecastForFeature({ probe, featureId: _$1.get(feature2, probe.featureId), startTime, endTime, forecastModel, forecastLevel, weacastApi });
    }
  } else {
    const location3 = centroid(feature2);
    const longitude = _$1.get(location3, "geometry.coordinates[0]");
    const latitude = _$1.get(location3, "geometry.coordinates[1]");
    data = await getForecastForLocation({ longitude, latitude, startTime, endTime, forecastModel, forecastLevel, weacastApi });
  }
  return data;
}
async function fetchDataForMeasureSeries({
  feature: feature2,
  location: location2,
  layer: layer2,
  startTime,
  endTime,
  level,
  probeFunction
}) {
  const { start, end } = Time.getRange();
  if (!startTime) startTime = start;
  if (!endTime) endTime = end;
  let data;
  if (probeFunction) {
    data = await probeFunction({ feature: feature2, location: location2, layer: layer2, level, startTime, endTime });
  } else if (isMeasureLayer(layer2)) {
    data = await getMeasureForFeature(layer2, feature2, startTime, endTime, level);
  }
  return data;
}
function getForecastTimeSeries({
  feature: feature2,
  location: location2,
  layer: layer2,
  startTime,
  endTime,
  runTime,
  forecastLayers,
  forecastModel,
  forecastLevel,
  weacastApi,
  fetchDelay
}) {
  let forecastVariables = [];
  if (forecastLayers && forecastLayers.length > 0) forecastLayers.forEach((layer3) => {
    forecastVariables = forecastVariables.concat(_$1.get(layer3, "variables", []));
  });
  forecastVariables = _$1.uniqBy(forecastVariables, "name");
  if (forecastVariables.length === 0) return [];
  const properties = _$1.get(feature2, "properties", {});
  const forecastData = fetchDataForForecastSeries({
    feature: feature2,
    location: location2,
    layer: layer2,
    startTime,
    endTime,
    forecastModel,
    forecastLevel,
    weacastApi
  });
  const fetchForecast = _$1.debounce(() => fetchDataForForecastSeries({
    feature: feature2,
    location: location2,
    layer: layer2,
    startTime,
    endTime,
    forecastModel,
    forecastLevel,
    weacastApi
  }), fetchDelay || 250, { leading: true, trailing: false });
  const series = forecastVariables.map((variable) => {
    const baseUnit = _$1.get(properties, "unit", variable.unit);
    const unit = Units.getUnit(baseUnit);
    const targetUnit = Units.getTargetUnit(baseUnit);
    const serie = {
      probedLocationData: forecastData,
      data: getDataForVariable(forecastData, variable, forecastLevel, runTime),
      variable: {
        name: variable.name,
        label: `${i18n.tie(variable.label)} (${Units.getTargetUnitSymbol(baseUnit)})`,
        unit,
        targetUnit,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: forecastLevel ? `${variable.name}-${forecastLevel}` : variable.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, _$1.cloneDeep(variable.chartjs))
      }
    };
    serie.fetch = () => {
      serie.probedLocationData = fetchForecast();
      serie.data = getDataForVariable(serie.probedLocationData, variable, forecastLevel, runTime);
      return serie.data;
    };
    return serie;
  });
  return series;
}
function getMeasureTimeSeries({
  feature: feature2,
  location: location2,
  layer: layer2,
  layers,
  startTime,
  endTime,
  runTime,
  level,
  probeFunction,
  fetchDelay
}) {
  let variables = _$1.get(layer2, "variables", []);
  if (layers && layers.length > 0) layers.forEach((layer3) => {
    variables = variables.concat(_$1.get(layer3, "variables", []));
  });
  variables = _$1.uniqBy(variables, "name");
  if (variables.length === 0) return [];
  const properties = _$1.get(feature2, "properties", {});
  const data = fetchDataForMeasureSeries({
    feature: feature2,
    location: location2,
    layer: layer2,
    startTime,
    endTime,
    level,
    probeFunction
  });
  const fetch2 = _$1.debounce(() => fetchDataForMeasureSeries({
    feature: feature2,
    location: location2,
    layer: layer2,
    startTime,
    endTime,
    level,
    probeFunction
  }), fetchDelay || 250, { leading: true, trailing: false });
  const series = variables.map((variable) => {
    const baseUnit = _$1.get(properties, "unit", variable.unit);
    const unit = Units.getUnit(baseUnit);
    const targetUnit = Units.getTargetUnit(baseUnit);
    const serie = {
      probedLocationData: data,
      data: getDataForVariable(data, variable),
      variable: {
        name: variable.name,
        label: `${i18n.tie(variable.label)} (${Units.getTargetUnitSymbol(baseUnit)})`,
        unit,
        targetUnit,
        chartjs: Object.assign({
          parsing: {
            xAxisKey: "time",
            yAxisKey: variable.name
          },
          cubicInterpolationMode: "monotone",
          tension: 0.4
        }, _$1.cloneDeep(variable.chartjs))
      }
    };
    serie.fetch = () => {
      serie.probedLocationData = fetch2();
      serie.data = getDataForVariable(serie.probedLocationData, variable);
      return serie.data;
    };
    return serie;
  });
  return series;
}
function useSelection(name, options = {}) {
  let layerServiceEventListeners = {};
  const selection = useSelection$1(name, options);
  const { get: get2, has: has2, set: set2 } = useStore(`selections.${name}`);
  options = get2("options", Object.assign({
    // Specific selection item comparator
    matches: (item1) => (item2) => {
      const layer1 = _$1.get(item1, "layer.name");
      const layer2 = _$1.get(item2, "layer.name");
      if (layer1 && layer2) {
        if (layer1 !== layer2) return false;
        if (item1.feature && item2.feature) {
          const id1 = getFeatureId(item1.feature, item1.layer);
          const id2 = getFeatureId(item2.feature, item2.layer);
          return id1 === id2;
        } else {
          return false;
        }
      } else {
        if (layer1 || layer2) return false;
        const location1 = _$1.get(item1, "location");
        const location2 = _$1.get(item2, "location");
        return location1.lat === location2.lat && location1.lon === location2.lon;
      }
    },
    // Multiple selection key
    multiple: "ctrlKey",
    // Buffer selection width (10px)
    buffer: 10,
    showBuffer: false,
    showBufferDelay: 250,
    boxSelection: true,
    clusterSelection: false
  }, options));
  if (!has2("options")) set2("options", options);
  const { kActivity } = useCurrentActivity$1();
  let activity2 = unref(kActivity);
  function setCurrentActivity(newActivity) {
    if (activity2 === newActivity) return;
    if (activity2 && activity2.$engineEvents) {
      unlistenToFeaturesServiceEventsForLayers();
      selection.setSelectionEnabled();
      selection.clearSelection();
      activity2.$engineEvents.off("click", onClicked);
      if (options.boxSelection) activity2.$engineEvents.off("boxselectionend", onBoxSelection);
      if (options.clusterSelection) activity2.$engineEvents.off("spiderfied", onClusterSelection);
      activity2.$engineEvents.off("layer-added", listenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.off("layer-removed", unlistenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.off("layer-hidden", onSelectedLayerHidden);
    }
    activity2 = newActivity;
    if (activity2 && activity2.$engineEvents) {
      listenToFeaturesServiceEventsForLayers();
      activity2.$engineEvents.on("click", onClicked);
      if (options.boxSelection) activity2.$engineEvents.on("boxselectionend", onBoxSelection);
      if (options.clusterSelection) activity2.$engineEvents.on("spiderfied", onClusterSelection);
      activity2.$engineEvents.on("layer-added", listenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.on("layer-removed", unlistenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.on("layer-hidden", onSelectedLayerHidden);
    }
  }
  function setBoxSelectionEnabled(enabled) {
    if (options.boxSelection === enabled) return;
    options.boxSelection = enabled;
    if (!activity2) return;
    if (enabled) {
      activity2.$engineEvents.on("boxselectionend", onBoxSelection);
      activity2.map.boxSelection.enable();
    } else {
      activity2.$engineEvents.off("boxselectionend", onBoxSelection);
      activity2.map.boxSelection.disable();
    }
  }
  function setClusterSelectionEnabled(enabled) {
    if (options.clusterSelection === enabled) return;
    options.clusterSelection = enabled;
    if (!activity2) return;
    if (enabled) {
      activity2.$engineEvents.on("spiderfied", onClusterSelection);
    } else {
      activity2.$engineEvents.off("spiderfied", onClusterSelection);
    }
  }
  function setBufferWidth(width) {
    options.buffer = width;
  }
  function hasSelectedFeature() {
    return selection.hasSelectedItem() && selection.getSelectedItem().feature;
  }
  function getSelectedFeature() {
    return selection.getSelectedItem().feature;
  }
  function getSelectedFeatures() {
    return selection.getSelectedItems().filter((item) => item.feature).map((item) => item.feature);
  }
  function getSelectedFeatureCollection() {
    return { type: "FeatureCollection", features: selection.getSelectedItems().filter((item) => item.feature).map((item) => item.feature) };
  }
  function getSelectedFeaturesByLayer() {
    const featuresByLayer = {};
    const items = selection.getSelectedItems().filter((item) => item.feature && item.layer);
    items.forEach((item) => {
      const key = item.layer._id || item.layer.name;
      if (!featuresByLayer[key]) featuresByLayer[key] = { layer: item.layer, features: [] };
      featuresByLayer[key].features.push(item.feature);
    });
    return _$1.values(featuresByLayer);
  }
  function hasSelectedLayer() {
    return selection.hasSelectedItem() && selection.getSelectedItem().layer;
  }
  function getSelectedLayer() {
    return selection.getSelectedItem().layer;
  }
  function getSelectedLayers() {
    return selection.getSelectedItem().filter((item) => item.layer).map((item) => item.layer);
  }
  function hasSelectedLocation() {
    return selection.hasSelectedItem() && selection.getSelectedItem().location;
  }
  function getSelectedLocation() {
    return selection.getSelectedItem().location;
  }
  function findSelectedFeature(feature2, layer2) {
    const items = selection.getSelectedItems();
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.feature && item.layer && item.layer.name === layer2.name) {
        const selectedId = getFeatureId(item.feature, item.layer);
        const featureId = getFeatureId(feature2, layer2);
        if (featureId === selectedId) return item;
      }
    }
    return null;
  }
  function isFeatureSelected(feature2, layer2) {
    return findSelectedFeature(feature2, layer2) !== null;
  }
  function getWidgetForSelection() {
    let widget;
    if (hasSelectedLayer()) {
      const layer2 = getSelectedLayer();
      widget = _$1.get(layer2, "widget");
      if (widget) {
        if (typeof widget !== "string") {
          widget = _$1.get(widget, "type", "information-box");
        }
      } else {
        if (_$1.has(layer2, "probe") || // Static probe on pre-defined sites
        _$1.has(layer2, "variables")) {
          widget = "time-series";
        } else if (_$1.get(layer2, "leaflet.type") === "mapillary") {
          widget = "mapillary-viewer";
        } else {
          widget = "information-box";
        }
      }
    }
    return widget;
  }
  function centerOnSelection() {
    if (hasSelectedFeature()) {
      activity2.center(..._$1.get(centroid(getSelectedFeature()), "geometry.coordinates"));
    } else if (hasSelectedLocation()) {
      activity2.center(getSelectedLocation().lng, getSelectedLocation().lat);
    }
  }
  function handleSelection(items, clearSelection) {
    if (!Array.isArray(items)) items = [items];
    const selectedItems = [];
    const unselectedItems = [];
    items.forEach((item) => {
      const { location: location2, feature: feature2, layer: layer2 } = item;
      if (feature2 && layer2) {
        if (isFeatureSelected(feature2, layer2)) {
          unselectedItems.push(item);
        } else {
          selectedItems.push(item);
        }
      } else if (location2 && layer2) {
        selectedItems.push(item);
      }
    });
    if (clearSelection || _$1.isEmpty(selectedItems) && _$1.isEmpty(unselectedItems)) selection.clearSelection();
    unselectedItems.forEach((item) => selection.unselectItem(item));
    selectedItems.forEach((item) => selection.selectItem(item));
  }
  function getIntersectedItems(polygon2) {
    const items = [];
    const layers = _$1.values(activity2.layers).filter(sift({
      scope: { $ne: "system" },
      "leaflet.type": "geoJson",
      isVisible: true
    }));
    layers.forEach((layer2) => {
      if (!activity2.isLayerSelectable(layer2)) return;
      const geoJson = activity2.toGeoJson(layer2.name);
      featureEach(geoJson, (feature2) => {
        if (booleanIntersects(feature2, polygon2)) {
          const location2 = centroid(feature2);
          const lng = _$1.get(location2, "geometry.coordinates[0]");
          const lat = _$1.get(location2, "geometry.coordinates[1]");
          items.push({ feature: feature2, layer: layer2, location: { lng, lat } });
        }
      });
    });
    return items;
  }
  let lastClickedPosition, lastBoxSelectionPosition;
  function onClicked(layer2, event) {
    if (!selection.isSelectionEnabled()) return;
    const containerPosition = _$1.get(event, "containerPoint");
    if (lastClickedPosition && containerPosition.equals(lastClickedPosition)) {
      lastClickedPosition = null;
      return;
    }
    if (lastBoxSelectionPosition && containerPosition.equals(lastBoxSelectionPosition)) {
      lastBoxSelectionPosition = null;
      return;
    }
    lastClickedPosition = containerPosition;
    const multiple = options.multiple ? _$1.get(event, `originalEvent.${options.multiple}`) : false;
    let items;
    const location2 = _$1.get(event, "latlng");
    if (selection.getSelectionMode() === "buffer") {
      if (activity2.is2D() && options.showBuffer) {
        const highlightStyle = _$1.get(config, `engines.${activity2.engine}.style.selection.polygon`, {});
        const marker = L$1.circleMarker(location2, Object.assign({ radius: options.buffer }, convertPolygonStyleToLeafletPath(highlightStyle))).addTo(activity2.map);
        setTimeout(() => marker.removeFrom(activity2.map), options.showBufferDelay);
      }
      const center2 = activity2.getCenter();
      const metresPerPixel = 40075016686e-3 * Math.abs(Math.cos(location2.lat * Math.PI / 180)) / Math.pow(2, center2.zoomLevel + 8);
      items = getIntersectedItems(circle([location2.lng, location2.lat], options.buffer * metresPerPixel, { steps: 100, units: "meters" }));
    } else {
      let feature2;
      if (layer2 && layer2.name) {
        layer2 = activity2.getLayerByName(layer2.name);
        if (layer2 && activity2.isLayerSelectable(layer2)) {
          feature2 = _$1.get(event, "target.feature");
        } else {
          layer2 = void 0;
        }
      } else {
        layer2 = void 0;
      }
      items = [{ location: location2, feature: feature2, layer: layer2 }];
    }
    const clearSelection = selection.isSingleSelectionMode() || !multiple;
    if (options.handler) options.handler(items, clearSelection);
    else handleSelection(items, clearSelection);
  }
  function onBoxSelection(map, event) {
    if (!selection.isSelectionEnabled()) return;
    lastBoxSelectionPosition = _$1.get(event, "containerPoint");
    const { bounds } = event;
    let items = getIntersectedItems(bboxPolygon([
      bounds.getWest(),
      bounds.getSouth(),
      bounds.getEast(),
      bounds.getNorth()
    ]));
    if (!_$1.isEmpty(items) && selection.isSingleSelectionMode()) items = _$1.last(items);
    if (options.handler) options.handler(items, true);
    else handleSelection(items, true);
  }
  function onClusterSelection(layer2, event) {
    if (!selection.isSelectionEnabled()) return;
    if (selection.isSingleSelectionMode()) return;
    const items = _$1.get(event, "markers", []).map((marker) => {
      const feature2 = marker.feature;
      const location2 = centroid(feature2);
      const lng = _$1.get(location2, "geometry.coordinates[0]");
      const lat = _$1.get(location2, "geometry.coordinates[1]");
      return { feature: feature2, layer: layer2, location: { lng, lat } };
    });
    if (options.handler) options.handler(items, true);
    else handleSelection(items, true);
  }
  function onSelectedLayerHidden(layer2) {
    const hiddenFeatures = selection.getSelectedItems().filter((item) => layer2.name === _$1.get(item, "layer.name"));
    hiddenFeatures.forEach((item) => selection.unselectItem(item));
  }
  function listenToFeaturesServiceEventsForLayer$1(layer2) {
    const listeners = listenToFeaturesServiceEventsForLayer(layer2, {
      all: onFeatureUpdated,
      removed: onFeatureRemoved
    }, layerServiceEventListeners[layer2._id]);
    if (listeners) layerServiceEventListeners[layer2._id] = listeners;
  }
  function unlistenToFeaturesServiceEventsForLayer$1(layer2) {
    unlistenToFeaturesServiceEventsForLayer(layer2, layerServiceEventListeners[layer2._id]);
    delete layerServiceEventListeners[layer2._id];
  }
  function listenToFeaturesServiceEventsForLayers() {
    layerServiceEventListeners = {};
    _$1.forEach(activity2.getLayers(), listenToFeaturesServiceEventsForLayer$1);
  }
  function unlistenToFeaturesServiceEventsForLayers() {
    _$1.forOwn(layerServiceEventListeners, unlistenToFeaturesServiceEventsForLayer$1);
    layerServiceEventListeners = {};
  }
  function onFeatureUpdated(feature2, layer2) {
    if (!layer2 && feature2.layer) layer2 = activity2.getLayerById(feature2.layer);
    if (!layer2) return;
    const item = findSelectedFeature(feature2, layer2);
    if (item) Object.assign(item.feature, feature2);
  }
  function onFeatureRemoved(feature2, layer2) {
    if (!layer2 && feature2.layer) layer2 = activity2.getLayerById(feature2.layer);
    if (!layer2) return;
    const item = findSelectedFeature(feature2, layer2);
    if (item) selection.unselectItem(item);
  }
  return {
    ...selection,
    getSelectionOptions: () => get2("options"),
    setCurrentActivity,
    hasSelectedFeature,
    getSelectedFeature,
    getSelectedFeatures,
    getSelectedFeatureCollection,
    getSelectedFeaturesByLayer,
    hasSelectedLayer,
    getSelectedLayer,
    getSelectedLayers,
    hasSelectedLocation,
    getSelectedLocation,
    getWidgetForSelection,
    centerOnSelection,
    setBoxSelectionEnabled,
    setClusterSelectionEnabled,
    setBufferWidth
  };
}
function useProbe(name, options = {}) {
  const { kActivity } = useCurrentActivity$1();
  let activity2 = unref(kActivity);
  const { store: store2, set: set2, get: get2, has: has2 } = useStore(`probes.${name}`);
  function setCurrentActivity(newActivity) {
    if (activity2 === newActivity) return;
    if (activity2 && activity2.$engineEvents) {
      activity2.$engineEvents.off("click", onClicked);
    }
    activity2 = newActivity;
    if (newActivity && newActivity.$engineEvents) {
      newActivity.$engineEvents.on("click", onClicked);
    }
  }
  function clearProbe() {
    set2("item", null);
  }
  function setProbe(probe) {
    set2("item", probe);
  }
  function isProbing() {
    return activity2 && activity2.isCursor("probe-cursor");
  }
  function hasProbedLayer() {
    return get2("item") && get2("item").layer;
  }
  function getProbedLayer() {
    return get2("item").layer;
  }
  function hasProbedLocation() {
    return get2("item") && get2("item").location;
  }
  function getProbedLocation() {
    return get2("item").location;
  }
  function getWidgetForProbe() {
    let widget;
    if (hasProbedLocation()) {
      widget = "time-series";
    }
    return widget;
  }
  function centerOnProbe() {
    if (hasProbedLocation()) {
      activity2.center(getProbedLocation().lng, getProbedLocation().lat);
    }
  }
  function handleProbe(probe) {
    setProbe(probe);
  }
  let lastClickedPosition;
  function onClicked(layer2, event) {
    if (!isProbing()) {
      if (get2("item")) {
        const feature3 = _$1.get(event, "target.feature");
        if (!feature3) clearProbe();
      }
      return;
    }
    const containerPosition = _$1.get(event, "containerPoint");
    if (lastClickedPosition && containerPosition.equals(lastClickedPosition)) {
      lastClickedPosition = null;
      return;
    }
    lastClickedPosition = containerPosition;
    const location2 = _$1.get(event, "latlng");
    let feature2;
    if (layer2 && layer2.name) {
      layer2 = activity2.getLayerByName(layer2.name);
      if (layer2 && activity2.isLayerProbable(layer2)) {
        feature2 = _$1.get(event, "target.feature");
      } else {
        layer2 = void 0;
      }
    } else {
      layer2 = void 0;
    }
    if (options.handler) options.handler({ location: location2, feature: feature2, layer: layer2 });
    else handleProbe({ location: location2, feature: feature2, layer: layer2 });
  }
  function probeAtLocation() {
    activity2.setCursor("probe-cursor");
    activity2.$engineEvents.once("click", () => {
      setTimeout(() => {
        activity2.unsetCursor("probe-cursor");
      }, options.timeout || 500);
    });
  }
  if (!has2("item")) {
    clearProbe();
  }
  return {
    setCurrentActivity,
    probe: store2,
    clearProbe,
    setProbe,
    hasProbedLayer,
    getProbedLayer,
    hasProbedLocation,
    getProbedLocation,
    probeAtLocation,
    getWidgetForProbe,
    centerOnProbe
  };
}
const HighlightsLayerName = uid$2();
const HighlightsZIndex = 999;
const HighlightMargin = 8;
function useHighlight(name, options = {}) {
  let highlightMode = "highlightable-layers";
  let layerServiceEventListeners = {};
  options = Object.assign({ updateDelay: 250 }, options);
  const { kActivity } = useCurrentActivity$1();
  let activity2 = unref(kActivity);
  const { store: store2, clear, set: set2, get: get2, unset: unset2, has: has2 } = useStore(`highlights.${name}`);
  const { forOwn } = useStore("highlights");
  function setCurrentActivity(newActivity) {
    if (activity2 === newActivity) return;
    if (activity2) {
      removeHighlightsLayer();
      activity2.$engineEvents.off("layer-added", listenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.off("layer-removed", unlistenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.off("layer-added", createHighlightsLayer);
      activity2.$engineEvents.off("layer-disabled", onHighlightedLayerDisabled);
      activity2.$engineEvents.off("layer-enabled", onHighlightedLayerEnabled);
    }
    activity2 = newActivity;
    if (activity2) {
      activity2.$engineEvents.on("layer-added", listenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.on("layer-removed", unlistenToFeaturesServiceEventsForLayer$1);
      activity2.$engineEvents.on("layer-added", createHighlightsLayer);
      activity2.$engineEvents.on("layer-disabled", onHighlightedLayerDisabled);
      activity2.$engineEvents.on("layer-enabled", onHighlightedLayerEnabled);
    }
  }
  function getHighlightId(feature2, layer2) {
    let id = `${name}`;
    if (layer2) id += `-${_$1.kebabCase(layer2.name)}`;
    if (feature2) {
      const featureId = getFeatureId(feature2, layer2);
      if (featureId) id += `-${featureId}`;
    }
    return id;
  }
  function isHighlightFor(highlightId, layer2, feature2) {
    return feature2 ? highlightId.includes(`-${getFeatureId(feature2, layer2)}`) : highlightId.includes(`-${_$1.kebabCase(layer2.name)}`);
  }
  function hasHighlight(feature2, layer2) {
    return has2(getHighlightId(feature2, layer2));
  }
  function getHighlight(feature2, layer2) {
    return get2(getHighlightId(feature2, layer2));
  }
  function setHighlightGeometry(feature2, highlight2) {
    Object.assign(
      highlight2,
      feature2.geometry ? { geometry: feature2.geometry } : { geometry: { type: "Point", coordinates: [_$1.get(feature2, "lng", 0), _$1.get(feature2, "lat", 0)] } }
    );
    if (options.asBbox && highlight2.geometry.type !== "Point") {
      Object.assign(highlight2, bboxPolygon(bbox$1(highlight2)));
    }
    requestHighlightsLayerUpdate();
  }
  function setHighlightMode(mode = "highlightable-layers") {
    highlightMode = mode;
  }
  function highlight(feature2, layer2, selected = true) {
    if (layer2 && highlightMode === "highlightable-layers" && !isLayerHighlightable(layer2)) return;
    const highlightId = getHighlightId(feature2, layer2);
    const highlight2 = {
      highlightId,
      type: "Feature",
      properties: Object.assign({
        zOrder: 0
      }, options)
    };
    setHighlightGeometry(feature2, highlight2);
    if (selected) {
      const selectionStylePath = `engines.${activity2.engine}.style.selection.${getFeatureStyleType(highlight2)}`;
      let highlightStyle = _$1.cloneDeep(_$1.get(config, selectionStylePath, {}));
      if (activity2.is2D()) {
        let radius = _$1.get(feature2, "style.radius");
        let size = _$1.get(feature2, "style.size");
        if (size && !Array.isArray(size)) {
          size = [size, size];
        }
        if (!size && !radius) {
          size = _$1.get(layer2, `${activity2.engine}.style.point.size`);
          radius = _$1.get(layer2, `${activity2.engine}.style.point.radius`);
          if (size && !Array.isArray(size)) {
            size = [size, size];
          }
        }
        if (radius) Object.assign(highlightStyle, { radius: radius + 0.5 * HighlightMargin });
        else if (size) Object.assign(highlightStyle, { size: [size[0] + HighlightMargin, size[1] + HighlightMargin] });
        Object.assign(highlight2, { style: highlightStyle });
      } else {
        Object.assign(highlight2, { style: _$1.defaults({}, highlightStyle, feature2.style) });
      }
    } else {
      Object.assign(highlight2, { style: feature2.style });
    }
    _$1.merge(highlight2, _$1.omit(feature2, ["geometry", "style"]));
    set2(highlightId, highlight2);
    setHighlightEnabled(feature2, layer2, layer2 ? !layer2.isDisabled : true);
    return highlight2;
  }
  function unhighlight(feature2, layer2) {
    const highlightId = getHighlightId(feature2, layer2);
    unset2(highlightId);
    requestHighlightsLayerUpdate();
  }
  function setHighlightEnabled(feature2, layer2, enabled = true) {
    const highlight2 = getHighlight(feature2, layer2);
    _$1.set(highlight2, "style.visibility", enabled);
    requestHighlightsLayerUpdate();
  }
  function setHighlightsEnabled(layer2, enabled = true) {
    getHighlights(layer2).forEach((highlight2) => setHighlightEnabled(highlight2, layer2, enabled));
  }
  function clearHighlights() {
    clear();
    requestHighlightsLayerUpdate();
  }
  function getHighlights(layer2, feature2) {
    let features = [];
    forOwn((store3) => {
      _$1.forOwn(store3, (value, key) => {
        if (!layer2 || layer2 && isHighlightFor(key, layer2, feature2)) {
          features.push(value);
        }
      });
    });
    return features;
  }
  async function createHighlightsLayer() {
    const layer2 = activity2.getLayerByName(HighlightsLayerName);
    if (!layer2) {
      await activity2.addLayer({
        name: HighlightsLayerName,
        type: "OverlayLayer",
        scope: "system",
        isSelectable: false,
        featureId: "highlightId",
        leaflet: {
          type: "geoJson",
          isVisible: true,
          realtime: true,
          interactive: false,
          cluster: false,
          removeMissing: true,
          popup: { pick: [] },
          zIndex: HighlightsZIndex,
          interactive: false
        },
        cesium: {
          type: "geoJson",
          isVisible: true,
          realtime: true,
          cluster: false,
          removeMissing: true,
          popup: { pick: [] }
        }
      });
    }
    if (!activity2.isLayerVisible(HighlightsLayerName)) await activity2.showLayer(HighlightsLayerName);
  }
  function updateHighlightsLayer() {
    let features = getHighlights();
    features = features.filter((feature2) => !feature2.isDisabled);
    features = _$1.sortBy(features, (feature2) => _$1.get(feature2, "properties.zOrder"));
    if (activity2) {
      activity2.updateLayer(HighlightsLayerName, {
        type: "FeatureCollection",
        features
      }, { replace: true });
    }
  }
  const requestHighlightsLayerUpdate = _$1.debounce(updateHighlightsLayer, options.updateDelay);
  function removeHighlightsLayer() {
    if (activity2) activity2.removeLayer(HighlightsLayerName);
  }
  function onHighlightedLayerDisabled(layer2) {
    getHighlights(layer2).forEach((highlight2) => {
      setHighlightEnabled(highlight2, layer2, false);
    });
  }
  function onHighlightedLayerEnabled(layer2) {
    getHighlights(layer2).forEach((highlight2) => {
      setHighlightEnabled(highlight2, layer2, true);
    });
  }
  function listenToFeaturesServiceEventsForLayer$1(layer2) {
    const listeners = listenToFeaturesServiceEventsForLayer(layer2, {
      all: onFeatureUpdated,
      removed: onFeatureRemoved
    }, layerServiceEventListeners[layer2._id]);
    if (listeners) layerServiceEventListeners[layer2._id] = listeners;
  }
  function unlistenToFeaturesServiceEventsForLayer$1(layer2) {
    unlistenToFeaturesServiceEventsForLayer(layer2, layerServiceEventListeners[layer2._id]);
    delete layerServiceEventListeners[layer2._id];
  }
  function listenToFeaturesServiceEventsForLayers() {
    layerServiceEventListeners = {};
    _$1.forEach(activity2.getLayers(), listenToFeaturesServiceEventsForLayer$1);
  }
  function unlistenToFeaturesServiceEventsForLayers() {
    _$1.forOwn(layerServiceEventListeners, unlistenToFeaturesServiceEventsForLayer$1);
    layerServiceEventListeners = {};
  }
  function onFeatureUpdated(feature2, layer2) {
    if (!layer2 && feature2.layer) layer2 = activity2.getLayerById(feature2.layer);
    if (!layer2) return;
    if (hasHighlight(feature2, layer2)) setHighlightGeometry(feature2, getHighlight(feature2, layer2));
  }
  function onFeatureRemoved(feature2, layer2) {
    if (!layer2 && feature2.layer) layer2 = activity2.getLayerById(feature2.layer);
    if (!layer2) return;
    if (hasHighlight(feature2, layer2)) unhighlight(feature2, layer2);
  }
  onBeforeMount(() => {
    listenToFeaturesServiceEventsForLayers();
  });
  onBeforeUnmount(() => {
    unlistenToFeaturesServiceEventsForLayers();
    clearHighlights();
  });
  return {
    setCurrentActivity,
    highlights: store2,
    setHighlightMode,
    hasHighlight,
    getHighlight,
    getHighlights,
    highlight,
    unhighlight,
    setHighlightEnabled,
    setHighlightsEnabled,
    clearHighlights
  };
}
const ActivityComposables = {};
function useActivity(name, options = {}) {
  _$1.defaults(options, { selection: true, probe: true, highlight: true });
  const coreActivity = useActivity$1(name, options);
  const { CurrentActivityContext: CurrentActivityContext2 } = coreActivity;
  let selection, probe, highlight;
  function setCurrentActivity(activity2) {
    coreActivity.setCurrentActivity(activity2);
    if (selection) selection.setCurrentActivity(activity2);
    if (probe) probe.setCurrentActivity(activity2);
    if (highlight) highlight.setCurrentActivity(activity2);
  }
  const expose = {
    ...coreActivity
  };
  if (options.selection) {
    selection = useSelection(name, _$1.get(CurrentActivityContext2, "config.selection"));
    Object.assign(expose, {
      ...selection
    });
  }
  if (options.probe) {
    probe = useProbe(name, _$1.get(CurrentActivityContext2, "config.probe"));
    Object.assign(expose, {
      ...probe
    });
  }
  if (options.highlight) {
    highlight = useHighlight(name, _$1.get(CurrentActivityContext2, "config.highlight"));
    Object.assign(expose, {
      ...highlight
    });
  }
  Object.assign(expose, {
    setCurrentActivity
  });
  _$1.set(ActivityComposables, name, expose);
  return expose;
}
const activityProject = shallowRef(null);
function useCurrentActivity(options = {}) {
  _$1.defaults(options, { selection: true, probe: true });
  const coreActivity = useCurrentActivity$1();
  const { CurrentActivityContext: CurrentActivityContext2 } = coreActivity;
  function setActivityProject(project) {
    activityProject.value = unref(project);
  }
  function getActivityProject() {
    return activityProject.value;
  }
  const expose = {
    ...coreActivity,
    setActivityProject,
    getActivityProject
  };
  if (CurrentActivityContext2.name) {
    Object.assign(expose, _$1.get(ActivityComposables, CurrentActivityContext2.name));
  }
  return expose;
}
class KGeolocationError extends KError {
}
const errors = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KGeolocationError
}, Symbol.toStringTag, { value: "Module" }));
function defineUserAbilities(subject, can, cannot) {
  can("service", "geocoder");
  can("create", "geocoder");
  can("service", "catalog");
  can("read", "catalog");
  can("service", "projects");
  can("read", "projects");
  can("service", "alerts");
  can("read", "alerts");
  can("service", "styles");
  can("read", "styles");
}
const permissions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  defineUserAbilities
}, Symbol.toStringTag, { value: "Module" }));
const SortOrder = {
  ASCENDING: 0,
  DESCENDING: 1
};
const gridSourceFactories = {};
const unitConverters = {};
const toHalf = function() {
  const floatView = new Float32Array(1);
  const int32View = new Int32Array(floatView.buffer);
  return function toHalf2(val) {
    floatView[0] = val;
    const x = int32View[0];
    let bits = x >> 16 & 32768;
    let m = x >> 12 & 2047;
    const e = x >> 23 & 255;
    if (e < 103) {
      return bits;
    }
    if (e > 142) {
      bits |= 31744;
      bits |= (e === 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  };
}();
class BaseGrid {
  constructor(sourceKey, bbox2, dimensions, nodata) {
    this.sourceKey = sourceKey;
    this.bbox = bbox2;
    this.dimensions = dimensions;
    this.resolution = [(bbox2[2] - bbox2[0]) / (dimensions[0] - 1), (bbox2[3] - bbox2[1]) / (dimensions[1] - 1)];
    this.nodata = nodata;
    if (this.bbox[0] >= this.bbox[2] || this.bbox[1] >= this.bbox[3]) {
      throw new Error("Grid bbox seems weird");
    }
    if (this.dimensions[0] <= 0 || this.dimensions[1] <= 0) {
      throw new Error("Grid dimension is < 0, something's wrong");
    }
    if (this.resolution[0] <= 0 || this.resolution[1] <= 0) {
      throw new Error("Grid resolution is < 0, something's wrong");
    }
  }
  getDimensions() {
    return this.dimensions;
  }
  getResolution() {
    return this.resolution;
  }
  getBBox() {
    return this.bbox;
  }
  hasData() {
    for (let ilat = 0; ilat < this.dimensions[0]; ++ilat) {
      for (let ilon = 0; ilon < this.dimensions[1]; ++ilon) {
        const value = this.getValue(ilat, ilon);
        if (value !== this.nodata) {
          return true;
        }
      }
    }
    return false;
  }
  getDataBounds() {
    if (this.dataBounds) {
      return this.dataBounds;
    }
    let ilat = 0;
    let ilon = 0;
    let minVal;
    let maxVal;
    for (; ilat < this.dimensions[0] && maxVal === void 0; ++ilat) {
      for (; ilon < this.dimensions[1] && maxVal === void 0; ++ilon) {
        const value = this.getValue(ilat, ilon);
        if (value === this.nodata) {
          continue;
        }
        minVal = maxVal = value;
      }
    }
    for (; ilat < this.dimensions[0]; ++ilat) {
      for (; ilon < this.dimensions[1]; ++ilon) {
        const value = this.getValue(ilat, ilon);
        if (value === this.nodata) {
          continue;
        }
        minVal = Math.min(minVal, value);
        maxVal = Math.max(maxVal, value);
      }
    }
    this.dataBounds = [minVal, maxVal];
    return this.dataBounds;
  }
  getLat(ilat) {
    return this.bbox[0] + ilat * this.resolution[0];
  }
  getLon(ilon) {
    return this.bbox[1] + ilon * this.resolution[1];
  }
  getValue(ilat, ilon) {
    throw new Error("Not implemented");
  }
  getIndices(lat, lon) {
    if (lat < this.bbox[0] || lat > this.bbox[2] || lon < this.bbox[1] || lon > this.bbox[2]) {
      return null;
    }
    const ilat = (lat - this.bbox[0]) / this.resolution[0];
    const ilon = (lon - this.bbox[1]) / this.resolution[1];
    return [Math.floor(ilat), Math.floor(ilon)];
  }
  getBestFit(fitBbox) {
    let iminlat = -1;
    for (let ilat = 0; ilat < this.dimensions[0] - 1 && iminlat === -1; ++ilat) {
      const lat = this.getLat(ilat + 1);
      if (lat > fitBbox[0]) iminlat = ilat;
    }
    let imaxlat = -1;
    for (let ilat = this.dimensions[0] - 1; ilat > 0 && imaxlat === -1; --ilat) {
      const lat = this.getLat(ilat - 1);
      if (lat < fitBbox[2]) imaxlat = ilat;
    }
    let iminlon = -1;
    for (let ilon = 0; ilon < this.dimensions[1] - 1 && iminlon === -1; ++ilon) {
      const lon = this.getLon(ilon + 1);
      if (lon > fitBbox[1]) iminlon = ilon;
    }
    let imaxlon = -1;
    for (let ilon = this.dimensions[1] - 1; ilon > 0 && imaxlon === -1; --ilon) {
      const lon = this.getLon(ilon - 1);
      if (lon < fitBbox[3]) imaxlon = ilon;
    }
    return [iminlat, iminlon, imaxlat, imaxlon];
  }
  genCoordsBuffer() {
    const numPoints = this.dimensions[0] * this.dimensions[1];
    const coords = new Uint16Array(2 * numPoints);
    const minLat = this.getLat(0);
    const maxLat = this.getLat(this.dimensions[0] - 1);
    const minLon = this.getLon(0);
    const maxLon = this.getLon(this.dimensions[1] - 1);
    const deltaLat = maxLat - minLat;
    const deltaLon = maxLon - minLon;
    let vidx = 0;
    for (let ilon = 0; ilon < this.dimensions[1]; ++ilon) {
      const lon = this.getLon(ilon);
      for (let ilat = 0; ilat < this.dimensions[0]; ++ilat) {
        const lat = this.getLat(ilat);
        coords[vidx * 2] = toHalf((lat - minLat) / deltaLat);
        coords[vidx * 2 + 1] = toHalf((lon - minLon) / deltaLon);
        ++vidx;
      }
    }
    return { coords, minLat, maxLat, minLon, maxLon, deltaLat, deltaLon };
  }
  genValuesBuffer() {
    const numPoints = this.dimensions[0] * this.dimensions[1];
    const values = new Float32Array(numPoints);
    let vidx = 0;
    for (let ilon = 0; ilon < this.dimensions[1]; ++ilon) {
      for (let ilat = 0; ilat < this.dimensions[0]; ++ilat) {
        values[vidx] = this.getValue(ilat, ilon);
        ++vidx;
      }
    }
    return values;
  }
  genMeshIndexBuffer() {
    let iidx = 0;
    const maxIndex = this.dimensions[0] * this.dimensions[1] - 1;
    const numIndex = (this.dimensions[1] - 1) * (this.dimensions[0] * 2 + 1) - 1;
    const restart = maxIndex > 65534 ? 4294967295 : 65535;
    const index2 = maxIndex > 65534 ? new Uint32Array(numIndex) : new Uint16Array(numIndex);
    for (let i = 0; i < this.dimensions[1] - 1; ++i) {
      for (let j = 0; j < this.dimensions[0]; ++j) {
        index2[iidx++] = j + i * this.dimensions[0];
        index2[iidx++] = j + (i + 1) * this.dimensions[0];
      }
      if (i !== this.dimensions[1] - 2) {
        index2[iidx++] = restart;
      }
    }
    return index2;
  }
  genWireframeIndexBuffer() {
    const maxIndex = this.dimensions[0] * this.dimensions[1] - 1;
    const numIndex = this.dimensions[1] * (this.dimensions[0] + 1) + (this.dimensions[0] * (this.dimensions[1] + 1) - 1);
    const restart = maxIndex > 65534 ? 4294967295 : 65535;
    const index2 = maxIndex > 65534 ? new Uint32Array(numIndex) : new Uint16Array(numIndex);
    let iidx = 0;
    for (let i = 0; i < this.dimensions[1]; ++i) {
      for (let j = 0; j < this.dimensions[0]; ++j) {
        index2[iidx++] = j + i * this.dimensions[0];
      }
      index2[iidx++] = restart;
    }
    for (let j = 0; j < this.dimensions[0]; ++j) {
      for (let i = 0; i < this.dimensions[1]; ++i) {
        index2[iidx++] = j + i * this.dimensions[0];
      }
      if (j !== this.dimensions[0] - 1) {
        index2[iidx++] = restart;
      }
    }
    return index2;
  }
}
class GridSource {
  constructor(options) {
    this.events = {};
    this.sourceKey = 0;
  }
  getBBox() {
    return null;
  }
  getDataBounds() {
    throw new Error("Not implemented");
  }
  supportsNoData() {
    return this.nodata !== void 0;
  }
  /**
     * @returns {Number} Returns a new longitude with the value wrapped so it's always in the same range than the given bounding box (e.g. between -180 and +180 degrees).
     */
  wrapLongitude(lon, bounds) {
    if (bounds[0] < 0) {
      return lon > 180 ? lon - 360 : lon;
    } else if (bounds[2] > 180) {
      return lon < 0 ? lon + 360 : lon;
    } else {
      return lon;
    }
  }
  async setup(config2) {
    throw new Error("Not implemented");
  }
  async fetch(abort, bbox2, resolution) {
    throw new Error("Not implemented");
  }
  on(event, callback) {
    const callbacks = _$1.get(this.events, event, []);
    callbacks.push(callback);
    if (callbacks.length === 1) {
      this.events[event] = callbacks;
    }
  }
  off(event, callback) {
    const callbacks = _$1.get(this.events, event, []);
    callbacks.splice(0, 0, callback);
  }
  emit(event) {
    const callbacks = _$1.get(this.events, event, []);
    const ctx = { source: this, event };
    for (const cb of callbacks) {
      cb(ctx);
    }
  }
  dataChanged() {
    this.emit("data-changed");
  }
}
function makeGridSource(key, options = null) {
  const factory = _$1.get(gridSourceFactories, key, null);
  if (factory) {
    return factory(options);
  }
  return null;
}
function extractGridSourceConfig(options) {
  for (const key of Object.keys(options)) {
    const factory = _$1.get(gridSourceFactories, key, null);
    if (factory) {
      return [key, options[key]];
    }
  }
  return [null, null];
}
const grid1DAccessFunctions = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilon * latCount + ilat];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[(lonCount - (ilon + 1)) * latCount + ilat];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilon * latCount + (latCount - (ilat + 1))];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[(lonCount - (ilon + 1)) * latCount + (latCount - (ilat + 1))];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilat * lonCount + ilon];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilat * lonCount + (lonCount - (ilon + 1))];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[(latCount - (ilat + 1)) * lonCount + ilon];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[(latCount - (ilat + 1)) * lonCount + (lonCount - (ilon + 1))];
  }
];
class Grid1D extends BaseGrid {
  constructor(sourceKey, bbox2, dimensions, data, latFirst, latSortOrder, lonSortOrder, nodata = void 0, converter = null) {
    super(sourceKey, bbox2, dimensions, nodata);
    this.data = data;
    const index2 = lonSortOrder + latSortOrder * 2 + (latFirst ? 1 : 0) * 4;
    this.getByIndex = grid1DAccessFunctions[index2];
    if (converter) {
      for (let i = 0; i < data.length; ++i) {
        data[i] = converter(data[i]);
      }
    }
  }
  getValue(ilat, ilon) {
    return this.getByIndex(this.data, ilat, ilon, this.dimensions[0], this.dimensions[1]);
  }
}
const grid2DAccessFunctions = [
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilon][ilat];
  },
  // lonFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[lonCount - (ilon + 1)][ilat];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilon][latCount - (ilat + 1)];
  },
  // lonFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[lonCount - (ilon + 1)][latCount - (ilat + 1)];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilat][ilon];
  },
  // latFirst, latOrder=SortOrder.ASCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[ilat][lonCount - (ilon + 1)];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.ASCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[latCount - (ilat + 1)][ilon];
  },
  // latFirst, latOrder=SortOrder.DESCENDING, lonOrder=SortOrder.DESCENDING
  function(data, ilat, ilon, latCount, lonCount) {
    return data[latCount - (ilat + 1)][lonCount - (ilon + 1)];
  }
];
class Grid2D extends BaseGrid {
  constructor(sourceKey, bbox2, dimensions, data, latFirst, latSortOrder, lonSortOrder, nodata = void 0, converter = null) {
    super(sourceKey, bbox2, dimensions, nodata);
    this.data = data;
    const index2 = lonSortOrder + latSortOrder * 2 + (latFirst ? 1 : 0) * 4;
    this.getByIndex = grid2DAccessFunctions[index2];
    if (converter) {
      for (let l = 0; l < data.length; ++l) {
        const line = data[l];
        for (let r = 0; r < line.length; ++r) {
          line[r] = converter(line[r]);
        }
      }
    }
  }
  getValue(ilat, ilon) {
    return this.getByIndex(this.data, ilat, ilon, this.dimensions[0], this.dimensions[1]);
  }
}
class TiledGrid extends BaseGrid {
  constructor(sourceKey, tiles, nodata = void 0) {
    const bbox0 = tiles[0].getBBox();
    const dim0 = tiles[0].getDimensions();
    const res0 = tiles[0].getResolution();
    super(sourceKey, bbox0, dim0, nodata);
    this.dimensions = [0, 0];
    this.bbox = [bbox0[0], bbox0[1], bbox0[2], bbox0[3]];
    this.resolution = [res0[0], res0[1]];
    for (const tile of tiles) {
      const res = tile.getResolution();
      if (res[0] !== res0[0] || res[1] !== res0[1]) {
        throw new Error("Resolution does not match between tiles");
      }
      const bbox2 = tile.getBBox();
      this.bbox[0] = Math.min(this.bbox[0], bbox2[0]);
      this.bbox[1] = Math.min(this.bbox[1], bbox2[1]);
      this.bbox[2] = Math.max(this.bbox[2], bbox2[2]);
      this.bbox[3] = Math.max(this.bbox[3], bbox2[3]);
    }
    this.dimensions[0] = 1 + Math.trunc((this.bbox[2] - this.bbox[0]) / this.resolution[0]);
    this.dimensions[1] = 1 + Math.trunc((this.bbox[3] - this.bbox[1]) / this.resolution[1]);
    this.tiles = [];
    for (const tile of tiles) {
      const bbox2 = tile.getBBox();
      const meta = {
        tile,
        iLatMin: Math.floor((bbox2[0] - this.bbox[0]) / this.resolution[0]),
        iLatMax: Math.floor((bbox2[2] - this.bbox[0]) / this.resolution[0]),
        iLonMin: Math.floor((bbox2[1] - this.bbox[1]) / this.resolution[1]),
        iLonMax: Math.floor((bbox2[3] - this.bbox[1]) / this.resolution[1])
      };
      this.tiles.push(meta);
    }
  }
  getValue(ilat, ilon) {
    let tile = null;
    for (const t of this.tiles) {
      if (ilat < t.iLatMin || ilat > t.iLatMax || ilon < t.iLonMin || ilon > t.iLonMax) {
        continue;
      }
      tile = t;
      break;
    }
    if (!tile) {
      return 0;
    }
    return tile.tile.getValue(ilat - tile.iLatMin, ilon - tile.iLonMin);
  }
}
class SubGrid extends BaseGrid {
  constructor(sourceKey, grid2, subBbox) {
    const [iminlat, iminlon, imaxlat, imaxlon] = grid2.getBestFit(subBbox);
    const adjustedDims = [1 + imaxlat - iminlat, 1 + imaxlon - iminlon];
    const adjustedBbox = [grid2.getLat(iminlat), grid2.getLon(iminlon), grid2.getLat(imaxlat), grid2.getLon(imaxlon)];
    super(sourceKey, adjustedBbox, adjustedDims, grid2.nodata);
    this.latOffset = iminlat;
    this.lonOffset = iminlon;
    this.implGrid = grid2;
  }
  getValue(ilat, ilon) {
    return this.implGrid.getValue(ilat + this.latOffset, ilon + this.lonOffset);
  }
}
const grid = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseGrid,
  Grid1D,
  Grid2D,
  GridSource,
  SortOrder,
  SubGrid,
  TiledGrid,
  extractGridSourceConfig,
  gridSourceFactories,
  makeGridSource,
  unitConverters
}, Symbol.toStringTag, { value: "Module" }));
const opendapTypes = /* @__PURE__ */ new Set(["Float32", "Float64"]);
async function fetchDescriptor(url) {
  const question = url.indexOf("?");
  const ddsUrl = question === -1 ? `${url}.dds` : `${url.substring(0, question)}.dds${url.substring(question)}`;
  const dasUrl = question === -1 ? `${url}.das` : `${url.substring(0, question)}.das${url.substring(question)}`;
  const ddsReq = fetch(ddsUrl).then((response) => response.text());
  const dasReq = fetch(dasUrl).then((response) => response.text());
  const [ddsTxt, dasTxt] = await Promise.all([ddsReq, dasReq]);
  const dds = new parser.ddsParser(ddsTxt).parse();
  const das = new parser.dasParser(dasTxt, dds).parse();
  return das;
}
async function fetchData(query, abort = null) {
  const init2 = abort ? { signal: abort } : {};
  let dds = null;
  let dap = null;
  let attempt = 0;
  while (!dap) {
    ++attempt;
    try {
      const data2 = await fetch(query, init2).then((response) => response.arrayBuffer());
      const view = new DataView(data2);
      let ddsTxt = "";
      let byteIndex = 0;
      while (byteIndex < view.byteLength) {
        const u8 = view.getUint8(byteIndex);
        if (u8 === "\n" || u8 === 10) {
          const str = String.fromCodePoint(
            view.getUint8(byteIndex + 1),
            view.getUint8(byteIndex + 2),
            view.getUint8(byteIndex + 3),
            view.getUint8(byteIndex + 4),
            view.getUint8(byteIndex + 5),
            view.getUint8(byteIndex + 6)
          );
          if (str === "Data:\n") {
            break;
          }
        }
        ddsTxt += String.fromCodePoint(u8);
        ++byteIndex;
      }
      dds = new parser.ddsParser(ddsTxt).parse();
      dap = new xdr.dapUnpacker(data2.slice(byteIndex + 7), dds).getValue();
    } catch (err) {
      if (attempt >= 2) throw err;
    }
  }
  const data = {};
  if (dds && dap) {
    let offset = 0;
    for (const field in dds) {
      if (dds[field].type) {
        data[field] = dap[offset];
        offset += 1;
      }
    }
  }
  return data;
}
function variableIsGrid(descriptor, variable) {
  const varDesc = descriptor[variable];
  if (varDesc === void 0) {
    return false;
  }
  return varDesc.type === "Grid";
}
function variableIsArray(descriptor, variable) {
  const varDesc = descriptor[variable];
  if (varDesc === void 0) {
    return false;
  }
  if (varDesc.shape === void 0) {
    return false;
  }
  return varDesc.shape.length === 1 && opendapTypes.has(varDesc.type);
}
function getArrayVariableLength(descriptor, variable) {
  const varDesc = descriptor[variable];
  return varDesc.shape[0];
}
function getGridDimensionLength(descriptor, variable, dimension) {
  const varDesc = descriptor[variable];
  return varDesc.array.shape[dimension];
}
function makeGridIndices(descriptor, variable, dimensions) {
  const varDesc = descriptor[variable];
  const indices = [];
  for (let i = 0; i < varDesc.array.dimensions.length; ++i) {
    const value = dimensions[varDesc.array.dimensions[i]];
    if (value === void 0) {
      return [];
    }
    indices.push(value);
  }
  return indices;
}
function makeQuery(base, config2) {
  let variables;
  if (Array.isArray(config2)) {
    variables = config2;
  } else {
    variables = _$1.keys(config2).map((variable) => `${variable}[${config2[variable]}]`);
  }
  const question = base.indexOf("?");
  const url = (question === -1 ? `${base}.dods?` : `${base.substring(0, question)}.dods${base.substring(question)}&`) + variables.join(",");
  return encodeURI(url);
}
function getGridDimensionIndex(descriptor, variable, dimension) {
  const varDesc = descriptor[variable];
  if (varDesc === void 0) {
    return -1;
  }
  return varDesc.array.dimensions.indexOf(dimension);
}
function getMinMaxArray(vec) {
  const bounds = vec.reduce((accu, value) => {
    accu[0] = Math.min(accu[0], value);
    accu[1] = Math.max(accu[1], value);
    return accu;
  }, [vec[0], vec[0]]);
  return bounds;
}
function getGridValue(grid2, indices) {
  let dim = 0;
  let array = grid2;
  for (; dim < indices.length - 1; ++dim) {
    array = array[indices[dim]];
  }
  return array[indices[dim]];
}
function getFirstGridValue(grid2, dimension) {
  let dim = 0;
  let array = grid2;
  for (; dim < dimension - 1; ++dim) {
    array = array[0];
  }
  return array[0];
}
function getMinMaxGrid(grid2, dimension) {
  if (dimension > 1) {
    const init2 = getFirstGridValue(grid2, dimension);
    return grid2.reduce((accu, value) => {
      const local = getMinMaxGrid(value, dimension - 1);
      return [Math.min(accu[0], local[0]), Math.max(accu[1], local[1])];
    }, [init2, init2]);
  } else {
    return getMinMaxArray(grid2);
  }
}
const makeIndicesFunctions = [
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.ASCENDING
  function(indices, latIndex, lonIndex, ilat, ilon, latCount, lonCount) {
    const local = [...indices];
    local.fill(0);
    local[latIndex] = ilat;
    local[lonIndex] = ilon;
    return local;
  },
  // latSortOrder = SortOrder.ASCENDING, lonSortOrder = SortOrder.DESCENDING
  function(indices, latIndex, lonIndex, ilat, ilon, latCount, lonCount) {
    const local = [...indices];
    local.fill(0);
    local[latIndex] = ilat;
    local[lonIndex] = lonCount - (ilon + 1);
    return local;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.ASCENDING
  function(indices, latIndex, lonIndex, ilat, ilon, latCount, lonCount) {
    const local = [...indices];
    local.fill(0);
    local[latIndex] = latCount - (ilat + 1);
    local[lonIndex] = ilon;
    return local;
  },
  // latSortOrder = SortOrder.DESCENDING, lonSortOrder = SortOrder.DESCENDING
  function(indices, latIndex, lonIndex, ilat, ilon, latCount, lonCount) {
    const local = [...indices];
    local.fill(0);
    local[latIndex] = latCount - (ilat + 1);
    local[lonIndex] = lonCount - (ilon + 1);
    return local;
  }
];
class OpenDAPGrid extends BaseGrid {
  constructor(sourceKey, bbox2, dimensions, data, indices, latIndex, lonIndex, latSortOrder, lonSortOrder, nodata = void 0, converter = null) {
    super(sourceKey, bbox2, dimensions, nodata);
    this.data = data;
    this.indices = indices;
    this.latIndex = latIndex;
    this.lonIndex = lonIndex;
    const index2 = lonSortOrder + latSortOrder * 2;
    this.makeIndices = makeIndicesFunctions[index2];
    if (converter) {
      const idx = [...indices];
      idx.fill(0);
      for (let la = 0; la < dimensions[0]; ++la) {
        idx[latIndex] = la;
        for (let lo = 0; lo < dimensions[1]; ++lo) {
          idx[lonIndex] = lo;
          const array = getGridValue(data, idx.slice(0, idx.length - 1));
          array[idx[idx.length - 1]] = converter(array[idx[idx.length - 1]]);
        }
      }
    }
  }
  getValue(ilat, ilon) {
    const indices = this.makeIndices(this.indices, this.latIndex, this.lonIndex, ilat, ilon, this.dimensions[0], this.dimensions[1]);
    return getGridValue(this.data, indices);
  }
}
const opendapUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OpenDAPGrid,
  fetchData,
  fetchDescriptor,
  getArrayVariableLength,
  getGridDimensionIndex,
  getGridDimensionLength,
  getGridValue,
  getMinMaxArray,
  getMinMaxGrid,
  makeGridIndices,
  makeQuery,
  opendapTypes,
  variableIsArray,
  variableIsGrid
}, Symbol.toStringTag, { value: "Module" }));
class OpenDapGridSource extends GridSource {
  static getKey() {
    return "opendap";
  }
  constructor(options) {
    super(options);
    this.usable = false;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(config2) {
    this.usable = false;
    ++this.sourceKey;
    this.descriptor = null;
    this.indices = null;
    this.latCount = 0;
    this.latIndex = 0;
    this.lonCount = 0;
    this.lonIndex = 0;
    this.minMaxLat = null;
    this.minMaxLon = null;
    this.minMaxVal = null;
    this.latStep = 0;
    this.lonStep = 0;
    this.latSortOrder = SortOrder.ASCENDING;
    this.lonSortOrder = SortOrder.ASCENDING;
    this.canUseGrid2D = false;
    this.config = config2;
    this.converter = unitConverters[this.config.converter];
    try {
      this.descriptor = await fetchDescriptor(this.config.url);
    } catch (error) {
      this.descriptor = null;
      console.log(`Failed fetching opendap descriptor from ${this.config.url}`);
    }
    if (this.descriptor) {
      const varIsGrid = variableIsGrid(this.descriptor, this.config.variable);
      const latIsArray = variableIsArray(this.descriptor, this.config.latitude);
      const lonIsArray = variableIsArray(this.descriptor, this.config.longitude);
      if (varIsGrid && latIsArray && lonIsArray) {
        this.latIndex = getGridDimensionIndex(this.descriptor, this.config.variable, this.config.latitude);
        this.latCount = getGridDimensionLength(this.descriptor, this.config.variable, this.latIndex);
        this.lonIndex = getGridDimensionIndex(this.descriptor, this.config.variable, this.config.longitude);
        this.lonCount = getGridDimensionLength(this.descriptor, this.config.variable, this.lonIndex);
        const dimensions = await this.getDimensionsAsIndices();
        dimensions[this.config.latitude] = `0:${this.latCount - 1}`;
        dimensions[this.config.longitude] = `0:${this.lonCount - 1}`;
        this.indices = makeGridIndices(this.descriptor, this.config.variable, dimensions);
        if (this.indices.length !== 0) {
          const last = this.indices.length - 1;
          if (this.latIndex === last && this.lonIndex === last - 1 || this.latIndex === last - 1 && this.lonIndex === last) {
            this.canUseGrid2D = true;
          }
          await this.computeMetaDataFromData();
          this.usable = true;
        } else {
          console.log("Couldn't create index array for grid");
        }
      } else {
        if (!varIsGrid) console.log(`${this.config.variable} is not a grid variable!`);
        if (!latIsArray) console.log(`${this.config.latitude} is expected to be an array variable!`);
        if (!lonIsArray) console.log(`${this.config.longitude} is expected to be an array variable!`);
      }
    }
    this.dataChanged();
  }
  async fetch(abort, bbox2, resolution) {
    if (!this.usable) {
      return null;
    }
    const query = this.makeQuery(bbox2, resolution);
    if (!query) {
      return null;
    }
    const sourceKey = this.sourceKey;
    const data = await fetchData(query, abort);
    const req = data[this.config.variable];
    const valData = req[0];
    const latData = req[this.latIndex + 1];
    const lonData = req[this.lonIndex + 1];
    const lat0 = latData[0];
    const lat1 = latData[latData.length - 1];
    let lon0 = lonData[0];
    let lon1 = lonData[lonData.length - 1];
    if (lon0 > 180) lon0 -= 360;
    if (lon1 > 180) lon1 -= 360;
    const databbox = [Math.min(lat0, lat1), Math.min(lon0, lon1), Math.max(lat0, lat1), Math.max(lon0, lon1)];
    if (this.canUseGrid2D) {
      const indices = this.indices.slice(0, this.indices.length - 2);
      indices.fill(0);
      const subgrid = getGridValue(valData, indices);
      return new Grid2D(
        sourceKey,
        databbox,
        [latData.length, lonData.length],
        subgrid,
        this.latIndex < this.lonIndex,
        this.latSortOrder,
        this.lonSortOrder,
        this.nodata,
        this.converter
      );
    }
    return new OpenDAPGrid(
      sourceKey,
      databbox,
      [latData.length, lonData.length],
      valData,
      this.indices,
      this.latIndex,
      this.lonIndex,
      this.latSortOrder,
      this.lonSortOrder,
      this.nodata,
      this.converter
    );
  }
  makeQuery(bbox2, resolution) {
    const reqMinLat = bbox2[0];
    const reqMinLon = bbox2[1];
    const reqMaxLat = bbox2[2];
    const reqMaxLon = bbox2[3];
    let iMinLat = Math.floor((reqMinLat - this.minMaxLat[0]) / this.latStep);
    let iMinLon = Math.floor((reqMinLon - this.minMaxLon[0]) / this.lonStep);
    let iMaxLat = Math.ceil((reqMaxLat - this.minMaxLat[0]) / this.latStep);
    let iMaxLon = Math.ceil((reqMaxLon - this.minMaxLon[0]) / this.lonStep);
    iMinLat = Math.min(Math.max(iMinLat, 0), this.latCount - 1);
    iMinLon = Math.min(Math.max(iMinLon, 0), this.lonCount - 1);
    iMaxLat = Math.min(Math.max(iMaxLat, 0), this.latCount - 1);
    iMaxLon = Math.min(Math.max(iMaxLon, 0), this.lonCount - 1);
    if (this.latSortOrder === SortOrder.DESCENDING) {
      const tmp = iMinLat;
      iMinLat = this.latCount - 1 - iMaxLat;
      iMaxLat = this.latCount - 1 - tmp;
    }
    if (this.lonSortOrder === SortOrder.DESCENDING) {
      const tmp = iMinLon;
      iMinLon = this.lonCount - 1 - iMaxLon;
      iMaxLon = this.lonCount - 1 - tmp;
    }
    const strideLat = Math.max(1, Math.floor(resolution[0] / this.latStep));
    const strideLon = Math.max(1, Math.floor(resolution[1] / this.lonStep));
    if (strideLat > 1) {
      iMaxLat = Math.min(this.latCount - 1, iMaxLat + strideLat);
    }
    if (strideLon > 1) {
      iMaxLon = Math.min(this.lonCount - 1, iMaxLon + strideLon);
    }
    const indices = [...this.indices];
    indices[this.latIndex] = `${iMinLat}:${strideLat}:${iMaxLat}`;
    indices[this.lonIndex] = `${iMinLon}:${strideLon}:${iMaxLon}`;
    const conf = {};
    conf[this.config.variable] = indices.join("][");
    return makeQuery(this.config.url, conf);
  }
  async computeMetaDataFromData() {
    const query = {};
    query[this.config.latitude] = `0:${this.latCount - 1}:${this.latCount - 1}`;
    query[this.config.longitude] = `0:${this.lonCount - 1}:${this.lonCount - 1}`;
    const url = makeQuery(this.config.url, query);
    const res = await fetchData(url);
    const latData = res[this.config.latitude];
    const lonData = res[this.config.longitude];
    const lat0 = latData[0];
    const lat1 = latData[latData.length - 1];
    this.minMaxLat = [Math.min(lat0, lat1), Math.max(lat0, lat1)];
    const lon0 = lonData[0] > 180 ? lonData[0] - 360 : lonData[0];
    const lon1 = lonData[lonData.length - 1] > 180 ? lonData[lonData.length - 1] - 360 : lonData[lonData.length - 1];
    this.minMaxLon = [Math.min(lon0, lon1), Math.max(lon0, lon1)];
    this.latStep = (this.minMaxLat[1] - this.minMaxLat[0]) / (this.latCount - 1);
    this.lonStep = (this.minMaxLon[1] - this.minMaxLon[0]) / (this.lonCount - 1);
    this.latSortOrder = lat0 < lat1 ? SortOrder.ASCENDING : SortOrder.DESCENDING;
    this.lonSortOrder = lon0 < lon1 ? SortOrder.ASCENDING : SortOrder.DESCENDING;
  }
  async getDimensionsAsIndices() {
    const dimensions = {};
    if (this.config.dimensionsAsIndices) {
      Object.assign(dimensions, this.config.dimensionsAsIndices);
    }
    if (this.config.dimensionsAsValues) {
      const variables = _$1.keys(this.config.dimensionsAsValues);
      const query = makeQuery(this.config.url, variables);
      const data = await fetchData(query, null);
      for (let i = 0; i < variables.length; ++i) {
        const varValues = data[variables[i]];
        const varValue = this.config.dimensionsAsValues[variables[i]];
        let valueIndex = -1;
        for (let j = 0; j < varValues.length && valueIndex === -1; ++j) {
          if (varValues[j] === varValue) {
            valueIndex = j;
          }
        }
        if (valueIndex === -1) {
          throw new Error(`Failed looking up value '${varValue}' for dimension named '${variables[i]}'`);
        }
        dimensions[variables[i]] = valueIndex;
      }
    }
    return dimensions;
  }
}
function fetchAsJson$1(query, headers = {}) {
  return fetch(query, { redirect: "follow", headers }).then((response) => response.text()).then((txt) => xml2js.parseStringPromise(txt, { tagNameProcessors: [xml2js.processors.stripPrefix] }));
}
async function DescribeCoverage(url, version, coverage, searchParams = {}, headers = {}) {
  const query = buildUrl(url, Object.assign({
    SERVICE: "WCS",
    VERSION: version,
    REQUEST: "DescribeCoverage",
    COVERAGE: coverage
  }, searchParams));
  return fetchAsJson$1(query, headers);
}
async function GetCoverage(abort, url, version, coverage, format, bbox2, width, height, searchParams = {}, headers = {}) {
  const query = buildUrl(url, Object.assign({
    SERVICE: "WCS",
    VERSION: version,
    REQUEST: "GetCoverage",
    COVERAGE: coverage,
    CRS: "EPSG:4326",
    BBOX: `${bbox2.join(",")}`,
    WIDTH: width,
    HEIGHT: height,
    FORMAT: format
  }, searchParams));
  return fetch(query, { method: "get", signal: abort, headers }).then((response) => response.arrayBuffer());
}
function GetCoverageSpatialBounds(coverage) {
  const envelope = _$1.get(coverage, "CoverageDescription.CoverageOffering[0].lonLatEnvelope[0].pos", null);
  if (!envelope) {
    return null;
  }
  const lats = [];
  const lons = [];
  for (const p of envelope) {
    const lonLat = p.split(" ");
    lons.push(parseFloat(lonLat[0]));
    lats.push(parseFloat(lonLat[1]));
  }
  const minLatLon = [Math.min(...lats), Math.min(...lons)];
  const maxLatLon = [Math.max(...lats), Math.max(...lons)];
  return [minLatLon[0], minLatLon[1], maxLatLon[0], maxLatLon[1]];
}
function GetSupportedFormats(coverage) {
  const root = _$1.get(coverage, "CoverageDescription.CoverageOffering[0].supportedFormats[0]", null);
  const formats = _$1.get(root, "formats");
  return formats;
}
class WcsGridSource extends GridSource {
  static getKey() {
    return "wcs";
  }
  constructor(options) {
    super(options);
    this.usable = false;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(config2) {
    this.usable = false;
    ++this.sourceKey;
    this.minMaxLat = null;
    this.minMaxLon = null;
    this.minMaxVal = null;
    this.queryFormat = null;
    this.config = config2;
    this.converter = unitConverters[config2.converter];
    try {
      const coverage = await DescribeCoverage(this.config.url, this.config.version, this.config.coverage, this.config.searchParams, this.config.headers);
      const bounds = GetCoverageSpatialBounds(coverage);
      const formats = GetSupportedFormats(coverage);
      this.queryFormat = formats[0];
      this.minMaxLat = [bounds[0], bounds[2]];
      this.minMaxLon = [bounds[1], bounds[3]];
      this.usable = true;
    } catch (error) {
      console.log(`Failed fetching wcs from ${this.config.url}`);
    }
    this.dataChanged();
  }
  async fetch(abort, bbox2, resolution) {
    if (!this.usable) {
      return null;
    }
    const sourceKey = this.sourceKey;
    const reqMinLat = bbox2[0];
    const reqMinLon = bbox2[1];
    const reqMaxLat = bbox2[2];
    const reqMaxLon = bbox2[3];
    const width = 1 + Math.trunc((bbox2[3] - bbox2[1]) / resolution[1]);
    const height = 1 + Math.trunc((bbox2[2] - bbox2[0]) / resolution[0]);
    const wcsbbox = [reqMinLon, reqMinLat, reqMaxLon, reqMaxLat];
    const image2 = await GetCoverage(abort, this.config.url, this.config.version, this.config.coverage, this.queryFormat, wcsbbox, width, height, this.config.searchParams, this.config.headers).then((buffer) => GeoTIFF.fromArrayBuffer(buffer)).then((tiff) => tiff.getImage());
    const data = image2.readRasters();
    const databbox = image2.getBoundingBox();
    const gridbbox = [databbox[1], databbox[0], databbox[3], databbox[2]];
    const dimensions = [image2.getHeight(), image2.getWidth()];
    return new Grid1D(
      sourceKey,
      gridbbox,
      dimensions,
      (await data)[0],
      true,
      SortOrder.DESCENDING,
      SortOrder.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function packRgb(r, g, b) {
  return r | g << 8 | b << 16 | 62 << 24;
}
function encodeRgb(packed) {
  const asuint = new Uint32Array(1);
  const asfloat = new Float32Array(asuint.buffer);
  asuint[0] = packed;
  return asfloat[0];
}
function mergeRgb(bands) {
  const scale2 = 8 * (bands.BYTES_PER_ELEMENT - 1);
  const merged = new Float32Array(bands.length / 3);
  const uint32View = new Uint32Array(merged.buffer);
  for (let i = 0; i < merged.length; i++) {
    uint32View[i] = packRgb(bands[i * 3] >> scale2, bands[i * 3 + 1] >> scale2, bands[i * 3 + 2] >> scale2);
  }
  return merged;
}
class GeoTiffGridSource extends GridSource {
  static getKey() {
    return "geotiff";
  }
  constructor(options) {
    super(options);
    this.usable = false;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(config2) {
    this.usable = false;
    ++this.sourceKey;
    this.minMaxLat = null;
    this.minMaxLon = null;
    this.minMaxVal = null;
    this.nodata = config2.nodata;
    this.converter = unitConverters[config2.converter];
    this.rgb = config2.rgb;
    try {
      this.geotiff = await GeoTIFF.fromUrl(config2.url);
    } catch (error) {
      this.geotiff = null;
      console.error(`Failed fetching geotiff from ${config2.url}`);
    }
    if (this.geotiff) {
      this.imageCount = await this.geotiff.getImageCount();
      this.refImage = await this.geotiff.getImage();
      if (this.nodata === void 0) {
        const meta = this.refImage.getFileDirectory();
        const nodata = parseFloat(meta.GDAL_NODATA);
        if (nodata && !isNaN(nodata)) this.nodata = nodata;
      }
      if (this.rgb === void 0) {
        this.rgb = this.refImage.getSamplesPerPixel() > 1;
      }
      if (this.rgb && this.nodata && this.nodata.length === 3) {
        this.nodata = encodeRgb(packRgb(this.nodata[0], this.nodata[1], this.nodata[2]));
      }
      const tiffBbox = this.refImage.getBoundingBox();
      this.minMaxLat = [tiffBbox[1], tiffBbox[3]];
      this.minMaxLon = [tiffBbox[0], tiffBbox[2]];
      this.usable = true;
    }
    this.dataChanged();
  }
  async fetch(abort, bbox2, resolution) {
    if (!this.usable) {
      return null;
    }
    const sourceKey = this.sourceKey;
    let usedImage = await this.geotiff.getImage(0);
    for (let i = 1; i < this.imageCount; ++i) {
      const img = await this.geotiff.getImage(i);
      const [rx3, ry2] = img.getResolution(this.refImage);
      if (Math.abs(rx3) > resolution[1] || Math.abs(ry2) > resolution[0]) break;
      usedImage = img;
    }
    const [rx2, ry] = usedImage.getResolution(this.refImage);
    const [ox, oy] = this.refImage.getOrigin();
    const [sx, sy] = [usedImage.getWidth(), usedImage.getHeight()];
    let left = (bbox2[1] - ox) / rx2;
    let right = (bbox2[3] - ox) / rx2;
    let bottom = (bbox2[0] - oy) / ry;
    let top = (bbox2[2] - oy) / ry;
    if (rx2 < 0) [left, right] = [right, left];
    if (ry < 0) [bottom, top] = [top, bottom];
    left = Math.min(sx - 1, Math.max(0, Math.floor(left)));
    right = Math.min(sx - 1, Math.max(0, Math.ceil(right)));
    bottom = Math.min(sy - 1, Math.max(0, Math.floor(bottom)));
    top = Math.min(sy - 1, Math.max(0, Math.ceil(top)));
    const window2 = [left, bottom, right + 1, top + 1];
    const bands = this.rgb ? await usedImage.readRGB({ window: window2 }) : await usedImage.readRasters({ window: window2, fillValue: this.nodata });
    const data = this.rgb ? mergeRgb(bands) : bands[0];
    if (rx2 < 0) [left, right] = [right, left];
    if (ry < 0) [bottom, top] = [top, bottom];
    const dataBbox = [
      oy + bottom * ry,
      ox + left * rx2,
      oy + top * ry,
      ox + right * rx2
    ];
    return new Grid1D(
      sourceKey,
      dataBbox,
      [bands.height, bands.width],
      data,
      true,
      SortOrder.DESCENDING,
      SortOrder.ASCENDING,
      this.nodata,
      this.converter
    );
  }
}
function additionalPointsNeeded(lat, lon1, lon2, precision) {
  const dist = lon2 - lon1;
  const num = Math.ceil(dist / precision) - 1;
  return Math.max(0, num);
}
function makeMongoPolygon(bbox2, precision) {
  const minLatPoints = additionalPointsNeeded(bbox2[0], bbox2[1], bbox2[3], precision);
  const maxLatPoints = additionalPointsNeeded(bbox2[2], bbox2[1], bbox2[3], precision);
  const deltaLon = bbox2[3] - bbox2[1];
  const polygon2 = [];
  for (let i = 0; i < minLatPoints + 2; ++i) {
    const lon = bbox2[1] + i / (minLatPoints + 1) * deltaLon;
    polygon2.push([lon, bbox2[0]]);
  }
  for (let i = 0; i < maxLatPoints + 2; ++i) {
    const lon = bbox2[3] - i / (maxLatPoints + 1) * deltaLon;
    polygon2.push([lon, bbox2[2]]);
  }
  polygon2.push([bbox2[1], bbox2[0]]);
  return polygon2;
}
function tile2key(x, y) {
  return x * 4294967296 + y;
}
function key2tile(k) {
  const x = Math.floor(k / 4294967296);
  return [x, k - x * 4294967296];
}
class WeacastGridSource extends GridSource {
  static getKey() {
    return "weacast";
  }
  constructor(options) {
    super(options);
    this.api = options.weacastApi;
    this.usable = false;
  }
  getBBox() {
    return this.usable ? [this.minMaxLat[0], this.minMaxLon[0], this.minMaxLat[1], this.minMaxLon[1]] : null;
  }
  getDataBounds() {
    return this.usable ? this.minMaxVal : null;
  }
  async setup(config2) {
    this.usable = false;
    ++this.sourceKey;
    if (!this.api) return;
    const model = this.api.models.find((model2) => model2.name === config2.model);
    if (!model) return;
    this.converter = unitConverters[config2.converter];
    this.time = moment(config2.forecastTime).utc().format();
    this.service = config2.model + "/" + config2.element;
    this.lonResolution = model.tileResolution[0];
    this.useCache = _$1.get(config2, "useCache", true);
    this.maxCacheSize = _$1.get(config2, "maxCacheSize", 0);
    if (this.useCache) {
      this.tileCache = /* @__PURE__ */ new Map();
      this.tileCounter = 0;
      this.tileOrigin = [model.origin[1], model.origin[0]];
      this.tileSize = [model.tileResolution[1], model.tileResolution[0]];
      this.wrapLon = model.bounds[2] > 180;
      this.maxTileX = (model.bounds[2] - model.bounds[0]) / model.tileResolution[0] - 1;
      this.maxTileY = (model.bounds[3] - model.bounds[1]) / model.tileResolution[1] - 1;
    } else {
      this.tileCache = null;
    }
    this.minMaxLat = [model.bounds[1], model.bounds[3]];
    const wrapLongitude = model.bounds[2] === 360;
    this.minMaxLon = [wrapLongitude ? -180 : model.bounds[0], wrapLongitude ? 180 : model.bounds[2]];
    this.minMaxVal = null;
    const query = {
      time: this.time,
      $select: ["forecastTime", "minValue", "maxValue"],
      $paginate: false
    };
    const results = await this.api.getService(this.service).find({ query });
    if (results.length > 0) this.minMaxVal = [results[0].minValue, results[0].maxValue];
    this.usable = true;
    this.dataChanged();
  }
  fetch(abort, bbox2, resolution) {
    if (!this.usable) {
      return null;
    }
    return this.useCache ? this.fetchWithCache(abort, bbox2, resolution) : this.fetchWithoutCache(abort, bbox2, resolution);
  }
  async fetchWithCache(abort, bbox2, resolution) {
    const minLon = this.wrapLon ? bbox2[1] < 0 ? bbox2[1] + 360 : bbox2[1] : bbox2[1];
    const maxLon = this.wrapLon ? bbox2[3] < 0 ? bbox2[3] + 360 : bbox2[3] : bbox2[3];
    const e = Math.min(Math.max(Math.floor((maxLon - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX);
    const w = Math.min(Math.max(Math.floor((minLon - this.tileOrigin[1]) / this.tileSize[1]), 0), this.maxTileX);
    const n = Math.min(Math.max(Math.floor((this.tileOrigin[0] - bbox2[2]) / this.tileSize[0]), 0), this.maxTileY);
    const s = Math.min(Math.max(Math.floor((this.tileOrigin[0] - bbox2[0]) / this.tileSize[0]), 0), this.maxTileY);
    const hits = [];
    for (let j = n; j <= s; ++j) {
      if (w > e) {
        for (let i = 0; i <= e; ++i) hits.push(tile2key(i, j));
        for (let i = w; i <= this.maxTileX; ++i) hits.push(tile2key(i, j));
      } else {
        for (let i = w; i <= e; ++i) hits.push(tile2key(i, j));
      }
    }
    const waits = [];
    const grids = [];
    const requests = [];
    const entries = hits.map((key) => this.tileCache.get(key));
    for (let i = 0; i < hits.length; ++i) {
      if (!entries[i]) {
        requests.push(hits[i]);
      } else {
        if (entries[i].grid) {
          grids.push(entries[i].grid);
        } else {
          waits.push(entries[i].request);
        }
      }
    }
    const sourceKey = this.sourceKey;
    if (requests.length) {
      const points = [];
      const offset = [this.tileSize[1] * 0.5, this.tileSize[0] * 0.5];
      for (let i = 0; i < requests.length; ++i) {
        const [x, y] = key2tile(requests[i]);
        let tilex = this.tileOrigin[1] + this.tileSize[1] * x;
        const tiley = this.tileOrigin[0] - this.tileSize[0] * y;
        if (tilex >= 180) tilex -= 360;
        points.push([tilex + offset[0], tiley - offset[1]]);
      }
      const query = {
        time: this.time,
        $select: ["forecastTime", "data", "geometry", "size", "x", "y"],
        $paginate: false,
        geometry: {
          $geoIntersects: {
            $geometry: {
              type: "MultiPoint",
              coordinates: points
            }
          }
        }
      };
      const request = new Promise((resolve, reject) => {
        this.api.getService(this.service).find({ query }).then((tiles) => {
          const grids2 = [];
          if (sourceKey === this.sourceKey) {
            for (const tile of tiles) {
              const tileBBox = tile.geometry.coordinates[0];
              const tileBounds = [tileBBox[0][1], tileBBox[0][0], tileBBox[2][1], tileBBox[2][0]];
              if (tileBounds[1] > tileBounds[3]) tileBounds[1] -= 360;
              const key = tile2key(tile.x, tile.y);
              const cached = this.tileCache.get(key);
              cached.grid = new Grid1D(
                sourceKey,
                tileBounds,
                tile.size,
                tile.data,
                true,
                SortOrder.DESCENDING,
                SortOrder.ASCENDING,
                this.nodata,
                this.converter
              );
              cached.request = null;
              if (this.maxCacheSize !== void 0) {
                cached.tileCounter = this.tileCounter;
                ++this.tileCounter;
                if (this.tileCounter > this.maxCacheSize) {
                  let oldestKey = key;
                  let oldestCounter = cached.tileCounter;
                  for (const [key2, tile2] of this.tileCache) {
                    if (tile2.tileCounter === void 0) continue;
                    if (tile2.tileCounter < oldestCounter) {
                      oldestCounter = tile2.tileCounter;
                      oldestKey = key2;
                    }
                  }
                  this.tileCache.delete(oldestKey);
                }
              }
              grids2.push(cached.grid);
            }
          }
          resolve(grids2);
        });
      });
      for (let i = 0; i < requests.length; ++i) {
        this.tileCache.set(requests[i], { request });
      }
      waits.push(request);
    }
    const newGrids = await Promise.all(waits);
    const allGrids = grids.concat(newGrids.flat());
    if (allGrids.length === 0) return null;
    const grid2 = allGrids.length > 1 ? new TiledGrid(sourceKey, allGrids) : allGrids[0];
    return new SubGrid(sourceKey, grid2, bbox2);
  }
  async fetchWithoutCache(abort, bbox2, resolution) {
    const query = {
      time: this.time,
      $select: ["forecastTime", "data", "geometry", "size"],
      $paginate: false,
      // build a polygon with points longitudaly spaced every lonResolution degrees
      // otherwise mongodb will connect points using shortest path on sphere
      // which is not going to be a square lat/lon box
      geometry: {
        $geoIntersects: {
          $geometry: {
            type: "Polygon",
            coordinates: [makeMongoPolygon(bbox2, this.lonResolution)]
          }
        }
      }
    };
    const sourceKey = this.sourceKey;
    const results = await this.api.getService(this.service).find({ query });
    if (results.length === 0) return null;
    const tiles = [];
    for (const tile of results) {
      const tileBBox = tile.geometry.coordinates[0];
      const tileBounds = [tileBBox[0][1], tileBBox[0][0], tileBBox[2][1], tileBBox[2][0]];
      if (tileBounds[1] > tileBounds[3]) tileBounds[1] -= 360;
      const grid2 = new Grid1D(
        sourceKey,
        tileBounds,
        tile.size,
        tile.data,
        true,
        SortOrder.DESCENDING,
        SortOrder.ASCENDING,
        this.nodata,
        this.converter
      );
      tiles.push(grid2);
    }
    return tiles.length > 1 ? new TiledGrid(sourceKey, tiles) : tiles[0];
  }
}
function roundHours(hours, interval) {
  return Math.floor(hours / interval) * interval;
}
function getNearestRunTime(datetime, runInterval) {
  const h2 = roundHours(datetime.hours(), runInterval / 3600);
  return datetime.clone().hours(h2).minutes(0).seconds(0).milliseconds(0);
}
function getNearestForecastTime(datetime, interval) {
  const offsetDateTime = datetime.clone().add({ seconds: 0.5 * interval });
  const h2 = roundHours(offsetDateTime.hours(), interval / 3600);
  return offsetDateTime.clone().hours(h2).minutes(0).seconds(0).milliseconds(0);
}
class DynamicGridSource extends GridSource {
  constructor(options) {
    super(options);
    this.source = null;
    this.updateId = null;
    this.updateCtx = {};
    this.buildCtx = {};
    this.onDataChanged = this.dataChanged.bind(this);
  }
  getBBox() {
    return this.source ? this.source.getBBox() : null;
  }
  getDataBounds() {
    return this.source ? this.source.getDataBounds() : null;
  }
  supportsNoData() {
    return this.source ? this.source.supportsNoData() : false;
  }
  async fetch(abort, bbox2, resolution) {
    return this.source ? this.source.fetch(abort, bbox2, resolution) : null;
  }
  invalidate() {
    this.forceUpdate = true;
  }
  queueUpdate() {
    if (this.updateId) return;
    this.updateId = setTimeout(() => {
      this.update(this.updateCtx);
      this.updateId = null;
    }, 50);
  }
  update(updateCtx) {
    const newCtx = this.makeBuildContext(updateCtx);
    const skipUpdate = this.forceUpdate ? false : this.shouldSkipUpdate(newCtx, this.buildCtx);
    this.forceUpdate = false;
    if (skipUpdate) return;
    this.buildCtx = newCtx;
    const [source, config2] = this.buildSourceAndConfig(newCtx);
    if (this.source) this.source.off("data-changed", this.onDataChanged);
    this.source = source;
    if (this.source) {
      this.source.on("data-changed", this.onDataChanged);
      this.source.setup(config2);
      this.sourceKey = this.source.sourceKey;
    } else {
      this.dataChanged();
    }
  }
  makeBuildContext(updateCtx) {
    return Object.assign({}, updateCtx);
  }
  shouldSkipUpdate(newContext, oldContext) {
    return false;
  }
  buildSourceAndConfig(ctx) {
    throw new Error("Not implemented");
  }
  deriveConfig(ctx, staticProps, dynamicProps) {
    const config2 = Object.assign({}, staticProps);
    for (const prop of _$1.keys(dynamicProps)) {
      const value = dynamicProps[prop](ctx);
      if (value !== null && value !== void 0) {
        let root = config2;
        const sub = prop.split("$");
        for (let i = 0; i < sub.length - 1; ++i) {
          if (root[sub[i]] === void 0) root[sub[i]] = {};
          root = root[sub[i]];
        }
        root[sub[sub.length - 1]] = value;
      }
    }
    return config2;
  }
  dynpropGenerator(conf) {
    if (conf.strTemplate) {
      return _$1.template(conf.strTemplate);
    }
    if (conf.intTemplate) {
      const strGen = _$1.template(conf.intTemplate);
      return function(ctx) {
        const strValue = strGen(ctx);
        return parseInt(strValue);
      };
    }
    if (conf.floatTemplate) {
      const strGen = _$1.template(conf.floatTemplate);
      return function(ctx) {
        const strValue = strGen(ctx);
        return parseFloat(strValue);
      };
    }
    return null;
  }
}
function readAsTimeOrDuration(conf) {
  let ret = null;
  if (typeof conf === "string") {
    if (conf.charAt(0) === "P") {
      ret = moment.duration(conf);
    } else {
      ret = moment.utc(conf);
    }
    ret = ret.isValid() ? ret : null;
  } else if (!conf) {
    ret = moment.duration(0);
  }
  return ret;
}
function makeTime(timeOrDuration, referenceTime) {
  return moment.isDuration(timeOrDuration) ? referenceTime.clone().add(timeOrDuration) : timeOrDuration;
}
class MeteoModelGridSource extends DynamicGridSource {
  static getKey() {
    return "meteo_model";
  }
  constructor(options) {
    super(options);
    this.options = options;
    this.updateCtx.level = void 0;
  }
  setModel(model) {
    this.updateCtx.model = model;
    this.queueUpdate();
  }
  setTime(time) {
    this.updateCtx.time = time.clone();
    this.updateCtx.time.utc();
    this.updateCtx.runOffset = 0;
    this.queueUpdate();
  }
  setLevel(level) {
    if (level !== null) this.updateCtx.level = level;
    else if (this.updateCtx.level) delete this.updateCtx.level;
    this.queueUpdate();
  }
  async setup(config2) {
    this.candidates = [];
    for (const source of config2.sources) {
      const item = Object.assign(Object.assign({}, config2.default), source);
      const [key, conf] = extractGridSourceConfig(item);
      const candidate = {
        key,
        staticProps: conf,
        dynamicProps: {},
        from: item.from ? readAsTimeOrDuration(item.from) : null,
        to: item.to ? readAsTimeOrDuration(item.to) : null,
        model: item.model
      };
      const dynprops = _$1.has(item.dynprops, candidate.key) ? item.dynprops[candidate.key] : item.dynprops;
      for (const prop of _$1.keys(dynprops)) {
        const value = dynprops[prop];
        const generator = this.dynpropGenerator(value);
        if (generator) candidate.dynamicProps[prop] = generator;
      }
      this.candidates.push(candidate);
    }
  }
  makeBuildContext(updateCtx) {
    const ctx = Object.assign({}, updateCtx);
    ctx.candidate = this.selectCandidate(updateCtx.time, updateCtx.model.name);
    if (ctx.candidate) {
      ctx.runTime = getNearestRunTime(updateCtx.time, updateCtx.model.runInterval);
      ctx.runTime.subtract(ctx.runOffset * updateCtx.model.runInterval, "seconds");
      ctx.forecastTime = getNearestForecastTime(updateCtx.time, updateCtx.model.interval);
      ctx.forecastOffset = moment.duration(ctx.forecastTime.diff(ctx.runTime));
      ctx.time.utc();
      ctx.runTime.utc();
      ctx.forecastTime.utc();
    }
    return ctx;
  }
  shouldSkipUpdate(newContext, oldContext) {
    if (oldContext.candidate !== newContext.candidate) return false;
    if (oldContext.runTime && newContext.runTime && !oldContext.runTime.isSame(newContext.runTime)) return false;
    if (oldContext.forecastTime && newContext.forecastTime && !oldContext.forecastTime.isSame(newContext.forecastTime)) return false;
    if (oldContext.level !== newContext.level) return false;
    return true;
  }
  buildSourceAndConfig(ctx) {
    let source = null;
    let config2 = null;
    if (ctx.candidate) {
      config2 = this.deriveConfig(ctx, ctx.candidate.staticProps, ctx.candidate.dynamicProps);
      if (config2) {
        source = makeGridSource(ctx.candidate.key, this.options);
      }
    }
    return [source, config2];
  }
  selectCandidate(time, model) {
    const now = moment();
    let candidate = null;
    for (const source of this.candidates) {
      if (source.model !== model) continue;
      const from = source.from ? makeTime(source.from, now) : null;
      const to = source.to ? makeTime(source.to, now) : null;
      if (from && to) {
        candidate = time.isBetween(from, to) ? source : null;
      } else if (from) {
        candidate = time.isSameOrAfter(from) ? source : null;
      } else if (to) {
        candidate = time.isSameOrBefore(to) ? source : null;
      }
      if (candidate) break;
    }
    return candidate;
  }
  dataChanged() {
    if (this.source && !this.source.usable) {
      if (this.updateCtx.runOffset === 0) {
        this.updateCtx.runOffset = 1;
        this.queueUpdate();
        return;
      }
    }
    super.dataChanged();
  }
}
class TimeBasedGridSource extends DynamicGridSource {
  static getKey() {
    return "time_based";
  }
  constructor(options) {
    super(options);
    this.options = options;
  }
  setTime(time) {
    this.updateCtx.time = time.clone();
    this.updateCtx.time.utc();
    this.queueUpdate();
  }
  async setup(config2) {
    this.candidates = [];
    for (const source of config2.sources) {
      const item = Object.assign(Object.assign({}, config2.default), source);
      const [key, conf] = extractGridSourceConfig(item);
      const candidate = {
        key,
        staticProps: conf,
        dynamicProps: {},
        from: item.from ? readAsTimeOrDuration(item.from) : null,
        to: item.to ? readAsTimeOrDuration(item.to) : null,
        every: moment.duration(item.every)
      };
      const dynprops = _$1.has(item.dynprops, candidate.key) ? item.dynprops[candidate.key] : item.dynprops;
      for (const prop of _$1.keys(dynprops)) {
        const value = dynprops[prop];
        const generator = this.dynpropGenerator(value);
        if (generator) candidate.dynamicProps[prop] = generator;
      }
      this.candidates.push(candidate);
    }
  }
  makeBuildContext(updateCtx) {
    const ctx = Object.assign({}, updateCtx);
    ctx.candidate = this.selectCandidate(ctx.time);
    if (ctx.candidate) {
      ctx.stepTime = moment(Math.trunc(ctx.time / ctx.candidate.every) * ctx.candidate.every);
      ctx.time.utc();
      ctx.stepTime.utc();
    }
    return ctx;
  }
  shouldSkipUpdate(newContext, oldContext) {
    if (oldContext.candidate !== newContext.candidate) return false;
    if (oldContext.stepTime && newContext.stepTime && !oldContext.stepTime.isSame(newContext.stepTime)) return false;
    return true;
  }
  buildSourceAndConfig(ctx) {
    let source = null;
    let config2 = null;
    if (ctx.candidate) {
      config2 = this.deriveConfig(ctx, ctx.candidate.staticProps, ctx.candidate.dynamicProps);
      if (config2) {
        source = makeGridSource(ctx.candidate.key, this.options);
      }
    }
    return [source, config2];
  }
  selectCandidate(time) {
    const now = moment();
    let candidate = null;
    for (const source of this.candidates) {
      const from = source.from ? makeTime(source.from, now) : null;
      const to = source.to ? makeTime(source.to, now) : null;
      if (from && to) {
        candidate = time.isBetween(from, to) ? source : null;
      } else if (from) {
        candidate = time.isSameOrAfter(from) ? source : null;
      } else if (to) {
        candidate = time.isSameOrBefore(to) ? source : null;
      }
      if (candidate) break;
    }
    return candidate;
  }
}
gridSourceFactories[OpenDapGridSource.getKey()] = function(options) {
  return new OpenDapGridSource(options);
};
gridSourceFactories[WcsGridSource.getKey()] = function(options) {
  return new WcsGridSource(options);
};
gridSourceFactories[GeoTiffGridSource.getKey()] = function(options) {
  return new GeoTiffGridSource(options);
};
gridSourceFactories[WeacastGridSource.getKey()] = function(options) {
  return new WeacastGridSource(options);
};
gridSourceFactories[MeteoModelGridSource.getKey()] = function(options) {
  return new MeteoModelGridSource(options);
};
gridSourceFactories[TimeBasedGridSource.getKey()] = function(options) {
  return new TimeBasedGridSource(options);
};
unitConverters.kelvin2celsius = function(kelvin) {
  return kelvin - 273.15;
};
const Geolocation = {
  initialize() {
    Store.set("geolocation", { location: null, error: void 0 });
  },
  hasLocation() {
    return Store.get("geolocation.location");
  },
  get() {
    return Store.get("geolocation");
  },
  getLongitude() {
    return Store.get("geolocation.location.geometry.coordinates[0]", 0);
  },
  get longitude() {
    return this.getLongitude();
  },
  getLatitude() {
    return Store.get("geolocation.location.geometry.coordinates[1]", 0);
  },
  get latitude() {
    return this.getLatitude();
  },
  getAltitude() {
    return Store.get("geolocation.location.geometry.coordinates[2]", 0);
  },
  get altitude() {
    return this.getAltitude();
  },
  getGeometry() {
    return Store.get("geolocation.location.geometry");
  },
  get geometry() {
    return this.getGeometry();
  },
  getAccuracy() {
    return Store.get("geolocation.location.properties.accuracy");
  },
  get accuracy() {
    return this.getAccuracy();
  },
  getAltitudeAccuracy() {
    return Store.get("geolocation.location.properties.altitudeAccuracy");
  },
  get altitudeAccuracy() {
    return this.getAltitudeAccuracy();
  },
  async update() {
    let location2 = null;
    try {
      location2 = await this.refresh();
      Store.patch("geolocation", { location: location2, error: void 0 });
      logger$1.debug("[KDK] Geolocation updated:", location2);
    } catch (error) {
      const code = error.code;
      const geolocationError = new KGeolocationError();
      if (code === error.PERMISSION_DENIED) {
        geolocationError.code = "GEOLOCATION_PERMISSION_DENIED";
      } else if (code === error.POSITION_UNAVAILABLE) {
        geolocationError.code = "GEOLOCATION_POSITION_UNAVAILABLE";
      } else if (code === error.TIMEOUT) {
        geolocationError.code = "GEOLOCATION_POSITION_TIMEOUT";
      } else {
        geolocationError.code = "GEOLOCATION_ERROR";
      }
      Store.patch("geolocation", { location: null, error: geolocationError });
      Events.emit("error", Object.assign(geolocationError, {
        // By default we only show geolocation errors, nothing if disabled by user
        ignore: code === error.PERMISSION_DENIED,
        retryHandler: () => this.refresh()
      }));
      logger$1.debug("[KDK] geolocation failed: ", error);
    }
    return location2;
  },
  async refresh() {
    this.positionPromise = createQuerablePromise(new Promise((resolve, reject) => {
      if (!window.navigator.geolocation) {
        Events.emit("error", {
          message: "errors.GEOLOCATION_NOT_SUPPORTED",
          // By default we only show geolocation errors, nothing if unsupported
          ignore: true
        });
        return;
      }
      window.navigator.geolocation.getCurrentPosition(
        (position2) => {
          const longitude = position2.coords.longitude;
          const latitude = position2.coords.latitude;
          const altitude2 = position2.coords.altitude;
          resolve({
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: altitude2 ? [longitude, latitude, altitude2] : [longitude, latitude]
            },
            properties: {
              name: formatUserCoordinates(latitude, longitude, Store.get("locationFormat", "FFf")),
              accuracy: position2.coords.accuracy,
              altitudeAccuracy: position2.coords.altitudeAccuracy
            }
          });
        },
        (error) => reject(error),
        { timeout: 3e4, enableHighAccuracy: true }
      );
    }));
    return this.positionPromise;
  }
};
const Navigator = {
  initialize() {
    this.availableApps = {
      waze: "https://waze.com/ul?q=<%= lat %>,<%= lon %>",
      "google-maps": "https://www.google.com/maps/dir/?api=1&destination=<%= lat %>,<%= lon %>",
      "apple-plan": "https://maps.apple.com/place?ll=<%= lat %>,<%= lon %>"
    };
    const settings = LocalStorage.get("settings");
    if (_$1.isNil(settings)) {
      let app2 = "google-maps";
      if (Platform.ios) app2 = "apple-plan";
      Store.set("navigator", app2);
      logger$1.debug("[KDK] Navigator initialized to:", this.get());
    } else {
      logger$1.debug("[KDK] Navigator initialized to:", settings.navigator);
    }
  },
  get() {
    return Store.get("navigator");
  },
  navigateTo(lat, lon) {
    const app2 = this.get();
    if (_$1.isEmpty(app2)) {
      logger$1.debug("[KDK] Default navigator is undefined");
      return;
    }
    const compiledUrl = _$1.template(this.availableApps[app2]);
    const interpolatedUrl = compiledUrl({ lat, lon });
    window.open(interpolatedUrl);
  }
};
const GEOJSONReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`reading GeoJSON file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        let content = reader.result;
        try {
          content = JSON.parse(content);
        } catch (error) {
          reject(new Error(i18n.t("errors.INVALID_JSON_FILE", { file: file.name }), { errors: error }));
          return;
        }
        if (content.crs) {
          const name = _$1.get(content.crs, "properties.name");
          if (name) {
            const crs = name.toLowerCase();
            const allowedCrs = ["epsg:4326", "urn:ogc:def:crs:OGC:1.3:CRS84", "urn:ogc:def:crs:EPSG::4326"];
            const isCrsValid = _$1.some(allowedCrs, (allowrdCrs) => {
              return allowrdCrs.toLowerCase() === crs;
            });
            if (!isCrsValid) {
              reject(new Error(i18n.t("errors.INVALID_GEOJSON_CRS", { file: file.name }), { errors: `Invalid CRS ${name}` }));
              return;
            }
            delete content.crs;
          }
        }
        resolve(content);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: file.name }), { errors: error }));
      };
      reader.readAsText(file);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
const KMLReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`reading KML file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        let content = reader.result;
        try {
          content = convertToGeoJsonWithStyle(new DOMParser().parseFromString(content, "text/xml"));
        } catch (error) {
          logger$1.debug(error);
          reject(new Error(i18n.t("errors.INVALID_KML_FILE", { file: file.name }), { errors: error }));
          return;
        }
        resolve(content);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: file.name }), { errors: error }));
      };
      reader.readAsText(file);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
function getExtraPropertiesFromKMLByName(document2) {
  const properties = {};
  const propertiesToAdd = ["extrude", "altitudeMode"];
  const placemarks = document2.getElementsByTagName("Placemark");
  _$1.forEach(placemarks, (placemark) => {
    const nameElements = placemark.getElementsByTagName("name");
    if (!nameElements.length) return;
    const name = nameElements[0].textContent;
    _$1.forEach(propertiesToAdd, (property) => {
      const propertyElements = placemark.getElementsByTagName(property);
      if (!propertyElements.length) return;
      let value = propertyElements[0].textContent;
      if (["0", "1"].includes(value)) {
        value = value === "1";
      }
      _$1.set(properties, [name, property].join("."), value);
    });
  });
  return properties;
}
function convertToGeoJsonWithStyle(document2) {
  const extraProperties = getExtraPropertiesFromKMLByName(document2);
  const geoJson = kml(document2);
  _$1.forEach(_$1.get(geoJson, "features", []), (feature2) => {
    const name = _$1.get(feature2, "properties.name", false);
    const style2 = _$1.merge(convertSimpleStyleToPointStyle(feature2.properties), convertSimpleStyleToLineStyle(feature2.properties), convertSimpleStyleToPolygonStyle(feature2.properties));
    if (name && _$1.has(extraProperties, name)) {
      _$1.merge(style2, extraProperties[name]);
    }
    _$1.set(feature2, "style", style2);
    const trimmedProperties = _$1.mapValues(_$1.get(feature2, "properties", {}), (value) => {
      return typeof value === "string" ? value.trim() : value;
    });
    _$1.set(feature2, "properties", trimmedProperties);
    if (_$1.get(feature2, "geometry.type") === "Point" && _$1.has(feature2, "properties.name")) {
      _$1.set(feature2, "properties.icon-text", feature2.properties.name);
      _$1.set(feature2, "properties.entityStyle.label", {
        heightReference: "Cesium.HeightReference.RELATIVE_TO_GROUND"
      });
    }
  });
  return geoJson;
}
const GPXReader = {
  read(files, options) {
    if (files.length !== 1) {
      logger$1.debug("invalid 'files' arguments");
      return;
    }
    const file = files[0];
    logger$1.debug(`reading GPX file ${file.name}`);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        let content = reader.result;
        try {
          content = gpx(new DOMParser().parseFromString(content, "text/xml"));
        } catch (error) {
          logger$1.debug(error);
          reject(new Error(i18n.t("errors.INVALID_GPX_FILE", { file: file.name }), { errors: error }));
          return;
        }
        resolve(content);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: file.name }), { errors: error }));
      };
      reader.readAsText(file);
    });
  },
  getAdditionalFiles() {
    return [];
  }
};
const SHPReader = {
  async read(files, options) {
    if (files.length < 1 || files.length > this.getAdditionalFiles().length + 1) {
      logger$1.info("invalid 'files' arguments");
      return;
    }
    const promises = [];
    const shpFile = files[0];
    promises.push(new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = (error) => {
        logger$1.debug(error);
        reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: shpFile.name }), { errors: error }));
      };
      reader.readAsArrayBuffer(shpFile);
    }));
    const prjFile = _$1.find(files, (file) => path.extname(file.name) === ".prj");
    if (prjFile) {
      promises.push(new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result);
        };
        reader.onerror = (error) => {
          logger$1.debug(error);
          reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: prjFile.name }), { errors: error }));
        };
        reader.readAsText(prjFile);
      }));
    }
    const dbfFile = _$1.find(files, (file) => path.extname(file.name) === ".dbf");
    if (dbfFile) {
      promises.push(new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve(reader.result);
        };
        reader.onerror = (error) => {
          logger$1.debug(error);
          reject(new Error(i18n.t("errors.CANNOT_READ_FILE", { file: dbfFile.name }), { errors: error }));
        };
        reader.readAsArrayBuffer(dbfFile);
      }));
    }
    const buffers = await Promise.all(promises);
    if (dbfFile) {
      if (prjFile) return shp.combine([shp.parseShp(buffers[0], buffers[1]), shp.parseDbf(buffers[2])]);
      return shp.combine([shp.parseShp(buffers[0]), shp.parseDbf(buffers[1])]);
    }
    let content;
    if (prjFile) content = shp.parseShp(buffers[0], buffers[1]);
    content = shp.parseShp(buffers[0]);
    const geoJson = {
      type: "FeatureCollection",
      features: []
    };
    _$1.forEach(content, (geometry) => {
      geoJson.features.push({
        type: "Feature",
        properties: {},
        geometry
      });
    });
    return geoJson;
  },
  getAdditionalFiles() {
    return [".dbf", ".prj", ".shx", ".cpg"];
  }
};
const readers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GEOJSONReader,
  GPXReader,
  KMLReader,
  SHPReader,
  convertToGeoJsonWithStyle
}, Symbol.toStringTag, { value: "Module" }));
function siftMatcher(originalQuery) {
  const keysToOmit = ["geoJson"];
  return _$1.omit(originalQuery, ...keysToOmit);
}
function setupApi(configuration) {
  const api2 = this;
  api2.setForecastTime = (time) => {
    api2.forecastTime = time;
    api2.emit("forecast-time-changed", time);
  };
  api2.getForecastTime = () => {
    return api2.forecastTime;
  };
  api2.createOfflineFeaturesService = async function(serviceName, options = {}) {
    options = Object.assign(_$1.omit(options, ["hooks", "dataPath"]), {
      // Set required default hooks and data path for snapshot as the service responds in GeoJson format
      hooks: _$1.defaultsDeep(_$1.get(options, "hooks"), {
        before: {
          all: [ensureSerializable, removeServerSideParameters$1, removeServerSideParameters],
          create: [generateId, referenceCountCreateHook],
          remove: referenceCountRemoveHook
        },
        after: {
          find: [geoJsonPaginationHook, intersectBBoxHook]
        }
      }),
      dataPath: "features",
      // Here are service options used to manage offline features services
      features: true
    });
    const offlineService = await api2.createOfflineService(serviceName, options);
    return offlineService;
  };
  return api2;
}
async function init() {
  const api2 = this;
  logger$1.debug("[KDK] Initializing Map module...");
  api2.registerMatcher(siftMatcher);
  api2.createService("features-edition", {
    service: memory({
      id: "_id",
      paginate: { default: 10 },
      matcher: api2.matcher
    })
  });
  Geolocation.initialize();
  Planets.initialize();
  Geocoder.initialize();
  Navigator.initialize();
  Store.set("timeFormat", reactive({
    time: reactive({
      short: "H[h]",
      long: "HH:mm"
    }),
    date: reactive({
      short: "DD/MM",
      long: "dddd D"
    }),
    year: reactive({
      short: "YY",
      long: "YYYY"
    }),
    utc: false,
    locale: getLocale()
  }));
  Store.set("locationFormat", "f");
  Store.set("restore", reactive({
    view: true,
    layers: false
  }));
  Store.set("timeseries", reactive({
    span: 1440,
    // 24H
    groupBy: "feature"
  }));
  _$1.forEach(_$1.get(config, "readers.map", []), (entry) => {
    logger$1.debug(`[KDK] Registering mime types [${entry.mimeTypes}] to reader ${entry.reader}`);
    Reader.register(entry.mimeTypes, readers[entry.reader]);
  });
  Shapes.polyline = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M1 44L17 6L33 44L49 6" />',
    clipPath: false
  };
  Shapes.polygon = {
    viewBox: [0, 0, 50, 50],
    content: '<path d="M10 40L1 24L5 10L20 1L40 10L49 24L40 40L32 49Z" />'
  };
  Store.set("kdk.map.initialized", true);
  logger$1.debug("[KDK] Map module initialized");
}
const Planets = {
  initialize() {
    this.planets = {};
  },
  async connect(name, options = {}) {
    _$1.defaults(options, {
      origin: window.location.origin,
      apiPath: config.apiPath,
      apiJwt: `${name}-jwt`,
      gatewayJwt: `${name}-gateway-jwt`,
      apiTimeout: config.apiTimeout,
      transport: config.transport,
      appName: `${name}`,
      renewJwt: false
    });
    const client2 = await createClient(options);
    setupApi.bind(client2)(options);
    client2.on("authenticated", (data) => {
      if (data.gatewayToken) client2.get("storage").setItem(options.gatewayJwt, data.gatewayToken);
    });
    client2.on("logout", (data) => {
      client2.get("storage").removeItem(options.gatewayJwt);
    });
    const accessToken = await client2.get("storage").getItem(options.apiJwt);
    if (!accessToken) {
      logger$1.error(new Error(`You must set planet ${name} token first`));
      return;
    }
    await client2.authenticate({
      strategy: "jwt",
      accessToken
    });
    this.planets[name] = client2;
    return client2;
  },
  async disconnect(name) {
    await this.planets[name].logout();
    delete this.planets[name];
  },
  isConnected(name) {
    return !_$1.isNil(this.planets[name]);
  },
  get(name) {
    if (!this.planets[name]) logger$1.error(new Error(`You must connect to planet ${name} first`));
    else return this.planets[name];
  },
  // Register an existing planet
  set(name, client2) {
    this.planets[name] = client2;
  }
};
const Geocoder = {
  initialize() {
    Store.set("geocoder", _$1.defaultsDeep(config.geocoder, {
      planet: void 0,
      path: "geocoder"
    }));
    logger$1.debug("[KDK] Geocoder initialized with configuration:", Store.get("geocoder"));
  },
  getApiConfig() {
    const planet = Store.get("geocoder.planet");
    if (planet) return Planets.get(planet).getConfig();
    return api.getConfig();
  },
  getApiPath() {
    return Store.get("geocoder.path");
  },
  async query(path2, query = "") {
    const apiConfig = this.getApiConfig();
    if (!_$1.has(apiConfig, "gateway")) {
      logger$1.error("[KDK] Invalid Geocoder configuration: missing 'gateway' property");
      return;
    }
    if (!_$1.has(apiConfig, "gatewayJwt")) {
      logger$1.error("[KDK] Invalid Geocoder configuration: missing 'gatewayJwt' property");
      return;
    }
    const endpoint = `${apiConfig.gateway}/${this.getApiPath()}`;
    const jwt = await api.get("storage").getItem(apiConfig.gatewayJwt);
    let url = `${endpoint}/${path2}`;
    if (query) url += `?${query}`;
    const response = await fetch(url, { headers: { Authorization: `Bearer ${jwt}` } });
    return response.json();
  },
  async getForwardCapabilities() {
    let response;
    try {
      response = await this.query("capabilities/forward");
      if (response.i18n) i18n.registerTranslation(response.i18n);
    } catch (error) {
      Events.emit("error", { message: i18n.t("errors.NETWORK_ERROR") });
    }
    return _$1.get(response, "geocoders", []);
  },
  async getReverseCapabilities() {
    let response;
    try {
      response = await this.query("capabilities/reverse");
      if (response.i18n) i18n.registerTranslation(response.i18n);
    } catch (error) {
      Events.emit("error", { message: i18n.t("errors.NETWORK_ERROR") });
    }
    return _$1.get(response, "geocoders", []);
  },
  async queryForward(pattern, options = {}) {
    const locations = [];
    const coordinates = parseCoordinates(pattern);
    if (coordinates) {
      locations.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [coordinates.longitude, coordinates.latitude]
        },
        properties: {
          name: formatUserCoordinates(coordinates.latitude, coordinates.longitude, Store.get("locationFormat", "FFf"))
        }
      });
    } else {
      let filter = "";
      if (!_$1.isEmpty(options.geocoders)) {
        filter += "&sources=*(" + options.geocoders.join("|") + ")";
      }
      if (!_$1.isEmpty(options.viewbox)) {
        filter += "&viewbox=" + options.viewbox.join(",");
      }
      filter += "&limit=" + (options.limit || 20);
      const results = await this.query("forward", `q=${pattern}${filter}`);
      results.forEach((result) => {
        locations.push(
          Object.assign(
            _$1.pick(result, ["type", "geometry"]),
            { properties: { name: formatForwardGeocodingResult(result), source: result.geokoder.source } }
          )
        );
      });
    }
    return locations;
  }
};
function useLocation() {
  const { getActivityProject } = useCurrentActivity({ selection: false, probe: false });
  const availableGeocoders = ref([]);
  const selectedGeocoders = ref([]);
  const selectedViewbox = ref([]);
  async function setGeocoders(geocoders) {
    if (_$1.isNull(geocoders)) {
      availableGeocoders.value = [];
      selectedGeocoders.value = [];
    } else {
      let allGeocoders = await Geocoder.getForwardCapabilities();
      allGeocoders = filterGeocoders(allGeocoders, getActivityProject());
      if (_$1.isEmpty(geocoders)) {
        availableGeocoders.value = _$1.map(allGeocoders, (geocoder) => {
          return { value: geocoder, label: i18n.tie(`Geocoders.${geocoder}`) };
        });
        selectedGeocoders.value = allGeocoders;
      } else {
        availableGeocoders.value = _$1.reduce(geocoders, (reducedGeocoders, geocoder) => {
          const source = _$1.replace(geocoder.source, /^services:.*\//g, `services:${Context.getId()}/`);
          const label = _$1.replace(geocoder.source, /^services:.*\//g, `services:*/`);
          if (allGeocoders.includes(source)) {
            reducedGeocoders.push({ value: source, label: i18n.tie(`Geocoders.${label}`), selected: geocoder.selected });
          }
          return reducedGeocoders;
        }, []);
        selectedGeocoders.value = _$1.reduce(availableGeocoders.value, (reducedGeocoders, geocoder) => {
          if (geocoder.selected) reducedGeocoders.push(geocoder.value);
          return reducedGeocoders;
        }, []);
      }
    }
  }
  async function setViewbox(viewbox) {
    if (_$1.isNull(viewbox)) {
      selectedViewbox.value = [];
    } else {
      selectedViewbox.value = viewbox;
    }
  }
  async function geolocate() {
    await Geolocation.update();
    const error = Store.get("geolocation.error");
    if (error) return;
    return Store.get("geolocation.location");
  }
  async function search(pattern, limit = 25) {
    return Geocoder.queryForward(pattern, {
      geocoders: selectedGeocoders.value,
      viewbox: selectedViewbox.value,
      limit
    });
  }
  return {
    availableGeocoders,
    selectedGeocoders,
    setGeocoders,
    setViewbox,
    geolocate,
    search
  };
}
function useMeasure() {
  function getMeasureValueAtCurrentTime(times, values) {
    if (Array.isArray(times) && Array.isArray(values)) {
      const nearestTime = getNearestTime(Time.getCurrentTime(), times.map((time) => moment.utc(time)));
      return nearestTime.index >= 0 ? values[nearestTime.index] : null;
    } else {
      return values;
    }
  }
  function getProbedLocationMeasureAtCurrentTime(probedLocation) {
    const feature2 = _$1.cloneDeep(probedLocation);
    _$1.forOwn(feature2.properties, (value, key) => {
      if (Array.isArray(value)) {
        const times = _$1.get(feature2, "time." + key);
        if (times) {
          _$1.set(feature2, "properties." + key, getMeasureValueAtCurrentTime(times, value));
          _$1.set(feature2, "time." + key, getMeasureValueAtCurrentTime(times, times));
        }
      }
    });
    return feature2;
  }
  return {
    getMeasureValueAtCurrentTime,
    getProbedLocationMeasureAtCurrentTime
  };
}
function useWeather(options = {}) {
  const { kActivity } = useCurrentActivity$1();
  let activity2 = unref(kActivity);
  watch(kActivity, (newActivity) => {
    newActivity = unref(newActivity);
    if (activity2 === newActivity) return;
    if (newActivity) {
      activity2 = newActivity;
    }
  });
  function getProbedLocationForecastFields(variables) {
    const fields = {
      // Only wind/temperature can be available at different levels now
      windDirection: {
        property: activity2.forecastLevel ? `properties.windDirection-${activity2.forecastLevel}` : "properties.windDirection"
      },
      windSpeed: {
        property: activity2.forecastLevel ? `properties.windSpeed-${activity2.forecastLevel}` : "properties.windSpeed"
      },
      temperature: {
        property: activity2.forecastLevel ? `properties.temperature-${activity2.forecastLevel}` : "properties.temperature"
      },
      gust: {
        property: "properties.gust",
        label: "max"
      },
      precipitations: {
        property: "properties.precipitations"
      },
      humidity: {
        property: "properties.humidity"
      },
      time: {
        property: "forecastTime"
      },
      name: {
        property: "properties.name"
      }
    };
    if (variables && variables.length > 0) {
      _$1.forOwn(fields, (value, key) => {
        const variable = _$1.find(variables, { name: `${value.property.replace("properties.", "")}` });
        if (variable) value.label = variable.label;
      });
    }
    return fields;
  }
  function isWeatherProbe(feature2) {
    const { windDirection, windSpeed } = getProbedLocationForecastFields();
    return _$1.has(feature2, windDirection.property) && _$1.has(feature2, windSpeed.property);
  }
  function getForecastAsHtml(feature2, fields = {}) {
    const defaults2 = getProbedLocationForecastFields();
    const windDirectionLabel = _$1.get(fields, "windDirection.label", defaults2.windDirection.label);
    const windSpeedLabel = _$1.get(fields, "windSpeed.label", defaults2.windSpeed.label);
    const gustLabel = _$1.get(fields, "gust.label", defaults2.gust.label);
    const temperatureLabel = _$1.get(fields, "temperature.label", defaults2.temperature.label);
    const precipitationsLabel = _$1.get(fields, "precipitations.label", defaults2.precipitations.label);
    const humidityLabel = _$1.get(fields, "humidity.label", defaults2.humidity.label);
    const windDirectionField = _$1.get(fields, "windDirection.property", defaults2.windDirection.property);
    const windSpeedField = _$1.get(fields, "windSpeed.property", defaults2.windSpeed.property);
    const gustField = _$1.get(fields, "gust.property", defaults2.gust.property);
    const temperatureField = _$1.get(fields, "temperature.property", defaults2.temperature.property);
    const precipitationsField = _$1.get(fields, "precipitations.property", defaults2.precipitations.property);
    const humidityField = _$1.get(fields, "humidity.property", defaults2.humidity.property);
    const timeField = _$1.get(fields, "time.property", defaults2.time.property);
    const nameField = _$1.get(fields, "name.property", defaults2.name.property);
    const windDirection = _$1.get(feature2, `${windDirectionField}`);
    const windSpeed = _$1.get(feature2, `${windSpeedField}`);
    const gust = _$1.get(feature2, `${gustField}`);
    const temperature2 = _$1.get(feature2, `${temperatureField}`);
    const precipitations = _$1.get(feature2, `${precipitationsField}`);
    const humidity = _$1.get(feature2, `${humidityField}`);
    let time = _$1.get(feature2, `${timeField}`);
    let uniqTime = true;
    if (typeof time === "object") {
      const uniqTimes = _$1.uniq(_$1.values(time));
      if (uniqTimes.length > 1) {
        uniqTime = false;
      } else {
        time = uniqTimes[0];
      }
    }
    const getTimeAsHtml = (time2) => {
      if (!_$1.isNil(time2)) {
        time2 = moment.utc(time2);
        if (time2.isValid()) return ` (${Time.format(time2, "date.short")} - ${Time.format(time2, "time.long")})`;
      }
      return "";
    };
    let html = "";
    if (!_$1.isNil(windSpeed) && _$1.isFinite(windSpeed)) {
      if (windSpeedLabel) html += `${i18n.tie(windSpeedLabel)}: `;
      html += Units.format(windSpeed, "m/s");
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, windSpeedField.replace("properties.", "")));
      html += "</br>";
    }
    if (!_$1.isNil(gust) && _$1.isFinite(gust)) {
      if (gustLabel) html += `${i18n.tie(gustLabel)}: `;
      html += Units.format(gust, "m/s");
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, gustField.replace("properties.", "")));
      html += "</br>";
    }
    if (!_$1.isNil(windDirection) && _$1.isFinite(windDirection)) {
      if (windDirectionLabel) html += `${i18n.tie(windDirectionLabel)}: `;
      html += Units.format(windDirection, "deg");
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, windDirectionField.replace("properties.", "")));
      html += "</br>";
    }
    if (!_$1.isNil(precipitations) && _$1.isFinite(precipitations)) {
      if (precipitationsLabel) html += `${i18n.tie(precipitationsLabel)}: `;
      html += Units.format(precipitations, "mm/h");
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, precipitationsField.replace("properties.", "")));
      html += "</br>";
    }
    if (!_$1.isNil(humidity) && _$1.isFinite(humidity)) {
      if (humidityLabel) html += `${i18n.tie(humidityLabel)}: `;
      html += `${humidity.toFixed(0)} %`;
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, humidityField.replace("properties.", "")));
      html += "</br>";
    }
    if (!_$1.isNil(temperature2) && _$1.isFinite(temperature2)) {
      if (temperatureLabel) html += `${i18n.tie(temperatureLabel)}: `;
      html += Units.format(temperature2, "degC");
      if (!uniqTime) html += getTimeAsHtml(_$1.get(time, temperatureField.replace("properties.", "")));
      html += "</br>";
    }
    if (html) {
      const name = _$1.get(feature2, `${nameField}`);
      if (!_$1.isNil(name)) html = `<b><u>${name}</u></b></br>` + html;
      if (uniqTime) {
        html += getTimeAsHtml(time).trim().replace("(", "").replace(")", "");
      }
    }
    return html;
  }
  function getForecastValueAtCurrentTime(times, values) {
    if (Array.isArray(times) && Array.isArray(values)) {
      const nearestTime = getNearestTime(Time.getCurrentTime(), times.map((time) => moment.utc(time)));
      if (nearestTime.difference / 1e3 > 0.5 * activity2.forecastModel.interval) return null;
      else return values[nearestTime.index];
    } else {
      return values;
    }
  }
  function getProbedLocationForecastAtCurrentTime(probedLocation) {
    const feature2 = _$1.cloneDeep(probedLocation);
    _$1.forOwn(feature2.properties, (value, key) => {
      if (Array.isArray(value)) {
        const times = _$1.get(feature2, "forecastTime." + key);
        if (times) {
          _$1.set(feature2, "properties." + key, getForecastValueAtCurrentTime(times, value));
          _$1.set(feature2, "forecastTime." + key, getForecastValueAtCurrentTime(times, times));
        }
      }
    });
    return feature2;
  }
  function getWindBarbOptions(feature2, fields = {}) {
    const defaults2 = getProbedLocationForecastFields();
    let windDirection = _$1.get(fields, "windDirection.property", defaults2.windDirection.property);
    let windSpeed = _$1.get(fields, "windSpeed.property", defaults2.windSpeed.property);
    windDirection = _$1.get(feature2, `${windDirection}`);
    windSpeed = _$1.get(feature2, `${windSpeed}`);
    if (_$1.isNil(windDirection) || !_$1.isFinite(windDirection) || _$1.isNil(windSpeed) || !_$1.isFinite(windSpeed)) return null;
    return {
      deg: windDirection,
      speed: windSpeed,
      // Expressed as m/s
      pointRadius: 10,
      pointColor: "#2196f3",
      pointStroke: "#888888",
      strokeWidth: 2,
      strokeColor: "#888888",
      strokeLength: 12,
      fillColor: "#2196f3",
      barbSpaceing: 4,
      barbHeight: 10,
      forceDir: true
    };
  }
  function createWindBarbIcon(feature2, fields = {}) {
    const options2 = getWindBarbOptions(feature2, fields);
    return options2 ? new L$1.WindBarb.Icon(options2) : null;
  }
  function getProbedLocationForecastTooltip(feature2, layer2, options2, fields = {}) {
    const html = getForecastAsHtml(feature2, fields);
    return html ? L$1.tooltip({ permanent: false }, layer2).setContent(`<b>${html}</b>`) : null;
  }
  function getProbedLocationForecastMarker(feature2, latlng, options2, fields = {}) {
    const icon = createWindBarbIcon(feature2, fields);
    return icon ? L$1.marker(latlng, { icon }) : null;
  }
  return {
    getProbedLocationForecastFields,
    isWeatherProbe,
    getForecastAsHtml,
    getWindBarbOptions,
    createWindBarbIcon,
    getProbedLocationForecastAtCurrentTime,
    getProbedLocationForecastTooltip,
    getProbedLocationForecastMarker
  };
}
function useCatalog(options = {}) {
  _$1.defaults(options, {
    // Default filter queries
    layers: {},
    categories: {},
    sublegends: {},
    views: {},
    // Default to contextual or global catalog depending on store
    context: "",
    // Default to app API
    planetApi: api
  });
  const layers = ref([]);
  const categories = ref([]);
  const sublegends = ref([]);
  const views = ref([]);
  const layersByCategory = computed(() => getLayersByCategory(layers.value, categories.value));
  const orphanLayers = computed(() => getOrphanLayers(layers.value, layersByCategory.value));
  async function getLayers$1(filterQuery = {}) {
    const query = Object.assign(
      {},
      options.project ? Object.assign(getCatalogProjectQuery(options.project), options.layers) : options.layers,
      filterQuery
    );
    layers.value = await getLayers({
      query,
      context: options.context,
      planetApi: options.planetApi
    });
    return layers.value;
  }
  async function getCategories$1() {
    categories.value = await getCategories({
      query: options.categories,
      context: options.context,
      planetApi: options.planetApi
    });
    return categories.value;
  }
  async function getSublegends$1() {
    sublegends.value = await getSublegends({
      query: options.sublegends,
      context: options.context,
      planetApi: options.planetApi
    });
    return sublegends.value;
  }
  async function getViews$1() {
    views.value = await getViews({
      query: options.project ? Object.assign(getCatalogProjectQuery(options.project), options.views) : options.views,
      context: options.context,
      planetApi: options.planetApi
    });
    return views.value;
  }
  return {
    layers,
    categories,
    sublegends,
    layersByCategory,
    orphanLayers,
    views,
    getLayers: getLayers$1,
    getCategories: getCategories$1,
    getSublegends: getSublegends$1,
    getViews: getViews$1
  };
}
function useProject(options = {}) {
  const { setActivityProject } = useCurrentActivity({ selection: false, probe: false });
  _$1.defaults(options, {
    // Set if project should be extracted from route
    // otherwise it should be loaded manually
    route: true,
    // Default to contextual or global service depending on store
    context: "",
    // Default to target activity
    updateActivity: true,
    // Default to app API
    planetApi: api
  });
  const route = useRoute();
  const router = useRouter();
  const projectId = ref(null);
  const project = ref(null);
  let serviceEventListeners;
  const projectQuery = computed(() => {
    return _$1.isEmpty(projectId.value) ? {} : { project: projectId.value };
  });
  const catalogProjectQuery = computed(() => {
    return _$1.isEmpty(project.value) ? {} : getCatalogProjectQuery(project.value);
  });
  function hasProject() {
    return projectId.value;
  }
  function isProjectLoaded() {
    return project.value;
  }
  async function loadProject(query) {
    refreshProjectId();
    const projectQuery2 = query ? _$1.cloneDeep(query) : {};
    _$1.defaults(projectQuery2, { populate: true });
    if (!projectId.value) {
      project.value = null;
      if (query) {
        const response = await options.planetApi.getService("projects", options.context).find({ query: projectQuery2 });
        project.value = _$1.get(response, "data[0]");
        if (project.value) projectId.value = project.value._id;
      }
    } else {
      project.value = await options.planetApi.getService("projects", options.context).get(projectId.value, { query: projectQuery2 });
    }
    if (options.updateActivity) setActivityProject(project.value);
    if (project.value) {
      project.value.getPlanetApi = () => options.planetApi;
    }
  }
  function onProjectUpdated(updatedProject) {
    if (project.value && updatedProject._id === project.value._id) {
      project.value = updatedProject;
      if (options.updateActivity) setActivityProject(updatedProject);
    }
  }
  function onProjectRemoved(removedProject) {
    if (project.value && removedProject._id === project.value._id) {
      project.value = null;
      projectId.value = null;
      if (options.route) {
        router.push({
          name: route.name,
          query: _$1.omit(route.query, ["project"]),
          params: route.params
        });
      }
    }
  }
  function refreshProjectId() {
    if (!options.route) return;
    const id = _$1.get(route, "query.project", null);
    if (projectId.value !== id) projectId.value = id;
  }
  if (options.route) watch(() => route.query.project, refreshProjectId);
  onBeforeMount(() => {
    refreshProjectId();
    serviceEventListeners = listenToServiceEvents(options.planetApi.getService("projects", options.context), {
      patched: onProjectUpdated,
      updated: onProjectUpdated,
      removed: onProjectRemoved
    });
  });
  onBeforeUnmount(() => {
    unlistenToServiceEvents(serviceEventListeners);
  });
  return {
    project,
    projectId,
    hasProject,
    isProjectLoaded,
    loadProject,
    projectQuery,
    catalogProjectQuery
  };
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HighlightMargin,
  HighlightsLayerName,
  HighlightsZIndex,
  useActivity,
  useCatalog,
  useCurrentActivity,
  useHighlight,
  useLocation,
  useMeasure,
  useProbe,
  useProject,
  useSelection,
  useWeather
}, Symbol.toStringTag, { value: "Module" }));
const activity$2 = {
  emits: [
    "layer-filter-toggled"
  ],
  data() {
    return {
      layerCategories: [],
      variables: [],
      engine: "leaflet",
      engineReady: false,
      engineContainerWidth: null,
      engineContainerHeight: null
    };
  },
  computed: {
    viewStyle() {
      return "width: 100%; height: 100%; fontWeight: normal; zIndex: 0; position: absolute;";
    },
    variablesForCurrentLevel() {
      return this.variables.map((variable) => Object.assign({ name: `${variable.name}-${this.selectedLevel}` }, _$1.omit(variable, ["name"])));
    },
    currentVariables() {
      return this.forecastLevel ? this.variablesForCurrentLevel : this.variables;
    }
  },
  methods: {
    is2D() {
      return this.engine === "leaflet";
    },
    is3D() {
      return this.engine === "cesium";
    },
    // This method should be overriden in activities
    getFeatureActions(feature2, layer2) {
      return [];
    },
    async getCatalogLayers() {
      const query = {};
      if (this.project) {
        Object.assign(query, this.catalogProjectQuery ? this.catalogProjectQuery : getCatalogProjectQuery(this.project));
      } else {
        this.project = null;
      }
      let layers = await getLayers({ query });
      const context2 = Store.get("context");
      if (context2) layers = layers.concat(await getLayers({ query, context: context2 }));
      return layers;
    },
    async addCatalogLayer(layer2) {
      if (layer2[this.engine]) {
        const isWeacastLayer = _$1.get(layer2, `${this.engine}.type`, "").startsWith("weacast.");
        if (isWeacastLayer && (!this.getWeacastApi() || !this.forecastModel)) return;
        await this.addLayer(layer2);
      }
      if (layer2.variables) this.variables = _$1.uniqBy(this.variables.concat(layer2.variables), (variable) => variable.name);
    },
    async removeCatalogLayer(layer2) {
      if (layer2[this.engine]) {
        await this.removeLayer(layer2.name);
      }
    },
    async getCatalogCategories() {
      let categories = await getCategories();
      const context2 = Store.get("context");
      if (context2) categories = categories.concat(await getCategories({ context: context2 }));
      return categories;
    },
    async getCatalogSublegends() {
      let sublegends = await getSublegends();
      const context2 = Store.get("context");
      if (context2) sublegends = sublegends.concat(await getSublegends({ context: context2 }));
      return sublegends;
    },
    async addCatalogCategory(category) {
      this.layerCategories.push(category);
    },
    async refreshLayerCategories() {
      this.layerCategories.splice(0, this.layerCategories.length);
      const layerCategories = await this.getCatalogCategories();
      for (let i = 0; i < layerCategories.length; i++) {
        this.addCatalogCategory(layerCategories[i]);
      }
      await this.refreshOrphanLayers();
    },
    async updateCategoriesOrder(sourceCategoryId, targetCategoryId) {
      this.reorganizeLayers();
    },
    async updateLayersOrder(sourceCategoryId, data) {
      this.reorganizeLayers();
    },
    async updateOrphanLayersOrder(orphanLayers) {
      this.reorganizeLayers();
    },
    async refreshLayers() {
      this.clearLayers();
      this.variables = [];
      const catalogLayers = await this.getCatalogLayers();
      for (let i = 0; i < catalogLayers.length; i++) {
        await this.addCatalogLayer(catalogLayers[i]);
      }
      const hasVisibleBaseLayer = catalogLayers.find((layer2) => layer2.type === "BaseLayer" && layer2.isVisible);
      if (!hasVisibleBaseLayer) {
        const baseLayer = catalogLayers.find((layer2) => layer2.type === "BaseLayer");
        if (baseLayer) await this.showLayer(baseLayer.name);
      }
    },
    async refreshOrphanLayers() {
      if (typeof this.reorganizeLayers === "function") this.reorganizeLayers();
    },
    isInMemoryLayer,
    isUserLayer,
    isFeatureLayer,
    hasFeatureSchema,
    isLayerSelectable(layer2) {
      if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) return false;
      return isLayerSelectable(layer2);
    },
    isLayerProbable,
    isLayerStorable,
    isLayerCached,
    isLayerCachable,
    setLayerCached,
    setLayerUncached,
    isLayerEditable,
    isLayerFilterEditable,
    isLayerRemovable,
    isLayerStyleEditable,
    isLayerDataEditable,
    canCreateLayer() {
      return api.can("create", "catalog");
    },
    canUpdateLayer(layer2) {
      return isInMemoryLayer(layer2) || api.can("update", "catalog");
    },
    canRemoveLayer(layer2) {
      return isInMemoryLayer(layer2) || api.can("remove", "catalog");
    },
    async resetLayer(layer2) {
      const isVisible = this.isLayerVisible(layer2.name);
      if (isVisible) {
        let geoJson;
        if (isInMemoryLayer(layer2) && typeof this.toGeoJson === "function") geoJson = await this.toGeoJson(layer2.name);
        await this.hideLayer(layer2.name);
        await this.showLayer(layer2.name);
        if (geoJson) this.updateLayer(layer2.name, geoJson);
        if (typeof this.updateLayerDisabled === "function") this.updateLayerDisabled(layer2);
      }
    },
    configureLayerActions(layer2) {
      let actions = _$1.get(this, "activityOptions.layers.actions", []);
      actions = filterContent(actions, _$1.get(this, "activityOptions.layers.filter", {}));
      actions = bindContent(_$1.cloneDeep(actions), this, ["dialog"]);
      actions.push({ id: "toggle", handler: () => this.onTriggerLayer(layer2) });
      actions.push({ id: "toggle-filter", handler: (filter) => this.onTriggerLayerFilter(layer2, filter) });
      layer2.actions = actions;
      return actions;
    },
    async onTriggerLayer(layer2) {
      if (!this.isLayerVisible(layer2.name)) {
        await this.showLayer(layer2.name);
      } else {
        await this.hideLayer(layer2.name);
      }
      const hasContext = typeof this.storeContext === "function";
      if (hasContext) this.storeContext("layers");
    },
    async onTriggerLayerFilter(layer2, filter) {
      if (typeof this.updateLayer === "function") await this.updateLayer(layer2.name, null, { removeMissing: true });
      this.$emit("layer-filter-toggled", layer2, filter);
      this.$engineEvents.emit("layer-filter-toggled", layer2, filter);
    },
    onZoomIn() {
      const center2 = this.getCenter();
      this.center(center2.longitude, center2.latitude, center2.zoomLevel ? center2.zoomLevel + 1 : center2.altitude * 0.5);
    },
    onZoomOut() {
      const center2 = this.getCenter();
      this.center(center2.longitude, center2.latitude, center2.zoomLevel ? center2.zoomLevel - 1 : center2.altitude * 2);
    },
    onZoomToLayer(layer2) {
      this.zoomToLayer(layer2.name);
    },
    onBringLayerToFront(layer2) {
      if (typeof this.bringLayerToFront === "function") this.bringLayerToFront(layer2.name);
    },
    onBringLayerToBack(layer2) {
      if (typeof this.bringLayerToBack === "function") this.bringLayerToBack(layer2.name);
    },
    async onSaveLayer(layer2) {
      if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) await this.stopEditLayer("accept");
      let createdLayer;
      if (!_$1.has(layer2, "wfs") && _$1.get(layer2, `${this.engine}.type`) === "geoJson") {
        const geoJson = this.toGeoJson(layer2.name);
        createdLayer = await saveGeoJsonLayer(layer2, geoJson, _$1.get(this, "activityOptions.featuresChunkSize", 5e3));
      } else {
        createdLayer = await saveLayer(layer2);
      }
      if (this.project && this.project.getPlanetApi() === api) {
        this.project.layers.push({ _id: createdLayer._id });
        await api.getService("projects").patch(this.project._id, {
          layers: this.project.layers
        });
      }
      if (createdLayer) {
        layer2._id = createdLayer._id;
        await this.resetLayer(createdLayer);
      }
    },
    editLayerByName(name, editOptions = {}) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      this.startEditLayer(layer2, editOptions);
    },
    async onEditLayerData(layer2) {
      if (this.isLayerEdited(layer2)) {
        await this.stopEditLayer("accept");
      } else {
        await this.startEditLayer(layer2, { editMode: "edit-properties" });
      }
    },
    async onEndLayerEdition(status = "accept") {
      await this.stopEditLayer(status);
    },
    async onResetLayerStyle(layer2) {
      await editLayerStyle(layer2, {});
      if (!layer2._id) {
        await this.resetLayer(layer2);
      }
    },
    async onRemoveLayer(layer2) {
      if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) await this.stopEditLayer("reject");
      if (await removeLayer(layer2)) {
        this.removeLayer(layer2.name);
      }
      await this.refreshOrphanLayers();
    },
    onEngineReady(engine) {
      this.engine = engine;
      this.engineReady = true;
    },
    onToggleFullscreen() {
      if (!this.$q.fullscreen.isActive) this.$q.fullscreen.request();
      else this.$q.fullscreen.exit();
    },
    listenToCatalogServiceEvents() {
      const globalCatalogService = api.getService("catalog", "global");
      const catalogService = api.getService("catalog");
      this.globalCatalogListeners = listenToServiceEvents("catalog", {
        context: "global",
        all: this.onCatalogUpdated,
        removed: (object) => this.onCatalogUpdated(object, "removed")
      }, this.globalCatalogListeners);
      if (catalogService && catalogService !== globalCatalogService) {
        this.catalogListeners = listenToServiceEvents("catalog", {
          all: this.onCatalogUpdated,
          removed: (object) => this.onCatalogUpdated(object, "removed")
        }, this.catalogListeners);
      }
    },
    unlistenToCatalogServiceEvents() {
      if (this.globalCatalogListeners) unlistenToServiceEvents(this.globalCatalogListeners);
      if (this.catalogListeners) unlistenToServiceEvents(this.catalogListeners);
      this.globalCatalogListeners = null;
      this.catalogListeners = null;
    },
    resetCatalogServiceEventsListeners() {
      this.listenToCatalogServiceEvents();
    },
    async initialize() {
      const hasContext = typeof this.restoreContext === "function";
      const weacastEnabled = _$1.get(config, "weacast.enabled", true);
      if (weacastEnabled && this.setupWeacast) {
        try {
          await this.setupWeacast();
        } catch (error) {
          logger$1.error("[KDK]", error);
        }
      } else {
        if (weacastEnabled) logger$1.warn("[KDK] Weacast setup function is missing");
        else logger$1.debug("[KDK] disabling Weacast");
      }
      try {
        await this.refreshLayerCategories();
        await this.refreshLayers();
        if (hasContext) await this.restoreContext("layers");
      } catch (error) {
        logger$1.error("[KDK]", error);
      }
      if (hasContext) await this.restoreContext("time");
      const viewRestored = hasContext ? await this.restoreContext("view") : false;
      if (!viewRestored && _$1.get(this, "activityOptions.restore.geolocation", true)) {
        await Geolocation.update();
        if (Geolocation.hasLocation()) this.center(Geolocation.getLongitude(), Geolocation.getLatitude());
      }
      this.listenToCatalogServiceEvents();
    },
    finalize() {
      this.unlistenToCatalogServiceEvents();
    },
    async refreshLayer(layer2, event) {
      let planetApi;
      if (layer2 && typeof layer2.getPlanetApi === "function") {
        planetApi = layer2.getPlanetApi();
      }
      if (layer2) {
        if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) await this.stopEditLayer("reject");
        await this.removeCatalogLayer(layer2);
      }
      if (event !== "removed") {
        if (planetApi) Object.assign(layer2, { getPlanetApi: () => planetApi });
        await setEngineJwt([layer2], planetApi);
        await this.addCatalogLayer(layer2);
      }
    },
    requestRefreshLayer(layer2, event) {
      if (!this.pendingLayerRefresh) this.pendingLayerRefresh = {};
      if (this.pendingLayerRefresh[layer2]) clearTimeout(this.pendingLayerRefresh[layer2]);
      this.pendingLayerRefresh[layer2] = setTimeout(() => {
        delete this.pendingLayerRefresh[layer2];
        this.refreshLayer(layer2, event);
      }, 500);
    },
    async onCatalogUpdated(object, event) {
      switch (object.type) {
        case "Category":
          await this.requestRefreshLayerCategories();
          break;
        case "Context":
        case "Service":
          break;
        default: {
          await this.requestRefreshLayer(object, event);
          break;
        }
      }
    }
  },
  // Need to be in the first lifecycle hook as others mixins might use activity options
  created() {
    const defaultOptions2 = _$1.get(config, `engines.${this.engine}`);
    if (defaultOptions2) {
      logger$1.debug(`[KDK] Configuring '${this.engine}' engine with options:`, defaultOptions2);
      this.activityOptions.engine = _$1.defaultsDeep(_$1.get(this.activityOptions, "engine", {}), defaultOptions2);
    }
    this.$engineEvents.on("map-ready", this.onEngineReady);
    this.$engineEvents.on("globe-ready", this.onEngineReady);
    this.$engineEvents.on("layer-added", this.configureLayerActions);
  },
  mounted() {
    this.requestRefreshLayerCategories = _$1.debounce(this.refreshLayerCategories, 200);
    Events.on("navigator-disconnected", this.resetCatalogServiceEventsListeners);
    Events.on("navigator-reconnected", this.resetCatalogServiceEventsListeners);
    Events.on("websocket-disconnected", this.resetCatalogServiceEventsListeners);
    Events.on("websocket-reconnected", this.resetCatalogServiceEventsListeners);
  },
  beforeUnmount() {
    this.$engineEvents.off("map-ready", this.onEngineReady);
    this.$engineEvents.off("globe-ready", this.onEngineReady);
    this.$engineEvents.off("layer-added", this.configureLayerActions);
    Events.off("navigator-disconnected", this.resetCatalogServiceEventsListeners);
    Events.off("navigator-reconnected", this.resetCatalogServiceEventsListeners);
    Events.off("websocket-disconnected", this.resetCatalogServiceEventsListeners);
    Events.off("websocket-reconnected", this.resetCatalogServiceEventsListeners);
    this.finalize();
  }
};
const context = {
  methods: {
    getContextKey(context2) {
      return `${this.activityName}-${context2}`;
    },
    shouldRestoreContext(context2) {
      if (_$1.has(this, `activityOptions.restore.${context2}`)) {
        if (!_$1.get(this, `activityOptions.restore.${context2}`)) return false;
      }
      return Store.get(`restore.${context2}`);
    },
    getRouteContext(context2) {
      switch (context2) {
        case "layers":
          if (_$1.get(this.$route, "query.layers")) {
            return _$1.pick(this.$route.query, ["layers"]);
          }
          break;
        case "time":
          if (_$1.get(this.$route, "query.time")) {
            return _$1.pick(this.$route.query, ["time"]);
          }
          break;
        case "view":
        default:
          if (_$1.get(this.$route, "params.south") && _$1.get(this.$route, "params.west") && _$1.get(this.$route, "params.north") && _$1.get(this.$route, "params.east")) {
            const currentBounds = _$1.pick(this.$route.params, ["south", "west", "north", "east"]);
            return _$1.mapValues(currentBounds, (value) => _$1.toNumber(value));
          }
          break;
      }
      return {};
    },
    contextAsQuery(context2) {
      switch (context2) {
        case "layers":
          return true;
        case "time":
          return true;
        case "view":
        default:
          return false;
      }
    },
    getContextParameters(context2) {
      let targetParameters;
      switch (context2) {
        case "layers":
          targetParameters = {
            layers: _$1.values(this.layers).filter(sift({ isVisible: true, scope: { $nin: ["system"] }, _id: { $exists: true } })).map((layer2) => layer2.name)
          };
          break;
        case "time": {
          targetParameters = {
            time: Time.getCurrentTime()
          };
          break;
        }
        case "view":
        default: {
          const bounds = this.getBounds();
          const south = bounds[0][0];
          const west = bounds[0][1];
          const north = bounds[1][0];
          const east = bounds[1][1];
          targetParameters = { south, west, north, east };
        }
      }
      return targetParameters;
    },
    updateRouteContext(context2, parameters) {
      const asQuery = this.contextAsQuery(context2);
      const route = {
        query: Object.assign({}, _$1.get(this.$route, "query", {})),
        params: Object.assign({}, _$1.get(this.$route, "params", {}))
      };
      switch (context2) {
        case "layers": {
          parameters = _$1.pick(parameters, ["layers"]);
          break;
        }
        case "time": {
          parameters = _$1.pick(parameters, ["time"]);
          break;
        }
        case "view":
        default: {
          parameters = _$1.pick(parameters, ["south", "west", "north", "east"]);
        }
      }
      if (asQuery) Object.assign(route.query, parameters);
      else Object.assign(route.params, parameters);
      if (this.$router) this.$router.replace(route).catch((_2) => {
      });
    },
    async setContextParameters(context2, targetParameters) {
      switch (context2) {
        case "layers": {
          if (!_$1.has(targetParameters, "layers")) return;
          const activeLayers = _$1.values(this.layers).filter(sift({ isVisible: true, scope: { $nin: ["system"] }, _id: { $exists: true } })).map((layer2) => layer2.name);
          let targetLayers = _$1.isArray(targetParameters.layers) ? targetParameters.layers : [targetParameters.layers];
          targetLayers = targetLayers.map((name) => {
            if (this.hasLayer(name)) return name;
            if (!_$1.startsWith(name, "Layers.")) {
              if (!_$1.startsWith(name, "layers-")) name = "layers-" + name;
              name = _$1.replace(_$1.replace(_$1.upperCase(name), / /g, "_"), "LAYERS_", "Layers.");
            }
            return name;
          });
          targetLayers = targetLayers.filter((name) => this.hasLayer(name));
          if (_$1.isEmpty(targetLayers)) return;
          const activedLayers = _$1.difference(targetLayers, activeLayers);
          const inactivatedLayers = _$1.difference(activeLayers, targetLayers);
          const inactivatedTerrainLayer = _$1.find(inactivatedLayers, (name) => this.hasLayer(name) && isTerrainLayer(this.getLayerByName(name)));
          const activatedTerrainLayer = _$1.find(activedLayers, (name) => this.hasLayer(name) && isTerrainLayer(this.getLayerByName(name)));
          if (inactivatedTerrainLayer && !activatedTerrainLayer) _$1.pull(inactivatedLayers, inactivatedTerrainLayer);
          await Promise.all(activedLayers.map((layer2) => this.showLayer(layer2)));
          await Promise.all(inactivatedLayers.map((layer2) => this.hideLayer(layer2)));
          break;
        }
        case "time": {
          if (!_$1.has(targetParameters, "time")) return;
          Store.set("time.currentTime", moment(targetParameters.time).utc());
          break;
        }
        case "view":
        default:
          if (!_$1.has(targetParameters, "south") || !_$1.has(targetParameters, "west") || !_$1.has(targetParameters, "north") || !_$1.has(targetParameters, "east")) return;
          this.zoomToBounds([
            [targetParameters.south, targetParameters.west],
            [targetParameters.north, targetParameters.east]
          ]);
          break;
      }
    },
    storeContext(context2) {
      const targetParameters = this.getContextParameters(context2);
      if (this.shouldRestoreContext(context2)) {
        if (!_$1.isEqual(this.getRouteContext(context2), targetParameters)) {
          this.updateRouteContext(context2, targetParameters);
        }
        LocalStorage.set(this.getContextKey(context2), targetParameters);
      }
    },
    async restoreContext(context2) {
      let targetParameters = this.getRouteContext(context2);
      if (_$1.isEmpty(targetParameters)) {
        const savedParameters = LocalStorage.get(this.getContextKey(context2));
        if (this.shouldRestoreContext(context2)) {
          if (!_$1.isEmpty(savedParameters)) {
            targetParameters = savedParameters;
            if (Array.isArray(targetParameters)) {
              targetParameters = {
                south: targetParameters[0][0],
                west: targetParameters[0][1],
                north: targetParameters[1][0],
                east: targetParameters[1][1]
              };
            }
          } else {
            if (_$1.isUndefined(this.homeContext)) {
              const response = await api.getService("catalog").find({ query: { type: "Context", isDefault: true } });
              this.homeContext = response.data.length > 0 ? response.data[0] : null;
            }
            if (this.homeContext) targetParameters = this.homeContext;
          }
        }
      }
      if (!_$1.isEmpty(targetParameters)) {
        if (this.shouldRestoreContext(context2) && !_$1.isEqual(this.getRouteContext(context2), targetParameters)) {
          this.updateRouteContext(context2, targetParameters);
        }
        this.setContextParameters(context2, targetParameters);
      }
      return targetParameters;
    },
    clearContext(context2) {
      let parameters;
      switch (context2) {
        case "layers":
          parameters = { layers: void 0 };
          break;
        case "time":
          parameters = { time: void 0 };
          break;
        case "view":
        default:
          parameters = { south: void 0, west: void 0, north: void 0, east: void 0 };
          break;
      }
      this.updateRouteContext(context2, parameters);
      window.localStorage.removeItem(this.getContextKey(context2));
    },
    async saveContext(context2) {
      context2 = Object.assign({}, context2);
      const hasLayers = context2.layers;
      delete context2.layers;
      context2.type = "Context";
      Object.assign(context2, this.getContextParameters("view"));
      if (hasLayers) {
        Object.assign(context2, this.getContextParameters("layers"));
      }
      context2 = await api.getService("catalog").create(context2);
      return context2;
    },
    async loadContext(context2) {
      if (typeof context2 === "string") {
        if (isObjectID(context2)) {
          context2 = await api.getService("catalog").get(context2);
        } else {
          const response = await api.getService("catalog").find({ query: { type: "Context", name: context2 } });
          context2 = response.data.length > 0 ? response.data[0] : null;
        }
      }
      if (!context2) throw new Error("Cannot find or invalid context");
      this.setContextParameters("view", context2);
      this.setContextParameters("layers", context2);
      return context2;
    },
    updateViewSettings(enabled) {
      if (!enabled) this.clearContext("view");
    },
    updateLayersSettings(enabled) {
      if (!enabled) this.clearContext("layers");
    }
  },
  mounted() {
    Events.on("restore-view-changed", this.updateViewSettings);
    Events.on("restore-layers-changed", this.updateLayersSettings);
  },
  beforeUnmount() {
    Events.off("restore-view-changed", this.updateViewSettings);
    Events.off("restore-layers-changed", this.updateLayersSettings);
  }
};
const featureSelection = {
  watch: {
    "selection.items": {
      handler() {
        this.updateHighlights();
        this.handleWidget(this.getWidgetForSelection());
      }
    },
    "probe.item": {
      handler() {
        this.updateHighlights();
        this.handleWidget(this.getWidgetForProbe());
      }
    }
  },
  methods: {
    updateHighlights() {
      this.clearHighlights();
      this.getSelectedItems().forEach((item) => {
        this.highlight(item.feature || item.location, item.layer);
      });
      if (this.hasProbedLocation()) this.highlight(this.getProbedLocation(), this.getProbedLayer());
    },
    handleWidget(widget) {
      if (widget && widget !== "none" && !this.isWidgetWindowVisible(widget)) this.openWidget(widget);
    }
  }
};
const featureService = {
  methods: {
    getBaseQueryForFeatures,
    getFilterQueryForFeatures,
    getSortQueryForFeatures,
    getFeaturesUpdateInterval,
    getFeaturesQueryInterval,
    shouldSkipFeaturesUpdate,
    getFeaturesLevel(options) {
      return this.selectableLevelsLayer && this.selectableLevelsLayer.name === options.name ? this.selectedLevel : null;
    },
    getProbeFeatures,
    async getProbeFeaturesFromLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      return this.getProbeFeatures(layer2);
    },
    async getFeaturesQuery(options, queryInterval, queryLevel) {
      if (!queryLevel) {
        queryLevel = this.getFeaturesLevel(options);
      }
      return getFeaturesQuery(options, queryInterval, queryLevel);
    },
    getFeaturesFromQuery,
    async getFeatures(options, queryInterval, queryLevel) {
      const query = await this.getFeaturesQuery(options, queryInterval, queryLevel);
      const response = await getFeaturesFromQuery(options, query);
      return response;
    },
    async getFeaturesFromLayer(name, queryInterval) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      return this.getFeatures(layer2, queryInterval);
    },
    getMeasureForFeatureBaseQuery,
    async getMeasureForFeatureQuery(layer2, feature2, startTime, endTime) {
      const query = await this.getFeaturesQuery(_$1.merge({
        baseQuery: getMeasureForFeatureBaseQuery(layer2, feature2)
      }, layer2), {
        $gte: startTime.toISOString(),
        $lte: endTime.toISOString()
      });
      return query;
    },
    getMeasureForFeatureFromQuery,
    async getMeasureForFeature(layer2, feature2, startTime, endTime) {
      let probedLocation;
      this.setCursor("processing-cursor");
      try {
        const query = await this.getMeasureForFeatureQuery(layer2, feature2, startTime, endTime);
        probedLocation = await getMeasureForFeatureFromQuery(layer2, feature2, query);
      } catch (error) {
        logger$1.error(error);
      }
      this.unsetCursor("processing-cursor");
      return probedLocation;
    },
    checkFeatures,
    createFeatures,
    editFeaturesGeometry,
    editFeaturesProperties,
    editFeaturesStyle,
    removeFeatures,
    onFeatureUpdated(feature2, layer2) {
      if (!layer2 && feature2.layer) layer2 = this.getLayerById(feature2.layer);
      if (!layer2 || !this.isLayerVisible(layer2.name)) return;
      if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) return;
      if (!isFeatureInQueryInterval(feature2, layer2)) return;
      if (typeof this.updateLayer === "function") {
        const filteredFeature = [feature2].filter(sift(_$1.omit(layer2.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"])));
        if (filteredFeature.length > 0) this.updateLayer(layer2.name, feature2, { removeMissing: false });
      }
    },
    onFeatureRemoved(feature2, layer2) {
      if (!layer2 && feature2.layer) layer2 = this.getLayerById(feature2.layer);
      if (!layer2 || !this.isLayerVisible(layer2.name)) return;
      if (typeof this.isLayerEdited === "function" && this.isLayerEdited(layer2)) return;
      if (typeof this.updateLayer === "function") {
        const filteredFeature = [feature2].filter(sift(_$1.omit(layer2.baseQuery || {}, ["$skip", "$sort", "$limit", "$select"])));
        if (filteredFeature.length > 0) this.updateLayer(layer2.name, feature2, { remove: true });
      }
    },
    listenToFeaturesServiceEventsForLayer(layer2) {
      const listeners = listenToFeaturesServiceEventsForLayer(layer2, {
        created: this.onFeatureUpdated,
        updated: this.onFeatureUpdated,
        patched: this.onFeatureUpdated,
        removed: this.onFeatureRemoved
      }, this.layerServiceEventListeners[layer2._id]);
      if (listeners) this.layerServiceEventListeners[layer2._id] = listeners;
    },
    unlistenToFeaturesServiceEventsForLayer(layer2) {
      unlistenToFeaturesServiceEventsForLayer(layer2, this.layerServiceEventListeners[layer2._id]);
      delete this.layerServiceEventListeners[layer2._id];
    },
    listenToFeaturesServiceEventsForLayers() {
      this.layerServiceEventListeners = {};
      _$1.forEach(this.getLayers(), this.listenToFeaturesServiceEventsForLayer);
    },
    unlistenToFeaturesServiceEventsForLayers() {
      _$1.forOwn(this.layerServiceEventListeners, this.unlistenToFeaturesServiceEventsForLayer);
      this.layerServiceEventListeners = {};
    }
  },
  created() {
    api.getService("features").timeout = 60 * 60 * 1e3;
  },
  mounted() {
    this.listenToFeaturesServiceEventsForLayers();
    this.$engineEvents.on("layer-added", this.listenToFeaturesServiceEventsForLayer);
    this.$engineEvents.on("layer-removed", this.unlistenToFeaturesServiceEventsForLayer);
    Events.on("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.on("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.on("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.on("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  },
  beforeUnmount() {
    this.unlistenToFeaturesServiceEventsForLayers();
    this.$engineEvents.off("layer-added", this.listenToFeaturesServiceEventsForLayer);
    this.$engineEvents.off("layer-removed", this.unlistenToFeaturesServiceEventsForLayer);
    Events.off("navigator-disconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.off("navigator-reconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.off("websocket-disconnected", this.listenToFeaturesServiceEventsForLayers);
    Events.off("websocket-reconnected", this.listenToFeaturesServiceEventsForLayers);
  }
};
const infobox = {
  methods: {
    getDefaultInfoBox(feature2, options) {
      let properties = feature2.properties;
      if (properties) {
        const engineOptions = _$1.get(options, this.engine, options);
        if (_$1.has(engineOptions, "infobox") && !_$1.get(engineOptions, "infobox")) return [];
        if (_$1.has(properties, "infobox") && !_$1.get(properties, "infobox")) return [];
        const infoboxStyle = Object.assign(
          {},
          _$1.get(this, "activityOptions.engine.infobox"),
          engineOptions.infobox,
          properties.infobox
        );
        if (infoboxStyle.pick) {
          properties = _$1.pick(properties, infoboxStyle.pick);
        } else if (infoboxStyle.omit) {
          properties = _$1.omit(properties, infoboxStyle.omit);
        }
      }
      return properties;
    }
  },
  created() {
    this.registerStyle("infobox", this.getDefaultInfoBox);
  }
};
const levels = {
  emits: [
    "selected-level-changed"
  ],
  data() {
    return {
      selectedLevel: null,
      selectableLevels: {},
      selectableLevelsLayer: null
    };
  },
  computed: {
    hasSelectableLevels() {
      return _$1.get(this.selectableLevels, "values", []).length > 0;
    }
  },
  methods: {
    setSelectableLevels(layer2, levels2, initialLevel) {
      this.selectableLevels = levels2;
      this.selectableLevelsLayer = layer2;
      if (_$1.isNil(initialLevel)) {
        initialLevel = _$1.get(levels2, "values[0]", _$1.get(levels2, "range.min"));
      }
      this.setSelectedLevel(initialLevel);
    },
    clearSelectableLevels(layer2) {
      if (this.selectableLevelsLayer) {
        this.selectableLevels = {};
        this.selectableLevelsLayer = null;
        this.setSelectedLevel(null);
      }
    },
    setSelectedLevel(level) {
      if (this.selectedLevel === level) return;
      this.selectedLevel = level;
      this.onSelectedLevelChanged(level);
    },
    onSelectedLevelChanged(level) {
      this.$emit("selected-level-changed", level);
      this.$engineEvents.emit("selected-level-changed", level);
    },
    onShowSelectableLevelsLayer(layer2) {
      const levels2 = _$1.get(layer2, "levels");
      if (levels2) {
        this.setSelectableLevels(layer2, levels2);
      }
    },
    onHideSelectableLevelsLayer(layer2) {
      const levels2 = _$1.get(layer2, "levels");
      if (levels2) {
        this.clearSelectableLevels(layer2);
      }
    }
  },
  created() {
    this.$engineEvents.on("layer-shown", this.onShowSelectableLevelsLayer);
    this.$engineEvents.on("layer-hidden", this.onHideSelectableLevelsLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-shown", this.onShowSelectableLevelsLayer);
    this.$engineEvents.off("layer-hidden", this.onHideSelectableLevelsLayer);
  }
};
const style$2 = {
  methods: {
    registerStyle(type, generator) {
      if (!this[type + "Factory"]) this[type + "Factory"] = [];
      this[type + "Factory"].push(generator);
    },
    unregisterStyle(type, generator) {
      _$1.pull(this[type + "Factory"], generator);
    },
    generateStyle() {
      const args = Array.from(arguments);
      const type = args[0];
      if (!this[type + "Factory"]) return;
      args.shift();
      let style2;
      for (let i = this[type + "Factory"].length - 1; i >= 0; i--) {
        const generator = this[type + "Factory"][i];
        style2 = generator(...args);
        if (style2) break;
      }
      return style2;
    }
  }
};
const weacast = {
  emits: [
    "forecast-model-changed",
    "forecast-level-changed"
  ],
  data() {
    return {
      forecastModel: null,
      forecastModels: []
    };
  },
  methods: {
    getWeacastApi() {
      return api;
    },
    async setupWeacast() {
      try {
        await this.setupForecastModels();
      } catch (error) {
        logger$1.error("Cannot retrieve available Weacast forecast models", error);
      }
    },
    async setupForecastModels() {
      if (!this.getWeacastApi() || this.getWeacastApi().isDisconnected || this.getWeacastApi().useLocalFirst) return;
      const response = await this.getWeacastApi().getService("forecasts").find();
      this.forecastModels.splice(0, this.forecastModels.length, ...response.data);
      this.getWeacastApi().models = this.forecastModels;
      this.forecastModels.forEach((forecastModel2) => {
        forecastModel2.actions = [{ id: "toggle", handler: () => this.setForecastModel(forecastModel2) }];
      });
      let forecastModel = this.forecastModels.find((forecast) => forecast.isDefault);
      if (!forecastModel) {
        forecastModel = this.forecastModels.length > 0 ? this.forecastModels[0] : null;
      }
      this.setForecastModel(forecastModel);
    },
    setForecastModel(model) {
      if (this.forecastModel === model) return;
      this.forecastModel = model;
      this.onForecastModelChanged(model);
    },
    onForecastModelChanged(model) {
      this.$emit("forecast-model-changed", model);
      this.$engineEvents.emit("forecast-model-changed", model);
    },
    setForecastLevel(level) {
      if (this.forecastLevel === level) return;
      this.forecastLevel = level;
      this.onForecastLevelChanged(level);
    },
    onForecastLevelChanged(level) {
      this.$emit("forecast-level-changed", level);
      this.$engineEvents.emit("forecast-level-changed", level);
    },
    async getForecastForLocation(long, lat, startTime, endTime) {
      if (!this.forecastModel) return;
      this.setCursor("processing-cursor");
      const probedLocation = await getForecastForLocation({
        startTime,
        endTime,
        forecastModel: this.forecastModel,
        forecastLevel: this.forecastLevel,
        weacastApi: this.getWeacastApi()
      });
      this.unsetCursor("processing-cursor");
      return probedLocation;
    },
    async getForecastProbe(name) {
      if (!this.forecastModel) return;
      if (this.probe && this.probe.name === name && this.probe.forecast === this.forecastModel.name) {
        return this.probe;
      }
      this.probe = await getForecastProbe({ name, forecastModel: this.forecastModel, weacastApi: this.getWeacastApi() });
      return this.probe;
    },
    async getForecastForFeature(featureId, startTime, endTime) {
      if (!this.forecastModel) return;
      if (!this.probe) return;
      this.setCursor("processing-cursor");
      const probedLocation = await getForecastForFeature({ probe: this.probe, featureId, startTime, endTime, forecastModel: this.forecastModel, forecastLevel: this.forecastLevel, weacastApi: this.getWeacastApi() });
      this.unsetCursor("processing-cursor");
      return probedLocation;
    },
    onCurrentForecastTimeChanged(time) {
      if (this.getWeacastApi()) this.getWeacastApi().setForecastTime(time);
    },
    onWeacastSelectedLevelChanged(level) {
      if (_$1.isNil(level)) {
        this.setForecastLevel(null);
        return;
      }
      const layer2 = this.selectableLevelsLayer;
      if (layer2) {
        const type = _$1.get(layer2, `${this.engine}.type`);
        const sources = _$1.get(layer2, "meteo_model.sources", []);
        const weacastSource = sources.find((source) => _$1.has(source, "weacast"));
        if (type.startsWith("weacast") || weacastSource) {
          this.setForecastLevel(level);
        }
      }
    }
  },
  created() {
    Events.on("time-current-time-changed", this.onCurrentForecastTimeChanged);
    this.$engineEvents.on("selected-level-changed", this.onWeacastSelectedLevelChanged);
  },
  beforeUnmount() {
    Events.off("time-current-time-changed", this.onCurrentForecastTimeChanged);
    this.$engineEvents.off("selected-level-changed", this.onWeacastSelectedLevelChanged);
  }
};
const commonMixins = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: activity$2,
  context,
  featureSelection,
  featureService,
  infobox,
  levels,
  style: style$2,
  weacast
}, Symbol.toStringTag, { value: "Module" }));
(function() {
  function __$strToBlobUri(str, mime, isBinary) {
    try {
      return window.URL.createObjectURL(new Blob([Uint8Array.from(str.split("").map(function(c) {
        return c.charCodeAt(0);
      }))], { type: mime }));
    } catch (e) {
      return "data:" + mime + "," + str;
    }
  }
  (function(self2) {
    if (self2.fetch) {
      return;
    }
    var support = {
      searchParams: "URLSearchParams" in self2,
      iterable: "Symbol" in self2 && "iterator" in Symbol,
      blob: "FileReader" in self2 && "Blob" in self2 && function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: "FormData" in self2,
      arrayBuffer: "ArrayBuffer" in self2
    };
    if (support.arrayBuffer) {
      var viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ];
      var isDataView = function(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };
      var isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    function normalizeName(name) {
      if (typeof name !== "string") {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError("Invalid character in header field name");
      }
      return name.toLowerCase();
    }
    function normalizeValue(value) {
      if (typeof value !== "string") {
        value = String(value);
      }
      return value;
    }
    function iteratorFor(items) {
      var iterator = {
        next: function() {
          var value = items.shift();
          return { done: value === void 0, value };
        }
      };
      if (support.iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator;
        };
      }
      return iterator;
    }
    function Headers(headers) {
      this.map = {};
      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }
    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + "," + value : value;
    };
    Headers.prototype["delete"] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
      var this$1$1 = this;
      for (var name in this.map) {
        if (this$1$1.map.hasOwnProperty(name)) {
          callback.call(thisArg, this$1$1.map[name], name, this$1$1);
        }
      }
    };
    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError("Already read"));
      }
      body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      });
    }
    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }
    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }
    function readArrayBufferAsText(buf2) {
      var view = new Uint8Array(buf2);
      var chars = new Array(view.length);
      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join("");
    }
    function bufferClone(buf2) {
      if (buf2.slice) {
        return buf2.slice(0);
      } else {
        var view = new Uint8Array(buf2.byteLength);
        view.set(new Uint8Array(buf2));
        return view.buffer;
      }
    }
    function Body2() {
      this.bodyUsed = false;
      this._initBody = function(body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = "";
        } else if (typeof body === "string") {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error("unsupported BodyInit type");
        }
        if (!this.headers.get("content-type")) {
          if (typeof body === "string") {
            this.headers.set("content-type", "text/plain;charset=UTF-8");
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set("content-type", this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
          }
        }
      };
      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as blob");
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };
        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }
      this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error("could not read FormData body as text");
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode);
        };
      }
      this.json = function() {
        return this.text().then(JSON.parse);
      };
      return this;
    }
    var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
      options = options || {};
      var body = options.body;
      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError("Already read");
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }
      this.credentials = options.credentials || this.credentials || "omit";
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || "GET");
      this.mode = options.mode || this.mode || null;
      this.referrer = null;
      if ((this.method === "GET" || this.method === "HEAD") && body) {
        throw new TypeError("Body not allowed for GET or HEAD requests");
      }
      this._initBody(body);
    }
    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit });
    };
    function decode(body) {
      var form = new FormData();
      body.trim().split("&").forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split("=");
          var name = split.shift().replace(/\+/g, " ");
          var value = split.join("=").replace(/\+/g, " ");
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }
    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      rawHeaders.split(/\r?\n/).forEach(function(line) {
        var parts = line.split(":");
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(":").trim();
          headers.append(key, value);
        }
      });
      return headers;
    }
    Body2.call(Request.prototype);
    function Response2(bodyInit, options) {
      if (!options) {
        options = {};
      }
      this.type = "default";
      this.status = "status" in options ? options.status : 200;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = "statusText" in options ? options.statusText : "OK";
      this.headers = new Headers(options.headers);
      this.url = options.url || "";
      this._initBody(bodyInit);
    }
    Body2.call(Response2.prototype);
    Response2.prototype.clone = function() {
      return new Response2(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };
    Response2.error = function() {
      var response = new Response2(null, { status: 0, statusText: "" });
      response.type = "error";
      return response;
    };
    var redirectStatuses = [301, 302, 303, 307, 308];
    Response2.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError("Invalid status code");
      }
      return new Response2(null, { status, headers: { location: url } });
    };
    self2.Headers = Headers;
    self2.Request = Request;
    self2.Response = Response2;
    self2.fetch = function(input, init2) {
      return new Promise(function(resolve, reject) {
        var request = new Request(input, init2);
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || "")
          };
          options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
          var body = "response" in xhr ? xhr.response : xhr.responseText;
          resolve(new Response2(body, options));
        };
        xhr.onerror = function() {
          reject(new TypeError("Network request failed"));
        };
        xhr.ontimeout = function() {
          reject(new TypeError("Network request failed"));
        };
        xhr.open(request.method, request.url, true);
        if (request.credentials === "include") {
          xhr.withCredentials = true;
        }
        if ("responseType" in xhr && support.blob) {
          xhr.responseType = "blob";
        }
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
        xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
      });
    };
    self2.fetch.polyfill = true;
  })(typeof self !== "undefined" ? self : void 0);
  var read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  var write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  };
  var index$12 = {
    read,
    write
  };
  var index2 = Pbf;
  var ieee754 = index$12;
  function Pbf(buf2) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf2) ? buf2 : new Uint8Array(buf2 || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
  }
  Pbf.Varint = 0;
  Pbf.Fixed64 = 1;
  Pbf.Bytes = 2;
  Pbf.Fixed32 = 5;
  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
  var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  Pbf.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(readField, result, end) {
      var this$1$1 = this;
      end = end || this.length;
      while (this.pos < end) {
        var val = this$1$1.readVarint(), tag = val >> 3, startPos = this$1$1.pos;
        this$1$1.type = val & 7;
        readField(tag, result, this$1$1);
        if (this$1$1.pos === startPos) {
          this$1$1.skip(val);
        }
      }
      return result;
    },
    readMessage: function(readField, result) {
      return this.readFields(readField, result, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var val = readUInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    readSFixed32: function() {
      var val = readInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readSFixed64: function() {
      var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    },
    readFloat: function() {
      var val = ieee754.read(this.buf, this.pos, true, 23, 4);
      this.pos += 4;
      return val;
    },
    readDouble: function() {
      var val = ieee754.read(this.buf, this.pos, true, 52, 8);
      this.pos += 8;
      return val;
    },
    readVarint: function(isSigned) {
      var buf2 = this.buf, val, b;
      b = buf2[this.pos++];
      val = b & 127;
      if (b < 128) {
        return val;
      }
      b = buf2[this.pos++];
      val |= (b & 127) << 7;
      if (b < 128) {
        return val;
      }
      b = buf2[this.pos++];
      val |= (b & 127) << 14;
      if (b < 128) {
        return val;
      }
      b = buf2[this.pos++];
      val |= (b & 127) << 21;
      if (b < 128) {
        return val;
      }
      b = buf2[this.pos];
      val |= (b & 15) << 28;
      return readVarintRemainder(val, isSigned, this);
    },
    readVarint64: function() {
      return this.readVarint(true);
    },
    readSVarint: function() {
      var num = this.readVarint();
      return num % 2 === 1 ? (num + 1) / -2 : num / 2;
    },
    readBoolean: function() {
      return Boolean(this.readVarint());
    },
    readString: function() {
      var end = this.readVarint() + this.pos, str = readUtf8(this.buf, this.pos, end);
      this.pos = end;
      return str;
    },
    readBytes: function() {
      var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
      this.pos = end;
      return buffer;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(arr, isSigned) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readVarint(isSigned));
      }
      return arr;
    },
    readPackedSVarint: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readSVarint());
      }
      return arr;
    },
    readPackedBoolean: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readBoolean());
      }
      return arr;
    },
    readPackedFloat: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readFloat());
      }
      return arr;
    },
    readPackedDouble: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readDouble());
      }
      return arr;
    },
    readPackedFixed32: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readFixed32());
      }
      return arr;
    },
    readPackedSFixed32: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readSFixed32());
      }
      return arr;
    },
    readPackedFixed64: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readFixed64());
      }
      return arr;
    },
    readPackedSFixed64: function(arr) {
      var this$1$1 = this;
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this$1$1.readSFixed64());
      }
      return arr;
    },
    skip: function(val) {
      var type = val & 7;
      if (type === Pbf.Varint) {
        while (this.buf[this.pos++] > 127) {
        }
      } else if (type === Pbf.Bytes) {
        this.pos = this.readVarint() + this.pos;
      } else if (type === Pbf.Fixed32) {
        this.pos += 4;
      } else if (type === Pbf.Fixed64) {
        this.pos += 8;
      } else {
        throw new Error("Unimplemented type: " + type);
      }
    },
    // === WRITING =================================================================
    writeTag: function(tag, type) {
      this.writeVarint(tag << 3 | type);
    },
    realloc: function(min) {
      var length2 = this.length || 16;
      while (length2 < this.pos + min) {
        length2 *= 2;
      }
      if (length2 !== this.length) {
        var buf2 = new Uint8Array(length2);
        buf2.set(this.buf);
        this.buf = buf2;
        this.length = length2;
      }
    },
    finish: function() {
      this.length = this.pos;
      this.pos = 0;
      return this.buf.subarray(0, this.length);
    },
    writeFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeSFixed32: function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    },
    writeFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeSFixed64: function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    },
    writeVarint: function(val) {
      val = +val || 0;
      if (val > 268435455 || val < 0) {
        writeBigVarint(val, this);
        return;
      }
      this.realloc(4);
      this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = val >>> 7 & 127;
    },
    writeSVarint: function(val) {
      this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },
    writeBoolean: function(val) {
      this.writeVarint(Boolean(val));
    },
    writeString: function(str) {
      str = String(str);
      this.realloc(str.length * 4);
      this.pos++;
      var startPos = this.pos;
      this.pos = writeUtf8(this.buf, str, this.pos);
      var len = this.pos - startPos;
      if (len >= 128) {
        makeRoomForExtraLength(startPos, len, this);
      }
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeFloat: function(val) {
      this.realloc(4);
      ieee754.write(this.buf, val, this.pos, true, 23, 4);
      this.pos += 4;
    },
    writeDouble: function(val) {
      this.realloc(8);
      ieee754.write(this.buf, val, this.pos, true, 52, 8);
      this.pos += 8;
    },
    writeBytes: function(buffer) {
      var this$1$1 = this;
      var len = buffer.length;
      this.writeVarint(len);
      this.realloc(len);
      for (var i = 0; i < len; i++) {
        this$1$1.buf[this$1$1.pos++] = buffer[i];
      }
    },
    writeRawMessage: function(fn, obj) {
      this.pos++;
      var startPos = this.pos;
      fn(obj, this);
      var len = this.pos - startPos;
      if (len >= 128) {
        makeRoomForExtraLength(startPos, len, this);
      }
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    },
    writeMessage: function(tag, fn, obj) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeRawMessage(fn, obj);
    },
    writePackedVarint: function(tag, arr) {
      this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function(tag, arr) {
      this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function(tag, arr) {
      this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function(tag, arr) {
      this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function(tag, arr) {
      this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function(tag, arr) {
      this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function(tag, arr) {
      this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function(tag, arr) {
      this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function(tag, arr) {
      this.writeMessage(tag, writePackedSFixed64, arr);
    },
    writeBytesField: function(tag, buffer) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeString(str);
    },
    writeFloatField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
      this.writeVarintField(tag, Boolean(val));
    }
  };
  function readVarintRemainder(l, s, p) {
    var buf2 = p.buf, h2, b;
    b = buf2[p.pos++];
    h2 = (b & 112) >> 4;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    b = buf2[p.pos++];
    h2 |= (b & 127) << 3;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    b = buf2[p.pos++];
    h2 |= (b & 127) << 10;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    b = buf2[p.pos++];
    h2 |= (b & 127) << 17;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    b = buf2[p.pos++];
    h2 |= (b & 127) << 24;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    b = buf2[p.pos++];
    h2 |= (b & 1) << 31;
    if (b < 128) {
      return toNum(l, h2, s);
    }
    throw new Error("Expected varint not more than 10 bytes");
  }
  function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
  }
  function toNum(low, high, isSigned) {
    if (isSigned) {
      return high * 4294967296 + (low >>> 0);
    }
    return (high >>> 0) * 4294967296 + (low >>> 0);
  }
  function writeBigVarint(val, pbf) {
    var low, high;
    if (val >= 0) {
      low = val % 4294967296 | 0;
      high = val / 4294967296 | 0;
    } else {
      low = ~(-val % 4294967296);
      high = ~(-val / 4294967296);
      if (low ^ 4294967295) {
        low = low + 1 | 0;
      } else {
        low = 0;
        high = high + 1 | 0;
      }
    }
    if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
      throw new Error("Given varint doesn't fit into 10 bytes");
    }
    pbf.realloc(10);
    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
  }
  function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf.buf[pbf.pos++] = low & 127 | 128;
    low >>>= 7;
    pbf.buf[pbf.pos] = low & 127;
  }
  function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 7) << 4;
    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
    if (!high) {
      return;
    }
    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high) {
      return;
    }
    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high) {
      return;
    }
    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high) {
      return;
    }
    pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
    if (!high) {
      return;
    }
    pbf.buf[pbf.pos++] = high & 127;
  }
  function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) {
      pbf.buf[i + extraLen] = pbf.buf[i];
    }
  }
  function writePackedVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeVarint(arr[i]);
    }
  }
  function writePackedSVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeSVarint(arr[i]);
    }
  }
  function writePackedFloat(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeFloat(arr[i]);
    }
  }
  function writePackedDouble(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeDouble(arr[i]);
    }
  }
  function writePackedBoolean(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeBoolean(arr[i]);
    }
  }
  function writePackedFixed32(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeFixed32(arr[i]);
    }
  }
  function writePackedSFixed32(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeSFixed32(arr[i]);
    }
  }
  function writePackedFixed64(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeFixed64(arr[i]);
    }
  }
  function writePackedSFixed64(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
      pbf.writeSFixed64(arr[i]);
    }
  }
  function readUInt32(buf2, pos) {
    return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16) + buf2[pos + 3] * 16777216;
  }
  function writeInt32(buf2, val, pos) {
    buf2[pos] = val;
    buf2[pos + 1] = val >>> 8;
    buf2[pos + 2] = val >>> 16;
    buf2[pos + 3] = val >>> 24;
  }
  function readInt32(buf2, pos) {
    return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16) + (buf2[pos + 3] << 24);
  }
  function readUtf8(buf2, pos, end) {
    var str = "";
    var i = pos;
    while (i < end) {
      var b0 = buf2[i];
      var c = null;
      var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
      if (i + bytesPerSequence > end) {
        break;
      }
      var b1, b2, b3;
      if (bytesPerSequence === 1) {
        if (b0 < 128) {
          c = b0;
        }
      } else if (bytesPerSequence === 2) {
        b1 = buf2[i + 1];
        if ((b1 & 192) === 128) {
          c = (b0 & 31) << 6 | b1 & 63;
          if (c <= 127) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 3) {
        b1 = buf2[i + 1];
        b2 = buf2[i + 2];
        if ((b1 & 192) === 128 && (b2 & 192) === 128) {
          c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
          if (c <= 2047 || c >= 55296 && c <= 57343) {
            c = null;
          }
        }
      } else if (bytesPerSequence === 4) {
        b1 = buf2[i + 1];
        b2 = buf2[i + 2];
        b3 = buf2[i + 3];
        if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
          c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
          if (c <= 65535 || c >= 1114112) {
            c = null;
          }
        }
      }
      if (c === null) {
        c = 65533;
        bytesPerSequence = 1;
      } else if (c > 65535) {
        c -= 65536;
        str += String.fromCharCode(c >>> 10 & 1023 | 55296);
        c = 56320 | c & 1023;
      }
      str += String.fromCharCode(c);
      i += bytesPerSequence;
    }
    return str;
  }
  function writeUtf8(buf2, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
      c = str.charCodeAt(i);
      if (c > 55295 && c < 57344) {
        if (lead) {
          if (c < 56320) {
            buf2[pos++] = 239;
            buf2[pos++] = 191;
            buf2[pos++] = 189;
            lead = c;
            continue;
          } else {
            c = lead - 55296 << 10 | c - 56320 | 65536;
            lead = null;
          }
        } else {
          if (c > 56319 || i + 1 === str.length) {
            buf2[pos++] = 239;
            buf2[pos++] = 191;
            buf2[pos++] = 189;
          } else {
            lead = c;
          }
          continue;
        }
      } else if (lead) {
        buf2[pos++] = 239;
        buf2[pos++] = 191;
        buf2[pos++] = 189;
        lead = null;
      }
      if (c < 128) {
        buf2[pos++] = c;
      } else {
        if (c < 2048) {
          buf2[pos++] = c >> 6 | 192;
        } else {
          if (c < 65536) {
            buf2[pos++] = c >> 12 | 224;
          } else {
            buf2[pos++] = c >> 18 | 240;
            buf2[pos++] = c >> 12 & 63 | 128;
          }
          buf2[pos++] = c >> 6 & 63 | 128;
        }
        buf2[pos++] = c & 63 | 128;
      }
    }
    return pos;
  }
  var index$52 = Point$1;
  function Point$1(x, y) {
    this.x = x;
    this.y = y;
  }
  Point$1.prototype = {
    clone: function() {
      return new Point$1(this.x, this.y);
    },
    add: function(p) {
      return this.clone()._add(p);
    },
    sub: function(p) {
      return this.clone()._sub(p);
    },
    mult: function(k) {
      return this.clone()._mult(k);
    },
    div: function(k) {
      return this.clone()._div(k);
    },
    rotate: function(a) {
      return this.clone()._rotate(a);
    },
    matMult: function(m) {
      return this.clone()._matMult(m);
    },
    unit: function() {
      return this.clone()._unit();
    },
    perp: function() {
      return this.clone()._perp();
    },
    round: function() {
      return this.clone()._round();
    },
    mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    equals: function(p) {
      return this.x === p.x && this.y === p.y;
    },
    dist: function(p) {
      return Math.sqrt(this.distSqr(p));
    },
    distSqr: function(p) {
      var dx = p.x - this.x, dy = p.y - this.y;
      return dx * dx + dy * dy;
    },
    angle: function() {
      return Math.atan2(this.y, this.x);
    },
    angleTo: function(b) {
      return Math.atan2(this.y - b.y, this.x - b.x);
    },
    angleWith: function(b) {
      return this.angleWithSep(b.x, b.y);
    },
    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
      return Math.atan2(
        this.x * y - this.y * x,
        this.x * x + this.y * y
      );
    },
    _matMult: function(m) {
      var x = m[0] * this.x + m[1] * this.y, y = m[2] * this.x + m[3] * this.y;
      this.x = x;
      this.y = y;
      return this;
    },
    _add: function(p) {
      this.x += p.x;
      this.y += p.y;
      return this;
    },
    _sub: function(p) {
      this.x -= p.x;
      this.y -= p.y;
      return this;
    },
    _mult: function(k) {
      this.x *= k;
      this.y *= k;
      return this;
    },
    _div: function(k) {
      this.x /= k;
      this.y /= k;
      return this;
    },
    _unit: function() {
      this._div(this.mag());
      return this;
    },
    _perp: function() {
      var y = this.y;
      this.y = this.x;
      this.x = -y;
      return this;
    },
    _rotate: function(angle2) {
      var cos = Math.cos(angle2), sin = Math.sin(angle2), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
      this.x = x;
      this.y = y;
      return this;
    },
    _round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
  };
  Point$1.convert = function(a) {
    if (a instanceof Point$1) {
      return a;
    }
    if (Array.isArray(a)) {
      return new Point$1(a[0], a[1]);
    }
    return a;
  };
  var Point = index$52;
  var vectortilefeature = VectorTileFeature$2;
  function VectorTileFeature$2(pbf, end, extent, keys, values) {
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    pbf.readFields(readFeature, this, end);
  }
  function readFeature(tag, feature2, pbf) {
    if (tag == 1) {
      feature2.id = pbf.readVarint();
    } else if (tag == 2) {
      readTag(pbf, feature2);
    } else if (tag == 3) {
      feature2.type = pbf.readVarint();
    } else if (tag == 4) {
      feature2._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature2) {
    var end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      var key = feature2._keys[pbf.readVarint()], value = feature2._values[pbf.readVarint()];
      feature2.properties[key] = value;
    }
  }
  VectorTileFeature$2.types = ["Unknown", "Point", "LineString", "Polygon"];
  VectorTileFeature$2.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;
    var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x = 0, y = 0, lines = [], line;
    while (pbf.pos < end) {
      if (!length2) {
        var cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length2 = cmdLen >> 3;
      }
      length2--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          if (line) {
            lines.push(line);
          }
          line = [];
        }
        line.push(new Point(x, y));
      } else if (cmd === 7) {
        if (line) {
          line.push(line[0].clone());
        }
      } else {
        throw new Error("unknown command " + cmd);
      }
    }
    if (line) {
      lines.push(line);
    }
    return lines;
  };
  VectorTileFeature$2.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;
    var end = pbf.readVarint() + pbf.pos, cmd = 1, length2 = 0, x = 0, y = 0, x1 = Infinity, x2 = -Infinity, y1 = Infinity, y2 = -Infinity;
    while (pbf.pos < end) {
      if (!length2) {
        var cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length2 = cmdLen >> 3;
      }
      length2--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (x < x1) {
          x1 = x;
        }
        if (x > x2) {
          x2 = x;
        }
        if (y < y1) {
          y1 = y;
        }
        if (y > y2) {
          y2 = y;
        }
      } else if (cmd !== 7) {
        throw new Error("unknown command " + cmd);
      }
    }
    return [x1, y1, x2, y2];
  };
  VectorTileFeature$2.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z), x0 = this.extent * x, y0 = this.extent * y, coords = this.loadGeometry(), type = VectorTileFeature$2.types[this.type], i, j;
    function project(line) {
      for (var j2 = 0; j2 < line.length; j2++) {
        var p = line[j2], y2 = 180 - (p.y + y0) * 360 / size;
        line[j2] = [
          (p.x + x0) * 360 / size - 180,
          360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
        ];
      }
    }
    switch (this.type) {
      case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
          points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;
      case 2:
        for (i = 0; i < coords.length; i++) {
          project(coords[i]);
        }
        break;
      case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
          for (j = 0; j < coords[i].length; j++) {
            project(coords[i][j]);
          }
        }
        break;
    }
    if (coords.length === 1) {
      coords = coords[0];
    } else {
      type = "Multi" + type;
    }
    var result = {
      type: "Feature",
      geometry: {
        type,
        coordinates: coords
      },
      properties: this.properties
    };
    if ("id" in this) {
      result.id = this.id;
    }
    return result;
  };
  function classifyRings(rings) {
    var len = rings.length;
    if (len <= 1) {
      return [rings];
    }
    var polygons = [], polygon2, ccw;
    for (var i = 0; i < len; i++) {
      var area2 = signedArea(rings[i]);
      if (area2 === 0) {
        continue;
      }
      if (ccw === void 0) {
        ccw = area2 < 0;
      }
      if (ccw === area2 < 0) {
        if (polygon2) {
          polygons.push(polygon2);
        }
        polygon2 = [rings[i]];
      } else {
        polygon2.push(rings[i]);
      }
    }
    if (polygon2) {
      polygons.push(polygon2);
    }
    return polygons;
  }
  function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
      p1 = ring[i];
      p2 = ring[j];
      sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
  }
  var VectorTileFeature$1 = vectortilefeature;
  var vectortilelayer = VectorTileLayer$2;
  function VectorTileLayer$2(pbf, end) {
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  function readLayer(tag, layer2, pbf) {
    if (tag === 15) {
      layer2.version = pbf.readVarint();
    } else if (tag === 1) {
      layer2.name = pbf.readString();
    } else if (tag === 5) {
      layer2.extent = pbf.readVarint();
    } else if (tag === 2) {
      layer2._features.push(pbf.pos);
    } else if (tag === 3) {
      layer2._keys.push(pbf.readString());
    } else if (tag === 4) {
      layer2._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    var value = null, end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      var tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }
  VectorTileLayer$2.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i];
    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature$1(this._pbf, end, this.extent, this._keys, this._values);
  };
  var VectorTileLayer$1 = vectortilelayer;
  var vectortile = VectorTile$1;
  function VectorTile$1(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
  }
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      var layer2 = new VectorTileLayer$1(pbf, pbf.readVarint() + pbf.pos);
      if (layer2.length) {
        layers[layer2.name] = layer2;
      }
    }
  }
  var VectorTile = vectortile;
  L.SVG.Tile = L.SVG.extend({
    initialize: function(tileCoord, tileSize, options) {
      L.SVG.prototype.initialize.call(this, options);
      this._tileCoord = tileCoord;
      this._size = tileSize;
      this._initContainer();
      this._container.setAttribute("width", this._size.x);
      this._container.setAttribute("height", this._size.y);
      this._container.setAttribute("viewBox", [0, 0, this._size.x, this._size.y].join(" "));
      this._layers = {};
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    onAdd: L.Util.falseFn,
    addTo: function(map) {
      this._map = map;
      if (this.options.interactive) {
        for (var i in this._layers) {
          var layer2 = this._layers[i];
          layer2._path.style.pointerEvents = "auto";
          this._map._targets[L.stamp(layer2._path)] = layer2;
        }
      }
    },
    removeFrom: function(map) {
      if (this.options.interactive) {
        for (var i in this._layers) {
          var layer2 = this._layers[i];
          delete this._map._targets[L.stamp(layer2._path)];
        }
      }
      delete this._map;
    },
    _initContainer: function() {
      L.SVG.prototype._initContainer.call(this);
      L.SVG.create("rect");
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _addPath: function(layer2) {
      this._rootGroup.appendChild(layer2._path);
      this._layers[L.stamp(layer2)] = layer2;
    },
    _updateIcon: function(layer2) {
      var path2 = layer2._path = L.SVG.create("image"), icon = layer2.options.icon, options = icon.options, size = L.point(options.iconSize), anchor = options.iconAnchor || size && size.divideBy(2, true), p = layer2._point.subtract(anchor);
      path2.setAttribute("x", p.x);
      path2.setAttribute("y", p.y);
      path2.setAttribute("width", size.x + "px");
      path2.setAttribute("height", size.y + "px");
      path2.setAttribute("href", options.iconUrl);
    }
  });
  L.svg.tile = function(tileCoord, tileSize, opts) {
    return new L.SVG.Tile(tileCoord, tileSize, opts);
  };
  var Symbolizer = L.Class.extend({
    // 🍂method initialize(feature: GeoJSON, pxPerExtent: Number)
    // Initializes a new Line Symbolizer given a GeoJSON feature and the
    // pixel-to-coordinate-units ratio. Internal use only.
    // 🍂method render(renderer, style)
    // Renders this symbolizer in the given tiled renderer, with the given
    // `L.Path` options.  Internal use only.
    render: function(renderer, style2) {
      this._renderer = renderer;
      this.options = style2;
      renderer._initPath(this);
      renderer._updateStyle(this);
    },
    // 🍂method render(renderer, style)
    // Updates the `L.Path` options used to style this symbolizer, and re-renders it.
    // Internal use only.
    updateStyle: function(renderer, style2) {
      this.options = style2;
      renderer._updateStyle(this);
    },
    _getPixelBounds: function() {
      var parts = this._parts;
      var bounds = L.bounds([]);
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          bounds.extend(part[j]);
        }
      }
      var w = this._clickTolerance(), p = new L.Point(w, w);
      bounds.min._subtract(p);
      bounds.max._add(p);
      return bounds;
    },
    _clickTolerance: L.Path.prototype._clickTolerance
  });
  var PolyBase = {
    _makeFeatureParts: function(feat, pxPerExtent) {
      var rings = feat.geometry;
      var coord;
      this._parts = [];
      for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];
        var part = [];
        for (var j = 0; j < ring.length; j++) {
          coord = ring[j];
          part.push(L.point(coord).scaleBy(pxPerExtent));
        }
        this._parts.push(part);
      }
    },
    makeInteractive: function() {
      this._pxBounds = this._getPixelBounds();
    }
  };
  var PointSymbolizer = L.CircleMarker.extend({
    includes: Symbolizer.prototype,
    statics: {
      iconCache: {}
    },
    initialize: function(feature2, pxPerExtent) {
      this.properties = feature2.properties;
      this._makeFeatureParts(feature2, pxPerExtent);
    },
    render: function(renderer, style2) {
      Symbolizer.prototype.render.call(this, renderer, style2);
      this._radius = style2.radius || L.CircleMarker.prototype.options.radius;
      this._updatePath();
    },
    _makeFeatureParts: function(feat, pxPerExtent) {
      var coord = feat.geometry[0];
      if (typeof coord[0] === "object" && "x" in coord[0]) {
        this._point = L.point(coord[0]).scaleBy(pxPerExtent);
        this._empty = L.Util.falseFn;
      } else {
        this._point = L.point(coord).scaleBy(pxPerExtent);
        this._empty = L.Util.falseFn;
      }
    },
    makeInteractive: function() {
      this._updateBounds();
    },
    updateStyle: function(renderer, style2) {
      this._radius = style2.radius || this._radius;
      this._updateBounds();
      return Symbolizer.prototype.updateStyle.call(this, renderer, style2);
    },
    _updateBounds: function() {
      var icon = this.options.icon;
      if (icon) {
        var size = L.point(icon.options.iconSize), anchor = icon.options.iconAnchor || size && size.divideBy(2, true), p = this._point.subtract(anchor);
        this._pxBounds = new L.Bounds(p, p.add(icon.options.iconSize));
      } else {
        L.CircleMarker.prototype._updateBounds.call(this);
      }
    },
    _updatePath: function() {
      if (this.options.icon) {
        this._renderer._updateIcon(this);
      } else {
        L.CircleMarker.prototype._updatePath.call(this);
      }
    },
    _getImage: function() {
      if (this.options.icon) {
        var url = this.options.icon.options.iconUrl, img = PointSymbolizer.iconCache[url];
        if (!img) {
          var icon = this.options.icon;
          img = PointSymbolizer.iconCache[url] = icon.createIcon();
        }
        return img;
      } else {
        return null;
      }
    },
    _containsPoint: function(p) {
      var icon = this.options.icon;
      if (icon) {
        return this._pxBounds.contains(p);
      } else {
        return L.CircleMarker.prototype._containsPoint.call(this, p);
      }
    }
  });
  var LineSymbolizer = L.Polyline.extend({
    includes: [Symbolizer.prototype, PolyBase],
    initialize: function(feature2, pxPerExtent) {
      this.properties = feature2.properties;
      this._makeFeatureParts(feature2, pxPerExtent);
    },
    render: function(renderer, style2) {
      style2.fill = false;
      Symbolizer.prototype.render.call(this, renderer, style2);
      this._updatePath();
    },
    updateStyle: function(renderer, style2) {
      style2.fill = false;
      Symbolizer.prototype.updateStyle.call(this, renderer, style2);
    }
  });
  var FillSymbolizer = L.Polygon.extend({
    includes: [Symbolizer.prototype, PolyBase],
    initialize: function(feature2, pxPerExtent) {
      this.properties = feature2.properties;
      this._makeFeatureParts(feature2, pxPerExtent);
    },
    render: function(renderer, style2) {
      Symbolizer.prototype.render.call(this, renderer, style2);
      this._updatePath();
    }
  });
  L.VectorGrid = L.GridLayer.extend({
    options: {
      // 🍂option rendererFactory = L.svg.tile
      // A factory method which will be used to instantiate the per-tile renderers.
      rendererFactory: L.svg.tile,
      // 🍂option vectorTileLayerStyles: Object = {}
      // A data structure holding initial symbolizer definitions for the vector features.
      vectorTileLayerStyles: {},
      // 🍂option interactive: Boolean = false
      // Whether this `VectorGrid` fires `Interactive Layer` events.
      interactive: false
      // 🍂option getFeatureId: Function = undefined
      // A function that, given a vector feature, returns an unique identifier for it, e.g.
      // `function(feat) { return feat.properties.uniqueIdField; }`.
      // Must be defined for `setFeatureStyle` to work.
    },
    initialize: function(options) {
      L.setOptions(this, options);
      L.GridLayer.prototype.initialize.apply(this, arguments);
      if (this.options.getFeatureId) {
        this._vectorTiles = {};
        this._overriddenStyles = {};
        this.on("tileunload", function(e) {
          var key = this._tileCoordsToKey(e.coords), tile = this._vectorTiles[key];
          if (tile && this._map) {
            tile.removeFrom(this._map);
          }
          delete this._vectorTiles[key];
        }, this);
      }
      this._dataLayerNames = {};
    },
    createTile: function(coords, done) {
      var storeFeatures = this.options.getFeatureId;
      var tileSize = this.getTileSize();
      var renderer = this.options.rendererFactory(coords, tileSize, this.options);
      var vectorTilePromise = this._getVectorTilePromise(coords);
      if (storeFeatures) {
        this._vectorTiles[this._tileCoordsToKey(coords)] = renderer;
        renderer._features = {};
      }
      vectorTilePromise.then((function renderTile(vectorTile) {
        for (var layerName in vectorTile.layers) {
          this._dataLayerNames[layerName] = true;
          var layer2 = vectorTile.layers[layerName];
          var pxPerExtent = this.getTileSize().divideBy(layer2.extent);
          var layerStyle = this.options.vectorTileLayerStyles[layerName] || L.Path.prototype.options;
          for (var i = 0; i < layer2.features.length; i++) {
            var feat = layer2.features[i];
            var id;
            var styleOptions = layerStyle;
            if (storeFeatures) {
              id = this.options.getFeatureId(feat);
              var styleOverride = this._overriddenStyles[id];
              if (styleOverride) {
                if (styleOverride[layerName]) {
                  styleOptions = styleOverride[layerName];
                } else {
                  styleOptions = styleOverride;
                }
              }
            }
            if (styleOptions instanceof Function) {
              styleOptions = styleOptions(feat.properties, coords.z);
            }
            if (!(styleOptions instanceof Array)) {
              styleOptions = [styleOptions];
            }
            if (!styleOptions.length) {
              continue;
            }
            var featureLayer = this._createLayer(feat, pxPerExtent);
            for (var j = 0; j < styleOptions.length; j++) {
              var style2 = L.extend({}, L.Path.prototype.options, styleOptions[j]);
              featureLayer.render(renderer, style2);
              renderer._addPath(featureLayer);
            }
            if (this.options.interactive) {
              featureLayer.makeInteractive();
            }
            if (storeFeatures) {
              renderer._features[id] = {
                layerName,
                feature: featureLayer
              };
            }
          }
        }
        if (this._map != null) {
          renderer.addTo(this._map);
        }
        L.Util.requestAnimFrame(done.bind(coords, null, null));
      }).bind(this));
      return renderer.getContainer();
    },
    // 🍂method setFeatureStyle(id: Number, layerStyle: L.Path Options): this
    // Given the unique ID for a vector features (as per the `getFeatureId` option),
    // re-symbolizes that feature across all tiles it appears in.
    setFeatureStyle: function(id, layerStyle) {
      this._overriddenStyles[id] = layerStyle;
      for (var tileKey in this._vectorTiles) {
        var tile = this._vectorTiles[tileKey];
        var features = tile._features;
        var data = features[id];
        if (data) {
          var feat = data.feature;
          var styleOptions = layerStyle;
          if (layerStyle[data.layerName]) {
            styleOptions = layerStyle[data.layerName];
          }
          this._updateStyles(feat, tile, styleOptions);
        }
      }
      return this;
    },
    // 🍂method setFeatureStyle(id: Number): this
    // Reverts the effects of a previous `setFeatureStyle` call.
    resetFeatureStyle: function(id) {
      delete this._overriddenStyles[id];
      for (var tileKey in this._vectorTiles) {
        var tile = this._vectorTiles[tileKey];
        var features = tile._features;
        var data = features[id];
        if (data) {
          var feat = data.feature;
          var styleOptions = this.options.vectorTileLayerStyles[data.layerName] || L.Path.prototype.options;
          this._updateStyles(feat, tile, styleOptions);
        }
      }
      return this;
    },
    // 🍂method getDataLayerNames(): Array
    // Returns an array of strings, with all the known names of data layers in
    // the vector tiles displayed. Useful for introspection.
    getDataLayerNames: function() {
      return Object.keys(this._dataLayerNames);
    },
    _updateStyles: function(feat, renderer, styleOptions) {
      styleOptions = styleOptions instanceof Function ? styleOptions(feat.properties, renderer.getCoord().z) : styleOptions;
      if (!(styleOptions instanceof Array)) {
        styleOptions = [styleOptions];
      }
      for (var j = 0; j < styleOptions.length; j++) {
        var style2 = L.extend({}, L.Path.prototype.options, styleOptions[j]);
        feat.updateStyle(renderer, style2);
      }
    },
    _createLayer: function(feat, pxPerExtent, layerStyle) {
      var layer2;
      switch (feat.type) {
        case 1:
          layer2 = new PointSymbolizer(feat, pxPerExtent);
          break;
        case 2:
          layer2 = new LineSymbolizer(feat, pxPerExtent);
          break;
        case 3:
          layer2 = new FillSymbolizer(feat, pxPerExtent);
          break;
      }
      if (this.options.interactive) {
        layer2.addEventParent(this);
      }
      return layer2;
    }
  });
  L.vectorGrid = function(options) {
    return new L.VectorGrid(options);
  };
  L.VectorGrid.Protobuf = L.VectorGrid.extend({
    options: {
      // 🍂section
      // As with `L.TileLayer`, the URL template might contain a reference to
      // any option (see the example above and note the `{key}` or `token` in the URL
      // template, and the corresponding option).
      //
      // 🍂option subdomains: String = 'abc'
      // Akin to the `subdomains` option for `L.TileLayer`.
      subdomains: "abc",
      // Like L.TileLayer
      //
      // 🍂option fetchOptions: Object = {}
      // options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
      fetchOptions: {}
    },
    initialize: function(url, options) {
      this._url = url;
      L.VectorGrid.prototype.initialize.call(this, options);
    },
    // 🍂method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    setUrl: function(url, noRedraw) {
      this._url = url;
      if (!noRedraw) {
        this.redraw();
      }
      return this;
    },
    _getSubdomain: L.TileLayer.prototype._getSubdomain,
    _getVectorTilePromise: function(coords) {
      var data = {
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: coords.z
        // 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
      };
      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;
        if (this.options.tms) {
          data["y"] = invertedY;
        }
        data["-y"] = invertedY;
      }
      var tileUrl = L.Util.template(this._url, L.extend(data, this.options));
      return fetch(tileUrl, this.options.fetchOptions).then(function(response) {
        if (!response.ok) {
          return { layers: [] };
        }
        return response.blob().then(function(blob) {
          var reader = new FileReader();
          return new Promise(function(resolve) {
            reader.addEventListener("loadend", function() {
              var pbf = new index2(reader.result);
              return resolve(new VectorTile(pbf));
            });
            reader.readAsArrayBuffer(blob);
          });
        });
      }).then(function(json) {
        for (var layerName in json.layers) {
          var feats = [];
          for (var i = 0; i < json.layers[layerName].length; i++) {
            var feat = json.layers[layerName].feature(i);
            feat.geometry = feat.loadGeometry();
            feats.push(feat);
          }
          json.layers[layerName].features = feats;
        }
        return json;
      });
    }
  });
  L.vectorGrid.protobuf = function(url, options) {
    return new L.VectorGrid.Protobuf(url, options);
  };
  var workerCode = __$strToBlobUri(`'use strict';

var simplify_1 = simplify$1;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify$1(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

var convert_1 = convert$1;

var simplify = simplify_1;

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert$1(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    if (feature.geometry === null) {
        // ignore features with null geometry
        return;
    }

    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings, projectedRing;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            projectedRing = project(coords[i], tolerance);
            if (type === 'Polygon') { projectedRing.outer = (i === 0); }
            rings.push(projectedRing);
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                projectedRing = project(coords[i][j], tolerance);
                projectedRing.outer = (j === 0);
                rings.push(projectedRing);
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < 0 ? 0 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) { calcRingBBox(min, max, geometry); }
    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

var tile = transformTile;
var point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) { return tile; }

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

var transform$1 = {
	tile: tile,
	point: point
};

var clip_1 = clip$1;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   ____|____/
 *     |        |
 */

function clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept
    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) { continue; } // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) { slice.push(a); }
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            outer = points.outer,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) { slice.push(a); }

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }

        // add the final slice
        newSlice(slices, slice, area, dist, outer);
    }

    return slices;
}

function newSlice(slices, slice, area, dist, outer) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;
        if (outer !== undefined) { slice.outer = outer; }

        slices.push(slice);
    }
    return [];
}

var clip$2 = clip_1;

var wrap_1 = wrap$1;

function wrap$1(features, buffer, intersectX) {
    var merged = features,
        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center
        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

var tile$1 = createTile$1;

function createTile$1(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }
        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }
        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }
        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            if (type === 3) { rewind(simplifiedRing, ring.outer); }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

function rewind(ring, clockwise) {
    var area = signedArea(ring);
    if (area < 0 === clockwise) { ring.reverse(); }
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
}

var index = geojsonvt;

var convert = convert_1;
var transform = transform$1;
var clip = clip_1;
var wrap = wrap_1;
var createTile = tile$1;     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) { console.time('preprocess data'); }

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) { this.splitTile(features, 0, 0, 0); }

    if (debug) {
        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {
    var this$1 = this;


    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this$1.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) { console.time('creation'); }

            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this$1.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this$1.stats[key] = (this$1.stats[key] || 0) + 1;
                this$1.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) { continue; }

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) { solid = z; } // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) { console.time('clipping'); }

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) { console.timeEnd('clipping'); }

        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }
        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }
        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }
        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var this$1 = this;

    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }

    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this$1.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) { return null; }

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }

    if (debug > 1) { console.time('drilling down'); }
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) { console.timeEnd('drilling down'); }

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) { dest[i] = src[i]; }
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) { return false; }

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }

    var len = feature.geometry[0].length;
    if (len !== 5) { return false; }

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }
    }

    return true;
}

var identity = function(x) {
  return x;
};

var transform$3 = function(topology) {
  if ((transform = topology.transform) == null) { return identity; }
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) { x0 = y0 = 0; }
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
    return point;
  };
};

var bbox = function(topology) {
  var bbox = topology.bbox;

  function bboxPoint(p0) {
    p1[0] = p0[0], p1[1] = p0[1], t(p1);
    if (p1[0] < x0) { x0 = p1[0]; }
    if (p1[0] > x1) { x1 = p1[0]; }
    if (p1[1] < y0) { y0 = p1[1]; }
    if (p1[1] > y1) { y1 = p1[1]; }
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  if (!bbox) {
    var t = transform$3(topology), p0, p1 = new Array(2), name,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length;
      while (++i < n) {
        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);
        if (p1[0] < x0) { x0 = p1[0]; }
        if (p1[0] > x1) { x1 = p1[0]; }
        if (p1[1] < y0) { y0 = p1[1]; }
        if (p1[1] > y1) { y1 = p1[1]; }
      }
    });

    for (name in topology.objects) {
      bboxGeometry(topology.objects[name]);
    }

    bbox = topology.bbox = [x0, y0, x1, y1];
  }

  return bbox;
};

var reverse = function(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }
};

var feature = function(topology, o) {
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); })}
      : feature$1(topology, o);
};

function feature$1(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = transform$3(topology),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) { points.pop(); }
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k].slice(), k));
    }
    if (i < 0) { reverse(points, n); }
  }

  function point(p) {
    return transformPoint(p.slice());
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }
    if (points.length < 2) { points.push(points[0].slice()); }
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) { points.push(points[0].slice()); }
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}

var stitch = function(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }
    else { p1 = arc[arc.length - 1]; }
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });

  return fragments;
};

function extractArcs(topology, object$$1, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object$$1);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });

  return arcs;
}

function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }
  return Math.abs(area); // Note: doubled area!
}

var bisect = function(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
};

var slicers = {};
var options;

onmessage = function (e) {
	if (e.data[0] === 'slice') {
		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.
		var geojson = e.data[1];
		options     = e.data[2];

		if (geojson.type && geojson.type === 'Topology') {
			for (var layerName in geojson.objects) {
				slicers[layerName] = index(
					feature(geojson, geojson.objects[layerName])
				, options);
			}
		} else {
			slicers[options.vectorTileLayerName] = index(geojson, options);
		}

	} else if (e.data[0] === 'get') {
		// Gets the vector tile for the given coordinates, sends it back as a message
		var coords = e.data[1];

		var tileLayers = {};
		for (var layerName in slicers) {
			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);

			if (slicedTileLayer) {
				var vectorTileLayer = {
					features: [],
					extent: options.extent,
					name: options.vectorTileLayerName,
					length: slicedTileLayer.features.length
				};

				for (var i in slicedTileLayer.features) {
					var feat = {
						geometry: slicedTileLayer.features[i].geometry,
						properties: slicedTileLayer.features[i].tags,
						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon
					};
					vectorTileLayer.features.push(feat);
				}
				tileLayers[layerName] = vectorTileLayer;
			}
		}
		postMessage({ layers: tileLayers, coords: coords });
	}
};
//# sourceMappingURL=slicerWebWorker.js.worker.map
`, "text/plain; charset=us-ascii");
  L.VectorGrid.Slicer = L.VectorGrid.extend({
    options: {
      // 🍂section
      // Additionally to these options, `VectorGrid.Slicer` can take in any
      // of the [`geojson-vt` options](https://github.com/mapbox/geojson-vt#options).
      // 🍂option vectorTileLayerName: String = 'sliced'
      // Vector tiles contain a set of *data layers*, and those data layers
      // contain features. Thus, the slicer creates one data layer, with
      // the name given in this option. This is important for symbolizing the data.
      vectorTileLayerName: "sliced",
      extent: 4096,
      // Default for geojson-vt
      maxZoom: 14
      // Default for geojson-vt
    },
    initialize: function(geojson, options) {
      L.VectorGrid.prototype.initialize.call(this, options);
      var options = {};
      for (var i in this.options) {
        if (i !== "rendererFactory" && i !== "vectorTileLayerStyles" && typeof this.options[i] !== "function") {
          options[i] = this.options[i];
        }
      }
      this._worker = new Worker(workerCode);
      this._worker.postMessage(["slice", geojson, options]);
    },
    _getVectorTilePromise: function(coords) {
      var _this = this;
      var p = new Promise(function waitForWorker(res) {
        _this._worker.addEventListener("message", function recv(m) {
          if (m.data.coords && m.data.coords.x === coords.x && m.data.coords.y === coords.y && m.data.coords.z === coords.z) {
            res(m.data);
            _this._worker.removeEventListener("message", recv);
          }
        });
      });
      this._worker.postMessage(["get", coords]);
      return p;
    }
  });
  L.vectorGrid.slicer = function(geojson, options) {
    return new L.VectorGrid.Slicer(geojson, options);
  };
  L.Canvas.Tile = L.Canvas.extend({
    initialize: function(tileCoord, tileSize, options) {
      L.Canvas.prototype.initialize.call(this, options);
      this._tileCoord = tileCoord;
      this._size = tileSize;
      this._initContainer();
      this._container.setAttribute("width", this._size.x);
      this._container.setAttribute("height", this._size.y);
      this._layers = {};
      this._drawnLayers = {};
      this._drawing = true;
      if (options.interactive) {
        this._container.style.pointerEvents = "auto";
      }
    },
    getCoord: function() {
      return this._tileCoord;
    },
    getContainer: function() {
      return this._container;
    },
    getOffset: function() {
      return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
    },
    onAdd: L.Util.falseFn,
    addTo: function(map) {
      this._map = map;
    },
    removeFrom: function(map) {
      delete this._map;
    },
    _onClick: function(e) {
      var point2 = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset()), layer2, clickedLayer;
      for (var id in this._layers) {
        layer2 = this._layers[id];
        if (layer2.options.interactive && layer2._containsPoint(point2) && !this._map._draggableMoved(layer2)) {
          clickedLayer = layer2;
        }
      }
      if (clickedLayer) {
        L.DomEvent.fakeStop(e);
        this._fireEvent([clickedLayer], e);
      }
    },
    _onMouseMove: function(e) {
      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
        return;
      }
      var point2 = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset());
      this._handleMouseHover(e, point2);
    },
    /// TODO: Modify _initPath to include an extra parameter, a group name
    /// to order symbolizers by z-index
    _updateIcon: function(layer2) {
      if (!this._drawing) {
        return;
      }
      var icon = layer2.options.icon, options = icon.options, size = L.point(options.iconSize), anchor = options.iconAnchor || size && size.divideBy(2, true), p = layer2._point.subtract(anchor), ctx = this._ctx, img = layer2._getImage();
      if (img.complete) {
        ctx.drawImage(img, p.x, p.y, size.x, size.y);
      } else {
        L.DomEvent.on(img, "load", function() {
          ctx.drawImage(img, p.x, p.y, size.x, size.y);
        });
      }
      this._drawnLayers[layer2._leaflet_id] = layer2;
    }
  });
  L.canvas.tile = function(tileCoord, tileSize, opts) {
    return new L.Canvas.Tile(tileCoord, tileSize, opts);
  };
})();
var leaflet_timedimension_src = { exports: {} };
var hasRequiredLeaflet_timedimension_src;
function requireLeaflet_timedimension_src() {
  if (hasRequiredLeaflet_timedimension_src) return leaflet_timedimension_src.exports;
  hasRequiredLeaflet_timedimension_src = 1;
  (function(module, exports) {
    (function(factory, window2) {
      {
        module.exports = factory(L$1, require$$1);
      }
    })(function(L2, iso8601) {
      if (typeof nezasa === "undefined") {
        var nezasa = { iso8601 };
      }
      L2.TimeDimension = (L2.Layer || L2.Class).extend({
        includes: L2.Evented || L2.Mixin.Events,
        initialize: function(options) {
          L2.setOptions(this, options);
          this._availableTimes = this._generateAvailableTimes();
          this._currentTimeIndex = -1;
          this._loadingTimeIndex = -1;
          this._loadingTimeout = this.options.loadingTimeout || 3e3;
          this._syncedLayers = [];
          if (this._availableTimes.length > 0) {
            this.setCurrentTime(this.options.currentTime || this._getDefaultCurrentTime());
          }
          if (this.options.lowerLimitTime) {
            this.setLowerLimit(this.options.lowerLimitTime);
          }
          if (this.options.upperLimitTime) {
            this.setUpperLimit(this.options.upperLimitTime);
          }
        },
        getAvailableTimes: function() {
          return this._availableTimes;
        },
        getCurrentTimeIndex: function() {
          if (this._currentTimeIndex === -1) {
            return this._availableTimes.length - 1;
          }
          return this._currentTimeIndex;
        },
        getCurrentTime: function() {
          var index2 = -1;
          if (this._loadingTimeIndex !== -1) {
            index2 = this._loadingTimeIndex;
          } else {
            index2 = this.getCurrentTimeIndex();
          }
          if (index2 >= 0) {
            return this._availableTimes[index2];
          } else {
            return null;
          }
        },
        isLoading: function() {
          return this._loadingTimeIndex !== -1;
        },
        setCurrentTimeIndex: function(newIndex) {
          var upperLimit = this._upperLimit || this._availableTimes.length - 1;
          var lowerLimit = this._lowerLimit || 0;
          newIndex = Math.min(Math.max(lowerLimit, newIndex), upperLimit);
          if (newIndex < 0) {
            return;
          }
          this._loadingTimeIndex = newIndex;
          var newTime = this._availableTimes[newIndex];
          if (this._checkSyncedLayersReady(this._availableTimes[this._loadingTimeIndex])) {
            this._newTimeIndexLoaded();
          } else {
            this.fire("timeloading", {
              time: newTime
            });
            setTimeout((function(index2) {
              if (index2 == this._loadingTimeIndex) {
                this._newTimeIndexLoaded();
              }
            }).bind(this, newIndex), this._loadingTimeout);
          }
        },
        _newTimeIndexLoaded: function() {
          if (this._loadingTimeIndex === -1) {
            return;
          }
          var time = this._availableTimes[this._loadingTimeIndex];
          this._currentTimeIndex = this._loadingTimeIndex;
          this.fire("timeload", {
            time
          });
          this._loadingTimeIndex = -1;
        },
        _checkSyncedLayersReady: function(time) {
          for (var i = 0, len = this._syncedLayers.length; i < len; i++) {
            if (this._syncedLayers[i].isReady) {
              if (!this._syncedLayers[i].isReady(time)) {
                return false;
              }
            }
          }
          return true;
        },
        setCurrentTime: function(time) {
          var newIndex = this._seekNearestTimeIndex(time);
          this.setCurrentTimeIndex(newIndex);
        },
        seekNearestTime: function(time) {
          var index2 = this._seekNearestTimeIndex(time);
          return this._availableTimes[index2];
        },
        nextTime: function(numSteps, loop) {
          if (!numSteps) {
            numSteps = 1;
          }
          var newIndex = this._currentTimeIndex;
          var upperLimit = this._upperLimit || this._availableTimes.length - 1;
          var lowerLimit = this._lowerLimit || 0;
          if (this._loadingTimeIndex > -1) {
            newIndex = this._loadingTimeIndex;
          }
          newIndex = newIndex + numSteps;
          if (newIndex > upperLimit) {
            if (!!loop) {
              newIndex = lowerLimit;
            } else {
              newIndex = upperLimit;
            }
          }
          if (newIndex < lowerLimit) {
            if (!!loop) {
              newIndex = upperLimit;
            } else {
              newIndex = lowerLimit;
            }
          }
          this.setCurrentTimeIndex(newIndex);
        },
        prepareNextTimes: function(numSteps, howmany, loop) {
          if (!numSteps) {
            numSteps = 1;
          }
          var newIndex = this._currentTimeIndex;
          var currentIndex = newIndex;
          if (this._loadingTimeIndex > -1) {
            newIndex = this._loadingTimeIndex;
          }
          for (var i = 0, len = this._syncedLayers.length; i < len; i++) {
            if (this._syncedLayers[i].setMinimumForwardCache) {
              this._syncedLayers[i].setMinimumForwardCache(howmany);
            }
          }
          var count = howmany;
          var upperLimit = this._upperLimit || this._availableTimes.length - 1;
          var lowerLimit = this._lowerLimit || 0;
          while (count > 0) {
            newIndex = newIndex + numSteps;
            if (newIndex > upperLimit) {
              if (!!loop) {
                newIndex = lowerLimit;
              } else {
                break;
              }
            }
            if (newIndex < lowerLimit) {
              if (!!loop) {
                newIndex = upperLimit;
              } else {
                break;
              }
            }
            if (currentIndex === newIndex) {
              break;
            }
            this.fire("timeloading", {
              time: this._availableTimes[newIndex]
            });
            count--;
          }
        },
        getNumberNextTimesReady: function(numSteps, howmany, loop) {
          if (!numSteps) {
            numSteps = 1;
          }
          var newIndex = this._currentTimeIndex;
          if (this._loadingTimeIndex > -1) {
            newIndex = this._loadingTimeIndex;
          }
          var count = howmany;
          var ready = 0;
          var upperLimit = this._upperLimit || this._availableTimes.length - 1;
          var lowerLimit = this._lowerLimit || 0;
          while (count > 0) {
            newIndex = newIndex + numSteps;
            if (newIndex > upperLimit) {
              if (!!loop) {
                newIndex = lowerLimit;
              } else {
                count = 0;
                ready = howmany;
                break;
              }
            }
            if (newIndex < lowerLimit) {
              if (!!loop) {
                newIndex = upperLimit;
              } else {
                count = 0;
                ready = howmany;
                break;
              }
            }
            var time = this._availableTimes[newIndex];
            if (this._checkSyncedLayersReady(time)) {
              ready++;
            }
            count--;
          }
          return ready;
        },
        previousTime: function(numSteps, loop) {
          this.nextTime(numSteps * -1, loop);
        },
        registerSyncedLayer: function(layer2) {
          this._syncedLayers.push(layer2);
          layer2.on("timeload", this._onSyncedLayerLoaded, this);
        },
        unregisterSyncedLayer: function(layer2) {
          var index2 = this._syncedLayers.indexOf(layer2);
          if (index2 != -1) {
            this._syncedLayers.splice(index2, 1);
          }
          layer2.off("timeload", this._onSyncedLayerLoaded, this);
        },
        _onSyncedLayerLoaded: function(e) {
          if (e.time == this._availableTimes[this._loadingTimeIndex] && this._checkSyncedLayersReady(e.time)) {
            this._newTimeIndexLoaded();
          }
        },
        _generateAvailableTimes: function() {
          if (this.options.times) {
            return L2.TimeDimension.Util.parseTimesExpression(this.options.times);
          } else if (this.options.timeInterval) {
            var tiArray = L2.TimeDimension.Util.parseTimeInterval(this.options.timeInterval);
            var period = this.options.period || "P1D";
            var validTimeRange = this.options.validTimeRange || void 0;
            return L2.TimeDimension.Util.explodeTimeRange(tiArray[0], tiArray[1], period, validTimeRange);
          } else {
            return [];
          }
        },
        _getDefaultCurrentTime: function() {
          var index2 = this._seekNearestTimeIndex((/* @__PURE__ */ new Date()).getTime());
          return this._availableTimes[index2];
        },
        _seekNearestTimeIndex: function(time) {
          var newIndex = 0;
          var len = this._availableTimes.length;
          for (; newIndex < len; newIndex++) {
            if (time < this._availableTimes[newIndex]) {
              break;
            }
          }
          if (newIndex > 0) {
            newIndex--;
          }
          return newIndex;
        },
        setAvailableTimes: function(times, mode) {
          var currentTime = this.getCurrentTime(), lowerLimitTime = this.getLowerLimit(), upperLimitTime = this.getUpperLimit();
          if (mode == "extremes") {
            var period = this.options.period || "P1D";
            this._availableTimes = L2.TimeDimension.Util.explodeTimeRange(new Date(times[0]), new Date(times[times.length - 1]), period);
          } else {
            var parsedTimes = L2.TimeDimension.Util.parseTimesExpression(times);
            if (this._availableTimes.length === 0) {
              this._availableTimes = parsedTimes;
            } else if (mode == "intersect") {
              this._availableTimes = L2.TimeDimension.Util.intersect_arrays(parsedTimes, this._availableTimes);
            } else if (mode == "union") {
              this._availableTimes = L2.TimeDimension.Util.union_arrays(parsedTimes, this._availableTimes);
            } else if (mode == "replace") {
              this._availableTimes = parsedTimes;
            } else {
              throw "Merge available times mode not implemented: " + mode;
            }
          }
          if (lowerLimitTime) {
            this.setLowerLimit(lowerLimitTime);
          }
          if (upperLimitTime) {
            this.setUpperLimit(upperLimitTime);
          }
          this.setCurrentTime(currentTime);
          this.fire("availabletimeschanged", {
            availableTimes: this._availableTimes,
            currentTime
          });
        },
        getLowerLimit: function() {
          return this._availableTimes[this.getLowerLimitIndex()];
        },
        getUpperLimit: function() {
          return this._availableTimes[this.getUpperLimitIndex()];
        },
        setLowerLimit: function(time) {
          var index2 = this._seekNearestTimeIndex(time);
          this.setLowerLimitIndex(index2);
        },
        setUpperLimit: function(time) {
          var index2 = this._seekNearestTimeIndex(time);
          this.setUpperLimitIndex(index2);
        },
        setLowerLimitIndex: function(index2) {
          this._lowerLimit = Math.min(Math.max(index2 || 0, 0), this._upperLimit || this._availableTimes.length - 1);
          this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        setUpperLimitIndex: function(index2) {
          this._upperLimit = Math.max(Math.min(index2, this._availableTimes.length - 1), this._lowerLimit || 0);
          this.fire("limitschanged", {
            lowerLimit: this._lowerLimit,
            upperLimit: this._upperLimit
          });
        },
        getLowerLimitIndex: function() {
          return this._lowerLimit;
        },
        getUpperLimitIndex: function() {
          return this._upperLimit;
        }
      });
      L2.Map.addInitHook(function() {
        if (this.options.timeDimension) {
          this.timeDimension = L2.timeDimension(this.options.timeDimensionOptions || {});
        }
      });
      L2.timeDimension = function(options) {
        return new L2.TimeDimension(options);
      };
      L2.TimeDimension.Util = {
        getTimeDuration: function(ISODuration) {
          if (typeof nezasa === "undefined") {
            throw "iso8601-js-period library is required for Leatlet.TimeDimension: https://github.com/nezasa/iso8601-js-period";
          }
          return nezasa.iso8601.Period.parse(ISODuration, true);
        },
        addTimeDuration: function(date, duration, utc) {
          if (typeof utc === "undefined") {
            utc = true;
          }
          if (typeof duration == "string" || duration instanceof String) {
            duration = this.getTimeDuration(duration);
          }
          var l = duration.length;
          var get2 = utc ? "getUTC" : "get";
          var set2 = utc ? "setUTC" : "set";
          if (l > 0 && duration[0] != 0) {
            date[set2 + "FullYear"](date[get2 + "FullYear"]() + duration[0]);
          }
          if (l > 1 && duration[1] != 0) {
            date[set2 + "Month"](date[get2 + "Month"]() + duration[1]);
          }
          if (l > 2 && duration[2] != 0) {
            date[set2 + "Date"](date[get2 + "Date"]() + duration[2] * 7);
          }
          if (l > 3 && duration[3] != 0) {
            date[set2 + "Date"](date[get2 + "Date"]() + duration[3]);
          }
          if (l > 4 && duration[4] != 0) {
            date[set2 + "Hours"](date[get2 + "Hours"]() + duration[4]);
          }
          if (l > 5 && duration[5] != 0) {
            date[set2 + "Minutes"](date[get2 + "Minutes"]() + duration[5]);
          }
          if (l > 6 && duration[6] != 0) {
            date[set2 + "Seconds"](date[get2 + "Seconds"]() + duration[6]);
          }
        },
        subtractTimeDuration: function(date, duration, utc) {
          if (typeof duration == "string" || duration instanceof String) {
            duration = this.getTimeDuration(duration);
          }
          var subDuration = [];
          for (var i = 0, l = duration.length; i < l; i++) {
            subDuration.push(-duration[i]);
          }
          this.addTimeDuration(date, subDuration, utc);
        },
        parseAndExplodeTimeRange: function(timeRange, overwritePeriod) {
          var tr = timeRange.split("/");
          var startTime = new Date(Date.parse(tr[0]));
          var endTime = new Date(Date.parse(tr[1]));
          var period = tr.length > 2 && tr[2].length ? tr[2] : "P1D";
          if (overwritePeriod !== void 0 && overwritePeriod !== null) {
            period = overwritePeriod;
          }
          return this.explodeTimeRange(startTime, endTime, period);
        },
        explodeTimeRange: function(startTime, endTime, ISODuration, validTimeRange) {
          var duration = this.getTimeDuration(ISODuration);
          var result = [];
          var currentTime = new Date(startTime.getTime());
          var minHour = null, minMinutes = null, maxHour = null, maxMinutes = null;
          if (validTimeRange !== void 0) {
            var validTimeRangeArray = validTimeRange.split("/");
            minHour = validTimeRangeArray[0].split(":")[0];
            minMinutes = validTimeRangeArray[0].split(":")[1];
            maxHour = validTimeRangeArray[1].split(":")[0];
            maxMinutes = validTimeRangeArray[1].split(":")[1];
          }
          while (currentTime < endTime) {
            if (validTimeRange === void 0 || currentTime.getUTCHours() >= minHour && currentTime.getUTCHours() <= maxHour) {
              if ((currentTime.getUTCHours() != minHour || currentTime.getUTCMinutes() >= minMinutes) && (currentTime.getUTCHours() != maxHour || currentTime.getUTCMinutes() <= maxMinutes)) {
                result.push(currentTime.getTime());
              }
            }
            this.addTimeDuration(currentTime, duration);
          }
          if (currentTime >= endTime) {
            result.push(endTime.getTime());
          }
          return result;
        },
        parseTimeInterval: function(timeInterval) {
          var parts = timeInterval.split("/");
          if (parts.length != 2) {
            throw "Incorrect ISO9601 TimeInterval: " + timeInterval;
          }
          var startTime = Date.parse(parts[0]);
          var endTime = null;
          var duration = null;
          if (isNaN(startTime)) {
            duration = this.getTimeDuration(parts[0]);
            endTime = Date.parse(parts[1]);
            startTime = new Date(endTime);
            this.subtractTimeDuration(startTime, duration, true);
            endTime = new Date(endTime);
          } else {
            endTime = Date.parse(parts[1]);
            if (isNaN(endTime)) {
              duration = this.getTimeDuration(parts[1]);
              endTime = new Date(startTime);
              this.addTimeDuration(endTime, duration, true);
            } else {
              endTime = new Date(endTime);
            }
            startTime = new Date(startTime);
          }
          return [startTime, endTime];
        },
        parseTimesExpression: function(times, overwritePeriod) {
          var result = [];
          if (!times) {
            return result;
          }
          if (typeof times == "string" || times instanceof String) {
            var timeRanges = times.split(",");
            var timeRange;
            var timeValue;
            for (var i = 0, l = timeRanges.length; i < l; i++) {
              timeRange = timeRanges[i];
              if (timeRange.split("/").length == 3) {
                result = result.concat(this.parseAndExplodeTimeRange(timeRange, overwritePeriod));
              } else {
                timeValue = Date.parse(timeRange);
                if (!isNaN(timeValue)) {
                  result.push(timeValue);
                }
              }
            }
          } else {
            result = times;
          }
          return result.sort(function(a, b) {
            return a - b;
          });
        },
        intersect_arrays: function(arrayA, arrayB) {
          var a = arrayA.slice(0);
          var b = arrayB.slice(0);
          var result = [];
          while (a.length > 0 && b.length > 0) {
            if (a[0] < b[0]) {
              a.shift();
            } else if (a[0] > b[0]) {
              b.shift();
            } else {
              result.push(a.shift());
              b.shift();
            }
          }
          return result;
        },
        union_arrays: function(arrayA, arrayB) {
          var a = arrayA.slice(0);
          var b = arrayB.slice(0);
          var result = [];
          while (a.length > 0 && b.length > 0) {
            if (a[0] < b[0]) {
              result.push(a.shift());
            } else if (a[0] > b[0]) {
              result.push(b.shift());
            } else {
              result.push(a.shift());
              b.shift();
            }
          }
          if (a.length > 0) {
            result = result.concat(a);
          } else if (b.length > 0) {
            result = result.concat(b);
          }
          return result;
        },
        sort_and_deduplicate: function(arr) {
          arr = arr.slice(0).sort();
          var result = [];
          var last = null;
          for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i] !== last) {
              result.push(arr[i]);
              last = arr[i];
            }
          }
          return result;
        }
      };
      L2.TimeDimension.Layer = (L2.Layer || L2.Class).extend({
        includes: L2.Evented || L2.Mixin.Events,
        options: {
          opacity: 1,
          zIndex: 1
        },
        initialize: function(layer2, options) {
          L2.setOptions(this, options || {});
          this._map = null;
          this._baseLayer = layer2;
          this._currentLayer = null;
          this._timeDimension = this.options.timeDimension || null;
        },
        addTo: function(map) {
          map.addLayer(this);
          return this;
        },
        onAdd: function(map) {
          this._map = map;
          if (!this._timeDimension && map.timeDimension) {
            this._timeDimension = map.timeDimension;
          }
          this._timeDimension.on("timeloading", this._onNewTimeLoading, this);
          this._timeDimension.on("timeload", this._update, this);
          this._timeDimension.registerSyncedLayer(this);
          this._update();
        },
        onRemove: function(map) {
          this._timeDimension.unregisterSyncedLayer(this);
          this._timeDimension.off("timeloading", this._onNewTimeLoading, this);
          this._timeDimension.off("timeload", this._update, this);
          this.eachLayer(map.removeLayer, map);
          this._map = null;
        },
        eachLayer: function(method, context2) {
          method.call(context2, this._baseLayer);
          return this;
        },
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          if (this._baseLayer.setZIndex) {
            this._baseLayer.setZIndex(zIndex);
          }
          if (this._currentLayer && this._currentLayer.setZIndex) {
            this._currentLayer.setZIndex(zIndex);
          }
          return this;
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._baseLayer.setOpacity) {
            this._baseLayer.setOpacity(opacity);
          }
          if (this._currentLayer && this._currentLayer.setOpacity) {
            this._currentLayer.setOpacity(opacity);
          }
          return this;
        },
        bringToBack: function() {
          if (!this._currentLayer) {
            return;
          }
          this._currentLayer.bringToBack();
          return this;
        },
        bringToFront: function() {
          if (!this._currentLayer) {
            return;
          }
          this._currentLayer.bringToFront();
          return this;
        },
        _onNewTimeLoading: function(ev) {
          this.fire("timeload", {
            time: ev.time
          });
          return;
        },
        isReady: function(time) {
          return true;
        },
        _update: function() {
          return true;
        },
        getBaseLayer: function() {
          return this._baseLayer;
        },
        getBounds: function() {
          var bounds = new L2.LatLngBounds();
          if (this._currentLayer) {
            bounds.extend(this._currentLayer.getBounds ? this._currentLayer.getBounds() : this._currentLayer.getLatLng());
          }
          return bounds;
        }
      });
      L2.timeDimension.layer = function(layer2, options) {
        return new L2.TimeDimension.Layer(layer2, options);
      };
      L2.TimeDimension.Layer.WMS = L2.TimeDimension.Layer.extend({
        initialize: function(layer2, options) {
          L2.TimeDimension.Layer.prototype.initialize.call(this, layer2, options);
          this._timeCacheBackward = this.options.cacheBackward || this.options.cache || 0;
          this._timeCacheForward = this.options.cacheForward || this.options.cache || 0;
          this._wmsVersion = this.options.wmsVersion || this.options.version || layer2.options.version || "1.1.1";
          this._getCapabilitiesParams = this.options.getCapabilitiesParams || {};
          this._getCapabilitiesAlternateUrl = this.options.getCapabilitiesUrl || null;
          this._getCapabilitiesAlternateLayerName = this.options.getCapabilitiesLayerName || null;
          this._proxy = this.options.proxy || null;
          this._updateTimeDimension = this.options.updateTimeDimension || false;
          this._setDefaultTime = this.options.setDefaultTime || false;
          this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "intersect";
          this._period = this.options.period || null;
          this._layers = {};
          this._defaultTime = 0;
          this._availableTimes = [];
          this._capabilitiesRequested = false;
          if (this._updateTimeDimension || this.options.requestTimeFromCapabilities) {
            this._requestTimeDimensionFromCapabilities();
          }
          this._baseLayer.on("load", (function() {
            this._baseLayer.setLoaded(true);
            this.fire("timeload", {
              time: this._defaultTime
            });
          }).bind(this));
        },
        getEvents: function() {
          var clearCache = L2.bind(this._unvalidateCache, this);
          return {
            moveend: clearCache,
            zoomend: clearCache
          };
        },
        eachLayer: function(method, context2) {
          for (var prop in this._layers) {
            if (this._layers.hasOwnProperty(prop)) {
              method.call(context2, this._layers[prop]);
            }
          }
          return L2.TimeDimension.Layer.prototype.eachLayer.call(this, method, context2);
        },
        _onNewTimeLoading: function(ev) {
          var layer2 = this._getLayerForTime(ev.time);
          if (!this._map.hasLayer(layer2)) {
            this._map.addLayer(layer2);
          }
        },
        isReady: function(time) {
          var layer2 = this._getLayerForTime(time);
          if (this.options.bounds && this._map) {
            if (!this._map.getBounds().contains(this.options.bounds))
              return true;
          }
          return layer2.isLoaded();
        },
        onAdd: function(map) {
          L2.TimeDimension.Layer.prototype.onAdd.call(this, map);
          if (this._availableTimes.length == 0) {
            this._requestTimeDimensionFromCapabilities();
          } else {
            this._updateTimeDimensionAvailableTimes();
          }
        },
        _update: function() {
          if (!this._map)
            return;
          var time = this._timeDimension.getCurrentTime();
          var layer2 = this._getLayerForTime(time);
          if (this._currentLayer == null) {
            this._currentLayer = layer2;
          }
          if (!this._map.hasLayer(layer2)) {
            this._map.addLayer(layer2);
          } else {
            this._showLayer(layer2, time);
          }
        },
        setOpacity: function(opacity) {
          L2.TimeDimension.Layer.prototype.setOpacity.apply(this, arguments);
          for (var prop in this._layers) {
            if (this._layers.hasOwnProperty(prop) && this._layers[prop].setOpacity) {
              this._layers[prop].setOpacity(opacity);
            }
          }
        },
        setZIndex: function(zIndex) {
          L2.TimeDimension.Layer.prototype.setZIndex.apply(this, arguments);
          for (var prop in this._layers) {
            if (this._layers.hasOwnProperty(prop) && this._layers[prop].setZIndex) {
              this._layers[prop].setZIndex(zIndex);
            }
          }
        },
        setParams: function(params, noRedraw) {
          L2.extend(this._baseLayer.options, params);
          if (this._baseLayer.setParams) {
            this._baseLayer.setParams(params, noRedraw);
          }
          for (var prop in this._layers) {
            if (this._layers.hasOwnProperty(prop) && this._layers[prop].setParams) {
              this._layers[prop].setLoaded(false);
              this._layers[prop].setParams(params, noRedraw);
            }
          }
          return this;
        },
        _unvalidateCache: function() {
          var time = this._timeDimension.getCurrentTime();
          for (var prop in this._layers) {
            if (time != prop && this._layers.hasOwnProperty(prop)) {
              this._layers[prop].setLoaded(false);
              this._layers[prop].redraw();
            }
          }
        },
        _evictCachedTimes: function(keepforward, keepbackward) {
          var times = this._getLoadedTimes();
          var strTime = String(this._currentTime);
          var index2 = times.indexOf(strTime);
          var remove = [];
          if (keepbackward > -1) {
            var objectsToRemove = index2 - keepbackward;
            if (objectsToRemove > 0) {
              remove = times.splice(0, objectsToRemove);
              this._removeLayers(remove);
            }
          }
          if (keepforward > -1) {
            index2 = times.indexOf(strTime);
            var objectsToRemove = times.length - index2 - keepforward - 1;
            if (objectsToRemove > 0) {
              remove = times.splice(index2 + keepforward + 1, objectsToRemove);
              this._removeLayers(remove);
            }
          }
        },
        _showLayer: function(layer2, time) {
          if (this._currentLayer && this._currentLayer !== layer2) {
            this._currentLayer.hide();
          }
          layer2.show();
          if (this._currentLayer && this._currentLayer === layer2) {
            return;
          }
          this._currentLayer = layer2;
          this._currentTime = time;
          this._evictCachedTimes(this._timeCacheForward, this._timeCacheBackward);
        },
        _getLayerForTime: function(time) {
          if (time == 0 || time == this._defaultTime || time == null) {
            return this._baseLayer;
          }
          if (this._layers.hasOwnProperty(time)) {
            return this._layers[time];
          }
          var nearestTime = this._getNearestTime(time);
          if (this._layers.hasOwnProperty(nearestTime)) {
            return this._layers[nearestTime];
          }
          var newLayer = this._createLayerForTime(nearestTime);
          this._layers[time] = newLayer;
          newLayer.on("load", (function(layer2, time2) {
            layer2.setLoaded(true);
            if (!this._layers[time2]) {
              this._layers[time2] = layer2;
            }
            if (this._timeDimension && time2 == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading()) {
              this._showLayer(layer2, time2);
            }
            this.fire("timeload", {
              time: time2
            });
          }).bind(this, newLayer, time));
          newLayer.onAdd = (function(map) {
            Object.getPrototypeOf(this).onAdd.call(this, map);
            this.hide();
          }).bind(newLayer);
          return newLayer;
        },
        _createLayerForTime: function(time) {
          var wmsParams = this._baseLayer.options;
          wmsParams.time = new Date(time).toISOString();
          return new this._baseLayer.constructor(this._baseLayer.getURL(), wmsParams);
        },
        _getLoadedTimes: function() {
          var result = [];
          for (var prop in this._layers) {
            if (this._layers.hasOwnProperty(prop)) {
              result.push(prop);
            }
          }
          return result.sort(function(a, b) {
            return a - b;
          });
        },
        _removeLayers: function(times) {
          for (var i = 0, l = times.length; i < l; i++) {
            if (this._map)
              this._map.removeLayer(this._layers[times[i]]);
            delete this._layers[times[i]];
          }
        },
        setMinimumForwardCache: function(value) {
          if (value > this._timeCacheForward) {
            this._timeCacheForward = value;
          }
        },
        _requestTimeDimensionFromCapabilities: function() {
          if (this._capabilitiesRequested) {
            return;
          }
          this._capabilitiesRequested = true;
          var url = this._getCapabilitiesUrl();
          if (this._proxy) {
            url = this._proxy + "?url=" + encodeURIComponent(url);
          }
          var oReq = new XMLHttpRequest();
          oReq.addEventListener("load", (function(xhr) {
            var data = xhr.currentTarget.responseXML;
            if (data !== null) {
              this._defaultTime = Date.parse(this._getDefaultTimeFromCapabilities(data));
              this._setDefaultTime = this._setDefaultTime || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0;
              this.setAvailableTimes(this._parseTimeDimensionFromCapabilities(data));
              if (this._setDefaultTime && this._timeDimension) {
                this._timeDimension.setCurrentTime(this._defaultTime);
              }
            }
          }).bind(this));
          oReq.overrideMimeType("application/xml");
          oReq.open("GET", url);
          oReq.send();
        },
        _getCapabilitiesUrl: function() {
          var url = this._baseLayer.getURL();
          if (this._getCapabilitiesAlternateUrl)
            url = this._getCapabilitiesAlternateUrl;
          var params = L2.extend({}, this._getCapabilitiesParams, {
            "request": "GetCapabilities",
            "service": "WMS",
            "version": this._wmsVersion
          });
          url = url + L2.Util.getParamString(params, url, params.uppercase);
          return url;
        },
        _parseTimeDimensionFromCapabilities: function(xml) {
          var layers = xml.querySelectorAll('Layer[queryable="1"]');
          var layerName = this._baseLayer.wmsParams.layers;
          var layer2 = null;
          var times = null;
          layers.forEach(function(current) {
            if (current.querySelector("Name").innerHTML === layerName) {
              layer2 = current;
            }
          });
          if (layer2) {
            times = this._getTimesFromLayerCapabilities(layer2);
            if (!times) {
              times = this._getTimesFromLayerCapabilities(layer2.parentNode);
            }
          }
          return times;
        },
        _getTimesFromLayerCapabilities: function(layer2) {
          var times = null;
          var nodes = layer2.children;
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].nodeName !== "Extent" && nodes[i].nodeName !== "Dimension") continue;
            if (nodes[i].getAttribute("name") !== "time") continue;
            if (!nodes[i].textContent.length) continue;
            times = nodes[i].textContent.trim();
            break;
          }
          return times;
        },
        _getDefaultTimeFromCapabilities: function(xml) {
          var layers = xml.querySelectorAll('Layer[queryable="1"]');
          var layerName = this._baseLayer.wmsParams.layers;
          var layer2 = null;
          layers.forEach(function(current) {
            if (current.querySelector("Name").innerHTML === layerName) {
              layer2 = current;
            }
          });
          var defaultTime = 0;
          if (layer2) {
            defaultTime = this._getDefaultTimeFromLayerCapabilities(layer2);
            if (defaultTime == 0) {
              defaultTime = this._getDefaultTimeFromLayerCapabilities(layer2.parentNode);
            }
          }
          return defaultTime;
        },
        _getDefaultTimeFromLayerCapabilities: function(layer2) {
          var defaultTime = 0;
          var nodes = layer2.children;
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].nodeName !== "Extent" && nodes[i].nodeName !== "Dimension") continue;
            if (nodes[i].getAttribute("name") !== "time") continue;
            if (!nodes[i].attributes.default) continue;
            if (!nodes[i].attributes.default.textContent.length) continue;
            defaultTime = nodes[i].attributes.default.textContent.trim();
            break;
          }
          return defaultTime;
        },
        setAvailableTimes: function(times) {
          this._availableTimes = L2.TimeDimension.Util.parseTimesExpression(times, this._period);
          this._updateTimeDimensionAvailableTimes();
        },
        _updateTimeDimensionAvailableTimes: function() {
          if (this._timeDimension && this._updateTimeDimension || this._timeDimension && this._timeDimension.getAvailableTimes().length == 0) {
            this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode);
            if (this._setDefaultTime && this._defaultTime > 0) {
              this._timeDimension.setCurrentTime(this._defaultTime);
            }
          }
        },
        _getNearestTime: function(time) {
          if (this._layers.hasOwnProperty(time)) {
            return time;
          }
          if (this._availableTimes.length == 0) {
            return time;
          }
          var index2 = 0;
          var len = this._availableTimes.length;
          for (; index2 < len; index2++) {
            if (time < this._availableTimes[index2]) {
              break;
            }
          }
          if (index2 > 0) {
            index2--;
          }
          if (time != this._availableTimes[index2]) ;
          return this._availableTimes[index2];
        }
      });
      if (!L2.NonTiledLayer) {
        L2.NonTiledLayer = (L2.Layer || L2.Class).extend({});
      }
      L2.NonTiledLayer.include({
        _visible: true,
        _loaded: false,
        _originalUpdate: L2.NonTiledLayer.prototype._update,
        _originalOnRemove: L2.NonTiledLayer.prototype.onRemove,
        _update: function() {
          if (!this._visible && this._loaded) {
            return;
          }
          this._originalUpdate();
        },
        onRemove: function(map) {
          this._loaded = false;
          this._originalOnRemove(map);
        },
        setLoaded: function(loaded) {
          this._loaded = loaded;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = false;
          this._div.style.display = "none";
        },
        show: function() {
          this._visible = true;
          this._div.style.display = "block";
        },
        getURL: function() {
          return this._wmsUrl;
        }
      });
      L2.TileLayer.include({
        _visible: true,
        _loaded: false,
        _originalUpdate: L2.TileLayer.prototype._update,
        _update: function() {
          if (!this._visible && this._loaded) {
            return;
          }
          this._originalUpdate();
        },
        setLoaded: function(loaded) {
          this._loaded = loaded;
        },
        isLoaded: function() {
          return this._loaded;
        },
        hide: function() {
          this._visible = false;
          if (this._container) {
            this._container.style.display = "none";
          }
        },
        show: function() {
          this._visible = true;
          if (this._container) {
            this._container.style.display = "block";
          }
        },
        getURL: function() {
          return this._url;
        }
      });
      L2.timeDimension.layer.wms = function(layer2, options) {
        return new L2.TimeDimension.Layer.WMS(layer2, options);
      };
      L2.TimeDimension.Layer.GeoJson = L2.TimeDimension.Layer.extend({
        initialize: function(layer2, options) {
          L2.TimeDimension.Layer.prototype.initialize.call(this, layer2, options);
          this._updateTimeDimension = this.options.updateTimeDimension || false;
          this._updateTimeDimensionMode = this.options.updateTimeDimensionMode || "extremes";
          this._duration = this.options.duration || null;
          this._addlastPoint = this.options.addlastPoint || false;
          this._waitForReady = this.options.waitForReady || false;
          this._defaultTime = 0;
          this._availableTimes = [];
          this._loaded = false;
          if (this._baseLayer.getLayers().length == 0) {
            if (this._waitForReady) {
              this._baseLayer.on("ready", this._onReadyBaseLayer, this);
            } else {
              this._loaded = true;
            }
          } else {
            this._loaded = true;
            this._setAvailableTimes();
          }
          this._baseLayer.on("layeradd", (function() {
            if (this._loaded) {
              this._setAvailableTimes();
            }
          }).bind(this));
        },
        onAdd: function(map) {
          L2.TimeDimension.Layer.prototype.onAdd.call(this, map);
          if (this._loaded) {
            this._setAvailableTimes();
          }
        },
        eachLayer: function(method, context2) {
          if (this._currentLayer) {
            method.call(context2, this._currentLayer);
          }
          return L2.TimeDimension.Layer.prototype.eachLayer.call(this, method, context2);
        },
        isReady: function(time) {
          return this._loaded;
        },
        _update: function() {
          if (!this._map)
            return;
          if (!this._loaded) {
            return;
          }
          this._timeDimension.getCurrentTime();
          var maxTime = this._timeDimension.getCurrentTime(), minTime = 0;
          if (this._duration) {
            var date = new Date(maxTime);
            L2.TimeDimension.Util.subtractTimeDuration(date, this._duration, true);
            minTime = date.getTime();
          }
          var layer2 = L2.geoJson(null, this._baseLayer.options);
          var layers = this._baseLayer.getLayers();
          for (var i = 0, l = layers.length; i < l; i++) {
            var feature2 = this._getFeatureBetweenDates(layers[i].feature, minTime, maxTime);
            if (feature2) {
              layer2.addData(feature2);
              if (this._addlastPoint && feature2.geometry.type == "LineString") {
                if (feature2.geometry.coordinates.length > 0) {
                  var properties = feature2.properties;
                  properties.last = true;
                  layer2.addData({
                    type: "Feature",
                    properties,
                    geometry: {
                      type: "Point",
                      coordinates: feature2.geometry.coordinates[feature2.geometry.coordinates.length - 1]
                    }
                  });
                }
              }
            }
          }
          if (this._currentLayer) {
            this._map.removeLayer(this._currentLayer);
          }
          if (layer2.getLayers().length) {
            layer2.addTo(this._map);
            this._currentLayer = layer2;
          }
        },
        _setAvailableTimes: function() {
          var times = [];
          var layers = this._baseLayer.getLayers();
          for (var i = 0, l = layers.length; i < l; i++) {
            if (layers[i].feature) {
              var featureTimes = this._getFeatureTimes(layers[i].feature);
              for (var j = 0, m = featureTimes.length; j < m; j++) {
                times.push(featureTimes[j]);
              }
            }
          }
          this._availableTimes = L2.TimeDimension.Util.sort_and_deduplicate(times);
          if (this._timeDimension && (this._updateTimeDimension || this._timeDimension.getAvailableTimes().length == 0)) {
            this._timeDimension.setAvailableTimes(this._availableTimes, this._updateTimeDimensionMode);
          }
        },
        _getFeatureTimes: function(feature2) {
          if (!feature2.featureTimes) {
            if (!feature2.properties) {
              feature2.featureTimes = [];
            } else if (feature2.properties.hasOwnProperty("coordTimes")) {
              feature2.featureTimes = feature2.properties.coordTimes;
            } else if (feature2.properties.hasOwnProperty("times")) {
              feature2.featureTimes = feature2.properties.times;
            } else if (feature2.properties.hasOwnProperty("linestringTimestamps")) {
              feature2.featureTimes = feature2.properties.linestringTimestamps;
            } else if (feature2.properties.hasOwnProperty("time")) {
              feature2.featureTimes = [feature2.properties.time];
            } else {
              feature2.featureTimes = [];
            }
            for (var i = 0, l = feature2.featureTimes.length; i < l; i++) {
              var time = feature2.featureTimes[i];
              if (typeof time == "string" || time instanceof String) {
                time = Date.parse(time.trim());
                feature2.featureTimes[i] = time;
              }
            }
          }
          return feature2.featureTimes;
        },
        _getFeatureBetweenDates: function(feature2, minTime, maxTime) {
          var featureTimes = this._getFeatureTimes(feature2);
          if (featureTimes.length == 0) {
            return feature2;
          }
          var index_min = null, index_max = null, l = featureTimes.length;
          if (featureTimes[0] > maxTime || featureTimes[l - 1] < minTime) {
            return null;
          }
          if (featureTimes[l - 1] > minTime) {
            for (var i = 0; i < l; i++) {
              if (index_min === null && featureTimes[i] > minTime) {
                index_min = i;
              }
              if (featureTimes[i] > maxTime) {
                index_max = i;
                break;
              }
            }
          }
          if (index_min === null) {
            index_min = 0;
          }
          if (index_max === null) {
            index_max = l;
          }
          var new_coordinates = [];
          if (feature2.geometry.coordinates[0].length) {
            new_coordinates = feature2.geometry.coordinates.slice(index_min, index_max);
          } else {
            new_coordinates = feature2.geometry.coordinates;
          }
          return {
            type: "Feature",
            properties: feature2.properties,
            geometry: {
              type: feature2.geometry.type,
              coordinates: new_coordinates
            }
          };
        },
        _onReadyBaseLayer: function() {
          this._loaded = true;
          this._setAvailableTimes();
          this._update();
        }
      });
      L2.timeDimension.layer.geoJson = function(layer2, options) {
        return new L2.TimeDimension.Layer.GeoJson(layer2, options);
      };
      L2.TimeDimension.Player = (L2.Layer || L2.Class).extend({
        includes: L2.Evented || L2.Mixin.Events,
        initialize: function(options, timeDimension) {
          L2.setOptions(this, options);
          this._timeDimension = timeDimension;
          this._paused = false;
          this._buffer = this.options.buffer || 5;
          this._minBufferReady = this.options.minBufferReady || 1;
          this._waitingForBuffer = false;
          this._loop = this.options.loop || false;
          this._steps = 1;
          this._timeDimension.on("timeload", (function(data) {
            this.release();
            this._waitingForBuffer = false;
          }).bind(this));
          this.setTransitionTime(this.options.transitionTime || 1e3);
          this._timeDimension.on("limitschanged availabletimeschanged timeload", (function(data) {
            this._timeDimension.prepareNextTimes(this._steps, this._minBufferReady, this._loop);
          }).bind(this));
        },
        _tick: function() {
          var maxIndex = this._getMaxIndex();
          var maxForward = this._timeDimension.getCurrentTimeIndex() >= maxIndex && this._steps > 0;
          var maxBackward = this._timeDimension.getCurrentTimeIndex() == 0 && this._steps < 0;
          if (maxForward || maxBackward) {
            if (!this._loop) {
              this.pause();
              this.stop();
              this.fire("animationfinished");
              return;
            }
          }
          if (this._paused) {
            return;
          }
          var numberNextTimesReady = 0, buffer = this._bufferSize;
          if (this._minBufferReady > 0) {
            numberNextTimesReady = this._timeDimension.getNumberNextTimesReady(this._steps, buffer, this._loop);
            if (this._waitingForBuffer) {
              if (numberNextTimesReady < buffer) {
                this.fire("waiting", {
                  buffer,
                  available: numberNextTimesReady
                });
                return;
              } else {
                this.fire("running");
                this._waitingForBuffer = false;
              }
            } else {
              if (numberNextTimesReady < this._minBufferReady) {
                this._waitingForBuffer = true;
                this._timeDimension.prepareNextTimes(this._steps, buffer, this._loop);
                this.fire("waiting", {
                  buffer,
                  available: numberNextTimesReady
                });
                return;
              }
            }
          }
          this.pause();
          this._timeDimension.nextTime(this._steps, this._loop);
          if (buffer > 0) {
            this._timeDimension.prepareNextTimes(this._steps, buffer, this._loop);
          }
        },
        _getMaxIndex: function() {
          return Math.min(
            this._timeDimension.getAvailableTimes().length - 1,
            this._timeDimension.getUpperLimitIndex() || Infinity
          );
        },
        start: function(numSteps) {
          if (this._intervalID) return;
          this._steps = numSteps || 1;
          this._waitingForBuffer = false;
          if (this.options.startOver) {
            if (this._timeDimension.getCurrentTimeIndex() === this._getMaxIndex()) {
              this._timeDimension.setCurrentTimeIndex(this._timeDimension.getLowerLimitIndex() || 0);
            }
          }
          this.release();
          this._intervalID = window.setInterval(
            L2.bind(this._tick, this),
            this._transitionTime
          );
          this._tick();
          this.fire("play");
          this.fire("running");
        },
        stop: function() {
          if (!this._intervalID) return;
          clearInterval(this._intervalID);
          this._intervalID = null;
          this._waitingForBuffer = false;
          this.fire("stop");
        },
        pause: function() {
          this._paused = true;
        },
        release: function() {
          this._paused = false;
        },
        getTransitionTime: function() {
          return this._transitionTime;
        },
        isPlaying: function() {
          return this._intervalID ? true : false;
        },
        isWaiting: function() {
          return this._waitingForBuffer;
        },
        isLooped: function() {
          return this._loop;
        },
        setLooped: function(looped) {
          this._loop = looped;
          this.fire("loopchange", {
            loop: looped
          });
        },
        setTransitionTime: function(transitionTime) {
          this._transitionTime = transitionTime;
          if (typeof this._buffer === "function") {
            this._bufferSize = this._buffer.call(this, this._transitionTime, this._minBufferReady, this._loop);
          } else {
            this._bufferSize = this._buffer;
          }
          if (this._intervalID) {
            this.stop();
            this.start(this._steps);
          }
          this.fire("speedchange", {
            transitionTime,
            buffer: this._bufferSize
          });
        },
        getSteps: function() {
          return this._steps;
        }
      });
      L2.UI = L2.ui = L2.UI || {};
      L2.UI.Knob = L2.Draggable.extend({
        options: {
          className: "knob",
          step: 1,
          rangeMin: 0,
          rangeMax: 10
          //minValue : null,
          //maxValue : null
        },
        initialize: function(slider, options) {
          L2.setOptions(this, options);
          this._element = L2.DomUtil.create("div", this.options.className || "knob", slider);
          L2.Draggable.prototype.initialize.call(this, this._element, this._element);
          this._container = slider;
          this.on("predrag", function() {
            this._newPos.y = 0;
            this._newPos.x = this._adjustX(this._newPos.x);
          }, this);
          this.on("dragstart", function() {
            L2.DomUtil.addClass(slider, "dragging");
          });
          this.on("dragend", function() {
            L2.DomUtil.removeClass(slider, "dragging");
          });
          L2.DomEvent.on(this._element, "dblclick", function(e) {
            this.fire("dblclick", e);
          }, this);
          L2.DomEvent.disableClickPropagation(this._element);
          this.enable();
        },
        _getProjectionCoef: function() {
          return (this.options.rangeMax - this.options.rangeMin) / (this._container.offsetWidth || this._container.style.width);
        },
        _update: function() {
          this.setPosition(L2.DomUtil.getPosition(this._element).x);
        },
        _adjustX: function(x) {
          var value = this._toValue(x) || this.getMinValue();
          return this._toX(this._adjustValue(value));
        },
        _adjustValue: function(value) {
          value = Math.max(this.getMinValue(), Math.min(this.getMaxValue(), value));
          value = value - this.options.rangeMin;
          value = Math.round(value / this.options.step) * this.options.step;
          value = value + this.options.rangeMin;
          value = Math.round(value * 100) / 100;
          return value;
        },
        _toX: function(value) {
          var x = (value - this.options.rangeMin) / this._getProjectionCoef();
          return x;
        },
        _toValue: function(x) {
          var v = x * this._getProjectionCoef() + this.options.rangeMin;
          return v;
        },
        getMinValue: function() {
          return this.options.minValue || this.options.rangeMin;
        },
        getMaxValue: function() {
          return this.options.maxValue || this.options.rangeMax;
        },
        setStep: function(step) {
          this.options.step = step;
          this._update();
        },
        setPosition: function(x) {
          L2.DomUtil.setPosition(
            this._element,
            L2.point(this._adjustX(x), 0)
          );
          this.fire("positionchanged");
        },
        getPosition: function() {
          return L2.DomUtil.getPosition(this._element).x;
        },
        setValue: function(v) {
          this.setPosition(this._toX(v));
        },
        getValue: function() {
          return this._adjustValue(this._toValue(this.getPosition()));
        }
      });
      L2.Control.TimeDimension = L2.Control.extend({
        options: {
          styleNS: "leaflet-control-timecontrol",
          position: "bottomleft",
          title: "Time Control",
          backwardButton: true,
          forwardButton: true,
          playButton: true,
          playReverseButton: false,
          loopButton: false,
          displayDate: true,
          timeSlider: true,
          timeSliderDragUpdate: false,
          limitSliders: false,
          limitMinimumRange: 5,
          speedSlider: true,
          minSpeed: 0.1,
          maxSpeed: 10,
          speedStep: 0.1,
          timeSteps: 1,
          autoPlay: false,
          playerOptions: {
            transitionTime: 1e3
          },
          timeZones: ["UTC", "Local"]
        },
        initialize: function(options) {
          L2.setOptions(options);
          L2.Control.prototype.initialize.call(this, options);
          this._timeZoneIndex = 0;
          this._timeDimension = this.options.timeDimension || null;
        },
        onAdd: function(map) {
          var container;
          this._map = map;
          if (!this._timeDimension && map.timeDimension) {
            this._timeDimension = map.timeDimension;
          }
          this._initPlayer();
          container = L2.DomUtil.create("div", "leaflet-bar leaflet-bar-horizontal leaflet-bar-timecontrol");
          if (this.options.backwardButton) {
            this._buttonBackward = this._createButton("Backward", container);
          }
          if (this.options.playReverseButton) {
            this._buttonPlayReversePause = this._createButton("Play Reverse", container);
          }
          if (this.options.playButton) {
            this._buttonPlayPause = this._createButton("Play", container);
          }
          if (this.options.forwardButton) {
            this._buttonForward = this._createButton("Forward", container);
          }
          if (this.options.loopButton) {
            this._buttonLoop = this._createButton("Loop", container);
          }
          if (this.options.displayDate) {
            this._displayDate = this._createButton("Date", container);
          }
          if (this.options.timeSlider) {
            this._sliderTime = this._createSliderTime(this.options.styleNS + " timecontrol-slider timecontrol-dateslider", container);
          }
          if (this.options.speedSlider) {
            this._sliderSpeed = this._createSliderSpeed(this.options.styleNS + " timecontrol-slider timecontrol-speed", container);
          }
          this._steps = this.options.timeSteps || 1;
          this._timeDimension.on("timeload", this._update, this);
          this._timeDimension.on("timeload", this._onPlayerStateChange, this);
          this._timeDimension.on("timeloading", this._onTimeLoading, this);
          this._timeDimension.on("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this);
          L2.DomEvent.disableClickPropagation(container);
          return container;
        },
        addTo: function() {
          L2.Control.prototype.addTo.apply(this, arguments);
          this._onPlayerStateChange();
          this._onTimeLimitsChanged();
          this._update();
          return this;
        },
        onRemove: function() {
          this._player.off("play stop running loopchange speedchange", this._onPlayerStateChange, this);
          this._player.off("waiting", this._onPlayerWaiting, this);
          this._timeDimension.off("timeload", this._update, this);
          this._timeDimension.off("timeload", this._onPlayerStateChange, this);
          this._timeDimension.off("timeloading", this._onTimeLoading, this);
          this._timeDimension.off("limitschanged availabletimeschanged", this._onTimeLimitsChanged, this);
        },
        _initPlayer: function() {
          if (!this._player) {
            if (this.options.player) {
              this._player = this.options.player;
            } else {
              this._player = new L2.TimeDimension.Player(this.options.playerOptions, this._timeDimension);
            }
          }
          if (this.options.autoPlay) {
            this._player.start(this._steps);
          }
          this._player.on("play stop running loopchange speedchange", this._onPlayerStateChange, this);
          this._player.on("waiting", this._onPlayerWaiting, this);
          this._onPlayerStateChange();
        },
        _onTimeLoading: function(data) {
          if (data.time == this._timeDimension.getCurrentTime()) {
            if (this._displayDate) {
              L2.DomUtil.addClass(this._displayDate, "loading");
            }
          }
        },
        _onTimeLimitsChanged: function() {
          var lowerIndex = this._timeDimension.getLowerLimitIndex(), upperIndex = this._timeDimension.getUpperLimitIndex(), max = this._timeDimension.getAvailableTimes().length - 1;
          if (this._limitKnobs) {
            this._limitKnobs[0].options.rangeMax = max;
            this._limitKnobs[1].options.rangeMax = max;
            this._limitKnobs[0].setValue(lowerIndex || 0);
            this._limitKnobs[1].setValue(upperIndex || max);
          }
          if (this._sliderTime) {
            this._sliderTime.options.rangeMax = max;
            this._sliderTime._update();
          }
        },
        _onPlayerWaiting: function(evt) {
          if (this._buttonPlayPause && this._player.getSteps() > 0) {
            L2.DomUtil.addClass(this._buttonPlayPause, "loading");
            this._buttonPlayPause.innerHTML = this._getDisplayLoadingText(evt.available, evt.buffer);
          }
          if (this._buttonPlayReversePause && this._player.getSteps() < 0) {
            L2.DomUtil.addClass(this._buttonPlayReversePause, "loading");
            this._buttonPlayReversePause.innerHTML = this._getDisplayLoadingText(evt.available, evt.buffer);
          }
        },
        _onPlayerStateChange: function() {
          if (this._buttonPlayPause) {
            if (this._player.isPlaying() && this._player.getSteps() > 0) {
              L2.DomUtil.addClass(this._buttonPlayPause, "pause");
              L2.DomUtil.removeClass(this._buttonPlayPause, "play");
            } else {
              L2.DomUtil.removeClass(this._buttonPlayPause, "pause");
              L2.DomUtil.addClass(this._buttonPlayPause, "play");
            }
            if (this._player.isWaiting() && this._player.getSteps() > 0) {
              L2.DomUtil.addClass(this._buttonPlayPause, "loading");
            } else {
              this._buttonPlayPause.innerHTML = "";
              L2.DomUtil.removeClass(this._buttonPlayPause, "loading");
            }
          }
          if (this._buttonPlayReversePause) {
            if (this._player.isPlaying() && this._player.getSteps() < 0) {
              L2.DomUtil.addClass(this._buttonPlayReversePause, "pause");
            } else {
              L2.DomUtil.removeClass(this._buttonPlayReversePause, "pause");
            }
            if (this._player.isWaiting() && this._player.getSteps() < 0) {
              L2.DomUtil.addClass(this._buttonPlayReversePause, "loading");
            } else {
              this._buttonPlayReversePause.innerHTML = "";
              L2.DomUtil.removeClass(this._buttonPlayReversePause, "loading");
            }
          }
          if (this._buttonLoop) {
            if (this._player.isLooped()) {
              L2.DomUtil.addClass(this._buttonLoop, "looped");
            } else {
              L2.DomUtil.removeClass(this._buttonLoop, "looped");
            }
          }
          if (this._sliderSpeed && !this._draggingSpeed) {
            var speed = this._player.getTransitionTime() || 1e3;
            speed = Math.round(1e4 / speed) / 10;
            this._sliderSpeed.setValue(speed);
          }
        },
        _update: function() {
          if (!this._timeDimension) {
            return;
          }
          if (this._timeDimension.getCurrentTimeIndex() >= 0) {
            var date = new Date(this._timeDimension.getCurrentTime());
            if (this._displayDate) {
              L2.DomUtil.removeClass(this._displayDate, "loading");
              this._displayDate.innerHTML = this._getDisplayDateFormat(date);
            }
            if (this._sliderTime && !this._slidingTimeSlider) {
              this._sliderTime.setValue(this._timeDimension.getCurrentTimeIndex());
            }
          } else {
            if (this._displayDate) {
              this._displayDate.innerHTML = this._getDisplayNoTimeError();
            }
          }
        },
        _createButton: function(title, container) {
          var link = L2.DomUtil.create("a", this.options.styleNS + " timecontrol-" + title.toLowerCase(), container);
          link.href = "#";
          link.title = title;
          L2.DomEvent.addListener(link, "click", L2.DomEvent.stopPropagation).addListener(link, "click", L2.DomEvent.preventDefault).addListener(link, "click", this["_button" + title.replace(/ /i, "") + "Clicked"], this);
          return link;
        },
        _createSliderTime: function(className, container) {
          var sliderContainer, sliderbar, max, knob, limits;
          sliderContainer = L2.DomUtil.create("div", className, container);
          sliderbar = L2.DomUtil.create("div", "slider", sliderContainer);
          max = this._timeDimension.getAvailableTimes().length - 1;
          if (this.options.limitSliders) {
            limits = this._limitKnobs = this._createLimitKnobs(sliderbar);
          }
          knob = new L2.UI.Knob(sliderbar, {
            className: "knob main",
            rangeMin: 0,
            rangeMax: max
          });
          knob.on("dragend", function(e) {
            var value = e.target.getValue();
            this._sliderTimeValueChanged(value);
            this._slidingTimeSlider = false;
          }, this);
          knob.on("drag", function(e) {
            this._slidingTimeSlider = true;
            var time = this._timeDimension.getAvailableTimes()[e.target.getValue()];
            if (time) {
              var date = new Date(time);
              if (this._displayDate) {
                this._displayDate.innerHTML = this._getDisplayDateFormat(date);
              }
              if (this.options.timeSliderDragUpdate) {
                this._sliderTimeValueChanged(e.target.getValue());
              }
            }
          }, this);
          knob.on("predrag", function() {
            var minPosition, maxPosition;
            if (limits) {
              minPosition = limits[0].getPosition();
              maxPosition = limits[1].getPosition();
              if (this._newPos.x < minPosition) {
                this._newPos.x = minPosition;
              }
              if (this._newPos.x > maxPosition) {
                this._newPos.x = maxPosition;
              }
            }
          }, knob);
          L2.DomEvent.on(sliderbar, "click", function(e) {
            if (L2.DomUtil.hasClass(e.target, "knob")) {
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, x = L2.DomEvent.getMousePosition(first, sliderbar).x;
            if (limits) {
              if (limits[0].getPosition() <= x && x <= limits[1].getPosition()) {
                knob.setPosition(x);
                this._sliderTimeValueChanged(knob.getValue());
              }
            } else {
              knob.setPosition(x);
              this._sliderTimeValueChanged(knob.getValue());
            }
          }, this);
          knob.setPosition(0);
          return knob;
        },
        _createLimitKnobs: function(sliderbar) {
          L2.DomUtil.addClass(sliderbar, "has-limits");
          var max = this._timeDimension.getAvailableTimes().length - 1;
          var rangeBar = L2.DomUtil.create("div", "range", sliderbar);
          var lknob = new L2.UI.Knob(sliderbar, {
            className: "knob lower",
            rangeMin: 0,
            rangeMax: max
          });
          var uknob = new L2.UI.Knob(sliderbar, {
            className: "knob upper",
            rangeMin: 0,
            rangeMax: max
          });
          L2.DomUtil.setPosition(rangeBar, 0);
          lknob.setPosition(0);
          uknob.setPosition(max);
          lknob.on("dragend", function(e) {
            var value = e.target.getValue();
            this._sliderLimitsValueChanged(value, uknob.getValue());
          }, this);
          uknob.on("dragend", function(e) {
            var value = e.target.getValue();
            this._sliderLimitsValueChanged(lknob.getValue(), value);
          }, this);
          lknob.on("drag positionchanged", function() {
            L2.DomUtil.setPosition(rangeBar, L2.point(lknob.getPosition(), 0));
            rangeBar.style.width = uknob.getPosition() - lknob.getPosition() + "px";
          }, this);
          uknob.on("drag positionchanged", function() {
            rangeBar.style.width = uknob.getPosition() - lknob.getPosition() + "px";
          }, this);
          uknob.on("predrag", function() {
            var lowerPosition = lknob._toX(lknob.getValue() + this.options.limitMinimumRange);
            if (uknob._newPos.x <= lowerPosition) {
              uknob._newPos.x = lowerPosition;
            }
          }, this);
          lknob.on("predrag", function() {
            var upperPosition = uknob._toX(uknob.getValue() - this.options.limitMinimumRange);
            if (lknob._newPos.x >= upperPosition) {
              lknob._newPos.x = upperPosition;
            }
          }, this);
          lknob.on("dblclick", function() {
            this._timeDimension.setLowerLimitIndex(0);
          }, this);
          uknob.on("dblclick", function() {
            this._timeDimension.setUpperLimitIndex(this._timeDimension.getAvailableTimes().length - 1);
          }, this);
          return [lknob, uknob];
        },
        _createSliderSpeed: function(className, container) {
          var sliderContainer = L2.DomUtil.create("div", className, container);
          var speedLabel = L2.DomUtil.create("span", "speed", sliderContainer);
          var sliderbar = L2.DomUtil.create("div", "slider", sliderContainer);
          var initialSpeed = Math.round(1e4 / (this._player.getTransitionTime() || 1e3)) / 10;
          speedLabel.innerHTML = this._getDisplaySpeed(initialSpeed);
          var knob = new L2.UI.Knob(sliderbar, {
            step: this.options.speedStep,
            rangeMin: this.options.minSpeed,
            rangeMax: this.options.maxSpeed
          });
          knob.on("dragend", function(e) {
            var value = e.target.getValue();
            this._draggingSpeed = false;
            speedLabel.innerHTML = this._getDisplaySpeed(value);
            this._sliderSpeedValueChanged(value);
          }, this);
          knob.on("drag", function(e) {
            this._draggingSpeed = true;
            speedLabel.innerHTML = this._getDisplaySpeed(e.target.getValue());
          }, this);
          knob.on("positionchanged", function(e) {
            speedLabel.innerHTML = this._getDisplaySpeed(e.target.getValue());
          }, this);
          L2.DomEvent.on(sliderbar, "click", function(e) {
            if (e.target === knob._element) {
              return;
            }
            var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, x = L2.DomEvent.getMousePosition(first, sliderbar).x;
            knob.setPosition(x);
            speedLabel.innerHTML = this._getDisplaySpeed(knob.getValue());
            this._sliderSpeedValueChanged(knob.getValue());
          }, this);
          return knob;
        },
        _buttonBackwardClicked: function() {
          this._timeDimension.previousTime(this._steps);
        },
        _buttonForwardClicked: function() {
          this._timeDimension.nextTime(this._steps);
        },
        _buttonLoopClicked: function() {
          this._player.setLooped(!this._player.isLooped());
        },
        _buttonPlayClicked: function() {
          if (this._player.isPlaying()) {
            this._player.stop();
          } else {
            this._player.start(this._steps);
          }
        },
        _buttonPlayReverseClicked: function() {
          if (this._player.isPlaying()) {
            this._player.stop();
          } else {
            this._player.start(this._steps * -1);
          }
        },
        _buttonDateClicked: function() {
          this._switchTimeZone();
        },
        _sliderTimeValueChanged: function(newValue) {
          this._timeDimension.setCurrentTimeIndex(newValue);
        },
        _sliderLimitsValueChanged: function(lowerLimit, upperLimit) {
          this._timeDimension.setLowerLimitIndex(lowerLimit);
          this._timeDimension.setUpperLimitIndex(upperLimit);
        },
        _sliderSpeedValueChanged: function(newValue) {
          this._player.setTransitionTime(1e3 / newValue);
        },
        _getCurrentTimeZone: function() {
          return this.options.timeZones[this._timeZoneIndex];
        },
        _switchTimeZone: function() {
          if (this._getCurrentTimeZone().toLowerCase() == "utc") {
            L2.DomUtil.removeClass(this._displayDate, "utc");
          }
          this._timeZoneIndex = (this._timeZoneIndex + 1) % this.options.timeZones.length;
          var timeZone = this._getCurrentTimeZone();
          if (timeZone.toLowerCase() == "utc") {
            L2.DomUtil.addClass(this._displayDate, "utc");
            this._displayDate.title = "UTC Time";
          } else if (timeZone.toLowerCase() == "local") {
            this._displayDate.title = "Local Time";
          } else {
            this._displayDate.title = timeZone;
          }
          this._update();
        },
        _getDisplayDateFormat: function(date) {
          var timeZone = this._getCurrentTimeZone();
          if (timeZone.toLowerCase() == "utc") {
            return date.toISOString();
          }
          if (timeZone.toLowerCase() == "local") {
            return date.toLocaleString();
          }
          return date.toLocaleString([], { timeZone, timeZoneName: "short" });
        },
        _getDisplaySpeed: function(fps) {
          return fps + "fps";
        },
        _getDisplayLoadingText: function(available, buffer) {
          return "<span>" + Math.floor(available / buffer * 100) + "%</span>";
        },
        _getDisplayNoTimeError: function() {
          return "Time not available";
        }
      });
      L2.Map.addInitHook(function() {
        if (this.options.timeDimensionControl) {
          this.timeDimensionControl = L2.control.timeDimension(this.options.timeDimensionControlOptions || {});
          this.addControl(this.timeDimensionControl);
        }
      });
      L2.control.timeDimension = function(options) {
        return new L2.Control.TimeDimension(options);
      };
      return L2.TimeDimension;
    });
  })(leaflet_timedimension_src);
  return leaflet_timedimension_src.exports;
}
requireLeaflet_timedimension_src();
(function(factory) {
  typeof define === "function" && define.amd ? define(factory) : factory();
})(function() {
  const domUtilProto = L.extend({}, L.DomUtil);
  L.extend(L.DomUtil, {
    /**
     * Resets the 3D CSS transform of `el` so it is
     * translated by `offset` pixels and optionally
     * scaled by `scale`. Does not have an effect if
     * the browser doesn't support 3D CSS transforms.
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} offset 
     * @param {Number} scale
     * @param {Number} bearing 
     * @param {L.Point} pivot 
     */
    setTransform: function(el, offset, scale2, bearing2, pivot) {
      var pos = offset || new L.Point(0, 0);
      if (!bearing2) {
        offset = pos._round();
        return domUtilProto.setTransform.apply(this, arguments);
      }
      pos = pos.rotateFrom(bearing2, pivot);
      el.style[L.DomUtil.TRANSFORM] = "translate3d(" + pos.x + "px," + pos.y + "px,0)" + (scale2 ? " scale(" + scale2 + ")" : "") + " rotate(" + bearing2 + "rad)";
    },
    /**
     * Sets the position of `el` to coordinates specified by
     * `position`, using CSS translate or top/left positioning
     * depending on the browser (used by Leaflet internally
     * to position its layers).
     * 
     * @param {HTMLElement} el 
     * @param {L.Point} point 
     * @param {Number} bearing
     * @param {L.Point} pivot 
     * @param {Number} scale 
     */
    setPosition: function(el, point2, bearing2, pivot, scale2) {
      if (!bearing2) {
        return domUtilProto.setPosition.apply(this, arguments);
      }
      el._leaflet_pos = point2;
      if (L.Browser.any3d) {
        L.DomUtil.setTransform(el, point2, scale2, bearing2, pivot);
      } else {
        el.style.left = point2.x + "px";
        el.style.top = point2.y + "px";
      }
    },
    /**
     * @constant radians = degrees × π/180°
     */
    DEG_TO_RAD: Math.PI / 180,
    /**
     * @constant degrees = radians × 180°/π
     */
    RAD_TO_DEG: 180 / Math.PI
  });
  L.Draggable.include({
    /** @TODO */
    // updateMapBearing: function(mapBearing) {
    //     this._mapBearing = mapBearing;
    // },
  });
  L.extend(L.Point.prototype, {
    /**
     * Rotate around (0,0) by applying the 2D rotation matrix:
     * 
     * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤
     * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦
     * 
     * @param theta must be given in radians.
     */
    rotate: function(theta) {
      return this.rotateFrom(theta, new L.Point(0, 0));
    },
    /**
     * Rotate around (pivot.x, pivot.y) by:
     * 
     * 1. subtract (pivot.x, pivot.y)
     * 2. rotate around (0, 0)
     * 3. add (pivot.x, pivot.y) back
     * 
     * same as `this.subtract(pivot).rotate(theta).add(pivot)`
     * 
     * @param {Number} theta 
     * @param {L.Point} pivot 
     * 
     * @returns {L.Point}
     */
    rotateFrom: function(theta, pivot) {
      if (!theta) {
        return this;
      }
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var cx = pivot.x, cy = pivot.y;
      var x = this.x - cx, y = this.y - cy;
      return new L.Point(
        x * cosTheta - y * sinTheta + cx,
        x * sinTheta + y * cosTheta + cy
      );
    }
  });
  const divOverlayProto = L.extend({}, L.DivOverlay.prototype);
  L.DivOverlay.include({
    /**
     * Update L.Popup and L.Tooltip anchor positions after
     * the map is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(divOverlayProto.getEvents.apply(this, arguments), { rotate: this._updatePosition });
    },
    /**
     * 0. update element anchor point (divOverlayProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _updatePosition: function() {
      if (!this._map) {
        return;
      }
      divOverlayProto._updatePosition.apply(this, arguments);
      if (this._map && this._map._rotate && this._zoomAnimated) {
        var anchor = this._getAnchor();
        var pos = L.DomUtil.getPosition(this._container).subtract(anchor);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));
      }
    }
  });
  const popupProto = L.extend({}, L.Popup.prototype);
  L.Popup.include({
    /**
     * 0. update element anchor point (popupProto v1.9.3)
     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)
     */
    _animateZoom: function(e) {
      popupProto._animateZoom.apply(this, arguments);
      if (this._map && this._map._rotate) {
        var anchor = this._getAnchor();
        var pos = L.DomUtil.getPosition(this._container).subtract(anchor);
        L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));
      }
    },
    /**
     * Fix for L.popup({ keepInView = true })
     * 
     * @see https://github.com/fnicollet/Leaflet/pull/21
     */
    _adjustPan: function() {
      if (!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress) {
        return;
      }
      if (this._autopanning) {
        this._autopanning = false;
        return;
      }
      var map = this._map, marginBottom = parseInt(L.DomUtil.getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);
      layerPos._add(L.DomUtil.getPosition(this._container));
      var containerPos = layerPos._add(this._map._getMapPanePos()), padding = L.point(this.options.autoPanPadding), paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding), paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }
      if (containerPos.x - dx - paddingTL.x < 0) {
        dx = containerPos.x - paddingTL.x;
      }
      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }
      if (containerPos.y - dy - paddingTL.y < 0) {
        dy = containerPos.y - paddingTL.y;
      }
      if (dx || dy) {
        if (this.options.keepInView) {
          this._autopanning = true;
        }
        map.fire("autopanstart").panBy([dx, dy]);
      }
    }
  });
  const tooltipProto = L.extend({}, L.Tooltip.prototype);
  L.Tooltip.include({
    _animateZoom: function(e) {
      if (!this._map._rotate) {
        return tooltipProto._animateZoom.apply(this, arguments);
      }
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
      pos = this._map.rotatedPointToMapPanePoint(pos);
      this._setPosition(pos);
    },
    _updatePosition: function() {
      if (!this._map._rotate) {
        return tooltipProto._updatePosition.apply(this, arguments);
      }
      var pos = this._map.latLngToLayerPoint(this._latlng);
      pos = this._map.rotatedPointToMapPanePoint(pos);
      this._setPosition(pos);
    }
  });
  L.extend({}, L.Icon.prototype);
  L.Icon.include({
    _setIconStyles: function(img, name) {
      var options = this.options;
      var sizeOption = options[name + "Size"];
      if (typeof sizeOption === "number") {
        sizeOption = [sizeOption, sizeOption];
      }
      var size = L.point(sizeOption), anchor = L.point(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
      img.className = "leaflet-marker-" + name + " " + (options.className || "");
      if (anchor) {
        img.style.marginLeft = -anchor.x + "px";
        img.style.marginTop = -anchor.y + "px";
        img.style[L.DomUtil.TRANSFORM + "Origin"] = anchor.x + "px " + anchor.y + "px 0px";
      }
      if (size) {
        img.style.width = size.x + "px";
        img.style.height = size.y + "px";
      }
    }
  });
  const markerProto = L.extend({}, L.Marker.prototype);
  L.Marker.mergeOptions({
    /**
     * Rotation of this marker in rad
     * 
     * @type {Number}
     */
    rotation: 0,
    /**
     * Rotate this marker when map rotates
     * 
     * @type {Boolean}
     */
    rotateWithView: false,
    /**
     * Scale of the marker icon
     * 
     * @type {Number}
     */
    scale: void 0
  });
  var markerDragProto;
  var MarkerDrag = {
    // _onDragStart: function() {
    //     if (!this._marker._map._rotate) {
    //         return markerDragProto._onDragStart.apply(this, arguments);
    //     }
    //     this._draggable.updateMapBearing(this._marker._map._bearing);
    // },
    _onDrag: function(e) {
      var marker = this._marker, rotated_marker = marker.options.rotation || marker.options.rotateWithView, shadow = marker._shadow, iconPos = L.DomUtil.getPosition(marker._icon);
      if (!rotated_marker && shadow) {
        L.DomUtil.setPosition(shadow, iconPos);
      }
      if (marker._map._rotate) {
        iconPos = marker._map.mapPanePointToRotatedPoint(iconPos);
      }
      var latlng = marker._map.layerPointToLatLng(iconPos);
      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng;
      if (rotated_marker) marker.setLatLng(latlng);
      else marker.fire("move", e);
      marker.fire("drag", e);
    },
    _onDragEnd: function(e) {
      if (this._marker._map._rotate) {
        this._marker.update();
      }
      markerDragProto._onDragEnd.apply(this, arguments);
    }
  };
  L.Marker.include({
    /**
     * Update L.Marker anchor position after the map
     * is moved by calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(markerProto.getEvents.apply(this, arguments), { rotate: this.update });
    },
    _initInteraction: function() {
      var ret = markerProto._initInteraction.apply(this, arguments);
      if (this.dragging && this.dragging.enabled() && this._map && this._map._rotate) {
        markerDragProto = markerDragProto || Object.getPrototypeOf(this.dragging);
        this.dragging.disable();
        Object.assign(this.dragging, {
          // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),
          _onDrag: MarkerDrag._onDrag.bind(this.dragging),
          _onDragEnd: MarkerDrag._onDragEnd.bind(this.dragging)
        });
        this.dragging.enable();
      }
      return ret;
    },
    _setPos: function(pos) {
      if (this._map._rotate) {
        pos = this._map.rotatedPointToMapPanePoint(pos);
      }
      var bearing2 = this.options.rotation || 0;
      if (this.options.rotateWithView) {
        bearing2 += this._map._bearing;
      }
      if (this._icon) {
        L.DomUtil.setPosition(this._icon, pos, bearing2, pos, this.options.scale);
      }
      if (this._shadow) {
        L.DomUtil.setPosition(this._shadow, pos, bearing2, pos, this.options.scale);
      }
      this._zIndex = pos.y + this.options.zIndexOffset;
      this._resetZIndex();
    },
    // _updateZIndex: function(offset) {
    //     if (!this._map._rotate) {
    //         return markerProto._updateZIndex.apply(this, arguments);
    //     }
    //     this._icon.style.zIndex = Math.round(this._zIndex + offset);
    // },
    setRotation: function(rotation) {
      this.options.rotation = rotation;
      this.update();
    }
  });
  const gridLayerProto = L.extend({}, L.GridLayer.prototype);
  L.GridLayer.include({
    /**
     * Redraw L.TileLayer bounds after the map is
     * moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      var events = gridLayerProto.getEvents.apply(this, arguments);
      if (this._map._rotate && !this.options.updateWhenIdle) {
        if (!this._onRotate) {
          this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
        }
        events.rotate = this._onRotate;
      }
      return events;
    },
    _getTiledPixelBounds: function(center2) {
      if (!this._map._rotate) {
        return gridLayerProto._getTiledPixelBounds.apply(this, arguments);
      }
      return this._map._getNewPixelBounds(center2, this._tileZoom);
    }
  });
  const rendererProto = L.extend({}, L.Renderer.prototype);
  L.Renderer.include({
    /**
     * Redraw L.Canvas and L.SVG renderer bounds after the
     * map is moved by just calling `map.setBearing(theta)`
     * 
     * @listens L.Map~rotate
     */
    getEvents: function() {
      return L.extend(rendererProto.getEvents.apply(this, arguments), { rotate: this._update });
    },
    /**
     * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     */
    onAdd: function() {
      rendererProto.onAdd.apply(this, arguments);
      if (L.version <= "1.9.3") {
        this._container.classList.add("leaflet-zoom-animated");
      }
    },
    /**
     * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)
     * 
     * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`
     * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`
     * 
     * @example
     *   map.setZoom(2);
     *   path._renderer._update();
     *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);
     * 
     * @see https://github.com/Leaflet/Leaflet/pull/8794
     * @see https://github.com/Leaflet/Leaflet/pull/8103
     * @see https://github.com/Leaflet/Leaflet/issues/7466
     * 
     * @TODO rechek this changes from leaflet@v1.9.3
     * 
     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3
     */
    _updateTransform: function(center2, zoom) {
      if (!this._map._rotate) {
        return rendererProto._updateTransform.apply(this, arguments);
      }
      var scale2 = this._map.getZoomScale(zoom, this._zoom), offset = this._map._latLngToNewLayerPoint(this._topLeft, zoom, center2);
      L.DomUtil.setTransform(this._container, offset, scale2);
    },
    // getEvents() {
    //     const events = {
    //         viewreset: this._reset,
    //         zoom: this._onZoom,
    //         moveend: this._update,
    //         zoomend: this._onZoomEnd
    //     };
    //     if (this._zoomAnimated) {
    //         events.zoomanim = this._onAnimZoom;
    //     }
    //     return events;
    // },
    // _onAnimZoom(ev) {
    //     this._updateTransform(ev.center, ev.zoom);
    // },
    // _onZoom() {
    //     this._updateTransform(this._map.getCenter(), this._map.getZoom());
    // },
    // _onZoomEnd() {
    //     for (const id in this._layers) {
    //         this._layers[id]._project();
    //     }
    // },
    // _reset() {
    //     this._update();
    //     this._updateTransform(this._center, this._zoom);
    //     for (const id in this._layers) {
    //         this._layers[id]._reset();
    //     }
    // },
    // _updatePaths() {
    //     for (const id in this._layers) {
    //         this._layers[id]._update();
    //     }
    // },
    _update: function() {
      if (!this._map._rotate) {
        return rendererProto._update.apply(this, arguments);
      }
      this._bounds = this._map._getPaddedPixelBounds(this.options.padding);
      this._topLeft = this._map.layerPointToLatLng(this._bounds.min);
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }
  });
  const mapProto = L.extend({}, L.Map.prototype);
  L.Map.mergeOptions({ rotate: false, bearing: 0 });
  L.Map.prototype._animateZoomNoDelay = function(center2, zoom, startAnim) {
    if (!this._mapPane) {
      return;
    }
    if (startAnim) {
      this._animatingZoom = true;
      this._animateToCenter = center2;
      this._animateToZoom = zoom;
      this._mapPane.classList.add("leaflet-zoom-anim");
    }
    this._onZoomTransitionEnd();
  };
  L.Map.include({
    /**
     * @param {(HTMLElement|String)} id html selector
     * @param {Object} [options={}] leaflet map options
     */
    initialize: function(id, options) {
      if (options.rotate) {
        this._rotate = true;
        this._bearing = 0;
      }
      mapProto.initialize.apply(this, arguments);
      if (this.options.rotate) {
        this.setBearing(this.options.bearing);
      }
    },
    /**
     * Given a pixel coordinate relative to the map container,
     * returns the corresponding pixel coordinate relative to
     * the [origin pixel](#map-getpixelorigin).
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    containerPointToLayerPoint: function(point2) {
      if (!this._rotate) {
        return mapProto.containerPointToLayerPoint.apply(this, arguments);
      }
      return L.point(point2).subtract(this._getMapPanePos()).rotateFrom(-this._bearing, this._getRotatePanePos()).subtract(this._getRotatePanePos());
    },
    /**
     * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
     * returns the corresponding pixel coordinate relative to the map container.
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point} transformed pixel point
     */
    layerPointToContainerPoint: function(point2) {
      if (!this._rotate) {
        return mapProto.layerPointToContainerPoint.apply(this, arguments);
      }
      return L.point(point2).add(this._getRotatePanePos()).rotateFrom(this._bearing, this._getRotatePanePos()).add(this._getMapPanePos());
    },
    /**
     * Converts a coordinate from the rotated pane reference system
     * to the reference system of the not rotated map pane.
     * 
     * (rotatePane) --> (mapPane)
     * (rotatePane) --> (norotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * @returns {L.Point}
     * 
     * @since leaflet-rotate (v0.1)
     */
    rotatedPointToMapPanePoint: function(point2) {
      return L.point(point2).rotate(this._bearing)._add(this._getRotatePanePos());
    },
    /**
     * Converts a coordinate from the not rotated map pane reference system
     * to the reference system of the rotated pane.
     * 
     * (mapPane) --> (rotatePane)
     * (norotatePane) --> (rotatePane)
     * 
     * @param {L.Point} point pixel screen coordinates
     * 
     * @since leaflet-rotate (v0.1)
     */
    mapPanePointToRotatedPoint: function(point2) {
      return L.point(point2)._subtract(this._getRotatePanePos()).rotate(-this._bearing);
    },
    // latLngToLayerPoint: function (latlng) {
    //     var projectedPoint = this.project(L.latLng(latlng))._round();
    //     return projectedPoint._subtract(this.getPixelOrigin());
    // },
    // latLngToContainerPoint: function (latlng) {
    // 	return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    // },
    /**
     * Given latlng bounds, returns the bounds in projected pixel
     * relative to the map container.
     * 
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135
     * 
     * @param {L.LatLngBounds} bounds 
     * @returns {L.Bounds}
     * 
     * @since leaflet-rotate (v0.2)
     */
    mapBoundsToContainerBounds: function(bounds) {
      if (!this._rotate && mapProto.mapBoundsToContainerBounds) {
        return mapProto.mapBoundsToContainerBounds.apply(this, arguments);
      }
      const origin = this.getPixelOrigin();
      const nw = this.layerPointToContainerPoint(this.project(bounds.getNorthWest())._subtract(origin)), ne = this.layerPointToContainerPoint(this.project(bounds.getNorthEast())._subtract(origin)), sw = this.layerPointToContainerPoint(this.project(bounds.getSouthWest())._subtract(origin)), se = this.layerPointToContainerPoint(this.project(bounds.getSouthEast())._subtract(origin));
      return L.bounds([
        L.point(Math.min(nw.x, ne.x, se.x, sw.x), Math.min(nw.y, ne.y, se.y, sw.y)),
        // [ minX, minY ]
        L.point(Math.max(nw.x, ne.x, se.x, sw.x), Math.max(nw.y, ne.y, se.y, sw.y))
        // [ maxX, maxY ]
      ]);
    },
    /**
     * Returns geographical bounds visible in the current map view
     * 
     * @TODO find out  if map bounds calculated by `L.Map::getBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     * 
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.LatLngBounds}
     */
    getBounds: function() {
      if (!this._rotate) {
        return mapProto.getBounds.apply(this, arguments);
      }
      var size = this.getSize();
      return new L.LatLngBounds([
        this.containerPointToLatLng([0, 0]),
        // topleft
        this.containerPointToLatLng([size.x, 0]),
        // topright 
        this.containerPointToLatLng([size.x, size.y]),
        // bottomright
        this.containerPointToLatLng([0, size.y])
        // bottomleft
      ]);
    },
    /**
     * Returns the bounds of the current map view in projected pixel
     * coordinates (sometimes useful in layer and overlay implementations).
     * 
     * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @returns {L.Bounds}
     */
    // getPixelBounds(center, zoom) {
    //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());
    //     const topLeftPoint = this._getTopLeftPoint(center, zoom);
    //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    // },
    /**
     * Change map rotation
     * 
     * @param {number} theta map degrees
     * @param {L.Point} rotation center offset in screen pixels to apply
     * 
     * @since leaflet-rotate (v0.1)
     */
    setBearing: function(theta, offset = L.point(0, 0)) {
      if (!L.Browser.any3d || !this._rotate) {
        return;
      }
      var bearing2 = L.Util.wrapNum(theta, [0, 360]) * L.DomUtil.DEG_TO_RAD, center2 = this._getPixelCenter().add(L.point(offset)), oldPos = this._getRotatePanePos().rotateFrom(-this._bearing, center2), newPos = oldPos.rotateFrom(bearing2, center2);
      L.DomUtil.setPosition(this._rotatePane, oldPos, bearing2, center2);
      this._pivot = center2;
      this._bearing = bearing2;
      this._rotatePanePos = newPos;
      this.fire("rotate");
    },
    /**
     * Get current map rotation
     * 
     * @returns {number} theta map degrees
     * 
     * @since leaflet-rotate (v0.1)
     */
    getBearing: function() {
      return this._bearing * L.DomUtil.RAD_TO_DEG;
    },
    /**
     * Creates a new [map pane](#map-pane) with the given name if it doesn't
     * exist already, then returns it. The pane is created as a child of
     * `container`, or as a child of the main map pane if not set.
     * 
     * @param {String} name leaflet pane
     * @param {HTMLElement} [container] parent element
     * @returns {HTMLElement} pane container
     */
    // createPane: function(name, container) {
    //     if (!this._rotate || name == 'mapPane') {
    //         return mapProto.createPane.apply(this, arguments);
    //     }
    //     // init "rotatePane"
    //     if (!this._rotatePane) {
    //         // this._pivot = this.getSize().divideBy(2);
    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);
    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);
    //     }
    //     return mapProto.createPane.call(this, name, container || this._rotatePane);
    // },
    /**
     * Panes are DOM elements used to control the ordering of layers on
     * the map. You can access panes with [`map.getPane`](#map-getpane)
     * or [`map.getPanes`](#map-getpanes) methods. New panes can be created
     * with the [`map.createPane`](#map-createpane) method.
     * 
     * Every map has the following default panes that differ only in zIndex:
     * 
     * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes
     * - tilePane    [HTMLElement = 2]      - Pane for tile layers
     * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons
     * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)
     * - markerPane  [HTMLElement = 6]      - Pane for marker icons
     * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.
     * - popupPane   [HTMLElement = 700]    - Pane for popups.
     */
    _initPanes: function() {
      var panes = this._panes = {};
      this._paneRenderers = {};
      this._mapPane = this.createPane("mapPane", this._container);
      L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
      if (this._rotate) {
        this._rotatePane = this.createPane("rotatePane", this._mapPane);
        this._norotatePane = this.createPane("norotatePane", this._mapPane);
        this.createPane("tilePane", this._rotatePane);
        this.createPane("overlayPane", this._rotatePane);
        this.createPane("shadowPane", this._norotatePane);
        this.createPane("markerPane", this._norotatePane);
        this.createPane("tooltipPane", this._norotatePane);
        this.createPane("popupPane", this._norotatePane);
      } else {
        this.createPane("tilePane");
        this.createPane("overlayPane");
        this.createPane("shadowPane");
        this.createPane("markerPane");
        this.createPane("tooltipPane");
        this.createPane("popupPane");
      }
      if (!this.options.markerZoomAnimation) {
        L.DomUtil.addClass(panes.markerPane, "leaflet-zoom-hide");
        L.DomUtil.addClass(panes.shadowPane, "leaflet-zoom-hide");
      }
    },
    /**
     * Pans the map the minimum amount to make the `latlng` visible. Use
     * padding options to fit the display to more restricted bounds.
     * If `latlng` is already within the (optionally padded) display bounds,
     * the map will not be panned.
     * 
     * @see https://github.com/Raruto/leaflet-rotate/issues/18
     * 
     * @param {L.LatLng} latlng coordinates
     * @param {Object} [options={}] padding options
     * 
     * @returns {L.Map} current map instance
     */
    panInside(latlng, options) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {
        return mapProto.panInside.apply(this, arguments);
      }
      options = options || {};
      const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]), rect = this._container.getBoundingClientRect(), pixelPoint = this.latLngToContainerPoint(latlng), pixelBounds = L.bounds([L.point(rect), L.point(rect).add(this.getSize())]), pixelCenter = pixelBounds.getCenter(), paddedBounds = L.bounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        const centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
        const offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
        this.panTo(this.containerPointToLatLng(pixelCenter), options);
        this._enforcingBounds = false;
      }
      return this;
    },
    /**
     * Pans the map to the closest view that would lie inside the given bounds
     * (if it's not already), controlling the animation using the options specific,
     * if any.
     * 
     * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`
     *       function should match the `rotatePane` or `norotatePane` bounds
     *
     * @see https://github.com/fnicollet/Leaflet/issues/7
     * 
     * @param {L.LatLngBounds} bounds coordinates
     * @param {Object} [options] pan options
     * @returns {L.Map} current map instance
     */
    // panInsideBounds: function (bounds, options) {
    //     this._enforcingBounds = true;
    //     var center = this.getCenter(),
    //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));
    //
    //     if (!center.equals(newCenter)) {
    //         this.panTo(newCenter, options);
    //     }
    //
    //     this._enforcingBounds = false;
    //     return this;
    // },
    // adjust center for view to get inside bounds
    // _limitCenter(center, zoom, bounds) {
    //
    //     if (!bounds) { return center; }
    //
    //     const centerPoint = this.project(center, zoom),
    //         viewHalf = this.getSize().divideBy(2),
    //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
    //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);
    //
    //     // If offset is less than a pixel, ignore.
    //     // This prevents unstable projections from getting into
    //     // an infinite loop of tiny offsets.
    //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
    //             return center;
    //     }
    //
    //     return this.unproject(centerPoint.add(offset), zoom);
    // },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    // flyToBounds(bounds, options) {
    //     const target = this._getBoundsCenterZoom(bounds, options);
    //     return this.flyTo(target.center, target.zoom, options);
    // },
    // _getBoundsCenterZoom(bounds, options) {
    //
    //     options = options || {};
    //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
    //
    //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
    //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);
    //
    //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
    //
    //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;
    //
    //     if (zoom === Infinity) {
    //         return { center: bounds.getCenter(), zoom };
    //     }
    //
    //     return { center, zoom };
    //
    // },
    /**
     * Returns the maximum zoom level on which the given bounds fit to the map
     * view in its entirety. If `inside` (optional) is set to `true`, the method
     * instead returns the minimum zoom level on which the map view fits into
     * the given bounds in its entirety.
     * 
     * @param {L.LatLngBounds} bounds
     * @param {Boolean} [inside=false]
     * @param {L.Point} [padding=[0,0]]
     * 
     * @returns {Number} zoom level
     */
    getBoundsZoom(bounds, inside, padding) {
      if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {
        return mapProto.getBoundsZoom.apply(this, arguments);
      }
      bounds = L.latLngBounds(bounds);
      padding = L.point(padding || [0, 0]);
      let zoom = this.getZoom() || 0;
      const min = this.getMinZoom(), max = this.getMaxZoom(), size = this.getSize().subtract(padding), boundsSize = this.mapBoundsToContainerBounds(bounds).getSize(), snap = this.options.zoomSnap, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
      zoom = this.getScaleZoom(scale2, zoom);
      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100);
        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
      }
      return Math.max(min, Math.min(max, zoom));
    },
    /**
     * Layer point of the current center
     * 
     * @returns {L.Point} layer center
     */
    // _getCenterLayerPoint: function () {
    //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    // },
    /**
     * Offset of the specified place to the current center in pixels
     * 
     * @param {L.LatLng} latlng map coordinates
     */
    _getCenterOffset: function(latlng) {
      var centerOffset = mapProto._getCenterOffset.apply(this, arguments);
      if (this._rotate) {
        centerOffset = centerOffset.rotate(this._bearing);
      }
      return centerOffset;
    },
    /**
     * @since leaflet-rotate (v0.1)
     */
    _getRotatePanePos: function() {
      return this._rotatePanePos || new L.Point(0, 0);
    },
    // _latLngToNewLayerPoint(latlng, zoom, center) {
    //    const topLeft = this._getNewPixelOrigin(center, zoom);
    //    return this.project(latlng, zoom)._subtract(topLeft);
    //},
    _getNewPixelOrigin: function(center2, zoom) {
      if (!this._rotate) {
        return mapProto._getNewPixelOrigin.apply(this, arguments);
      }
      var viewHalf = this.getSize()._divideBy(2);
      return this.project(center2, zoom).rotate(this._bearing)._subtract(viewHalf)._add(this._getMapPanePos())._add(this._getRotatePanePos()).rotate(-this._bearing)._round();
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\tile\GridLayer::_getTiledPixelBounds()
     */
    _getNewPixelBounds: function(center2, zoom) {
      center2 = center2 || this.getCenter();
      zoom = zoom || this.getZoom();
      if (!this._rotate && mapProto._getNewPixelBounds) {
        return mapProto._getNewPixelBounds.apply(this, arguments);
      }
      var mapZoom = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(), scale2 = this.getZoomScale(mapZoom, zoom), pixelCenter = this.project(center2, zoom).floor(), size = this.getSize(), halfSize = new L.Bounds([
        this.containerPointToLayerPoint([0, 0]).floor(),
        this.containerPointToLayerPoint([size.x, 0]).floor(),
        this.containerPointToLayerPoint([0, size.y]).floor(),
        this.containerPointToLayerPoint([size.x, size.y]).floor()
      ]).getSize().divideBy(scale2 * 2);
      return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @return {L.Point} map pivot point (center)
     */
    _getPixelCenter: function() {
      if (!this._rotate && mapProto._getPixelCenter) {
        return mapProto._getPixelCenter.apply(this, arguments);
      }
      return this.getSize()._divideBy(2)._subtract(this._getMapPanePos());
    },
    /**
     * @since leaflet-rotate (v0.2)
     * 
     * @see src\layer\vector\Renderer::_update()
     */
    _getPaddedPixelBounds: function(padding) {
      if (!this._rotate && mapProto._getPaddedPixelBounds) {
        return mapProto._getPaddedPixelBounds.apply(this, arguments);
      }
      var p = padding, size = this.getSize(), padMin = size.multiplyBy(-p), padMax = size.multiplyBy(1 + p);
      return new L.Bounds([
        this.containerPointToLayerPoint([padMin.x, padMin.y]).floor(),
        this.containerPointToLayerPoint([padMin.x, padMax.y]).floor(),
        this.containerPointToLayerPoint([padMax.x, padMin.y]).floor(),
        this.containerPointToLayerPoint([padMax.x, padMax.y]).floor()
      ]);
    },
    _handleGeolocationResponse: function(pos) {
      if (!this._container._leaflet_id) {
        return;
      }
      var lat = pos.coords.latitude, lng = pos.coords.longitude, hdg = pos.coords.heading, latlng = new L.LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy), options = this._locateOptions;
      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
      }
      var data = {
        latlng,
        bounds,
        timestamp: pos.timestamp,
        /** @TODO use mapProto._handleGeolocationResponse */
        heading: hdg
      };
      for (var i in pos.coords) {
        if (typeof pos.coords[i] === "number") {
          data[i] = pos.coords[i];
        }
      }
      this.fire("locationfound", data);
    }
    /**
     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264
     * 
     * @param {L.Bounds} points 
     * @returns {L.Bounds}
     */
    // toCircumscribedBounds(points) {
    //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),
    //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),
    //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),
    //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);
    //
    //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));
    // },
  });
  L.Map.CompassBearing = L.Handler.extend({
    initialize: function(map) {
      this._map = map;
      if ("ondeviceorientationabsolute" in window) {
        this.__deviceOrientationEvent = "deviceorientationabsolute";
      } else if ("ondeviceorientation" in window) {
        this.__deviceOrientationEvent = "deviceorientation";
      }
      this._throttled = L.Util.throttle(this._onDeviceOrientation, 100, this);
    },
    addHooks: function() {
      if (this._map._rotate && this.__deviceOrientationEvent) {
        L.DomEvent.on(window, this.__deviceOrientationEvent, this._throttled, this);
      } else {
        this.disable();
      }
    },
    removeHooks: function() {
      if (this._map._rotate && this.__deviceOrientationEvent) {
        L.DomEvent.off(window, this.__deviceOrientationEvent, this._throttled, this);
      }
    },
    /**
     * `DeviceOrientationEvent.absolute` - Indicates whether the device is providing absolute
     *                                     orientation values (relatives to Magnetic North) or
     *                                     using some arbitrary frame determined by the device.
     * 
     * `DeviceOrientationEvent.alpha`    - Returns the rotation of the device around the Z axis;
     *                                     that is, the number of degrees by which the device is
     *                                     being twisted around the center of the screen.
     * 
     * `window.orientation`              - Returns the screen orientation in degrees (in 90-degree increments)
     *                                     of the viewport relative to the device's natural orientation.
     *                                     Its only possible values are -90, 0, 90, and 180. Positive
     *                                     values are counterclockwise; negative values are clockwise.
     * 
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/alpha
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation
     */
    _onDeviceOrientation: function(e) {
      var angle2 = e.webkitCompassHeading || e.alpha;
      var deviceOrientation = 0;
      if (!e.absolute && e.webkitCompassHeading) {
        angle2 = 360 - angle2;
      }
      if (!e.absolute && "undefined" !== typeof window.orientation) {
        deviceOrientation = window.orientation;
      }
      this._map.setBearing(angle2 - deviceOrientation);
    }
  });
  L.Map.addInitHook("addHandler", "compassBearing", L.Map.CompassBearing);
  L.Map.mergeOptions({
    /**
     * Whether the map uses mutation observers to
     * detect changes in its container and trigger
     * `invalidateSize`. Disabled by default due to
     * support not being available in all web browsers.
     *
     * @type {Boolean}
     * 
     * @see https://developer.mozilla.org/docs/Web/API/MutationObserver
     */
    trackContainerMutation: false
  });
  L.Map.ContainerMutation = L.Handler.extend({
    addHooks: function() {
      if (!this._observer) {
        this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map));
      }
      this._observer.observe(this._map.getContainer(), {
        childList: false,
        attributes: true,
        characterData: false,
        subtree: false,
        attributeFilter: ["style"]
      });
    },
    removeHooks: function() {
      this._observer.disconnect();
    }
  });
  L.Map.addInitHook("addHandler", "trackContainerMutation", L.Map.ContainerMutation);
  L.Map.mergeOptions({
    /**
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: true,
    /**
     * Set a minimum bearing value (rotate threshold) to
     * prevent map from rotating when user just wants to
     * zoom.  
     * 
     * @type { number | undefined }
     */
    touchRotateIntertia: 0
  });
  L.Map.TouchGestures = L.Handler.extend({
    initialize: function(map) {
      this._map = map;
      this.rotate = !!this._map.options.touchRotate;
      this.zoom = !!this._map.options.touchZoom;
    },
    addHooks: function() {
      L.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
    },
    _onTouchStart: function(e) {
      var map = this._map;
      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming || this._rotating) {
        return;
      }
      var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), vector = p1.subtract(p2);
      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);
      this._center = this._startLatLng;
      if (this.zoom) {
        if (map.options.touchZoom !== "center") {
          this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
        }
        this._startDist = p1.distanceTo(p2);
        this._startZoom = map.getZoom();
        this._zooming = true;
      } else {
        this._zooming = false;
      }
      if (this.rotate) {
        this._startTheta = Math.atan(vector.x / vector.y);
        this._startBearing = map.getBearing();
        if (vector.y < 0) {
          this._startBearing += 180;
        }
        this._rotating = true;
      } else {
        this._rotating = false;
      }
      this._moved = false;
      map._stop();
      L.DomEvent.on(document, "touchmove", this._onTouchMove, this).on(document, "touchend touchcancel", this._onTouchEnd, this);
      L.DomEvent.preventDefault(e);
    },
    _onTouchMove: function(e) {
      if (!e.touches || e.touches.length !== 2 || !(this._zooming || this._rotating)) {
        return;
      }
      var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), vector = p1.subtract(p2), scale2 = p1.distanceTo(p2) / this._startDist, delta;
      var hasZoomed;
      if (this._rotating) {
        var theta = Math.atan(vector.x / vector.y);
        var bearingDelta = (theta - this._startTheta) * L.DomUtil.RAD_TO_DEG;
        if (vector.y < 0) {
          bearingDelta += 180;
        }
        if (Math.abs(bearingDelta) > this._map.options.touchRotateInertia) {
          map.setBearing(this._startBearing - bearingDelta);
        }
      }
      if (this._zooming) {
        this._zoom = map.getScaleZoom(scale2, this._startZoom);
        if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
          this._zoom = map._limitZoom(this._zoom);
        }
        if (map.options.touchZoom === "center") {
          this._center = this._startLatLng;
          if (scale2 === 1) {
            return;
          }
        } else {
          delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
          if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
            return;
          }
          var alpha = -map.getBearing() * L.DomUtil.DEG_TO_RAD;
          this._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta.rotate(alpha)));
        }
        hasZoomed = true;
      }
      if (!this._moved) {
        map._moveStart(true, false);
        this._moved = true;
      }
      L.Util.cancelAnimFrame(this._animRequest);
      if (this._animZoomRequest) L.Util.cancelAnimFrame(this._animZoomRequest);
      var moveFn = map._move.bind(map, this._center, this._zoom, { pinch: true, round: false });
      this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);
      if (hasZoomed) {
        var zoomFn = map._animateZoomNoDelay.bind(map, this._center, this._map._limitZoom(this._zoom), true);
        this._animZoomRequest = L.Util.requestAnimFrame(zoomFn, this, true);
      } else {
        this._animZoomRequest = null;
      }
      L.DomEvent.preventDefault(e);
    },
    _onTouchEnd: function() {
      if (!this._moved || !(this._zooming || this._rotating)) {
        this._zooming = false;
        return;
      }
      this._zooming = false;
      this._rotating = false;
      L.Util.cancelAnimFrame(this._animRequest);
      L.Util.cancelAnimFrame(this._animZoomRequest);
      L.DomEvent.off(document, "touchmove", this._onTouchMove, this).off(document, "touchend touchcancel", this._onTouchEnd, this);
      if (this.zoom) {
        if (this._map.options.zoomAnimation) {
          this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
        } else {
          this._map._animateZoomNoDelay(this._center, this._map._limitZoom(this._zoom), true);
        }
      }
    }
  });
  L.Map.addInitHook("addHandler", "touchGestures", L.Map.TouchGestures);
  L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with a two-finger rotation gesture
     * 
     * @type {Boolean}
     */
    touchRotate: false
  });
  L.Map.TouchRotate = L.Handler.extend({
    addHooks: function() {
      this._map.touchGestures.enable();
      this._map.touchGestures.rotate = true;
    },
    removeHooks: function() {
      this._map.touchGestures.rotate = false;
    }
  });
  L.Map.addInitHook("addHandler", "touchRotate", L.Map.TouchRotate);
  L.Map.mergeOptions({
    /**
     * Whether the map can be rotated with shift + wheel scroll
     * @type {Boolean}
     */
    shiftKeyRotate: true
  });
  L.Map.ShiftKeyRotate = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, "wheel", this._handleShiftScroll, this);
      this._map.shiftKeyRotate.rotate = true;
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, "wheel", this._handleShiftScroll, this);
      this._map.shiftKeyRotate.rotate = false;
    },
    _handleShiftScroll: function(e) {
      if (e.shiftKey) {
        e.preventDefault();
        this._map.scrollWheelZoom.disable();
        this._map.setBearing(this._map._bearing * L.DomUtil.RAD_TO_DEG + Math.sign(e.deltaY) * 5);
      } else {
        this._map.scrollWheelZoom.enable();
      }
    }
  });
  L.Map.addInitHook("addHandler", "shiftKeyRotate", L.Map.ShiftKeyRotate);
  L.Map.addInitHook(function() {
    if (this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled()) {
      this.scrollWheelZoom.disable();
      this.scrollWheelZoom.enable();
    }
  });
  L.Map.mergeOptions({
    /**
     * Whether the map can be zoomed by touch-dragging
     * with two fingers. If passed `'center'`, it will
     * zoom to the center of the view regardless of
     * where the touch events (fingers) were. Enabled
     * for touch-capable web browsers.
     * 
     * @type {(Boolean|String)}
     */
    touchZoom: L.Browser.touch,
    /**
     * @TODO check if this is a duplicate of `L.Map.TouchGestures::bounceAtZoomLimits`
     * 
     * Set it to false if you don't want the map to
     * zoom beyond min/max zoom and then bounce back
     * when pinch-zooming.
     * 
     * @type {Boolean}
     */
    bounceAtZoomLimits: false
  });
  L.Map.TouchZoom = L.Handler.extend({
    addHooks: function() {
      this._map._handlers.forEach((handler) => {
        if (typeof handler._onTouchMove === "function") handler.disable();
      });
      L.DomUtil.addClass(this._map._container, "leaflet-touch-zoom");
      this._map.touchGestures.enable();
      this._map.touchGestures.zoom = true;
    },
    removeHooks: function() {
      L.DomUtil.removeClass(this._map._container, "leaflet-touch-zoom");
      this._map.touchGestures.zoom = false;
    }
  });
  L.Map.addInitHook("addHandler", "touchZoom", L.Map.TouchZoom);
  L.Control.Rotate = L.Control.extend({
    options: {
      position: "topleft",
      closeOnZeroBearing: true
    },
    onAdd: function(map) {
      var container = this._container = L.DomUtil.create("div", "leaflet-control-rotate leaflet-bar");
      var arrow = this._arrow = L.DomUtil.create("span", "leaflet-control-rotate-arrow");
      arrow.style.backgroundImage = `url("data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E")`;
      arrow.style.cursor = "grab";
      arrow.style.display = "block";
      arrow.style.width = "100%";
      arrow.style.height = "100%";
      arrow.style.backgroundRepeat = "no-repeat";
      arrow.style.backgroundPosition = "50%";
      var link = this._link = L.DomUtil.create("a", "leaflet-control-rotate-toggle", container);
      link.appendChild(arrow);
      link.href = "#";
      link.title = "Rotate map";
      L.DomEvent.on(link, "dblclick", L.DomEvent.stopPropagation).on(link, "mousedown", this._handleMouseDown, this).on(link, "click", L.DomEvent.stop).on(link, "click", this._cycleState, this).on(link, "click", this._refocusOnMap, this);
      if (!L.Browser.any3d) {
        L.DomUtil.addClass(link, "leaflet-disabled");
      }
      this._restyle();
      map.on("rotate", this._restyle, this);
      this._follow = false;
      this._canFollow = false;
      if (this.options.closeOnZeroBearing && map.getBearing() === 0) {
        container.style.display = "none";
      }
      return container;
    },
    onRemove: function(map) {
      map.off("rotate", this._restyle, this);
    },
    _handleMouseDown: function(e) {
      L.DomEvent.stop(e);
      this.dragging = true;
      this.dragstartX = e.pageX;
      this.dragstartY = e.pageY;
      L.DomEvent.on(document, "mousemove", this._handleMouseDrag, this).on(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseUp: function(e) {
      L.DomEvent.stop(e);
      this.dragging = false;
      L.DomEvent.off(document, "mousemove", this._handleMouseDrag, this).off(document, "mouseup", this._handleMouseUp, this);
    },
    _handleMouseDrag: function(e) {
      if (!this.dragging) {
        return;
      }
      var deltaX = e.clientX - this.dragstartX;
      this._map.setBearing(deltaX);
    },
    _cycleState: function(ev) {
      if (!this._map) {
        return;
      }
      var map = this._map;
      if (!map.touchRotate.enabled() && !map.compassBearing.enabled()) {
        map.touchRotate.enable();
      } else if (!map.compassBearing.enabled()) {
        map.touchRotate.disable();
        (DeviceOrientationEvent && DeviceOrientationEvent.requestPermission ? DeviceOrientationEvent.requestPermission() : Promise.resolve("granted")).then((state) => "granted" === state && map.compassBearing.enable());
      } else {
        map.compassBearing.disable();
        map.setBearing(0);
        if (this.options.closeOnZeroBearing) {
          map.touchRotate.enable();
        }
      }
      this._restyle();
    },
    _restyle: function() {
      if (!this._map.options.rotate) {
        L.DomUtil.addClass(this._link, "leaflet-disabled");
      } else {
        var map = this._map;
        var bearing2 = map.getBearing();
        this._arrow.style.transform = "rotate(" + bearing2 + "deg)";
        if (bearing2 && this.options.closeOnZeroBearing) {
          this._container.style.display = "block";
        }
        if (map.compassBearing.enabled()) {
          this._link.style.backgroundColor = "orange";
        } else if (map.touchRotate.enabled()) {
          this._link.style.backgroundColor = null;
        } else {
          this._link.style.backgroundColor = "grey";
          if (0 === bearing2 && this.options.closeOnZeroBearing) {
            this._container.style.display = "none";
          }
        }
      }
    }
  });
  L.control.rotate = function(options) {
    return new L.Control.Rotate(options);
  };
  L.Map.mergeOptions({
    rotateControl: true
  });
  L.Map.addInitHook(function() {
    if (this.options.rotateControl) {
      var options = typeof this.options.rotateControl === "object" ? this.options.rotateControl : {};
      this.rotateControl = L.control.rotate(options);
      this.addControl(this.rotateControl);
    }
  });
});
L$1.Map.mergeOptions({
  // Deactivate by default
  boxSelection: false,
  // If active deactivate default box zoom as it will conflict
  // boxZoom: false,
  boxSelectionKey: "shiftKey"
});
const BoxSelection = L$1.Handler.extend({
  initialize: function(map) {
    this._map = map;
    this._boxSelectionKey = map.options.boxSelectionKey;
    this._container = map._container;
    this._pane = map._panes.overlayPane;
    this._resetStateTimeout = 0;
    map.on("unload", this._destroy, this);
  },
  addHooks: function() {
    L$1.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
  },
  removeHooks: function() {
    L$1.DomEvent.off(this._container, "mousedown", this._onMouseDown, this);
  },
  moved: function() {
    return this._moved;
  },
  _destroy: function() {
    L$1.DomUtil.remove(this._pane);
    delete this._pane;
  },
  _resetState: function() {
    this._resetStateTimeout = 0;
    this._moved = false;
  },
  _clearDeferredResetState: function() {
    if (this._resetStateTimeout !== 0) {
      clearTimeout(this._resetStateTimeout);
      this._resetStateTimeout = 0;
    }
  },
  _onMouseDown: function(e) {
    if (!e[this._boxSelectionKey] || e.which !== 1 && e.button !== 1) {
      return false;
    }
    this._clearDeferredResetState();
    this._resetState();
    L$1.DomUtil.disableTextSelection();
    L$1.DomUtil.disableImageDrag();
    this._startPoint = this._map.mouseEventToContainerPoint(e);
    L$1.DomEvent.on(document, {
      contextmenu: L$1.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseMove: function(e) {
    if (!this._moved) {
      this._moved = true;
      this._box = L$1.DomUtil.create("div", "leaflet-zoom-box", this._container);
      L$1.DomUtil.addClass(this._container, "leaflet-crosshair");
      this._map.fire("boxselectionstart", Object.assign(e, { containerPoint: this._startPoint }));
    }
    this._point = this._map.mouseEventToContainerPoint(e);
    const bounds = new L$1.Bounds(this._point, this._startPoint);
    const size = bounds.getSize();
    L$1.DomUtil.setPosition(this._box, bounds.min);
    this._box.style.width = size.x + "px";
    this._box.style.height = size.y + "px";
  },
  _finish: function() {
    if (this._moved) {
      L$1.DomUtil.remove(this._box);
      L$1.DomUtil.removeClass(this._container, "leaflet-crosshair");
    }
    L$1.DomUtil.enableTextSelection();
    L$1.DomUtil.enableImageDrag();
    L$1.DomEvent.off(document, {
      contextmenu: L$1.DomEvent.stop,
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp,
      keydown: this._onKeyDown
    }, this);
  },
  _onMouseUp: function(e) {
    if (e.which !== 1 && e.button !== 1) {
      return;
    }
    this._finish();
    if (!this._moved) {
      return;
    }
    this._clearDeferredResetState();
    this._resetStateTimeout = setTimeout(L$1.Util.bind(this._resetState, this), 0);
    const bounds = new L$1.LatLngBounds(
      this._map.containerPointToLatLng(this._startPoint),
      this._map.containerPointToLatLng(this._point)
    );
    this._map.fire("boxselectionend", Object.assign(e, { bounds, containerPoint: this._map.mouseEventToContainerPoint(e) }));
  },
  _onKeyDown: function(e) {
    if (e.keyCode === 27) {
      this._finish();
      this._clearDeferredResetState();
      this._resetState();
    }
  }
});
L$1.Map.addInitHook("addHandler", "boxSelection", BoxSelection);
const WindBarbIcon = L$1.Icon.extend({
  options: {
    fillColor: "#2B85C7",
    pointRadius: 8,
    pointStroke: "#010101",
    strokeColor: "#010101",
    strokeWidth: 2,
    strokeLength: 15,
    barbSpaceing: 5,
    barbHeight: 15,
    forceDir: false
  },
  initialize: function(options) {
    options = L$1.Util.setOptions(this, options);
  },
  createIcon: function() {
    const div = document.createElement("div");
    const svg2 = this._createPoint();
    div.appendChild(svg2);
    this._setIconStyles(div);
    return div;
  },
  _createPoint: function() {
    const sc = this.options.pointStroke;
    const sw = this.options.strokeWidth;
    const r = this.options.pointRadius;
    const fc = this.options.fillColor;
    const w = 2 * sw + 2 * r;
    const h2 = w;
    const xmlns = "http://www.w3.org/2000/svg";
    const svg2 = document.createElementNS(xmlns, "svg");
    svg2.setAttributeNS(null, "width", w);
    svg2.setAttributeNS(null, "height", h2);
    const c = document.createElementNS(xmlns, "circle");
    c.setAttributeNS(null, "stroke", sc);
    c.setAttributeNS(null, "stroke-width", sw);
    c.setAttributeNS(null, "fill", fc);
    c.setAttributeNS(null, "cx", w / 2);
    c.setAttributeNS(null, "cy", h2 / 2);
    c.setAttributeNS(null, "r", r);
    svg2.appendChild(c);
    return svg2;
  },
  _createBarbs: function(speed) {
    let s = speed / 0.514;
    const b = { 5: 0, 10: 0, 50: 0 };
    const bs = this.options.barbSpaceing;
    const bh = this.options.barbHeight;
    const r = this.options.pointRadius;
    const sc = this.options.strokeColor;
    const sw = this.options.strokeWidth;
    const sl = this.options.strokeLength;
    const fd = this.options.forceDir;
    const xmlns = "http://www.w3.org/2000/svg";
    const svg2 = document.createElementNS(xmlns, "svg");
    const g = document.createElementNS(xmlns, "g");
    s = s % 5 >= 2.5 ? parseInt(s / 5) * 5 + 5 : parseInt(s / 5) * 5;
    for (let i = s; i > 0; ) {
      if (i - 50 >= 0) {
        b[50] += 1;
        i -= 50;
      } else if (i - 10 >= 0) {
        b[10] += 1;
        i -= 10;
      } else if (i - 5 >= 0) {
        b[5] += 1;
        i -= 5;
      } else {
        break;
      }
    }
    const bn = b[5] + b[10] + b[50];
    let bw;
    if (bn === 0) {
      bw = 0;
    } else {
      bw = bn * bs;
      if (b[5] === 1 && b[10] > 0 || b[5] === 1 && b[50] > 0) {
        bw -= bs;
      }
      if (b[50] > 0) {
        bw += 3 * b[50] * bs;
      }
    }
    const p = Math.round(Math.sqrt(bh * bh + bw * bw)) + 2;
    const w = r * 2 + sw * 2 + 2 * (bw + sl) + 2 * p;
    const h2 = w;
    const cx = w / 2;
    const cy = h2 / 2;
    svg2.setAttributeNS(null, "width", w);
    svg2.setAttributeNS(null, "height", h2);
    svg2.appendChild(g);
    let px, py, pt, M, H, L2, path2;
    if (fd === true) {
      px = cx - r - sw * 0.5;
      py = cy;
      M = px + "," + py;
      H = px - sl;
      pt = H - 2 * bs;
      path2 = document.createElementNS(xmlns, "path");
      path2.setAttributeNS(null, "stroke", sc);
      path2.setAttributeNS(null, "stroke-width", sw);
      path2.setAttributeNS(null, "stroke-linecap", "butt");
      path2.setAttributeNS(null, "d", "M " + M + " H " + H);
      g.appendChild(path2);
      px = H;
    }
    if (bn !== 0) {
      if (fd !== true) {
        px = cx - r - sw * 0.5;
        py = cy;
        M = px + "," + py;
        H = px - sl;
        pt = H - 2 * bs;
        path2 = document.createElementNS(xmlns, "path");
        path2.setAttributeNS(null, "stroke", sc);
        path2.setAttributeNS(null, "stroke-width", sw);
        path2.setAttributeNS(null, "stroke-linecap", "butt");
        path2.setAttributeNS(null, "d", "M " + M + " H " + H);
        g.appendChild(path2);
        px = H;
      }
      if (b[5] === 1) {
        const bl10 = Math.sqrt(2 * bs * (2 * bs) + bh * bh);
        const ang10 = Math.atan(bh / (2 * bs));
        const bl5 = bl10 / 2;
        M = px + "," + py;
        L2 = px - bl5 * Math.cos(ang10) + "," + (cy - bh * 0.5);
        path2 = document.createElementNS(xmlns, "path");
        path2.setAttributeNS(null, "stroke", sc);
        path2.setAttributeNS(null, "stroke-width", sw);
        path2.setAttributeNS(null, "stroke-linecap", "butt");
        path2.setAttributeNS(null, "d", "M " + M + " L " + L2);
        g.appendChild(path2);
        if (b[10] === 0 && b[50] === 0) {
          px -= bs;
          H = px;
          path2 = document.createElementNS(xmlns, "path");
          path2.setAttributeNS(null, "stroke", sc);
          path2.setAttributeNS(null, "stroke-width", sw);
          path2.setAttributeNS(null, "stroke-linecap", "butt");
          path2.setAttributeNS(null, "d", "M " + M + " H " + H);
          g.appendChild(path2);
        }
      }
      for (let i = 0; i < b[10]; i++) {
        M = px + "," + py;
        px -= bs;
        H = px;
        path2 = document.createElementNS(xmlns, "path");
        path2.setAttributeNS(null, "stroke", sc);
        path2.setAttributeNS(null, "stroke-width", sw);
        path2.setAttributeNS(null, "stroke-linecap", "butt");
        path2.setAttributeNS(null, "d", "M " + M + " H " + H);
        g.appendChild(path2);
        M = H + "," + cy;
        pt -= bs;
        L2 = pt + "," + (cy - bh);
        path2 = document.createElementNS(xmlns, "path");
        path2.setAttributeNS(null, "stroke", sc);
        path2.setAttributeNS(null, "stroke-width", sw);
        path2.setAttributeNS(null, "stroke-linecap", "butt");
        path2.setAttributeNS(null, "d", "M " + M + " L " + L2);
        g.appendChild(path2);
      }
      if (b[50] > 0) {
        M = px + "," + py;
        px -= bs;
        H = px;
        path2 = document.createElementNS(xmlns, "path");
        path2.setAttributeNS(null, "stroke", sc);
        path2.setAttributeNS(null, "stroke-width", sw);
        path2.setAttributeNS(null, "stroke-linecap", "butt");
        path2.setAttributeNS(null, "d", "M " + M + " H " + H);
        g.appendChild(path2);
        for (let i = 0; i < b[50]; i++) {
          pt -= bs;
          const p1 = px + "," + cy;
          const p2 = pt + "," + (cy - bh);
          const p3 = pt + "," + cy;
          path2 = document.createElementNS(xmlns, "polygon");
          path2.setAttributeNS(null, "stroke", sc);
          path2.setAttributeNS(null, "stroke-width", sw);
          path2.setAttributeNS(null, "fill", "#000000");
          path2.setAttributeNS(null, "points", p1 + " " + p2 + " " + p3);
          g.appendChild(path2);
          px -= 2 * bs;
          pt -= bs;
        }
      }
    }
    return { ax: cx, ay: cy, svg: svg2 };
  },
  _setIconStyles: function(img, name, a) {
    let anchor;
    const options = this.options;
    const size = L$1.point(options[name === "shadow" ? "shadowSize" : "iconSize"]);
    const sw = this.options.strokeWidth;
    const r = this.options.pointRadius;
    if (name === "shadow") {
      anchor = a;
      img.style.width = anchor.x + "px";
      img.style.height = anchor.y + "px";
    } else {
      img.style.position = "absolute";
      const w = 2 * sw + 2 * r;
      const h2 = w;
      const x = w / 2;
      const y = h2 / 2;
      anchor = L$1.point([x, y]);
    }
    if (!anchor && size) {
      anchor = size.divideBy(2, true);
    }
    if (anchor) {
      img.style.marginLeft = -anchor.x + "px";
      img.style.marginTop = -anchor.y + "px";
    }
    if (size) {
      img.style.width = size.x + "px";
      img.style.height = size.y + "px";
    }
  },
  createShadow: function() {
    const d = this.options.deg + 90;
    const s = this.options.speed;
    const b = this._createBarbs(s);
    const div = document.createElement("div");
    if (this.options.mirrorVel) {
      b.svg.style.transform = "rotate(" + d + "deg) scaleY(-1)";
      b.svg.style.MozTransform = "rotate(" + d + "deg) scaleY(-1)";
      b.svg.style.webkitTransform = "rotate(" + d + "deg) scaleY(-1)";
      b.svg.style.msTransform = "rotate(" + d + "deg) scaleY(-1)";
    } else {
      b.svg.style.transform = "rotate(" + d + "deg)";
      b.svg.style.MozTransform = "rotate(" + d + "deg)";
      b.svg.style.webkitTransform = "rotate(" + d + "deg)";
      b.svg.style.msTransform = "rotate(" + d + "deg)";
    }
    div.appendChild(b.svg);
    const anchor = { x: b.ax, y: b.ay };
    this._setIconStyles(div, "shadow", anchor);
    return div;
  }
});
L$1.WindBarb = {};
L$1.WindBarb.version = "0.0.5";
L$1.WindBarb.Icon = WindBarbIcon;
L$1.WindBarb.icon = function(options) {
  return new L$1.WindBarb.Icon(options);
};
const markerIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=";
const retinaIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7cua5gzeKg8hJo3grY4g7c3grU0gLI2frE0daAubJc2gbQwd6QzeKk2gLMtd5sxdKIua5g1frA2f7IydaM0e6w2fq41fK01eqo3grgubJgta5cxdKI1f7AydaQydaMxc6EubJgvbJkwcZ4ubZkwcJwubZgubJcydqUydKIxapgubJctbJcubZcubJcvbJYubJcvbZkubJctbJctbZcubJg2f7AubJcrbZcubJcubJcua5g3grY0fq8ubJcubJdEkdEwhsw6i88vhswuhcsuhMtBjMgthMsrg8srgss6is8qgcs8i9A9iMYtg8spgcoogMo7hcMngMonf8olfso4gr8kfck5iM8jfMk4iM8he8k1fro7itAgesk2hs8eecgzfLcofssdeMg0hc4cd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqhUndROmdM1fK0wcZ8vb5w0eqpQm9MzeKhXoNVcpdYydKNWn9VZotVKltJFjsIwcJ1Rms9OlslLmtH///8+kc9epdYzd6dbo9VHkMM2f7FHmNBClM8ydqVcpNY9hro3gLM9hLczealQmcw3fa46f7A8gLMxc6I3eagyc6FIldJMl9JSnNRSntNNl9JPnNJFi75UnM9ZodVKksg8kM45jc09e6ZHltFBk883gbRBh7pDk9EwcaBzn784g7dKkcY2i81Om9M7j85Llc81is09g7Q4grY/j9A0eqxKmdFFltBEjcXf6fFImdBCiLxJl9FGlNFBi78yiMxVndEvbpo6js74+vx+psPP3+o/ks5HkcpGmNCjwdZCkNDM3ehYoNJEls+lxNkxh8xHks0+jdC1zd5Lg6r+/v/H2ufz9/o3jM3t8/edvdM/k89Th61OiLBSjbZklbaTt9BfptdjmL1AicBHj8hGk9FAgK1dkLNTjLRekrdClc/k7fM0icy0y9tgp9c4jc2NtM9Dlc8zicxeXZn3AAAAQ3RSTlMAHDdTb4yPA+LtnEQmC4L2EmHqB7XA0d0sr478x4/Yd5i1zOfyPkf1sLVq4Nh3FvjxopQ2/STNuFzUwFIwxKaejILpIBEV9wAABhVJREFUeF6s1NdyFEcYBeBeoQIhRAkLlRDGrhIgY3BJL8CVeKzuyXFzzjkn5ZxzzuScg3PO8cKzu70JkO0LfxdTU//pM9vTu7Xgf6KqOVTb9X7toRrVEfBf1HTVjZccrT/2by1VV928Yty9ZbVuucdz90frG8DBjl9pVApbOstvmMuvVgaNXSfAAd6pGxpy6yxf5ph43pS/4f3uoaGm2rdu72S9xzOvMymkZFq/ptDrk90mhW7e4zl7HLzhxGWPR20xmSxJ/VqldG5m9XhaVOA1DadsNh3Pu5L2N6QtPO/32JpqQBVVk20oy/Pi2s23WEvyfHbe1thadVQttvm7Llf65gGmXK67XtupyoM7HQhmXdLS8oGWJNeOJ3C5fG5XCEJnkez3/oFdsvgJ4l2ANZwhrJKk/7OSXa+3Vw2WJMlKnGkobouYk6T0TyX30klOUnTD9HJ5qpckL3EW/w4XF3Xd0FGywXUrstrclVsqz5Pd/sXFYyDnPdrLcQODmGOK47IZb4CmibmMn+MYRzFZ5jg33ZL/EJrWcszHmANy3ARBK/IXtciJy8VsitPSdE3uuHxzougojcUdr8/32atnz/ev3f/K5wtpxUTpcaI45zusVDpYtZi+jg0oU9b3x74h7+n9ABvYEZeKaVq0sh0AtLKsFtqNBdeT0MrSzwwlq9+x6xAO4tgOtSzbCjrNQQiNvQUbUEubvzBUeGw26yDCsRHCoLkTHDa7IdOLIThs/gHvChszh2CimE8peRs47cxANI0lYNB5y1DljpOF0IhzBDPOZnDOqYYbeGKECbPzWnXludPphw5c2YBq5zlwXphIbO4VDCZ0gnPfUO1TwZoYwAs2ExPCedAu9DAjfQUjzITQb3jNj0KG2Sgt6BHaQUdYzWz+XmBktOHwanXjaSTcwwziBcuMOtwBmqPrTOxFQR/DRKKPqyur0aiW6cULYsx6tBm0jXpR/AUWR6HRq9WVW6MRhIq5jLyjbaCTDCijyYJNpCajdyobP/eTw0iexBAKkJ3gA5KcQb2zBXsIBckn+xVv8jkZSaEFHE+jFEleAEfayRU0MouNoBmB/L50Ai/HSLIHxcrpCvnhSQAuakKp2C/YbCylJjXRVy/z3+Kv/RrNcCo+WUzlVEhzKffnTQnxeN9fWF88fiNCUdSTsaufaChKWInHeysygfpIqagoakW+vV20J8uyl6TyNKEZWV4oRSPyCkWpgOLSbkCObT8o2r6tlG58HQquf6O0v50tB7JM7F4EORd2dx/K0w/KHsVkLPaoYrwgP/y7krr3SSMA4zj+OBgmjYkxcdIJQyQRKgg2viX9Hddi9UBb29LrKR7CVVEEEXWojUkXNyfTNDE14W9gbHJNuhjDettN3ZvbOvdOqCD3Jp/9l+/wJE+9PkYGjx/fqkys3S2rMozM/o2106rfMUINo6hVqz+eu/hd1c4xTg0TAfy5kV+4UG6+IthHTU9woWmxuKNbTfuCSfovBCxq7EtHqvYL4Sm6F8GVxsSXHMQ07TOi1DKtZxjWaaIyi4CXWjxPccUw8WVbMYY5wxC1mzEyXMJWkllpRloi+Kkoq69sxBTlElF6aAxYUbjXNlhlDZilDnM4U5SlN5biRsRHnbx3mbeWjEh4mEyiuJDl5XcWVmX5GvNkFgLWZM5qwsop4/AWfLhU1cR7k1VVvcYCWRkOI6Xy5gmnphCYIkvzuNYzHzosq2oNk2RtSs8khfUOfHIDgR6ysYBaMpl4uEgk2U/oJTs9AaTSwma7dT69geAE2ZpEjUsn2ieJNHeKfrI3EcAGJ2ZaNgVuC8EBctCLc57P5u5led6IOBkIYkuQMrmmjChs4VkfOerHqSBkPzZlhe06RslZ3zMjk2sscqKwY0RcjKK+LWbzd7KiHhkncs/siFJ+V5eXxD34B8nVuJEpGJNmxN2gH3vSvp7J70tF+D1Ej8qUJD1TkErAND2GZwTFg/LubvmgiBG3SOvdlsqFQrkEzJCL1rstlnVFROixZoDDSuXQFHESwVGlcuQcMb/b42NgjLowh5MTDFE3vNB5qStRIErdCQEh6pLPR92anSUb/wAIhldAaDMpGgAAAABJRU5ErkJggg==";
const shadowIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
window.nezasa = { iso8601: require$$1 };
delete L$1.Icon.Default.prototype._getIconUrl;
L$1.Icon.Default.mergeOptions({
  iconUrl: markerIcon,
  iconRetinaUrl: retinaIcon,
  shadowUrl: shadowIcon
});
L$1.PM.setOptIn(true);
const _getTiledPixelBounds = L$1.GridLayer.prototype._getTiledPixelBounds;
L$1.GridLayer.include({
  _getTiledPixelBounds: function(center2) {
    let pixelBounds = _getTiledPixelBounds.call(this, center2);
    const edgeBufferTiles = this.options.edgeBufferTiles;
    if (edgeBufferTiles > 0) {
      const pixelEdgeBuffer = L$1.GridLayer.prototype.getTileSize.call(this).multiplyBy(edgeBufferTiles);
      pixelBounds = new L$1.Bounds(pixelBounds.min.subtract(pixelEdgeBuffer), pixelBounds.max.add(pixelEdgeBuffer));
    }
    return pixelBounds;
  }
});
const _createRenderer = L$1.Map.prototype._createRenderer;
L$1.Map.include({
  _createRenderer: function(options) {
    return _createRenderer.call(this, Object.assign(_$1.get(this.options, "rendererOptions", {}), options));
  }
});
const baseMap = {
  emits: [
    "map-ready",
    "layer-added",
    "layer-removed",
    "layer-shown",
    "layer-hidden",
    "layer-enabled",
    "layer-disabled",
    "pane-added",
    "pane-removed",
    "pane-shown",
    "pane-hidden"
  ],
  data() {
    return {
      layers: {},
      orphanLayers: []
    };
  },
  methods: {
    refreshMap() {
      if (this.map) this.map.invalidateSize();
    },
    setupMap(domEl, options = {}) {
      const viewerOptions = _$1.defaults(options, _$1.get(this, "activityOptions.engine.viewer", {}), {
        minZoom: 3,
        maxZoom: 21,
        center: [47, 3],
        zoom: 6,
        maxBounds: [[-90, -180], [90, 180]],
        maxBoundsViscosity: 0.25,
        scale: true,
        geolocate: true,
        rotateControl: false
        // Rotate plugin show this even if rotation is disabled
      });
      this.map = L$1.map(domEl, Object.assign({ zoomControl: false }, viewerOptions));
      const backgroundColor = _$1.get(viewerOptions, "backgroundColor");
      if (backgroundColor) this.map._container.style.backgroundColor = backgroundColor;
      if (this.map.pm === void 0) {
        this.map.options.pmIgnore = false;
        L$1.PM.reInitLayer(this.map);
        this.map.pm.setLang(getLocale());
      }
      L$1.DomEvent.on(this.map._container, TouchEvents.join(" "), this.onTouchEvent, this);
      bindLeafletEvents(this.map, LeafletEvents.Map, this, viewerOptions);
      const scale2 = _$1.get(viewerOptions, "scale", true);
      if (scale2) this.setupScaleControl(scale2);
      const geolocate = _$1.get(viewerOptions, "geolocate", true);
      if (geolocate) this.setupGeolocateControl(geolocate);
      const hiddenPane = this.map.createPane("kdk-hidden-features");
      hiddenPane.style.display = "none";
      this.onMapReady();
    },
    convertTouches(touches) {
      const convertedTouches = [];
      if (touches && touches.length) {
        for (let i = 0; i < touches.length; i++) {
          const touch = typeof touches.item === "function" ? touches.item(i) : touches[i];
          const data = {
            containerPoint: this.map.mouseEventToContainerPoint(touch)
          };
          if (data.containerPoint) {
            data.layerPoint = this.map.containerPointToLayerPoint(data.containerPoint);
            data.latlng = this.map.layerPointToLatLng(data.layerPoint);
          }
          convertedTouches.push(data);
        }
      }
      return convertedTouches;
    },
    onTouchEvent(event) {
      if (event.pointerType === "mouse") return;
      const pointerEventsMapping = {
        pointerdown: "touchstart",
        pointermove: "touchmove",
        pointerup: "touchend",
        pointercancel: "touchcancel"
      };
      const pointerEvent = pointerEventsMapping[event.type];
      const type = pointerEvent || event.type;
      let targets = this.map._findEventTargets(event, type);
      if (!targets.length) return;
      const touches = this.convertTouches(event.touches);
      const changedTouches = this.convertTouches(event.changedTouches);
      const targetTouches = this.convertTouches(event.targetTouches);
      for (let i = 0; i < targets.length; i++) {
        const target2 = targets[i];
        const data = {
          originalEvent: event,
          touches,
          changedTouches,
          targetTouches
        };
        const touchesForTarget = _$1.isEmpty(touches) ? _$1.isEmpty(changedTouches) ? [] : changedTouches : touches;
        const isMarker = target2.getLatLng && (!target2._radius || target2._radius <= 10);
        data.containerPoint = isMarker ? this.map.latLngToContainerPoint(target2.getLatLng()) : _$1.get(touchesForTarget, "[0].containerPoint");
        if (data.containerPoint) {
          data.layerPoint = this.map.containerPointToLayerPoint(data.containerPoint);
          data.latlng = isMarker ? target2.getLatLng() : this.map.layerPointToLatLng(data.layerPoint);
        }
        target2.fire(type, data, true);
        if (data.originalEvent._stopped) return;
      }
    },
    onMapReady() {
      this.$emit("map-ready", "leaflet");
      this.$engineEvents.emit("map-ready", "leaflet");
    },
    setupScaleControl(options) {
      if (typeof options === "object") {
        this.scaleControl = new L$1.control.graphicScale(options);
      } else {
        this.scaleControl = new L$1.control.scale();
      }
      this.scaleControl.addTo(this.map);
    },
    setupGeolocateControl() {
      this.locateControl = new L$1.control.locate({
        // eslint-disable-line
        locateOptions: {
          maxZoom: 16,
          watch: false,
          setView: false,
          timeout: 3e4,
          enableHighAccuracy: true
        },
        strings: {
          title: this.$t("geolocation.TITLE"),
          metersUnit: this.$t("geolocation.METERS"),
          feetUnit: this.$t("geolocation.FEET"),
          popup: this.$t("geolocation.POPUP"),
          outsideMapBoundsMsg: this.$t("geolocation.OUTSIDE_MAP_BOUNDS")
        }
      });
      this.locateControl.addTo(this.map);
      this.locateControl._container.style.display = "none";
    },
    processLeafletLayerOptions(options) {
      const processedOptions = _$1.cloneDeep(options);
      const leafletOptions = processedOptions.leaflet;
      this.leafletObjectOptions.forEach((option) => {
        if (typeof _$1.get(leafletOptions, option) === "string") {
          _$1.set(leafletOptions, option, _$1.get(L$1, _$1.get(leafletOptions, option)));
        }
      });
      if (_$1.has(leafletOptions, "minZoom") && !_$1.isNumber(leafletOptions.minZoom)) _$1.unset(leafletOptions, "minZoom");
      if (_$1.has(leafletOptions, "maxZoom") && !_$1.isNumber(leafletOptions.maxZoom)) _$1.unset(leafletOptions, "maxZoom");
      leafletOptions.attribution = processedOptions.attribution;
      return processedOptions;
    },
    getLeafletPaneName(paneOrZIndex) {
      return typeof paneOrZIndex === "object" ? paneOrZIndex.name || paneOrZIndex.zIndex.toString() : paneOrZIndex.toString();
    },
    createLeafletPane(paneOrZIndex) {
      const paneName = this.getLeafletPaneName(paneOrZIndex);
      let pane = this.map.getPane(paneName);
      if (!pane) {
        let zIndex;
        if (typeof paneOrZIndex === "object") zIndex = paneOrZIndex.zIndex || 400;
        else if (typeof paneOrZIndex === "number") zIndex = paneOrZIndex;
        let container = paneOrZIndex.container;
        if (this.map._rotate && !container) container = "rotatePane";
        container = this.map.getPane(container);
        pane = this.map.createPane(paneName, container);
        _$1.set(pane, "style.zIndex", zIndex || 400);
      }
      this.leafletPanes[paneName] = pane;
      this.onPaneAdded(paneName, pane);
      return pane;
    },
    onPaneAdded(name, leafletPane) {
      this.$emit("pane-added", name, leafletPane);
      this.$engineEvents.emit("pane-added", name, leafletPane);
    },
    getLeafletPaneByName(paneOrZIndex) {
      const paneName = paneOrZIndex.toString();
      return this.leafletPanes[paneName];
    },
    removeLeafletPane(paneOrZIndex) {
      const paneName = paneOrZIndex.toString();
      const pane = this.getLeafletPaneByName(paneName);
      if (!pane) return;
      delete this.leafletPanes[paneName];
      this.onPaneRemoved(paneName, pane);
    },
    onPaneRemoved(name, leafletPane) {
      this.$emit("pane-removed", name, leafletPane);
      this.$engineEvents.emit("pane-removed", name, leafletPane);
    },
    isPaneVisible(name) {
      const pane = this.getLeafletPaneByName(name);
      return pane && pane.style.display === "block";
    },
    showPane(name) {
      const pane = this.getLeafletPaneByName(name);
      if (!pane || pane.style.display === "block") return;
      pane.style.display = "block";
      this.onPaneShown(name, pane);
    },
    onPaneShown(name, leafletPane) {
      this.$emit("pane-shown", name, leafletPane);
      this.$engineEvents.emit("pane-shown", name, leafletPane);
    },
    hidePane(name) {
      const pane = this.getLeafletPaneByName(name);
      if (!pane || pane.style.display === "none") return;
      pane.style.display = "none";
      this.onPaneHidden(name, pane);
    },
    onPaneHidden(name, leafletPane) {
      this.$emit("pane-hidden", name, leafletPane);
      this.$engineEvents.emit("pane-hidden", name, leafletPane);
    },
    updateLeafletPanesVisibility() {
      const zoom = Math.floor(this.map.getZoom());
      _$1.forOwn(this.leafletPanes, (pane, paneName) => {
        const hasMinZoom = !!_$1.get(pane, "minZoom");
        const hasMaxZoom = !!_$1.get(pane, "maxZoom");
        if (!hasMinZoom && !hasMaxZoom) return;
        if (!pane.style) pane.style = {};
        if (hasMinZoom && zoom < _$1.get(pane, "minZoom")) {
          this.hidePane(paneName);
          return;
        }
        if (hasMaxZoom && zoom > _$1.get(pane, "maxZoom")) {
          this.hidePane(paneName);
          return;
        }
        this.showPane(paneName);
      });
    },
    createLeafletLayer(options) {
      const name = options.name;
      const leafletOptions = options.leaflet || options;
      const layerPane = { name };
      const hasMinZoom = !!_$1.get(leafletOptions, "minZoom");
      const hasMaxZoom = !!_$1.get(leafletOptions, "maxZoom");
      const hasZIndex = !!_$1.get(leafletOptions, "zIndex");
      if (hasMinZoom) layerPane.minZoom = _$1.get(leafletOptions, "minZoom");
      if (hasMaxZoom) layerPane.maxZoom = _$1.get(leafletOptions, "maxZoom");
      if (hasZIndex) layerPane.zIndex = _$1.get(leafletOptions, "zIndex");
      if (hasZIndex) {
        this.createLeafletPane(layerPane);
        if (!_$1.has(leafletOptions, "pane")) _$1.set(leafletOptions, "pane", layerPane.name);
      }
      const panes = _$1.get(leafletOptions, "panes", []);
      if (panes) {
        panes.forEach((paneOptions) => {
          const pane = this.createLeafletPane(paneOptions);
          Object.assign(pane, paneOptions);
        });
      }
      this.updateLeafletPanesVisibility();
      let args = _$1.get(leafletOptions, "options", []);
      if (typeof args === "object") args = [args];
      let layer2, type = leafletOptions.type;
      if (leafletOptions.source) {
        const source = leafletOptions.source;
        delete leafletOptions.source;
        layer2 = _$1.get(L$1, type)(source, _$1.omit(leafletOptions, ["options"]), ...args);
      } else {
        layer2 = _$1.get(L$1, type)(_$1.omit(leafletOptions, ["options"]), ...args);
      }
      return layer2;
    },
    registerLeafletConstructor(constructor) {
      this.leafletFactory.push(constructor);
    },
    async createLayer(options) {
      const processedOptions = this.processLeafletLayerOptions(options);
      let layer2;
      for (let i = 0; i < this.leafletFactory.length; i++) {
        const constructor = this.leafletFactory[i];
        layer2 = await constructor(processedOptions);
        if (layer2) break;
      }
      return layer2 || this.createLeafletLayer(processedOptions);
    },
    createLeafletTimedWmsLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "tileLayer.wms" && leafletOptions.type !== "TileLayer.wmsHeader") return;
      let layer2 = this.createLeafletLayer(options);
      const timeDimension = _$1.get(leafletOptions, "timeDimension");
      if (timeDimension) {
        _$1.set(timeDimension, "period", "P1D");
        const timeRange = _$1.get(timeDimension, "times");
        const timeRangeComponents = typeof timeRange === "string" ? timeRange.split("/") : [];
        const timeList = typeof timeRange === "string" ? timeRange.split(",") : [];
        let times = [];
        if (!_$1.isEmpty(timeList)) {
          _$1.unset(timeDimension, "period");
          times = _$1.sortBy(timeList.map((time) => moment.utc(time)), (time) => time.valueOf());
        } else if (timeRangeComponents.length === 2) {
          _$1.set(timeDimension, "times", `${timeRange}/P1D`);
        } else if (timeRangeComponents.length === 3) {
          _$1.set(timeDimension, "period", timeRangeComponents[2]);
        }
        const periodAsDuration = moment.duration(_$1.get(timeDimension, "period"));
        layer2 = this.createLeafletLayer({
          type: "timeDimension.layer.wms",
          source: layer2,
          timeDimension: L$1.timeDimension(timeDimension),
          currentTime: Time.getCurrentTime().toDate().getTime()
        });
        layer2.setCurrentTime = (datetime) => {
          layer2._timeDimension.setCurrentTime(datetime.toDate().getTime());
        };
        layer2._createLayerForTime = (time) => {
          time = moment.utc(time);
          const wmsParams = _$1.omit(layer2._baseLayer.options, ["timeDimension", "isVisible", "type"]);
          if (periodAsDuration.years() > 0) {
            wmsParams.time = time.format("YYYY").toISOString();
          } else if (periodAsDuration.months() > 0) {
            wmsParams.time = time.format("YYYY-MM");
          } else if (periodAsDuration.days() > 0) {
            wmsParams.time = time.format("YYYY-MM-DD");
          } else if (!_$1.isEmpty(times)) {
            const { index: index2, difference } = getNearestTime(time, times, true);
            if (index2 >= 0) wmsParams.time = timeList[index2];
            else wmsParams.time = time.toISOString();
          } else {
            wmsParams.time = time.toISOString();
          }
          let args = _$1.get(leafletOptions, "options", []);
          if (typeof args === "object") args = [args];
          return new layer2._baseLayer.constructor(layer2._baseLayer.getURL(), wmsParams, ...args);
        };
      }
      return layer2;
    },
    hasLayer(name) {
      return _$1.has(this.layers, name);
    },
    isLayerVisible(name) {
      const leafetLayer = this.getLeafletLayerByName(name);
      return leafetLayer && this.map.hasLayer(leafetLayer);
    },
    isLayerDisabled(layer2) {
      const minZoom = _$1.get(layer2, "leaflet.minZoom");
      const maxZoom = _$1.get(layer2, "leaflet.maxZoom");
      let isDisabled = false;
      if (minZoom && this.map.getZoom() < minZoom) isDisabled = true;
      if (maxZoom && this.map.getZoom() > maxZoom) isDisabled = true;
      return isDisabled;
    },
    updateLayerDisabled(layer2) {
      const wasDisabled = layer2.isDisabled;
      const isDisabled = this.isLayerDisabled(layer2);
      if (wasDisabled === isDisabled) return;
      layer2.isDisabled = isDisabled;
      if (wasDisabled) this.onLayerEnabled(layer2);
      else this.onLayerDisabled(layer2);
    },
    onLayerEnabled(layer2) {
      this.$emit("layer-enabled", layer2);
      this.$engineEvents.emit("layer-enabled", layer2);
    },
    onLayerDisabled(layer2) {
      this.$emit("layer-disabled", layer2);
      this.$engineEvents.emit("layer-disabled", layer2);
    },
    getLayerByName(name) {
      return this.layers[name];
    },
    getOrphanLayerByName(name) {
      return this.orphanLayers.find((l) => l?.name === name);
    },
    getLeafletLayerByName(name) {
      return this.leafletLayers[name];
    },
    getLayerById(id) {
      const layers = this.getLayers({ _id: id });
      return _$1.get(layers, "[0]");
    },
    getLayers(filter = {}) {
      return _$1.values(this.layers).filter(sift(filter));
    },
    hasLayers(filter = {}) {
      return _$1.values(this.layers).filter(sift(filter)).length > 0;
    },
    async showLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      if (this.isLayerVisible(name)) return;
      let leafletLayer = this.getLeafletLayerByName(name);
      if (!leafletLayer) {
        try {
          leafletLayer = await this.createLayer(layer2);
        } catch (error) {
          logger$1.error(error);
          return;
        }
      }
      this.leafletLayers[name] = leafletLayer;
      this.map.addLayer(leafletLayer);
      layer2.isVisible = true;
      if (typeof leafletLayer.setCurrentTime === "function") leafletLayer.setCurrentTime(Time.getCurrentTime());
      this.onLayerShown(layer2, leafletLayer);
    },
    onLayerShown(layer2, leafletLayer) {
      this.$emit("layer-shown", layer2, leafletLayer);
      this.$engineEvents.emit("layer-shown", layer2, leafletLayer);
    },
    hideLayer(name) {
      if (!this.isLayerVisible(name)) return;
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      layer2.isVisible = false;
      const leafletLayer = this.leafletLayers[name];
      delete this.leafletLayers[name];
      this.map.removeLayer(leafletLayer);
      const panes = _$1.get(layer2, "leaflet.panes");
      if (panes) panes.forEach((pane) => this.removeLeafletPane(pane.name || pane.zIndex));
      this.onLayerHidden(layer2, leafletLayer);
    },
    onLayerHidden(layer2, leafletLayer) {
      this.$emit("layer-hidden", layer2, leafletLayer);
      this.$engineEvents.emit("layer-hidden", layer2, leafletLayer);
    },
    async addLayer(layer2) {
      if (layer2 && !this.hasLayer(layer2.name)) {
        layer2.isVisible = false;
        layer2.isDisabled = this.isLayerDisabled(layer2);
        this.layers[layer2.name] = layer2;
        this.onLayerAdded(layer2);
        if (_$1.get(layer2, "leaflet.isVisible", false)) await this.showLayer(layer2.name);
      }
      return layer2;
    },
    onLayerAdded(layer2) {
      this.$emit("layer-added", layer2);
      this.$engineEvents.emit("layer-added", layer2);
    },
    async addGeoJsonLayer(layerSpec, geoJson, zoom = true) {
      if (!generateLayerDefinition(layerSpec, geoJson)) return;
      await this.addLayer(layerSpec);
      await this.updateLayer(layerSpec.name, geoJson);
      if (zoom) {
        if (geoJson.bbox) this.zoomToBBox(geoJson.bbox);
        else this.zoomToLayer(layerSpec.name);
      }
    },
    renameLayer(previousName, newName) {
      const layer2 = this.getLayerByName(previousName);
      const leafletLayer = this.getLeafletLayerByName(previousName);
      if (!layer2) return;
      if (leafletLayer) {
        this.leafletLayers[newName] = leafletLayer;
        delete this.leafletLayers[previousName];
      }
      this.layers[newName] = layer2;
      delete this.layers[previousName];
    },
    reorganizeLayers() {
      for (let i = this.layerCategories.length - 1; i >= 0; i--) {
        const category = this.layerCategories[i];
        if (!category?.layers) continue;
        for (let j = category.layers.length - 1; j >= 0; j--) {
          const layer2 = category.layers[j];
          this.bringLayerToFront(layer2);
        }
      }
      for (let i = this.orphanLayers.length - 1; i >= 0; i--) {
        const layer2 = this.orphanLayers[i];
        this.bringLayerToFront(layer2.name);
      }
    },
    removeLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      this.hideLayer(name);
      delete this.layers[layer2.name];
      this.onLayerRemoved(layer2);
    },
    onLayerRemoved(layer2) {
      this.$emit("layer-removed", layer2);
      this.$engineEvents.emit("layer-removed", layer2);
    },
    clearLayers() {
      Object.keys(this.layers).forEach((layer2) => this.removeLayer(layer2));
    },
    toGeoJson(name) {
      if (!this.isLayerVisible(name)) {
        const cachedGeojson = this.geojsonCache[name];
        if (cachedGeojson) return cachedGeojson;
      }
      const layer2 = this.getLeafletLayerByName(name);
      if (!layer2 || typeof layer2.toGeoJSON !== "function") return;
      return layer2.toGeoJSON();
    },
    zoomToLayer(name, options) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      if (this.isLayerDisabled(layer2)) {
        const minZoom = _$1.get(layer2, "leaflet.minZoom");
        if (minZoom) {
          const center2 = this.getCenter();
          this.center(center2.longitude, center2.latitude, minZoom);
          return;
        }
      }
      const bbox2 = _$1.get(layer2, "bbox");
      if (bbox2) {
        this.zoomToBBox(bbox2);
      } else {
        const leafletLayer = this.getLeafletLayerByName(name);
        if (leafletLayer) {
          if (typeof leafletLayer.getBounds === "function") {
            const bounds = leafletLayer.getBounds();
            if (bounds.isValid()) this.map.fitBounds(bounds, options);
          } else {
            const bounds = _$1.get(layer2, "leaflet.bounds", this.map.options.maxBounds);
            this.zoomToBounds(bounds);
          }
        }
      }
    },
    zoomToBounds(bounds) {
      this.map.fitBounds(bounds);
    },
    zoomToBBox(bbox2) {
      this.zoomToBounds([[bbox2[1], bbox2[0]], [bbox2[3], bbox2[2]]]);
    },
    bringLayerToFront(name) {
      let leafletLayer = this.getLeafletLayerByName(name);
      if (!leafletLayer) return;
      const panes = _$1.get(leafletLayer, "options.panes");
      if (panes) {
        panes.forEach((paneOptions) => {
          const pane = this.getLeafletPaneByName(this.getLeafletPaneName(paneOptions));
          if (pane) L$1.DomUtil.toFront(pane);
        });
        return;
      }
      if (leafletLayer instanceof L$1.MarkerClusterGroup) {
        const container = leafletLayer;
        leafletLayer = leafletLayer.getLayers().find((layer2) => layer2._container === container);
      }
      if (leafletLayer && typeof leafletLayer.bringToFront === "function") leafletLayer.bringToFront();
    },
    bringLayerToBack(name) {
      let leafletLayer = this.getLeafletLayerByName(name);
      if (!leafletLayer) return;
      const panes = _$1.get(leafletLayer, "options.panes");
      if (panes) {
        panes.forEach((paneOptions) => {
          const pane = this.getLeafletPaneByName(this.getLeafletPaneName(paneOptions));
          if (pane) L$1.DomUtil.toBack(pane);
        });
        return;
      }
      if (leafletLayer instanceof L$1.MarkerClusterGroup) {
        const container = leafletLayer;
        leafletLayer = leafletLayer.getLayers().find((layer2) => layer2._container === container);
      }
      if (leafletLayer && typeof leafletLayer.bringToBack === "function") leafletLayer.bringToBack();
    },
    animateCenter(timestamp) {
      if (!this.centerAnimation.startTime) this.centerAnimation.startTime = timestamp;
      const {
        id,
        duration,
        startTime,
        fps,
        animate: { center: center2, zoom, bearing: bearing2 },
        startLongitude,
        endLatitude,
        startLatitude,
        startZoom,
        startBearing,
        endLongitude,
        endZoom,
        endBearing
      } = this.centerAnimation;
      const elapsedSinceStart = timestamp - startTime;
      if (fps && this.centerAnimation.lastTime) {
        const elapsedSinceLastFrame = timestamp - this.centerAnimation.lastTime;
        const fpsInterval = 1e3 / fps;
        if (elapsedSinceLastFrame < fpsInterval) {
          this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
          return;
        }
      }
      const percent = Math.abs(elapsedSinceStart / (1e3 * duration));
      let percentCenter, percentZoom, percentBearing;
      if (percent <= 1) {
        const currentCenter = this.getCenter();
        if (center2) {
          const easingCenterFunction = center2.easing.function;
          const easingCenterParameters = center2.easing.parameters || [];
          percentCenter = maths[easingCenterFunction](percent, ...easingCenterParameters);
        }
        if (zoom) {
          const easingZoomFunction = zoom.easing.function;
          const easingZoomParameters = zoom.easing.parameters || [];
          percentZoom = maths[easingZoomFunction](percent, ...easingZoomParameters);
        }
        if (bearing2) {
          const easingBearingFunction = bearing2.easing.function;
          const easingBearingParameters = bearing2.easing.parameters || [];
          percentBearing = maths[easingBearingFunction](percent, ...easingBearingParameters);
        }
        const offset = this.centerAnimation.offset;
        const dx = center2 && offset ? percentCenter * offset.x || 0 : 0;
        const dy = center2 && offset ? percentCenter * offset.y || 0 : 0;
        let dLongitude = currentCenter.longitude, dLatitude = currentCenter.latitude;
        if (center2) {
          if (center2.rhumb) {
            const destination2 = rhumbDestination$1(this.centerAnimation.rhumbStart, percentCenter * this.centerAnimation.rhumbDistance, this.centerAnimation.rhumbBearing);
            dLongitude = destination2.geometry.coordinates[0];
            dLatitude = destination2.geometry.coordinates[1];
          } else {
            dLongitude = startLongitude + percentCenter * (endLongitude - startLongitude);
            dLatitude = startLatitude + percentCenter * (endLatitude - startLatitude);
          }
        }
        const dZoom = zoom ? startZoom + percentZoom * (endZoom - startZoom) : null;
        let dBearing;
        if (!_$1.isNil(startBearing)) {
          const bearingDifference = (endBearing - startBearing + 540) % 360 - 180;
          dBearing = bearing2 ? (startBearing + percentBearing * bearingDifference + 360) % 360 : null;
        }
        this.center(dLongitude, dLatitude, dZoom, dBearing, { offset: { x: Math.round(dx), y: Math.round(dy) }, bearingTolerance: this.centerAnimation.bearingTolerance });
        this.centerAnimation.lastTime = timestamp;
        this.centerAnimation.id = requestAnimationFrame(this.animateCenter);
      } else {
        this.centerAnimation.id = null;
      }
    },
    center(longitude, latitude, zoomLevel, bearing2, options = {}) {
      const offset = L$1.point(_$1.get(options, "offset.x", 0), _$1.get(options, "offset.y", 0));
      if (_$1.isNil(zoomLevel)) zoomLevel = this.map.getZoom();
      if (_$1.isNil(bearing2)) bearing2 = this.map.getBearing();
      if (bearing2 < 0) bearing2 += 360;
      const duration = _$1.get(options, "duration", 0);
      if (duration) {
        _$1.defaultsDeep(options, {
          animate: {
            center: { easing: { function: "linear" }, rhumb: false },
            zoom: { easing: { function: "linear" } },
            bearing: { easing: { function: "linear" } }
          }
        });
        if (_$1.has(this.centerAnimation, "id")) cancelAnimationFrame(_$1.get(this.centerAnimation, "id"));
        const currentCenter = this.getCenter(options);
        const rhumbStart = point$1([currentCenter.longitude, currentCenter.latitude]);
        const rhumbEnd = point$1([longitude, latitude]);
        this.centerAnimation = {
          id: requestAnimationFrame(this.animateCenter),
          ...options,
          startLongitude: currentCenter.longitude,
          startLatitude: currentCenter.latitude,
          startZoom: currentCenter.zoom,
          endLongitude: longitude,
          endLatitude: latitude,
          rhumbStart,
          rhumbEnd,
          rhumbBearing: rhumbBearing$1(rhumbStart, rhumbEnd),
          rhumbDistance: rhumbDistance$1(rhumbStart, rhumbEnd),
          endZoom: zoomLevel
        };
        if (typeof this.map.getBearing === "function") {
          Object.assign(this.centerAnimation, {
            startBearing: this.map.getBearing(),
            endBearing: bearing2
          });
        }
      } else {
        if (typeof this.map.setBearing === "function") {
          this.setBearing(bearing2, options);
        }
        this.map.setView(new L$1.LatLng(latitude, longitude), zoomLevel, { animate: false, duration: 0 });
        this.map.panBy(offset, { animate: false, duration: 0 });
      }
    },
    getCenter() {
      const center2 = this.map.getCenter();
      const zoom = this.map.getZoom();
      return {
        longitude: center2.lng,
        latitude: center2.lat,
        zoomLevel: zoom
      };
    },
    setBearing(bearing2, options = {}) {
      if (typeof this.map.setBearing !== "function") {
        logger$1.warn(`[KDK] Map not configured to handle bearing, ignoring`);
        return;
      }
      const offset = L$1.point(_$1.get(options, "offset.x", 0), _$1.get(options, "offset.y", 0));
      const tolerance = _$1.get(options, "bearingTolerance", 0.1);
      if (Math.abs(this.map.getBearing() - bearing2) >= tolerance) {
        this.map.setBearing(bearing2, offset);
      }
    },
    getBearing() {
      if (typeof this.map.getBearing !== "function") {
        return 0;
      }
      return this.map.getBearing();
    },
    setCompassBearingTrackingEnabled(enabled) {
      if (enabled) {
        if (!this.map.compassBearing.enabled()) this.map.compassBearing.enable();
      } else if (this.map.compassBearing.enabled()) {
        this.map.compassBearing.disable();
      }
    },
    setTouchRotateEnabled(enabled) {
      if (enabled) {
        if (!this.map.touchRotate.enabled()) this.map.touchRotate.enable();
      } else if (this.map.touchRotate.enabled()) {
        this.map.touchRotate.disable();
      }
    },
    getBounds() {
      this.viewBounds = this.map.getBounds();
      const south = this.viewBounds.getSouth();
      const west = this.viewBounds.getWest();
      const north = this.viewBounds.getNorth();
      const east = this.viewBounds.getEast();
      return [[south, west], [north, east]];
    },
    showUserLocation() {
      if (Geolocation.hasLocation()) {
        const lng = Geolocation.getLongitude();
        const lat = Geolocation.getLatitude();
        const accuracy = Geolocation.getAccuracy();
        if (accuracy) {
          this.zoomToBounds(new L$1.LatLng(lat, lng).toBounds(accuracy * 2));
        } else {
          this.center(lng, lat);
        }
      }
      if (this.locateControl) {
        this.locateControl.start();
      }
    },
    hideUserLocation() {
      if (this.locateControl) {
        this.locateControl.stop();
      }
    },
    isUserLocationVisible() {
      return this.locateControl && this.locateControl._active;
    },
    isOrphanLayer(layer2) {
      return this.orphanLayers.some((l) => l.name === layer2.name);
    },
    setCursor(className) {
      L$1.DomUtil.addClass(this.map._container, className);
    },
    isCursor(className) {
      return L$1.DomUtil.hasClass(this.map._container, className);
    },
    unsetCursor(className) {
      L$1.DomUtil.removeClass(this.map._container, className);
    },
    onCurrentMapTimeChanged(datetime) {
      _$1.forEach(this.leafletLayers, (leafletLayer) => {
        if (typeof leafletLayer.setCurrentTime === "function") leafletLayer.setCurrentTime(datetime);
      });
    },
    onMapZoomChanged() {
      this.updateLeafletPanesVisibility();
      const zoomLayers = _$1.values(this.layers).filter(sift({
        $or: [{ "leaflet.minZoom": { $exists: true } }, { "leaflet.maxZoom": { $exists: true } }]
      }));
      zoomLayers.forEach(async (layer2) => {
        this.updateLayerDisabled(layer2);
      });
    }
  },
  async created() {
    this.leafletLayers = {};
    this.leafletPanes = {};
    this.leafletFactory = [];
    this.leafletObjectOptions = ["crs", "rendererFactory"];
    this.registerLeafletConstructor(this.createLeafletTimedWmsLayer);
    this.$engineEvents = new EventBus();
    this.$engineEvents.on("zoomend", this.onMapZoomChanged);
    Events.on("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  beforeUnmount() {
    this.clearLayers();
    L$1.DomEvent.off(this.map._container, TouchEvents.join(" "), this.onTouchEvent, this);
    this.$engineEvents.off("zoomend", this.onMapZoomChanged);
    Events.off("time-current-time-changed", this.onCurrentMapTimeChanged);
  },
  unmounted() {
    if (this.map) {
      this.map.off();
      this.map.remove();
    }
  }
};
L$1.Polygon.extend({
  initialize: function(geoJson, options) {
    L$1.setOptions(this, Object.assign({
      interactive: false,
      fitBounds: true,
      bounds: new L$1.LatLngBounds([-90, -360], [90, 360])
    }), options);
    const outerBoundsLatLngs = [
      this.options.bounds.getSouthWest(),
      this.options.bounds.getNorthWest(),
      this.options.bounds.getNorthEast(),
      this.options.bounds.getSouthEast()
    ];
    const mask = [];
    const type = _$1.get(geoJson, "type");
    if (type === "Feature") {
      const geometryType = _$1.get(geoJson, "geometry.type");
      const coordinates = _$1.get(geoJson, "geometry.coordinates");
      if (geometryType === "Polygon" && coordinates) {
        this.addPolygon(coordinates, mask);
      } else if (geometryType === "MultiPolygon" && coordinates) {
        _$1.forEach(coordinates, (polygon2) => this.addPolygon(polygon2, mask));
      }
      if (!geoJson.bbox) {
        geoJson.bbox = bbox$1(geoJson);
      }
    } else {
      logger$1.warn("Invalid/Unsupported GeoJson object for MaskLayer");
    }
    L$1.Polygon.prototype.initialize.call(this, [outerBoundsLatLngs, mask], this.options);
  },
  addPolygon(coordinates, mask) {
    const hole = [];
    _$1.forEach(coordinates, (ring) => {
      const ringHole = [];
      for (let i = 0; i < ring.length; i++) {
        ringHole.push(new L$1.LatLng(ring[i][1], ring[i][0]));
      }
      hole.push(ringHole);
    });
    mask.push(hole);
  }
});
const TiledFeatureLayer = L$1.GridLayer.extend({
  initialize(options) {
    this.enableDebug = _$1.get(options, "enableDebug", false);
    L$1.GridLayer.prototype.initialize.call(this, options);
    this.on("tileunload", (event) => {
      this.onTileUnload(event);
    });
    this.userIsDragging = false;
    this.userIsZooming = false;
    this.pendingStationUpdates = [];
    this.pendingRequests = [];
    this.getFeatureKey = (feature2) => {
      return getFeatureId(feature2, this.layer);
    };
    this.probeSource = options.probeSource;
    this.featureSource = options.featureSource;
    this.flyingTiles = /* @__PURE__ */ new Map();
    this.modifiedTiles = /* @__PURE__ */ new Set();
    this.allFeatures = /* @__PURE__ */ new Map();
  },
  setup(activity2, layer2) {
    this.activity = activity2;
    this.layer = layer2;
  },
  onAdd(map) {
    this.userIsDragging = false;
    this.userIsZooming = false;
    this.pendingStationUpdates = [];
    this.zoomStartLevel = this.zoomEndLevel = this._map.getZoom();
    this.flyingTiles.clear();
    this.modifiedTiles.clear();
    this.allFeatures.clear();
    L$1.GridLayer.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    this.flyingTiles.clear();
    this.modifiedTiles.clear();
    this.allFeatures.clear();
    L$1.GridLayer.prototype.onRemove.call(this, map);
  },
  getEvents() {
    const events = L$1.GridLayer.prototype.getEvents.call(this);
    const onMoveStart = events.movestart;
    events.movestart = (event) => {
      this.userIsDragging = true;
      if (onMoveStart) onMoveStart.call(this, event);
    };
    const onMoveEnd = events.moveend;
    events.moveend = (event) => {
      this.userIsDragging = false;
      if (onMoveEnd) onMoveEnd.call(this, event);
    };
    const onZoomStart = events.zoomstart;
    events.zoomstart = (event) => {
      if (onZoomStart) onZoomStart.call(this, event);
      this.zoomStartLevel = this._map.getZoom();
      this.userIsZooming = true;
    };
    const onZoomEnd = events.zoomend;
    events.zoomend = (event) => {
      if (onZoomEnd) onZoomEnd.call(this, event);
      this.zoomEndLevel = this._map.getZoom();
      this.userIsZooming = false;
      if (this.layer.probeService) {
        const minFeatureZoom = _$1.get(this.options, "minFeatureZoom", this._map.getMinZoom());
        const maxFeatureZoom = _$1.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
        if (this.zoomStartLevel >= minFeatureZoom && this.zoomEndLevel < minFeatureZoom || this.zoomStartLevel <= maxFeatureZoom && this.zoomEndLevel > maxFeatureZoom) {
          let collection = [];
          for (const internalFeature of this.allFeatures.values()) {
            collection.push(_$1.cloneDeep(internalFeature.geojson));
          }
          collection = featureCollection(collection);
          this.activity.updateLayer(this.layer.name, collection, { replace: true });
        } else if (this.pendingStationUpdates.length) {
          for (const collection of this.pendingStationUpdates) {
            const known = [];
            featureEach(collection, (feature2) => {
              if (this.allFeatures.has(this.getFeatureKey(feature2))) {
                known.push(feature2);
              }
            });
            this.activity.updateLayer(this.layer.name, featureCollection(known));
          }
        }
        this.pendingStationUpdates.length = 0;
      }
    };
    return events;
  },
  createTile(coords) {
    const key = tile2key$1(coords);
    let tile = this.flyingTiles.get(key);
    if (tile === void 0) {
      tile = {
        div: document.createElement("div"),
        coords,
        bbox: this._tileCoordsToBounds(coords),
        featuresRequest: null,
        featuresChildren: [],
        features: [],
        measuresRequest: null,
        measuresChildren: [],
        unload: false
      };
      this.flyingTiles.set(key, tile);
      if (this.enableDebug) {
        tile.div.style.outline = "1px solid orange";
        tile.div.innerHTML = "";
      }
    } else {
      tile.unload = false;
      if (this.enableDebug) tile.div.innerHTML += "</br>createTile: found in flying tiles";
    }
    this.modifiedTiles.add(key);
    return tile.div;
  },
  onTileUnload(event) {
    const key = tile2key$1(event.coords);
    const tile = this.flyingTiles.get(key);
    if (tile) tile.unload = true;
    this.modifiedTiles.add(key);
    if (this.enableDebug && tile) tile.div.innerHTML += "</br>unload scheduled";
  },
  mergeRequests(tiles) {
    const requests = [];
    const sortedTiles = tiles.sort((a, b) => {
      if (a.coords.x === b.coords.x) {
        return a.coords.y < b.coords.y ? -1 : a.coords.y !== b.coords.y ? 1 : 0;
      }
      return a.coords.x < b.coords.x ? -1 : 1;
    });
    if (sortedTiles.length) {
      const z = sortedTiles[0].coords.z;
      const vrequests = [];
      sortedTiles.forEach((tile) => {
        let newRequest = true;
        if (vrequests.length) {
          const r = vrequests[vrequests.length - 1];
          if (tile.coords.x === r.x) {
            if (tile.coords.y === r.maxy + 1) {
              r.tiles.push(tile);
              r.maxy = tile.coords.y;
              newRequest = false;
            }
          }
        }
        if (newRequest) {
          vrequests.push({
            x: tile.coords.x,
            miny: tile.coords.y,
            maxy: tile.coords.y,
            tiles: [tile]
          });
        }
      });
      vrequests.forEach((v) => {
        let newRequest = true;
        if (requests.length) {
          const h2 = requests[requests.length - 1];
          if (v.miny === h2.miny && v.maxy === h2.maxy && v.x === h2.maxx + 1) {
            h2.tiles.push(...v.tiles);
            h2.maxx = v.x;
            newRequest = false;
          }
        }
        if (newRequest) {
          requests.push({
            minx: v.x,
            maxx: v.x,
            miny: v.miny,
            maxy: v.maxy,
            tiles: [].concat(v.tiles)
          });
        }
      });
      requests.forEach((r) => {
        const minp = L$1.point(r.minx, r.miny);
        const maxp = L$1.point(r.maxx, r.maxy);
        minp.z = maxp.z = z;
        const bounds = this._tileCoordsToBounds(minp);
        bounds.extend(this._tileCoordsToBounds(maxp));
        r.query = {
          south: bounds.getSouth(),
          north: bounds.getNorth(),
          west: bounds.getWest(),
          east: bounds.getEast()
        };
      });
      if (this.enableDebug) {
        let numTilesR = 0;
        requests.forEach((r) => {
          numTilesR += r.tiles.length;
        });
        if (numTilesR !== tiles.length) {
          logger$1.debug("TiledFeatureLayer: less requested tiles than expected !");
        }
      }
    }
    if (this.enableDebug && tiles.length) {
      logger$1.debug(`TiledFeatureLayer: ${tiles.length} requests reduced to ${requests.length}`);
    }
    return requests;
  },
  _update(center2) {
    L$1.GridLayer.prototype._update.call(this);
    this.pendingRequests = this.pendingRequests.filter((r) => r.status.pending);
    if (this.userIsDragging) return;
    const tilesToRemove = [];
    const tilesWithFeaturesRequest = [];
    const tilesWithMeasuresRequest = [];
    const minFeatureZoom = _$1.get(this.options, "minFeatureZoom", this._map.getMinZoom());
    const maxFeatureZoom = _$1.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
    this.modifiedTiles.forEach((key) => {
      const tile = this.flyingTiles.get(key);
      if (tile === void 0) return;
      if (tile.unload) {
        if (tile.featuresRequest === null && tile.measuresRequest === null) tilesToRemove.push(tile);
      } else {
        const tileWithMeasures = this.layer.probeService && tile.coords.z >= minFeatureZoom && tile.coords.z <= maxFeatureZoom;
        if (this.enableDebug) {
          tile.div.innerHTML += "</br>features";
          if (tileWithMeasures) tile.div.innerHTML += " + measures";
        }
        const parentTileCoords = getParentTileInTileSet(this.flyingTiles, tile.coords);
        if (parentTileCoords === void 0) {
          tilesWithFeaturesRequest.push(tile);
          if (tileWithMeasures) tilesWithMeasuresRequest.push(tile);
          if (this.enableDebug) tile.div.innerHTML += "</br>need request(s)";
        } else {
          const parentTile = this.flyingTiles.get(tile2key$1(parentTileCoords));
          if (parentTile.featuresRequest === null) {
            parentTile.features.forEach((featureId) => {
              const feature2 = this.allFeatures.get(featureId);
              if (tile.bbox.intersects(feature2.bbox)) {
                feature2.refCount += 1;
                tile.features.push(featureId);
              }
            });
            if (this.enableDebug) {
              tile.div.style.outline = "1px solid green";
              tile.div.innerHTML += `</br>found ${tile.features.length} features in parent tile`;
            }
          } else {
            parentTile.featuresChildren.push(tile);
            tile.featuresRequest = parentTile.featuresRequest;
            if (this.enableDebug) tile.div.innerHTML += "</br>pending parent features request";
          }
          if (tileWithMeasures) {
            if (parentTile.measuresRequest !== null) {
              parentTile.measuresChildren.push(tile);
              tile.measuresRequest = parentTile.measuresRequest;
              if (this.enableDebug) tile.div.innerHTML += "</br>pending parent measures request";
            } else if (parentTileCoords.z < minFeatureZoom) {
              tilesWithMeasuresRequest.push(tile);
              if (this.enableDebug) tile.div.innerHTML += "</br>need measures request";
            }
          }
        }
      }
    });
    this.modifiedTiles.clear();
    const featureRequests = this.mergeRequests(tilesWithFeaturesRequest);
    featureRequests.forEach((r) => {
      const promise = this.layer.probeService ? this.probeSource(r.query) : this.featureSource(r.query);
      r.tiles.forEach((tile) => {
        tile.featuresRequest = promise;
        if (this.enableDebug) tile.div.innerHTML += "</br>features request issued";
      });
      promise.status = { cancelled: false, pending: true };
      this.pendingRequests.push(promise);
      promise.then((data) => {
        if (promise.status.cancelled) return;
        const allTiles = [r.tiles];
        r.tiles.forEach((tile) => {
          if (tile.featuresChildren.length) allTiles.push(tile.featuresChildren);
        });
        const tiles = allTiles.flat();
        const addCollection = [];
        data.features.forEach((feature2) => {
          const featureId = this.getFeatureKey(feature2);
          let internalFeature = this.allFeatures.get(featureId);
          const unknownFeature = internalFeature === void 0;
          if (unknownFeature) {
            const turfBbox = bbox$1(feature2);
            const corner1 = L$1.latLng(turfBbox[1], turfBbox[0]);
            const corner2 = L$1.latLng(turfBbox[3], turfBbox[2]);
            internalFeature = { geojson: feature2, refCount: 0, bbox: L$1.latLngBounds(corner1, corner2) };
          }
          tiles.forEach((tile) => {
            if (tile.bbox.intersects(internalFeature.bbox)) {
              internalFeature.refCount += 1;
              tile.features.push(featureId);
            }
          });
          if (internalFeature.refCount > 0) {
            if (unknownFeature) {
              addCollection.push(_$1.cloneDeep(feature2));
              this.allFeatures.set(featureId, internalFeature);
            }
          }
        });
        if (addCollection.length) {
          const collection = featureCollection(addCollection);
          this.activity.updateLayer(this.layer.name, collection);
        }
        tiles.forEach((tile) => {
          tile.featuresRequest = null;
          tile.featuresChildren = [];
          if (tile.unload) this.modifiedTiles.add(tile2key$1(tile.coords));
          if (this.enableDebug) {
            tile.div.style.outline = "1px solid green";
            tile.div.innerHTML += `</br>features request success: ${data.features.length} total, ${tile.features.length} for tile`;
          }
        });
        if (this.enableDebug) logger$1.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).catch((err) => {
        if (promise.status.cancelled) return;
        const allTiles = [r.tiles];
        r.tiles.forEach((tile) => {
          if (tile.featuresChildren.length) allTiles.push(tile.featuresChildren);
        });
        const tiles = allTiles.flat();
        tiles.forEach((tile) => {
          this.flyingTiles.delete(tile2key$1(tile.coords));
          if (this.enableDebug) {
            tile.div.style.outline = "1px solid red";
            tile.div.innerHTML += `</br>features request failed: ${err}`;
          }
        });
        if (this.enableDebug) logger$1.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      }).finally(() => {
        promise.status.pending = false;
      });
    });
    const measureRequests = this.mergeRequests(tilesWithMeasuresRequest);
    measureRequests.forEach((r) => {
      const promise = this.featureSource(r.query);
      const stationPromises = [];
      r.tiles.forEach((tile) => {
        tile.measuresRequest = promise;
        if (tile.featuresRequest) stationPromises.push(tile.featuresRequest);
        if (this.enableDebug) tile.div.innerHTML += "</br>measures request issued";
      });
      promise.status = { cancelled: false, pending: true };
      this.pendingRequests.push(promise);
      Promise.all(stationPromises).then(() => {
        if (promise.status.cancelled) return;
        const flaggedStations = [];
        r.tiles.forEach((tile) => {
          tile.features.forEach((id) => {
            const internalFeature = this.allFeatures.get(id);
            if (internalFeature) {
              const feature2 = _$1.cloneDeep(internalFeature.geojson);
              feature2.measureRequestIssued = true;
              flaggedStations.push(feature2);
            }
          });
        });
        if (flaggedStations.length) this.updateStations(featureCollection(flaggedStations));
      });
      promise.then((data) => {
        if (promise.status.cancelled) return;
        const allTiles = [r.tiles];
        r.tiles.forEach((tile) => {
          if (tile.measuresChildren.length) allTiles.push(tile.measuresChildren);
        });
        const tiles = allTiles.flat();
        const stationPromises2 = [];
        tiles.forEach((tile) => {
          tile.measuresRequest = null;
          tile.measuresChildren = [];
          if (tile.featuresRequest) stationPromises2.push(tile.featuresRequest);
          if (this.enableDebug) tile.div.innerHTML += `</br>measures request success: ${data.features.length} total`;
        });
        Promise.all(stationPromises2).then(() => {
          const okMeasures = [];
          featureEach(data, (feature2) => {
            const id = this.getFeatureKey(feature2);
            if (this.allFeatures.has(id)) okMeasures.push(feature2);
          });
          if (okMeasures.length) this.updateStations(featureCollection(okMeasures));
        });
      }).catch((err) => {
        if (promise.status.cancelled) return;
        const allTiles = [r.tiles];
        r.tiles.forEach((tile) => {
          if (tile.measuresChildren.length) allTiles.push(tile.measuresChildren);
        });
        const tiles = allTiles.flat();
        tiles.forEach((tile) => {
          if (this.enableDebug) {
            tile.div.style.outline = "1px solid red";
            tile.div.innerHTML += `</br>measures request failed: ${err}`;
          }
        });
      }).finally(() => {
        promise.status.pending = false;
      });
    });
    const removeCollection = [];
    tilesToRemove.forEach((tile) => {
      tile.features.forEach((featureId) => {
        const feature2 = this.allFeatures.get(featureId);
        if (feature2.refCount === 1) {
          removeCollection.push(feature2.geojson);
          this.allFeatures.delete(featureId);
        } else {
          feature2.refCount -= 1;
        }
      });
      this.flyingTiles.delete(tile2key$1(tile.coords));
    });
    if (removeCollection.length) this.activity.updateLayer(this.layer.name, featureCollection(removeCollection), { remove: true });
    if (this.enableDebug) {
      logger$1.debug(`TiledFeatureLayer: flyingTiles is ${this.flyingTiles.size} long`);
      logger$1.debug(`TiledFeatureLayer: allFeatures is ${this.allFeatures.size} long`);
      if (this.flyingTiles.size === 0 && this.allFeatures.size !== 0) {
        logger$1.debug(`TileFeatureLayer: no more flyingTiles but ${this.allFeatures.size} remaining features !`);
        this.allFeatures.forEach((feature2) => {
          logger$1.debug(`TileFeatureLayer: ${this.getFeatureKey(feature2.geojson)}: refCount ${feature2.refCount}`);
        });
      }
    }
  },
  updateStations(geojson) {
    if (this.userIsZooming) {
      this.pendingStationUpdates.push(geojson);
    } else {
      const minFeatureZoom = _$1.get(this.options, "minFeatureZoom", this._map.getMinZoom());
      const maxFeatureZoom = _$1.get(this.options, "maxFeatureZoom", this._map.getMaxZoom());
      if (this.zoomEndLevel >= minFeatureZoom && this.zoomEndLevel <= maxFeatureZoom) {
        this.activity.updateLayer(this.layer.name, geojson);
      }
    }
  },
  redraw() {
    const allFeatures = Array.from(this.allFeatures.values(), (feat) => feat.geojson);
    this.activity.updateLayer(this.layer.name, featureCollection(allFeatures), { remove: true });
    this.flyingTiles.clear();
    this.modifiedTiles.clear();
    this.allFeatures.clear();
    this.pendingStationUpdates.length = 0;
    this.pendingRequests.forEach((r) => {
      r.status.cancelled = true;
    });
    L$1.GridLayer.prototype.redraw.call(this);
  }
});
function fetchAsJson(query, headers = {}) {
  return fetch(query, { redirect: "follow", headers }).then((response) => response.text()).then((txt) => xml2js.parseStringPromise(txt, { tagNameProcessors: [xml2js.processors.stripPrefix] }));
}
function GetFeature(url, version, typeNames, searchParams = {}, headers = {}, { xml2json = true } = {}) {
  const query = buildUrl(url, Object.assign({
    SERVICE: "WFS",
    VERSION: version,
    REQUEST: "GetFeature",
    TYPENAMES: typeof typeNames === "string" ? typeNames : typeNames.join(" ")
  }, searchParams));
  return xml2json ? fetchAsJson(query, headers) : fetch(query, { redirect: "follow", headers }).then((response) => response.json());
}
const geojsonLayers$1 = {
  emits: [
    "layer-updated"
  ],
  methods: {
    processRealtimeGeoJsonLayerOptions(options) {
      const leafletOptions = options.leaflet || options;
      leafletOptions.type = "realtime";
      _$1.set(leafletOptions, "getFeatureId", (feature2) => {
        return getFeatureId(feature2, options);
      });
      const container = _$1.get(leafletOptions, "container");
      if (typeof container === "string") {
        leafletOptions.container = this.createLeafletLayer({ type: container });
      }
      if (!_$1.has(leafletOptions, "updateFeature")) {
        leafletOptions.updateFeature = getUpdateFeatureFunction(leafletOptions);
      }
      if (options.service) {
        options = this.getLayerByName(options.name);
        _$1.set(leafletOptions, "start", false);
        if (leafletOptions.tiled) {
          leafletOptions.removeMissing = false;
          _$1.set(leafletOptions, "source", async (successCallback, errorCallback) => {
          });
          leafletOptions.probeSource = (baseQuery) => this.getProbeFeatures(_$1.merge({ baseQuery }, options));
          leafletOptions.featureSource = (baseQuery) => this.getFeatures(_$1.merge({ baseQuery }, options));
        } else {
          leafletOptions.removeMissing = !options.probeService;
          let initialized = !options.probeService;
          _$1.set(leafletOptions, "source", async (successCallback, errorCallback) => {
            if (!initialized) {
              try {
                const geoJson = await this.getProbeFeatures(options);
                const features = getGeoJsonFeatures(geoJson);
                features.forEach((feature2) => {
                  feature2.measureRequestIssued = true;
                });
                successCallback(geoJson);
                initialized = true;
              } catch (error) {
                errorCallback(error);
              }
            }
            try {
              const geoJson = await this.getFeatures(options);
              successCallback(geoJson);
            } catch (error) {
              errorCallback(error);
            }
          });
        }
      } else if (options.wfs) {
        _$1.set(leafletOptions, "start", false);
        _$1.set(leafletOptions, "source", async (successCallback, errorCallback) => {
        });
        if (leafletOptions.tiled) {
          leafletOptions.removeMissing = false;
          leafletOptions.featureSource = (query) => {
            const searchParams = Object.assign({
              OUTPUTFORMAT: options.wfs.outputFormat,
              // request as geojson
              SRSNAME: "EPSG:4326",
              // result in 4326
              BBOX: `${query.south},${query.west},${query.north},${query.east},urn:ogc:def:crs:EPSG::4326`
              // request bbox
            }, options.wfs.searchParams);
            return GetFeature(options.wfs.url, options.wfs.version, options.wfs.layer, searchParams, options.wfs.headers, { xml2json: false });
          };
        }
      } else if (_$1.has(leafletOptions, "sourceTemplate")) {
        const sourceCompiler = _$1.template(_$1.get(leafletOptions, "sourceTemplate"));
        let lastFetchedSource;
        _$1.set(leafletOptions, "source", async (successCallback, errorCallback) => {
          try {
            const sourceToFetch = sourceCompiler({ time: Time.getCurrentTime() });
            if (!lastFetchedSource || lastFetchedSource !== sourceToFetch) {
              lastFetchedSource = sourceToFetch;
              successCallback(await fetchGeoJson(sourceToFetch, options));
            }
          } catch (error) {
            errorCallback(error);
          }
        });
        _$1.set(leafletOptions, "start", false);
      } else if (!_$1.has(leafletOptions, "source")) {
        _$1.set(leafletOptions, "start", false);
        _$1.set(leafletOptions, "source", async (successCallback, errorCallback) => {
        });
      }
    },
    async processGeoJsonLayerOptions(options) {
      const leafletOptions = options.leaflet || options;
      const dataSource = _$1.get(leafletOptions, "source");
      if (_$1.isNil(dataSource)) {
        _$1.set(leafletOptions, "source", { type: "FeatureCollection", features: [] });
      } else if (typeof dataSource === "string") {
        let data;
        if (options.service) {
          data = await this.getFeatures(options);
        } else {
          data = await fetchGeoJson(dataSource, options);
        }
        _$1.set(leafletOptions, "source", data);
      }
    },
    processClusterLayerOptions(options) {
      const leafletOptions = options.leaflet || options;
      const clusterOptions = Object.assign({ type: "markerClusterGroup" }, leafletOptions.cluster);
      if (leafletOptions.pane) clusterOptions.clusterPane = leafletOptions.pane;
      leafletOptions.container = this.createLeafletLayer(clusterOptions);
      bindLeafletEvents(leafletOptions.container, LeafletEvents.Cluster, this, options);
    },
    async createLeafletGeoJsonLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "geoJson") return;
      try {
        const hasMinZoom = !!_$1.get(leafletOptions, "minZoom");
        const hasMaxZoom = !!_$1.get(leafletOptions, "maxZoom");
        const hasZIndex = !!_$1.get(leafletOptions, "zIndex");
        const name = options.name;
        const layerPane = { name };
        if (hasMinZoom) layerPane.minZoom = _$1.get(leafletOptions, "minZoom");
        if (hasMaxZoom) layerPane.maxZoom = _$1.get(leafletOptions, "maxZoom");
        if (hasZIndex) layerPane.zIndex = _$1.get(leafletOptions, "zIndex");
        const panes = _$1.get(leafletOptions, "panes", []);
        if (!_$1.find(panes, { name: layerPane.name })) panes.push(layerPane);
        if (!_$1.has(leafletOptions, "pane")) leafletOptions.pane = layerPane.name;
        if (!_$1.has(leafletOptions, "shadowPane")) leafletOptions.shadowPane = layerPane.name;
        for (const type of ["point", "line", "polygon"]) {
          _$1.set(leafletOptions, `style.${type}.pane`, layerPane.name);
          _$1.set(leafletOptions, `style.${type}.shadowPane`, layerPane.name);
        }
        if (!hasZIndex) {
          if (!_$1.find(panes, { name: `${name}-markers` })) panes.push(Object.assign({ name: `${name}-markers`, zIndex: 600 }, _$1.omit(layerPane, ["name"])));
          if (!_$1.find(panes, { name: `${name}-shadows` })) panes.push(Object.assign({ name: `${name}-shadows`, zIndex: 500 }, _$1.omit(layerPane, ["name"])));
          if (!_$1.has(leafletOptions, "shadowPane")) leafletOptions.shadowPane = `${name}-shadows`;
          _$1.set(leafletOptions, "style.point.pane", `${name}-markers`);
          _$1.set(leafletOptions, "style.point.shadowPane", `${name}-shadows`);
        }
        leafletOptions.panes = panes;
        if (!_$1.has(leafletOptions, "cluster") && _$1.get(this, "activityOptions.engine.cluster")) {
          if (leafletOptions.cluster) Object.assign(leafletOptions.cluster, _$1.get(this, "activityOptions.engine.cluster"));
          else leafletOptions.cluster = Object.assign({}, _$1.get(this, "activityOptions.engine.cluster"));
        }
        if (leafletOptions.cluster) {
          this.processClusterLayerOptions(options);
        }
        if (leafletOptions.realtime) {
          this.processRealtimeGeoJsonLayerOptions(options);
        } else {
          await this.processGeoJsonLayerOptions(options);
        }
        const layerStyleTemplate = _$1.get(leafletOptions, "template");
        if (layerStyleTemplate) {
          leafletOptions.template = layerStyleTemplate.map((property) => ({
            property,
            compiler: _$1.template(_$1.get(leafletOptions, property))
          }));
        }
        const popupTemplate = _$1.get(leafletOptions, "popup.template");
        if (popupTemplate) {
          leafletOptions.popup.compiler = _$1.template(popupTemplate);
        }
        const tooltipTemplate = _$1.get(leafletOptions, "tooltip.template");
        if (tooltipTemplate) {
          leafletOptions.tooltip.compiler = _$1.template(tooltipTemplate);
        }
        const variables = _$1.get(options, "variables", []);
        variables.forEach((variable) => {
          if (_$1.has(variable, "chromajs")) {
            variable.colorScale = buildColorScale(_$1.get(variable, "chromajs"));
          }
        });
        if (leafletOptions.style) {
          leafletOptions.layerPointStyle = _$1.get(leafletOptions.style, "point");
          leafletOptions.layerLineStyle = _$1.get(leafletOptions.style, "line");
          leafletOptions.layerPolygonStyle = _$1.get(leafletOptions.style, "polygon");
        } else {
          leafletOptions.layerPointStyle = convertSimpleStyleToPointStyle(leafletOptions);
          leafletOptions.layerLineStyle = convertSimpleStyleToLineStyle(leafletOptions);
          leafletOptions.layerPolygonStyle = convertSimpleStyleToPolygonStyle(leafletOptions);
        }
        const geoJsonOptions = this.getGeoJsonOptions(options);
        Object.keys(geoJsonOptions).forEach((key) => {
          if (!_$1.has(leafletOptions, key) || key === "style") _$1.set(leafletOptions, key, _$1.get(geoJsonOptions, key));
        });
        let layer2 = this.createLeafletLayer(options);
        if (leafletOptions.realtime) {
          if (leafletOptions.tiled) {
            const hasMinZoom2 = !!_$1.get(leafletOptions, "minZoom");
            const hasMaxZoom2 = !!_$1.get(leafletOptions, "maxZoom");
            const zoomLevelsToOmit = [];
            if (!hasMinZoom2) zoomLevelsToOmit.push("minZoom");
            if (!hasMaxZoom2) zoomLevelsToOmit.push("maxZoom");
            const tiledLayer = new TiledFeatureLayer(_$1.omit(leafletOptions, zoomLevelsToOmit));
            tiledLayer.setup(this, options);
            layer2.tiledLayer = tiledLayer;
            layer2.on("add", () => tiledLayer.addTo(this.map));
            layer2.on("remove", () => tiledLayer.removeFrom(this.map));
          }
          layer2.on("update", (data) => this.onLayerUpdated(options, layer2, data));
          layer2.update();
        } else {
          if (leafletOptions.cluster && leafletOptions.container) {
            leafletOptions.container.addLayer(layer2);
            layer2 = leafletOptions.container;
          }
        }
        if (leafletOptions.timeDimension) {
          layer2 = this.createLeafletLayer(Object.assign({ type: "timeDimension.layer.geoJson", source: layer2 }, leafletOptions.timeDimension));
        }
        return layer2;
      } catch (error) {
        logger$1.error(error);
        return null;
      }
    },
    getGeoJsonOptions(options = {}) {
      const geojsonOptions = {
        onEachFeature: (feature2, layer2) => {
          unbindLeafletEvents(layer2, LeafletEvents.Feature);
          if (typeof this.onLeafletFeature === "function") this.onLeafletFeature(feature2, layer2, options);
          if (layer2.getPopup()) layer2.unbindPopup();
          const popup2 = this.generateStyle("popup", feature2, layer2, options);
          if (popup2) {
            const wasOpen = layer2.getPopup() && layer2.isPopupOpen();
            layer2.bindPopup(popup2);
            bindLeafletEvents(layer2.getPopup(), LeafletEvents.Popup, this, options);
            if (wasOpen) layer2.openPopup();
          }
          if (layer2.getTooltip()) layer2.unbindTooltip();
          const tooltip2 = this.generateStyle("tooltip", feature2, layer2, options, this.map.getZoom());
          if (tooltip2) {
            const wasOpen = layer2.getTooltip() && layer2.isTooltipOpen();
            layer2.bindTooltip(tooltip2);
            bindLeafletEvents(layer2.getTooltip(), LeafletEvents.Tooltip, this, options);
            if (wasOpen) layer2.openTooltip();
          }
          bindLeafletEvents(layer2, LeafletEvents.Feature, this, options);
        },
        style: (feature2) => {
          const styleType = getFeatureStyleType(feature2);
          if (!styleType) {
            logger$1.warn(`[KDK] cannot get a style type from the feature of geometry type ${feature2.geometry.type}`);
            return;
          }
          return this.generateStyle(styleType, feature2, options, _$1.get(this, `activityOptions.engine.style.${styleType}`), this.map.getZoom());
        },
        pointToLayer: (feature2, latlng) => {
          const style2 = this.generateStyle("point", feature2, options, _$1.get(this, "activityOptions.engine.style.point"), this.map.getZoom());
          if (!style2) {
            logger$1.warn("[KDK] cannot generate point style from a feature");
            return;
          }
          return createMarkerFromPointStyle(latlng, style2);
        }
      };
      return geojsonOptions;
    },
    getUpdateAnimation(name, layer2, options, geoJson) {
      const { duration, removeMissing, animate } = options;
      const animatedProperties = _$1.keys(animate);
      animatedProperties.forEach((property) => {
        _$1.defaultsDeep(animate, {
          [property]: { easing: { function: "linear" }, bearing: false }
        });
      });
      const features = getGeoJsonFeatures(geoJson);
      features.forEach((feature2) => {
        const previousLayer = layer2.getLayer(layer2.options.getFeatureId(feature2));
        const previousFeature = previousLayer ? previousLayer.feature : null;
        if (previousFeature) {
          delete previousFeature["previousFeature"];
          feature2.previousFeature = previousFeature;
          const startLongitude = feature2.previousFeature.geometry.coordinates[0];
          const startLatitude = feature2.previousFeature.geometry.coordinates[1];
          const endLongitude = feature2.geometry.coordinates[0];
          const endLatitude = feature2.geometry.coordinates[1];
          const rhumbStart = point$1([startLongitude, startLatitude]);
          const rhumbEnd = point$1([endLongitude, endLatitude]);
          Object.assign(feature2, {
            rhumbStart,
            rhumbEnd,
            rhumbBearing: rhumbBearing$1(rhumbStart, rhumbEnd),
            rhumbDistance: rhumbDistance$1(rhumbStart, rhumbEnd)
          });
        }
      });
      return (timestamp) => {
        if (!options.startTime) options.startTime = timestamp;
        const { id, startTime, fps } = options;
        const elapsedSinceStart = timestamp - startTime;
        if (fps && options.lastTime) {
          const elapsedSinceLastFrame = timestamp - options.lastTime;
          const fpsInterval = 1e3 / fps;
          if (elapsedSinceLastFrame < fpsInterval) {
            options.id = requestAnimationFrame(options.step);
            return;
          }
        }
        const percent = Math.abs(elapsedSinceStart / (1e3 * duration));
        if (percent <= 1) {
          const animatedFeatures = [];
          features.forEach((feature2) => {
            if (!feature2.previousFeature) {
              animatedFeatures.push(feature2);
              return;
            }
            const endLongitude = feature2.geometry.coordinates[0];
            const endLatitude = feature2.geometry.coordinates[1];
            let dLongitude = endLongitude, dLatitude = endLatitude;
            if (animate.geometry) {
              const easingGeometryFunction = animate.geometry.easing.function;
              const easingGeometryParameters = animate.geometry.easing.parameters || [];
              const percentGeometry = maths[easingGeometryFunction](percent, ...easingGeometryParameters);
              if (animate.geometry.rhumb) {
                const destination2 = rhumbDestination$1(feature2.rhumbStart, percentGeometry * feature2.rhumbDistance, feature2.rhumbBearing);
                dLongitude = destination2.geometry.coordinates[0];
                dLatitude = destination2.geometry.coordinates[1];
              } else {
                const startLongitude = feature2.previousFeature.geometry.coordinates[0];
                const startLatitude = feature2.previousFeature.geometry.coordinates[1];
                dLongitude = startLongitude + percentGeometry * (endLongitude - startLongitude);
                dLatitude = startLatitude + percentGeometry * (endLatitude - startLatitude);
              }
            }
            const properties = {};
            const previousFeatureProperties = feature2.previousFeature.properties || {};
            const featureProperties = feature2.properties || {};
            animatedProperties.forEach((property) => {
              if (property === "geometry") return;
              const animateProperty = animate[property];
              const easingPropertyFunction = animateProperty.easing.function;
              const easingPropertyParameters = animateProperty.easing.parameters || [];
              const percentProperty = maths[easingPropertyFunction](percent, ...easingPropertyParameters);
              const startValue = previousFeatureProperties[property];
              const endValue = featureProperties[property];
              let dValue = startValue + percentProperty * (endValue - startValue);
              if (animateProperty.bearing) {
                const bearingDifference = (endValue - startValue + 540) % 360 - 180;
                dValue = (startValue + percentProperty * bearingDifference + 360) % 360;
              }
              properties[property] = dValue;
            });
            animatedFeatures.push({
              type: feature2.type,
              geometry: {
                type: feature2.geometry.type,
                coordinates: [dLongitude, dLatitude]
              },
              properties: Object.assign({}, featureProperties, properties),
              style: feature2.style
            });
          });
          layer2._onNewData(_$1.isNil(removeMissing) ? layer2.options.removeMissing : removeMissing, animatedFeatures);
          options.lastTime = timestamp;
          options.id = requestAnimationFrame(options.step);
        } else {
          delete options.id;
        }
      };
    },
    updateLayer(name, geoJson, options = {}) {
      let layer2 = this.getLeafletLayerByName(name);
      if (!layer2) return;
      if (!_$1.get(layer2, "options.realtime")) {
        logger$1.warn(`Impossible to update non-realtime layer ${name}`);
        return;
      }
      const replace = _$1.get(options, "replace", false);
      if (replace) {
        this.updateLayer(name, geoJson, { remove: true });
        this.updateLayer(name, geoJson, _$1.omit(options, ["replace"]));
      } else {
        const remove = typeof options === "boolean" ? options : options.remove;
        const removeMissing = _$1.get(options, "removeMissing", layer2.options.removeMissing);
        let container;
        if (layer2 instanceof L$1.MarkerClusterGroup) {
          container = layer2;
          layer2 = container.getLayers().find((layer3) => layer3._container === container);
        }
        if (remove) {
          if (typeof layer2.remove !== "function") return;
          let features = getGeoJsonFeatures(geoJson);
          features = features.filter((feature2) => layer2.getLayer(layer2.options.getFeatureId(feature2)));
          layer2.remove(features);
        } else if (geoJson) {
          if (typeof layer2._onNewData === "function") {
            let duration = _$1.get(options, "duration", 0);
            const features = Array.isArray(geoJson) ? geoJson : geoJson.type === "FeatureCollection" ? geoJson.features : [geoJson];
            if (duration && features.length === 0) {
              duration = 0;
            }
            if (duration && _$1.some(features, (feature2) => getType$1(feature2) !== "Point")) {
              logger$1.warn(`Impossible to animate layer ${name} as it does not contain only point geometries`);
              duration = 0;
            }
            if (duration) {
              _$1.defaultsDeep(options, {
                animate: {
                  geometry: { easing: { function: "linear" }, rhumb: false }
                }
              });
              const frameId = _$1.get(this.updateAnimations, `${name}.id`);
              if (!_$1.isNil(frameId)) cancelAnimationFrame(frameId);
              options.step = this.getUpdateAnimation(name, layer2, options, geoJson);
              options.id = requestAnimationFrame(options.step);
              _$1.set(this.updateAnimations, name, options);
            } else {
              _$1.unset(this.updateAnimations, name);
              layer2._onNewData(removeMissing, geoJson);
            }
          }
        } else {
          if (layer2.tiledLayer) layer2.tiledLayer.redraw();
          else if (typeof layer2.update === "function") layer2.update();
          else if (typeof layer2._onNewData === "function") layer2._onNewData(removeMissing, this.toGeoJson(name));
        }
        const baseLayer = this.getLayerByName(name);
        if (isInMemoryLayer(baseLayer)) {
          const geojson = layer2.toGeoJSON(false);
          this.geojsonCache[name] = geojson;
        }
      }
    },
    onLayerUpdated(layer2, leafletLayer, data) {
      this.$emit("layer-updated", layer2, leafletLayer, data);
      this.$engineEvents.emit("layer-updated", layer2, leafletLayer, data);
    },
    onCurrentTimeChangedGeoJsonLayers(time) {
      const geoJsonlayers = _$1.values(this.layers).filter(sift(GeoJsonLeafletLayerFilters.TimeUpdate));
      geoJsonlayers.forEach(async (geoJsonlayer) => {
        const layer2 = this.getLeafletLayerByName(geoJsonlayer.name);
        if (!layer2.lastUpdateTime || !this.shouldSkipFeaturesUpdate(layer2.lastUpdateTime, geoJsonlayer)) {
          layer2.lastUpdateTime = Time.getCurrentTime().clone();
          if (layer2.tiledLayer) {
            layer2.tiledLayer.redraw();
          } else {
            layer2.update();
          }
        }
      });
    },
    onCurrentLevelChangedGeoJsonLayers(level) {
      let layer2 = this.selectableLevelsLayer;
      if (layer2) {
        const type = _$1.get(layer2, `${this.engine}.type`);
        if (type === "geoJson") {
          layer2 = this.getLeafletLayerByName(layer2.name);
          if (layer2.tiledLayer) {
            layer2.tiledLayer.redraw();
          } else {
            layer2.update();
          }
        }
      }
    },
    onDefaultUnitChangedGeoJsonLayers(units) {
      _$1.forOwn(units.default, (unit, quantity) => {
        const units2 = _$1.map(Units.getUnits(quantity), "name");
        let geoJsonlayers = _$1.values(this.layers).filter(sift(GeoJsonLeafletLayerFilters.UnitUpdate));
        geoJsonlayers = geoJsonlayers.filter((layer2) => {
          return hasUnitInLeafletLayerTemplate(units2, layer2);
        });
        geoJsonlayers.forEach((layer2) => {
          layer2 = this.getLeafletLayerByName(layer2.name);
          if (layer2.tiledLayer) {
            layer2.tiledLayer.redraw();
          } else {
            layer2.update();
          }
        });
      });
    },
    onMapZoomChangedGeoJsonLayers() {
      const geoJsonlayers = _$1.values(this.layers).filter(sift(GeoJsonLeafletLayerFilters.TooltipUpdate));
      geoJsonlayers.forEach(async (geoJsonlayer) => {
        const layer2 = this.getLeafletLayerByName(geoJsonlayer.name);
        const minZoom = _$1.get(geoJsonlayer, "leaflet.tooltip.minZoom");
        const maxZoom = _$1.get(geoJsonlayer, "leaflet.tooltip.maxZoom");
        const zoom = this.map.getZoom();
        let showTooltips = true;
        if (maxZoom && zoom > maxZoom) showTooltips = false;
        if (minZoom && zoom < minZoom) showTooltips = false;
        if (layer2.showTooltips !== showTooltips) {
          layer2.showTooltips = showTooltips;
          this.updateLayer(geoJsonlayer.name, this.toGeoJson(geoJsonlayer.name));
        }
      });
    },
    onLayerShownGeoJsonLayers(layer2, engineLayer) {
      const cachedGeojson = this.geojsonCache[layer2.name];
      if (cachedGeojson) {
        if (isInMemoryLayer(layer2)) {
          if (engineLayer instanceof L$1.MarkerClusterGroup) {
            const container = engineLayer;
            engineLayer = container.getLayers().find((layer3) => layer3._container === container);
          }
          engineLayer._onNewData(false, cachedGeojson);
        } else {
          delete this.geojsonCache[layer2.name];
        }
      }
    },
    onLayerRemovedGeoJsonLayers(layer2) {
      if (_$1.has(this.geojsonCache, layer2.name)) {
        delete this.geojsonCache[layer2.name];
      }
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGeoJsonLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers);
    this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers);
    Events.on("units-changed", this.onDefaultUnitChangedGeoJsonLayers);
    this.$engineEvents.on("zoomend", this.onMapZoomChangedGeoJsonLayers);
    this.$engineEvents.on("layer-shown", this.onLayerShownGeoJsonLayers);
    this.$engineEvents.on("layer-removed", this.onLayerRemovedGeoJsonLayers);
    this.updateAnimations = {};
    this.geojsonCache = {};
  },
  beforeUnmount() {
    Events.off("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers);
    this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedGeoJsonLayers);
    Events.off("units-changed", this.onDefaultUnitChangedGeoJsonLayers);
    this.$engineEvents.off("zoomend", this.onMapZoomChangedGeoJsonLayers);
    this.$engineEvents.off("layer-shown", this.onLayerShownGeoJsonLayers);
    this.$engineEvents.off("layer-removed", this.onLayerRemovedGeoJsonLayers);
    this.geojsonCache = {};
  }
};
const fileLayers$1 = {
  methods: {
    async importFiles(filelist) {
      const acceptedFiles = await Reader.filter(filelist);
      for (let i = 0; i < acceptedFiles.length; i++) {
        const file = acceptedFiles[i];
        try {
          const content = await Reader.read(file);
          const name = path.basename(file.name, path.extname(file.name));
          const description = _$1.join(_$1.map(file.files, (subfile) => subfile.name), ",");
          await this.addGeoJsonLayer({ name, description }, content);
        } catch (error) {
        }
      }
    }
  },
  mounted() {
    this.$engineEvents.on("map-ready", () => {
      const container = this.map.getContainer();
      const dropFileInput = document.createElement("input");
      dropFileInput.setAttribute("id", "dropFileInput");
      dropFileInput.type = "file";
      dropFileInput.style.display = "none";
      dropFileInput.addEventListener("change", async (event) => {
        logger$1.debug("[KDK] processing dropped files: ", event.target.files);
        await this.importFiles(event.target.files);
      });
      container.appendChild(dropFileInput);
      this.map._container.addEventListener("dragenter", () => this.map.scrollWheelZoom.disable(), false);
      this.map._container.addEventListener("dragleave", () => this.map.scrollWheelZoom.enable(), false);
      this.map._container.addEventListener("dragover", (event) => {
        event.stopPropagation();
        event.preventDefault();
      }, false);
      this.map._container.addEventListener("drop", async (event) => {
        logger$1.debug("[KDK] processing dropped files: ", event.dataTransfer.files);
        event.stopPropagation();
        event.preventDefault();
        await this.importFiles(event.dataTransfer.files);
        this.map.scrollWheelZoom.enable();
      }, false);
    });
  }
};
function bearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.final === true) {
    return calculateFinalBearing(start, end);
  }
  var coordinates1 = getCoord(start);
  var coordinates2 = getCoord(end);
  var lon1 = degreesToRadians(coordinates1[0]);
  var lon2 = degreesToRadians(coordinates2[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
  var bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}
const mapEditEvents = ["pm:drawstart", "pm:drawend", "pm:create"];
const layerEditEvents = ["layerremove", "pm:update", "pm:dragend", "pm:rotateend", "pm:markerdragend"];
const editHelpersPaneName = "editHelpersPane";
const editLayers = {
  emits: [
    "edit-start",
    "edit-stop",
    "edit-point-moved"
  ],
  data() {
    return {
      editingLayer: false,
      allowedLayerEditModes: [],
      layerEditMode: ""
    };
  },
  watch: {
    async $route(to, from) {
      if (!this.editedFeature) return;
      if (_$1.get(to, "params.featureId")) {
        this.editedPopup = this.editedFeature.getPopup();
        if (this.editedPopup) this.editedFeature.unbindPopup(this.editedPopup);
      } else if (_$1.get(from, "params.featureId")) {
        if (this.editedPopup) this.editedFeature.bindPopup(this.editedPopup);
        const service2 = this.editedLayer._id ? _$1.get(this.editedLayer, "service", "features") : "features-edition";
        const feature2 = await api.getService(service2).get(this.editedFeature.feature._id);
        this.editableLayer.removeLayer(this.editedFeature);
        this.editableLayer.addData(feature2);
        this.editedPopup = null;
        this.editedFeature = null;
      }
    }
  },
  methods: {
    isLayerEdited(layer2) {
      return this.editedLayer && this.editedLayer.name === layer2.name;
    },
    getGeoJsonEditOptions(options, geometryTypes) {
      let filteredOptions = options;
      const leafletOptions = options.leaflet || options;
      const layerStyle = {};
      layerStyle.layerPointStyle = leafletOptions.style ? _$1.get(leafletOptions.style, "point") : convertSimpleStyleToPointStyle(leafletOptions);
      layerStyle.layerLineStyle = leafletOptions.style ? _$1.get(leafletOptions.style, "line") : convertSimpleStyleToLineStyle(leafletOptions);
      layerStyle.layerPolygonStyle = leafletOptions.style ? _$1.get(leafletOptions.style, "polygon") : convertSimpleStyleToPolygonStyle(leafletOptions);
      if (_$1.has(filteredOptions, "leaflet.tooltip") || _$1.has(filteredOptions, "leaflet.popup")) {
        filteredOptions = Object.assign({}, options);
        if (filteredOptions.leaflet.tooltip) delete filteredOptions.leaflet.tooltip;
        if (filteredOptions.leaflet.popup) delete filteredOptions.leaflet.popup;
      }
      const { onEachFeature, style: style2, pointToLayer } = this.getGeoJsonOptions(filteredOptions);
      return {
        // Ensure it is on top of all others layers while editing
        pane: "popupPane",
        // Allow geoman edition
        pmIgnore: false,
        onEachFeature,
        // Use default styling when editing as dynamic styling can conflict
        style: (feature2) => {
          const isLine = feature2.geometry.type === "LineString" || feature2.geometry.type === "MultiLineString";
          if (isLine) {
            if (!_$1.isEmpty(geometryTypes) && !geometryTypes.includes("LineString") && !geometryTypes.includes("MultiLineString")) return style2(feature2);
            else return getDefaultLineStyle(feature2, layerStyle, _$1.get(this, "activityOptions.engine.style.edition.line"));
          }
          const isPolygon = feature2.geometry.type === "Polygon" || feature2.geometry.type === "MultiPolygon";
          if (isPolygon) {
            if (!_$1.isEmpty(geometryTypes) && !geometryTypes.includes("Polygon") && !geometryTypes.includes("MultiPolygon")) return style2(feature2);
            else return getDefaultPolygonStyle(feature2, layerStyle, _$1.get(this, "activityOptions.engine.style.edition.polygon"));
          }
          logger.warn(`[KDK] the geometry of type of ${feature2.geometry.type} is not supported`);
        },
        pointToLayer: (feature2, latlng) => {
          if (!_$1.isEmpty(geometryTypes) && !geometryTypes.includes("Point") && !geometryTypes.includes("MultiPoint")) return pointToLayer(feature2, layer);
          const style3 = getDefaultPointStyle(feature2, layerStyle, _$1.get(this, "activityOptions.engine.style.edition.point"));
          style3.options = { pmIgnore: false };
          return createMarkerFromPointStyle(latlng, style3);
        }
      };
    },
    setEditMode(mode) {
      if (!this.editableLayer) return;
      if (this.map.pm.globalDrawModeEnabled()) this.map.pm.disableDraw();
      if (this.map.pm.globalEditModeEnabled()) this.map.pm.disableGlobalEditMode();
      if (this.map.pm.globalDragModeEnabled()) this.map.pm.disableGlobalDragMode();
      if (this.map.pm.globalRemovalModeEnabled()) this.map.pm.disableGlobalRemovalMode();
      if (this.map.pm.globalRotateModeEnabled()) this.map.pm.disableGlobalRotateMode();
      this.map.pm.setGlobalOptions({
        layerGroup: this.map,
        // Ensure it is on top of all others layers while editing
        panes: {
          layerPane: editHelpersPaneName,
          vertexPane: editHelpersPaneName,
          markerPane: editHelpersPaneName
        }
      });
      if (this.allowedLayerEditModes.indexOf(mode) === -1) return;
      if (mode === "edit-properties") ;
      else if (mode === "edit-geometry") {
        this.map.pm.enableGlobalEditMode();
      } else if (mode === "drag") {
        this.map.pm.enableGlobalDragMode();
      } else if (mode === "rotate") {
        this.map.pm.enableGlobalRotateMode();
      } else if (mode === "remove") {
        this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer });
        this.map.pm.enableGlobalRemovalMode();
      } else if (mode === "add-polygons") {
        this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer });
        this.map.pm.enableDraw("Polygon", { continueDrawing: true });
      } else if (mode === "add-rectangles") {
        this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer });
        this.map.pm.enableDraw("Rectangle", { continueDrawing: true });
      } else if (mode === "add-lines") {
        this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer });
        this.map.pm.enableDraw("Line", { continueDrawing: true });
      } else if (mode === "add-points") {
        this.map.pm.setGlobalOptions({ layerGroup: this.editableLayer });
        this.map.pm.enableDraw("Marker", { continueDrawing: true });
      }
      this.layerEditMode = mode;
    },
    async startEditLayer(layer2, {
      features = [],
      // Target features to be edited, otherwise the whole layer will be
      geometryTypes = [],
      // Target geometry types to be edited, otherwise the whole layer will be
      allowedEditModes = null,
      editMode = null,
      zIndex = -1,
      callback = null
      // Callback function to be called once edition is started/ended
    } = {}) {
      if (this.editedLayer) {
        await this.stopEditLayer("accept");
      }
      const leafletLayer = this.getLeafletLayerByName(layer2.name);
      if (!leafletLayer) return;
      this.allowedLayerEditModes = allowedEditModes || [
        "edit-properties",
        "edit-geometry",
        "drag",
        "rotate",
        "remove",
        "add-polygons",
        "add-rectangles",
        "add-lines",
        "add-points"
      ];
      this.editedLayer = layer2;
      this.editingLayer = true;
      this.editingCallback = callback;
      if (typeof this.setHighlightsEnabled === "function") this.setHighlightsEnabled(layer2, false);
      if (typeof this.setSelectionEnabled === "function") this.setSelectionEnabled(false);
      this.onEditStart(this.editedLayer);
      const geoJson = leafletLayer.toGeoJSON();
      let editedFeatures = getGeoJsonFeatures(geoJson);
      if (_$1.isEmpty(features) && _$1.isEmpty(geometryTypes)) {
        leafletLayer.clearLayers();
      } else if (!_$1.isEmpty(features)) {
        editedFeatures = editedFeatures.filter((feature2) => features.includes(getFeatureId(feature2, layer2)));
        leafletLayer.getLayers().forEach((layer3) => {
          const feature2 = layer3.feature;
          if (features.includes(getFeatureId(feature2, layer3))) leafletLayer.removeLayer(layer3);
        });
      } else if (!_$1.isEmpty(geometryTypes)) {
        editedFeatures = editedFeatures.filter((feature2) => geometryTypes.includes(_$1.get(feature2, "geometry.type")));
        leafletLayer.getLayers().forEach((layer3) => {
          const feature2 = layer3.feature;
          if (geometryTypes.includes(_$1.get(feature2, "geometry.type"))) leafletLayer.removeLayer(layer3);
        });
      }
      if (this.editedLayer._id === void 0) {
        for (const feature2 of editedFeatures) {
          feature2._id = uid$2().toString();
          await api.getService("features-edition").create(feature2);
        }
      } else {
        this.editedLayerServiceEventListeners = listenToFeaturesServiceEventsForLayer(this.editedLayer, {
          created: this.onEditedFeaturesCreated,
          updated: this.onEditedFeaturesUpdated,
          patched: this.onEditedFeaturesUpdated,
          removed: this.onEditedFeaturesRemoved
        });
      }
      this.editableLayer = L$1.geoJson(editedFeatures, this.getGeoJsonEditOptions(layer2, geometryTypes));
      this.map.addLayer(this.editableLayer);
      bindLeafletEvents(this.map, mapEditEvents, this);
      bindLeafletEvents(this.editableLayer, layerEditEvents, this);
      this.$engineEvents.on("click", this.onEditFeatureProperties);
      this.$engineEvents.on("mousemove", this.onMouseMoveWhileEditing);
      this.$engineEvents.on("zoomend", this.onMapZoomWhileEditing);
      this.$engineEvents.on("pm:drawstart", this.onDrawStart);
      this.$engineEvents.on("pm:drawend", this.onDrawEnd);
      this.$engineEvents.on("pm:create", this.onCreateFeatures);
      this.$engineEvents.on("pm:update", this.onEditFeatures);
      this.$engineEvents.on("pm:dragend", this.onEditFeatures);
      this.$engineEvents.on("pm:rotateend", this.onEditFeatures);
      this.$engineEvents.on("layerremove", this.onRemoveFeatures);
      this.$engineEvents.on("pm:markerdragend", this.onPointMoveEnd);
      let pane = this.map.getPane(editHelpersPaneName);
      if (!pane) pane = this.map.createPane(editHelpersPaneName);
      _$1.set(pane, "style.zIndex", zIndex !== -1 ? zIndex : 700);
      if (editMode) this.setEditMode(editMode);
    },
    onEditStart(layer2) {
      this.$emit("edit-start", { layer: layer2 });
      this.$engineEvents.emit("edit-start", { layer: layer2 });
      if (this.editingCallback) this.editingCallback({ status: "edit-start", layer: layer2 });
    },
    async stopEditLayer(status = "accept") {
      if (!this.editedLayer) return;
      const leafletLayer = this.getLeafletLayerByName(this.editedLayer.name);
      if (!leafletLayer) return;
      if (this.map.pm.globalDrawModeEnabled()) this.map.pm.disableDraw();
      if (this.map.pm.globalEditModeEnabled()) this.map.pm.disableGlobalEditMode();
      if (this.map.pm.globalDragModeEnabled()) this.map.pm.disableGlobalDragMode();
      if (this.map.pm.globalRemovalModeEnabled()) this.map.pm.disableGlobalRemovalMode();
      if (this.map.pm.globalRotateModeEnabled()) this.map.pm.disableGlobalRotateMode();
      this.map.pm.setGlobalOptions({ layerGroup: this.map });
      unbindLeafletEvents(this.map, mapEditEvents);
      unbindLeafletEvents(this.editableLayer, layerEditEvents);
      if (this.pendingOperations.length > 0) {
        const allOps = this.pendingOperations.flat();
        await Promise.all(allOps);
      }
      if (this.editedLayer._id === void 0) {
        const geoJson = this.editableLayer.toGeoJSON();
        const features = getGeoJsonFeatures(geoJson);
        const service2 = api.getService("features-edition");
        await Promise.all(features.map((f) => service2.remove(f._id)));
      } else {
        unlistenToFeaturesServiceEventsForLayer(this.editedLayer, this.editedLayerServiceEventListeners);
      }
      this.map.removeLayer(this.editableLayer);
      leafletLayer.addLayer(this.editableLayer);
      if (typeof this.setHighlightsEnabled === "function") this.setHighlightsEnabled(this.editedLayer, true);
      if (typeof this.setSelectionEnabled === "function") this.setSelectionEnabled(true);
      this.onEditStop(status, this.editedLayer);
      this.editedLayer = null;
      this.editingLayer = false;
      this.editingCallback = null;
      this.$engineEvents.off("click", this.onEditFeatureProperties);
      this.$engineEvents.off("mousemove", this.onMouseMoveWhileEditing);
      this.$engineEvents.off("zoomend", this.onMapZoomWhileEditing);
      this.$engineEvents.off("pm:drawstart", this.onDrawStart);
      this.$engineEvents.off("pm:drawend", this.onDrawEnd);
      this.$engineEvents.off("pm:create", this.onCreateFeatures);
      this.$engineEvents.off("pm:update", this.onEditFeatures);
      this.$engineEvents.off("pm:dragend", this.onEditFeatures);
      this.$engineEvents.off("pm:rotateend", this.onEditFeatures);
      this.$engineEvents.off("layerremove", this.onRemoveFeatures);
      this.$engineEvents.off("pm:markerdragend", this.onPointMoveEnd);
    },
    onEditStop(status, layer2) {
      this.$emit("edit-stop", { status, layer: layer2 });
      this.$engineEvents.emit("edit-stop", { status, layer: layer2 });
      if (this.editingCallback) this.editingCallback({ status, layer: layer2 });
    },
    resetEditionTooltip() {
      if (!this.hintTooltip) return;
      this.hintTooltipInitialContent = this.hintTooltip.getContent();
    },
    updateEditionTooltip(event) {
      if (!this.hintTooltip) return;
      const { latlng } = event;
      if (_$1.isNil(latlng)) return;
      let tooltip2 = this.hintTooltipInitialContent;
      const modesWithCoordinates = ["add-polygons", "add-rectangles", "add-lines", "add-points"];
      const modesWithOrientation = ["add-polygons", "add-lines"];
      if (modesWithCoordinates.includes(this.layerEditMode)) {
        tooltip2 += `<br/>${formatUserCoordinates(latlng.lat, latlng.lng, Store.get("locationFormat", "FFf"))}`;
      }
      if (modesWithOrientation.includes(this.layerEditMode) && this.workingLayer) {
        const coordinates = getCoords(this.workingLayer.toGeoJSON());
        if (coordinates.length > 0) {
          const angle2 = bearing(coordinates[coordinates.length - 1], [latlng.lng, latlng.lat]);
          tooltip2 += `<br/>${Units.format(angle2, "deg", Units.getDefaultUnit("angle"))}`;
        }
      }
      this.hintTooltip.setContent(tooltip2);
    },
    onDrawStart(event) {
      this.hintMarker = _$1.get(this.map.pm, `${event.source}.${event.shape}._hintMarker`);
      if (!this.hintMarker) return;
      this.hintTooltip = this.hintMarker.getTooltip();
      if (!this.hintTooltip) return;
      if (event.workingLayer) {
        this.workingLayer = event.workingLayer;
        this.workingLayer.on("pm:vertexadded", this.onVertexAddedWhileEditing);
      }
      this.resetEditionTooltip();
    },
    onDrawEnd(event) {
      if (this.hintTooltip) {
        if (this.workingLayer) this.workingLayer.off("pm:vertexadded", this.onVertexAddedWhileEditing);
      }
      this.hintMarker = null;
      this.hintTooltip = null;
    },
    onMouseMoveWhileEditing(options, event) {
      this.updateEditionTooltip(event);
    },
    onVertexAddedWhileEditing(event) {
      this.resetEditionTooltip();
    },
    async onEditFeatureProperties(layer2, event) {
      const leafletLayer = event && event.target;
      const feature2 = _$1.get(leafletLayer, "feature");
      if (this.layerEditMode !== "edit-properties" || !this.isLayerEdited(layer2) || !_$1.get(layer2, "schema.content") || !leafletLayer || !feature2) return;
      this.editedFeature = leafletLayer;
      this.$router.push({
        name: "edit-map-layer-feature",
        query: this.$route.query,
        params: Object.assign(this.$route.params, {
          layerId: this.editedLayer._id,
          layerName: this.editedLayer.name,
          featureId: feature2._id,
          contextId: Store.get("context")
        })
      });
    },
    async onCreateFeatures(event) {
      const leafletLayer = event && event.layer;
      if (this.layerEditMode !== "add-polygons" && this.layerEditMode !== "add-rectangles" && this.layerEditMode !== "add-lines" && this.layerEditMode !== "add-points" || !leafletLayer) return;
      let geoJson = leafletLayer.toGeoJSON();
      if (this.createdFeature && this.createdFeature._id === geoJson._id) return;
      const idValue = uid$2().toString();
      let idProp = _$1.get(this.editedLayer, "featureId");
      idProp = idProp && idProp !== "_id" ? "properties." + idProp : "_id";
      _$1.set(geoJson, idProp, idValue);
      if (this.editedLayer._id) {
        geoJson = await this.createFeatures(geoJson, this.editedLayer);
      } else {
        geoJson._id = idValue;
        await api.getService("features-edition").create(geoJson);
      }
      this.editableLayer.removeLayer(leafletLayer);
      this.editableLayer.addData(geoJson);
    },
    async onEditFeatures(event) {
      const leafletLayer = event && event.layer;
      if (this.layerEditMode !== "edit-geometry" && this.layerEditMode !== "drag" && this.layerEditMode !== "rotate" || !leafletLayer) return;
      const geoJson = leafletLayer.toGeoJSON();
      if (this.updatedFeature && this.updatedFeature._id === geoJson._id) return;
      if (this.editedLayer._id) {
        await this.editFeaturesGeometry(geoJson, this.editedLayer);
      } else {
        const features = getGeoJsonFeatures(geoJson);
        const service2 = api.getService("features-edition");
        const operations = Promise.all(features.map((f) => service2.patch(f._id, { geometry: f.geometry })));
        this.pendingOperations.push(operations);
        await operations;
        const index2 = this.pendingOperations.indexOf(operations);
        this.pendingOperations.splice(index2, 1);
      }
    },
    async onRemoveFeatures(event) {
      const leafletLayer = event && event.layer;
      if (this.layerEditMode !== "remove" || !leafletLayer) return;
      if (!event.target || event.target !== this.editableLayer) return;
      const geoJson = leafletLayer.toGeoJSON();
      if (this.removedFeature && this.removedFeature._id === geoJson._id) return;
      if (this.editedLayer._id) {
        await this.removeFeatures(geoJson, this.editedLayer);
      } else {
        const features = getGeoJsonFeatures(geoJson);
        const service2 = api.getService("features-edition");
        await Promise.all(features.map((f) => service2.remove(f._id)));
      }
    },
    onMapZoomWhileEditing(event) {
      if (this.editableLayer) {
        this.editableLayer.bringToFront();
      }
    },
    onPointMoveEnd(event) {
      if (typeof event.layer.getLatLngs !== "function") return;
      let coords = event.layer.getLatLngs();
      for (let deep = 0; deep < event.indexPath.length; ++deep) {
        coords = coords[event.indexPath[deep]];
      }
      const polylineIndex = this.editableLayer.pm._layers.findIndex((layer2) => layer2._leaflet_id === event.layer._leaflet_id);
      const pointPath = event.indexPath.slice(0, event.indexPath.length);
      pointPath.splice(0, 0, polylineIndex);
      this.onEditPointMoved(pointPath, coords, "user");
    },
    moveEditPoint(pointPath, newLat, newLon, origin) {
      if (!this.editingLayer) return;
      const leafletCoords = L$1.latLng(newLat, newLon);
      const polylineIndex = pointPath[0];
      const markerPath = pointPath.slice(1, pointPath.length);
      const polyline = this.editableLayer.pm._layers[polylineIndex];
      const coords = polyline.getLatLngs();
      const parentPath = markerPath.slice(0, markerPath.length - 1);
      const index2 = markerPath[markerPath.length - 1];
      let parentArr = coords;
      for (const i of parentPath) {
        parentArr = parentArr[i];
      }
      parentArr[index2] = leafletCoords;
      polyline.setLatLngs(coords);
      let marker = polyline.pm._markers;
      for (const i of markerPath) {
        marker = marker[i];
      }
      marker.setLatLng(leafletCoords);
      this.onEditPointMoved(pointPath, leafletCoords, origin || "app");
    },
    onEditPointMoved(pointPath, coords, origin) {
      const args = {
        layer: this.editedLayer,
        pointPath,
        latitude: coords.lat,
        longitude: coords.lng,
        origin
      };
      this.$emit("edit-point-moved", args);
      this.$engineEvents.emit("edit-point-moved", args);
    },
    onEditedFeaturesCreated(feature2, layer2) {
      if (!getType(feature2) || !getGeom(feature2)) return;
      if (!layer2 && feature2.layer) layer2 = this.getLayerById(feature2.layer);
      if (!layer2 || !this.isLayerEdited(layer2)) return;
      this.createdFeature = feature2;
      this.editableLayer.addData(feature2);
      this.createdFeature = null;
    },
    onEditedFeaturesUpdated(feature2, layer2) {
      if (!getType(feature2) || !getGeom(feature2)) return;
      if (!layer2 && feature2.layer) layer2 = this.getLayerById(feature2.layer);
      if (!layer2 || !this.isLayerEdited(layer2)) return;
      this.updatedFeature = feature2;
      this.editableLayer.eachLayer((layer3) => {
        if (_$1.get(layer3, "feature._id") === feature2._id) {
          this.editableLayer.removeLayer(layer3);
          this.editableLayer.addData(feature2);
        }
      });
      this.updatedFeature = null;
    },
    onEditedFeaturesRemoved(feature2, layer2) {
      if (!getType(feature2) || !getGeom(feature2)) return;
      if (!layer2 && feature2.layer) layer2 = this.getLayerById(feature2.layer);
      if (!layer2 || !this.isLayerEdited(layer2)) return;
      this.removedFeature = feature2;
      this.editableLayer.eachLayer((layer3) => {
        if (_$1.get(layer3, "feature._id") === feature2._id) {
          this.editableLayer.removeLayer(layer3);
        }
      });
      this.removedFeature = null;
    }
  },
  created() {
    this.pendingOperations = [];
  }
};
const style$1 = {
  created() {
    this.registerStyle("point", getDefaultPointStyle);
    this.registerStyle("line", getDefaultLineStyle);
    this.registerStyle("polygon", getDefaultPolygonStyle);
  }
};
const tooltip$1 = {
  methods: {
    getDefaultTooltip(feature2, layer2, options, zoom) {
      const properties = feature2.properties;
      let tooltip2;
      if (properties) {
        const leafletOptions = options.leaflet || options;
        if (_$1.has(leafletOptions, "tooltip") && !_$1.get(leafletOptions, "tooltip")) return;
        if (_$1.has(properties, "tooltip") && !_$1.get(properties, "tooltip")) return;
        const tooltipStyle = Object.assign(
          {},
          _$1.get(this, "activityOptions.engine.tooltip"),
          leafletOptions.tooltip,
          properties.tooltip
        );
        const minZoom = _$1.get(leafletOptions, "tooltip.minZoom");
        const maxZoom = _$1.get(leafletOptions, "tooltip.maxZoom");
        if (maxZoom && zoom > maxZoom || minZoom && zoom < minZoom) return;
        let html = tooltipStyle.html;
        if (!html) {
          if (tooltipStyle.property) {
            html = _$1.has(properties, tooltipStyle.property) ? _$1.get(properties, tooltipStyle.property) : _$1.get(feature2, tooltipStyle.property);
            if (html && typeof html.toString === "function") html = html.toString();
          } else if (tooltipStyle.template) {
            const compiler = tooltipStyle.compiler;
            html = compiler({ properties, feature: feature2, $t: this.$t, Units, Time, moment });
          }
        }
        if (html) {
          tooltip2 = L$1.tooltip(tooltipStyle.options || { permanent: false }, layer2);
          tooltip2.setContent(html);
        }
      }
      return tooltip2;
    }
  },
  created() {
    this.registerStyle("tooltip", this.getDefaultTooltip);
  }
};
const popup$1 = {
  methods: {
    getDefaultPopup(feature2, layer2, options) {
      let properties = feature2.properties;
      let popup2;
      if (properties) {
        const leafletOptions = options.leaflet || options;
        if (_$1.has(leafletOptions, "popup") && !_$1.get(leafletOptions, "popup")) return;
        if (_$1.has(properties, "popup") && !_$1.get(properties, "popup")) return;
        const popupStyle = Object.assign(
          {},
          _$1.get(this, "activityOptions.engine.popup"),
          leafletOptions.popup,
          properties.popup
        );
        let html = popupStyle.html;
        if (!html) {
          if (popupStyle.template) {
            const compiler = popupStyle.compiler;
            html = compiler({ properties, feature: feature2, $t: this.$t, Units, Time, moment });
          } else if (popupStyle.pick) {
            properties = _$1.pick(properties, popupStyle.pick);
          } else if (popupStyle.omit) {
            properties = _$1.omit(properties, popupStyle.omit);
          }
        }
        if (!html) html = getHtmlTable(properties);
        if (!html) return null;
        if (popupStyle.options) {
          popup2 = L$1.popup(popupStyle.options, layer2);
        } else {
          popup2 = L$1.popup({
            maxHeight: 400,
            maxWidth: 400,
            autoPan: false
          }, layer2);
        }
        popup2.setContent(html);
      }
      return popup2;
    }
  },
  created() {
    this.registerStyle("popup", this.getDefaultPopup);
  }
};
const activity$1 = {
  methods: {
    async initializeMap(container) {
      if (this.map) return;
      this.setupMap(container);
      await this.initialize();
      this.map.on("moveend", this.storeView);
    },
    finalizeMap() {
      this.map.off("moveend", this.storeView);
    },
    storeView() {
      if (typeof this.storeContext === "function") {
        if (!_$1.get(this.centerAnimation, "id")) this.storeContext("view");
      }
    },
    onMapResized(size) {
      if (this.observe) {
        this.refreshMap();
        if (this.mapContainer) {
          this.engineContainerWidth = this.mapContainer.getBoundingClientRect().width;
          this.engineContainerHeight = this.mapContainer.getBoundingClientRect().height;
        }
      }
    }
  },
  created() {
    this.engine = "leaflet";
    this.observe = true;
  },
  beforeUnmount() {
    this.observe = false;
    this.finalizeMap();
  }
};
var polyfill = {};
const privateData = /* @__PURE__ */ new WeakMap();
const wrappers = /* @__PURE__ */ new WeakMap();
function pd(event) {
  const retv = privateData.get(event);
  console.assert(
    retv != null,
    "'this' is expected an Event object, but got",
    event
  );
  return retv;
}
function setCancelFlag(data) {
  if (data.passiveListener != null) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "Unable to preventDefault inside passive event listener invocation.",
        data.passiveListener
      );
    }
    return;
  }
  if (!data.event.cancelable) {
    return;
  }
  data.canceled = true;
  if (typeof data.event.preventDefault === "function") {
    data.event.preventDefault();
  }
}
function Event(eventTarget, event) {
  privateData.set(this, {
    eventTarget,
    event,
    eventPhase: 2,
    currentTarget: eventTarget,
    canceled: false,
    stopped: false,
    immediateStopped: false,
    passiveListener: null,
    timeStamp: event.timeStamp || Date.now()
  });
  Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
  const keys = Object.keys(event);
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in this)) {
      Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
}
Event.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return pd(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return pd(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return pd(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const currentTarget = pd(this).currentTarget;
    if (currentTarget == null) {
      return [];
    }
    return [currentTarget];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return pd(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.stopPropagation === "function") {
      data.event.stopPropagation();
    }
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const data = pd(this);
    data.stopped = true;
    data.immediateStopped = true;
    if (typeof data.event.stopImmediatePropagation === "function") {
      data.event.stopImmediatePropagation();
    }
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return Boolean(pd(this).event.bubbles);
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return Boolean(pd(this).event.cancelable);
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    setCancelFlag(pd(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return pd(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return Boolean(pd(this).event.composed);
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return pd(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return pd(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return pd(this).stopped;
  },
  set cancelBubble(value) {
    if (!value) {
      return;
    }
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.cancelBubble === "boolean") {
      data.event.cancelBubble = true;
    }
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !pd(this).canceled;
  },
  set returnValue(value) {
    if (!value) {
      setCancelFlag(pd(this));
    }
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
  }
};
Object.defineProperty(Event.prototype, "constructor", {
  value: Event,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
  Object.setPrototypeOf(Event.prototype, window.Event.prototype);
  wrappers.set(window.Event.prototype, Event);
}
function defineRedirectDescriptor(key) {
  return {
    get() {
      return pd(this).event[key];
    },
    set(value) {
      pd(this).event[key] = value;
    },
    configurable: true,
    enumerable: true
  };
}
function defineCallDescriptor(key) {
  return {
    value() {
      const event = pd(this).event;
      return event[key].apply(event, arguments);
    },
    configurable: true,
    enumerable: true
  };
}
function defineWrapper(BaseEvent, proto) {
  const keys = Object.keys(proto);
  if (keys.length === 0) {
    return BaseEvent;
  }
  function CustomEvent(eventTarget, event) {
    BaseEvent.call(this, eventTarget, event);
  }
  CustomEvent.prototype = Object.create(BaseEvent.prototype, {
    constructor: { value: CustomEvent, configurable: true, writable: true }
  });
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in BaseEvent.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      const isFunc = typeof descriptor.value === "function";
      Object.defineProperty(
        CustomEvent.prototype,
        key,
        isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
      );
    }
  }
  return CustomEvent;
}
function getWrapper(proto) {
  if (proto == null || proto === Object.prototype) {
    return Event;
  }
  let wrapper = wrappers.get(proto);
  if (wrapper == null) {
    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
    wrappers.set(proto, wrapper);
  }
  return wrapper;
}
function wrapEvent(eventTarget, event) {
  const Wrapper = getWrapper(Object.getPrototypeOf(event));
  return new Wrapper(eventTarget, event);
}
function isStopped(event) {
  return pd(event).immediateStopped;
}
function setEventPhase(event, eventPhase) {
  pd(event).eventPhase = eventPhase;
}
function setCurrentTarget(event, currentTarget) {
  pd(event).currentTarget = currentTarget;
}
function setPassiveListener(event, passiveListener) {
  pd(event).passiveListener = passiveListener;
}
const listenersMap = /* @__PURE__ */ new WeakMap();
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;
function isObject(x) {
  return x !== null && typeof x === "object";
}
function getListeners(eventTarget) {
  const listeners = listenersMap.get(eventTarget);
  if (listeners == null) {
    throw new TypeError(
      "'this' is expected an EventTarget object, but got another value."
    );
  }
  return listeners;
}
function defineEventAttributeDescriptor(eventName) {
  return {
    get() {
      const listeners = getListeners(this);
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          return node.listener;
        }
        node = node.next;
      }
      return null;
    },
    set(listener) {
      if (typeof listener !== "function" && !isObject(listener)) {
        listener = null;
      }
      const listeners = getListeners(this);
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        node = node.next;
      }
      if (listener !== null) {
        const newNode = {
          listener,
          listenerType: ATTRIBUTE,
          passive: false,
          once: false,
          next: null
        };
        if (prev === null) {
          listeners.set(eventName, newNode);
        } else {
          prev.next = newNode;
        }
      }
    },
    configurable: true,
    enumerable: true
  };
}
function defineEventAttribute(eventTargetPrototype, eventName) {
  Object.defineProperty(
    eventTargetPrototype,
    `on${eventName}`,
    defineEventAttributeDescriptor(eventName)
  );
}
function defineCustomEventTarget(eventNames) {
  function CustomEventTarget() {
    EventTarget.call(this);
  }
  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
    constructor: {
      value: CustomEventTarget,
      configurable: true,
      writable: true
    }
  });
  for (let i = 0; i < eventNames.length; ++i) {
    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  }
  return CustomEventTarget;
}
function EventTarget() {
  if (this instanceof EventTarget) {
    listenersMap.set(this, /* @__PURE__ */ new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return defineCustomEventTarget(arguments[0]);
  }
  if (arguments.length > 0) {
    const types = new Array(arguments.length);
    for (let i = 0; i < arguments.length; ++i) {
      types[i] = arguments[i];
    }
    return defineCustomEventTarget(types);
  }
  throw new TypeError("Cannot call a class as a function");
}
EventTarget.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    if (typeof listener !== "function" && !isObject(listener)) {
      throw new TypeError("'listener' should be a function or an object.");
    }
    const listeners = getListeners(this);
    const optionsIsObj = isObject(options);
    const capture2 = optionsIsObj ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture2 ? CAPTURE : BUBBLE;
    const newNode = {
      listener,
      listenerType,
      passive: optionsIsObj && Boolean(options.passive),
      once: optionsIsObj && Boolean(options.once),
      next: null
    };
    let node = listeners.get(eventName);
    if (node === void 0) {
      listeners.set(eventName, newNode);
      return;
    }
    let prev = null;
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        return;
      }
      prev = node;
      node = node.next;
    }
    prev.next = newNode;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    const listeners = getListeners(this);
    const capture2 = isObject(options) ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture2 ? CAPTURE : BUBBLE;
    let prev = null;
    let node = listeners.get(eventName);
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
        return;
      }
      prev = node;
      node = node.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(event) {
    if (event == null || typeof event.type !== "string") {
      throw new TypeError('"event.type" should be a string.');
    }
    const listeners = getListeners(this);
    const eventName = event.type;
    let node = listeners.get(eventName);
    if (node == null) {
      return true;
    }
    const wrappedEvent = wrapEvent(this, event);
    let prev = null;
    while (node != null) {
      if (node.once) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
      } else {
        prev = node;
      }
      setPassiveListener(
        wrappedEvent,
        node.passive ? node.listener : null
      );
      if (typeof node.listener === "function") {
        try {
          node.listener.call(this, wrappedEvent);
        } catch (err) {
          if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(err);
          }
        }
      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
        node.listener.handleEvent(wrappedEvent);
      }
      if (isStopped(wrappedEvent)) {
        break;
      }
      node = node.next;
    }
    setPassiveListener(wrappedEvent, null);
    setEventPhase(wrappedEvent, 0);
    setCurrentTarget(wrappedEvent, null);
    return !wrappedEvent.defaultPrevented;
  }
};
Object.defineProperty(EventTarget.prototype, "constructor", {
  value: EventTarget,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}
class AbortSignal extends EventTarget {
  /**
   * AbortSignal cannot be constructed directly.
   */
  constructor() {
    super();
    throw new TypeError("AbortSignal cannot be constructed directly");
  }
  /**
   * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
   */
  get aborted() {
    const aborted = abortedFlags.get(this);
    if (typeof aborted !== "boolean") {
      throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
    }
    return aborted;
  }
}
defineEventAttribute(AbortSignal.prototype, "abort");
function createAbortSignal() {
  const signal = Object.create(AbortSignal.prototype);
  EventTarget.call(signal);
  abortedFlags.set(signal, false);
  return signal;
}
function abortSignal(signal) {
  if (abortedFlags.get(signal) !== false) {
    return;
  }
  abortedFlags.set(signal, true);
  signal.dispatchEvent({ type: "abort" });
}
const abortedFlags = /* @__PURE__ */ new WeakMap();
Object.defineProperties(AbortSignal.prototype, {
  aborted: { enumerable: true }
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortSignal"
  });
}
let AbortController$1 = class AbortController2 {
  /**
   * Initialize this controller.
   */
  constructor() {
    signals.set(this, createAbortSignal());
  }
  /**
   * Returns the `AbortSignal` object associated with this object.
   */
  get signal() {
    return getSignal(this);
  }
  /**
   * Abort and signal to any observers that the associated activity is to be aborted.
   */
  abort() {
    abortSignal(getSignal(this));
  }
};
const signals = /* @__PURE__ */ new WeakMap();
function getSignal(controller) {
  const signal = signals.get(controller);
  if (signal == null) {
    throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
  }
  return signal;
}
Object.defineProperties(AbortController$1.prototype, {
  signal: { enumerable: true },
  abort: { enumerable: true }
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
  Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {
    configurable: true,
    value: "AbortController"
  });
}
const abortController = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortController: AbortController$1,
  AbortSignal,
  default: AbortController$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(abortController);
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  const ac = require$$0;
  const g = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : (
    /* otherwise */
    void 0
  );
  if (g) {
    if (typeof g.AbortController === "undefined") {
      g.AbortController = ac.AbortController;
    }
    if (typeof g.AbortSignal === "undefined") {
      g.AbortSignal = ac.AbortSignal;
    }
  }
  return polyfill;
}
requirePolyfill();
PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2;
PIXI.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
(function() {
  const floatView = new Float32Array(1);
  const int32View = new Int32Array(floatView.buffer);
  return function toHalf2(val) {
    floatView[0] = val;
    const x = int32View[0];
    let bits = x >> 16 & 32768;
    let m = x >> 12 & 2047;
    const e = x >> 23 & 255;
    if (e < 103) {
      return bits;
    }
    if (e > 142) {
      bits |= 31744;
      bits |= (e === 255 ? 0 : 1) && x & 8388607;
      return bits;
    }
    if (e < 113) {
      m |= 2048;
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    bits += m & 1;
    return bits;
  };
})();
const WEBGL_FUNCTIONS = {
  latLonToWebMercator: `vec2 latLonToWebMercator(vec3 latLonZoom) {
  const float d = 3.14159265359 / 180.0;
  const float maxLat = 85.0511287798;     // max lat using Web Mercator, used by EPSG:3857 CRS
  const float R = 6378137.0;              // earth radius

  // project
  // float lat = max(min(maxLat, latLonZoom[0]), -maxLat);
  float lat = clamp(latLonZoom[0], -maxLat, maxLat);
  float sla = sin(lat * d);
  vec2 point = vec2(R * latLonZoom[1] * d, R * log((1.0 + sla) / (1.0 - sla)) / 2.0);

  // scale
  float scale = 256.0 * pow(2.0, latLonZoom[2]);

  // transform
  const float s = 0.5 / (3.14159265359 * R);
  const vec4 abcd = vec4(s, 0.5, -s, 0.5);

  return scale * ((point * abcd.xz) + abcd.yw);
}`,
  unpack2: `vec2 unpack2(vec2 v, vec4 offsetScale) {
  return offsetScale.xy + v * offsetScale.zw;
}`,
  rgbFromFloat: `vec4 rgbFromFloat(float v) {
  const uint mask = uint(0xFF);
  uint asuint = floatBitsToUint(v);
  return vec4(asuint & mask, (asuint >> 8) & mask, (asuint >> 16) & mask, (asuint >> 24) & mask) / vec4(255.0);
}`
};
PIXI.TYPES.HALF_FLOAT_VERTEX = 5131;
function buildShaderCode(features) {
  let vtxCode = "#version 300 es\nprecision highp float;";
  let frgCode = "#version 300 es\nprecision highp float;";
  vtxCode += "\n\n/// attributes, uniforms and varyings\n";
  frgCode += "\n\n/// uniforms and varyings\nout vec4 outColor;\n";
  for (const feat of features) {
    let addVtx = "";
    let addFrg = "";
    for (const v of _$1.get(feat, "vertex.attributes", [])) addVtx += `in ${v};
`;
    for (const v of _$1.get(feat, "vertex.uniforms", [])) addVtx += `uniform ${v};
`;
    for (const v of _$1.get(feat, "fragment.uniforms", [])) addFrg += `uniform ${v};
`;
    for (const v of _$1.get(feat, "varyings", [])) {
      addVtx += `out ${v};
`;
      addFrg += `in ${v};
`;
    }
    if (addVtx) vtxCode += `// ${feat.name} ------
${addVtx}`;
    if (addFrg) frgCode += `// ${feat.name} ------
${addFrg}`;
  }
  vtxCode += "\n/// additional functions\n";
  frgCode += "\n/// additional functions\n";
  for (const feat of features) {
    for (const v of _$1.get(feat, "vertex.functions", [])) vtxCode += `// ${feat.name} ------
${v}
`;
    for (const v of _$1.get(feat, "fragment.functions", [])) frgCode += `// ${feat.name} ------
${v}
`;
  }
  vtxCode += "\n/// vertex shader code\nvoid main()\n{\n";
  frgCode += "\n/// fragment shader code\nvoid main()\n{\n";
  for (const feat of features) {
    const vc = _$1.get(feat, "vertex.code");
    const fc = _$1.get(feat, "fragment.code");
    if (vc) vtxCode += `// ${feat.name} ------
${vc}
`;
    if (fc) frgCode += `// ${feat.name} ------
${fc}
`;
  }
  vtxCode += "}";
  frgCode += "}";
  return [vtxCode, frgCode];
}
function buildColorMapShaderCode(thresholds, colors2, interpolate) {
  for (let i = 1; i < thresholds.length; ++i) {
    if (thresholds[i - 1] > thresholds[i]) {
      throw new Error("Threshold array is not correctly sorted, color map shader code will be buggy!");
    }
  }
  let code = "vec4 ColorMap(float value) {\n";
  for (let i = 0; i < colors2.length; ++i) {
    code += `  const vec4 color${i} = vec4(${colors2[i].join(",")});
`;
  }
  code += "\n";
  if (!interpolate) {
    for (let i = 1; i < thresholds.length - 1; ++i) {
      const threshold = thresholds[i];
      code += `  if (value < float(${threshold})) { return color${i - 1}; }
`;
    }
    code += `  return color${colors2.length - 1};
`;
  } else {
    code += `  if (value < float(${thresholds[0]})) { return color0; }
`;
    for (let i = 1; i < thresholds.length; ++i) {
      const t0 = thresholds[i - 1];
      const t1 = thresholds[i];
      const dt = t1 - t0;
      code += `  if (value <= float(${t1})) { float t = (value - float(${t0})) / float(${dt}); return mix(color${i - 1}, color${i}, t); }
`;
    }
    code += `  return color${colors2.length - 1};
`;
  }
  code += "}";
  return code;
}
function buildColorMapShaderCodeFromDomain(domain, colors2, invertScale = false) {
  let thresholds = [];
  let mapping = colors2.slice();
  if (domain.length === colors2.length) {
    thresholds = domain.slice();
  } else if (domain.length < colors2.length) {
    const step = (domain[domain.length - 1] - domain[0]) / (colors2.length - 1);
    for (let i = 0; i < colors2.length; ++i) {
      thresholds.push(domain[0] + i * step);
    }
  }
  if (thresholds[0] > thresholds[thresholds.length - 1]) {
    thresholds = thresholds.reverse();
    invertScale = !invertScale;
  }
  if (invertScale) {
    mapping = mapping.reverse();
  }
  return buildColorMapShaderCode(thresholds, mapping, true);
}
function buildColorMapShaderCodeFromClasses(breaks, colors2, invertScale) {
  let thresholds = breaks.slice();
  let mapping = colors2.slice();
  if (thresholds[0] > thresholds[thresholds.length - 1]) {
    thresholds = thresholds.reverse();
    invertScale = !invertScale;
  }
  if (invertScale) {
    mapping = mapping.reverse();
  }
  return buildColorMapShaderCode(thresholds, mapping, false);
}
const TiledMeshLayer = L$1.GridLayer.extend({
  initialize(options, gridSource) {
    this.conf = {};
    this.conf.chromajs = options.chromajs;
    this.conf.render = {
      cutOver: options.cutOver,
      cutUnder: options.cutUnder,
      pixelColorMapping: options.pixelColorMapping,
      showWireframe: options.showWireframe,
      enableCulling: _$1.get(options, "enableCulling", true)
    };
    this.conf.debug = {
      showTileInfos: options.showTileInfos,
      meshAsPoints: options.meshAsPoints,
      showShader: options.showShader
    };
    this.conf.resolutionScale = _$1.get(options, "resolutionScale", [1, 1]);
    L$1.GridLayer.prototype.initialize.call(this, options);
    this.pixiRoot = new PIXI.Container();
    this.pixiLayer = L$1.pixiOverlay(
      (utils) => this.renderPixiLayer(utils),
      this.pixiRoot,
      { destroyInteractionManager: true, shouldRedrawOnMove: function() {
        return true;
      } }
    );
    this.layerUniforms = new PIXI.UniformGroup({ in_layerAlpha: options.opacity, in_zoomLevel: 1 });
    this.pixiState = new PIXI.State();
    this.pixiState.culling = this.conf.render.enableCulling;
    this.pixiState.blendMode = PIXI.BLEND_MODES.SCREEN;
    this.cutValueUniform = null;
    if (options.cutOver) {
      this.layerUniforms.uniforms.in_cutOver = 0;
      if (options.cutOver === "levels") {
        this.cutValueUniform = "in_cutOver";
      } else {
        this.layerUniforms.uniforms.in_cutOver = options.cutOver;
      }
    }
    if (options.cutUnder) {
      this.layerUniforms.uniforms.in_cutUnder = 0;
      if (options.cutUnder === "levels") {
        this.cutValueUniform = "in_cutUnder";
      } else {
        this.layerUniforms.uniforms.in_cutUnder = options.cutUnder;
      }
    }
    this.on("tileload", (event) => {
      this.onTileLoad(event);
    });
    this.on("tileunload", (event) => {
      this.onTileUnload(event);
    });
    this.gridSource = gridSource;
    this.onDataChangedCallback = this.onDataChanged.bind(this);
    this.gridSource.on("data-changed", this.onDataChangedCallback);
  },
  onAdd(map) {
    map.addLayer(this.pixiLayer);
    this.layerUniforms.uniforms.in_zoomLevel = this.pixiLayer._initialZoom;
    this.zoomStartCallback = this.onZoomStart.bind(this);
    this.zoomEndCallback = this.onZoomEnd.bind(this);
    map.on("zoomstart", this.zoomStartCallback);
    map.on("zoomend", this.zoomEndCallback);
    L$1.GridLayer.prototype.onAdd.call(this, map);
  },
  onRemove(map) {
    map.off("zoomstart", this.zoomStartCallback);
    map.off("zoomend", this.zoomEndCallback);
    this.zoomStartCallback = null;
    this.zoomEndCallback = null;
    map.removeLayer(this.pixiLayer);
    L$1.GridLayer.prototype.onRemove.call(this, map);
  },
  createTile(coords, done) {
    const tile = document.createElement("div");
    const bounds = this._tileCoordsToBounds(coords);
    const reqBBox = [bounds.getSouth(), bounds.getWest(), bounds.getNorth(), bounds.getEast()];
    const tileSize = this.getTileSize();
    const resolution = [
      this.conf.resolutionScale[0] * ((reqBBox[2] - reqBBox[0]) / (tileSize.y - 1)),
      this.conf.resolutionScale[1] * ((reqBBox[3] - reqBBox[1]) / (tileSize.x - 1))
    ];
    tile.fetchController = new AbortController();
    this.gridSource.fetch(tile.fetchController.signal, reqBBox, resolution).then((grid2) => {
      tile.fetchController = null;
      if (grid2) {
        if (grid2.hasData()) {
          const { coords: coords2, minLat, minLon, deltaLat, deltaLon } = grid2.genCoordsBuffer();
          const values = grid2.genValuesBuffer();
          const indexes = grid2.genMeshIndexBuffer();
          const geometry = new PIXI.Geometry().addAttribute("in_layerCoord", coords2, 2, false, PIXI.TYPES.HALF_FLOAT_VERTEX).addAttribute("in_layerValue", values, 1, false, PIXI.TYPES.FLOAT).addIndex(indexes);
          const uniforms = {
            in_layerBounds: Float32Array.from(reqBBox),
            in_layerOffsetScale: Float32Array.of(minLat, minLon, deltaLat, deltaLon),
            layerUniforms: this.layerUniforms
          };
          if (grid2.nodata !== void 0) {
            uniforms.in_nodata = grid2.nodata;
          }
          const shader = new PIXI.Shader(this.program, uniforms);
          const mode = this.conf.debug.meshAsPoints ? PIXI.DRAW_MODES.POINTS : PIXI.DRAW_MODES.TRIANGLE_STRIP;
          tile.mesh = new PIXI.Mesh(geometry, shader, this.pixiState, mode);
          if (this.conf.render.showWireframe) {
            const wireframeGeometry = new PIXI.Geometry().addAttribute("in_layerCoord", geometry.getBuffer("in_layerCoord"), 2, false, PIXI.TYPES.HALF_FLOAT_VERTEX).addIndex(grid2.genWireframeIndexBuffer());
            const wireframeShader = new PIXI.Shader(this.wireframeProgram, uniforms);
            tile.wireframe = new PIXI.Mesh(wireframeGeometry, wireframeShader, this.pixiState, PIXI.DRAW_MODES.LINE_STRIP);
          }
          if (this.conf.debug.showTileInfos) {
            tile.innerHTML = `leaflet tile is ${tileSize.y} x ${tileSize.x} pixels</br>
                 covering ${reqBBox[0].toPrecision(6)},${reqBBox[1].toPrecision(6)} to ${reqBBox[2].toPrecision(6)},${reqBBox[3].toPrecision(6)}</br>
                 req res: ${resolution[0].toPrecision(4)} ${resolution[1].toPrecision(4)}</br>
                 mesh is made of ${values.length} points`;
            tile.style.outline = "1px solid green";
          }
        } else if (this.conf.debug.showTileInfos) {
          tile.style.outline = "1px solid red";
          tile.innerHTML = "no data here (grid maybe full of nodata)!";
        }
      } else if (this.conf.debug.showTileInfos) {
        tile.style.outline = "1px solid red";
        tile.innerHTML = "no data here (grid source returned null grid)!";
      }
      done(null, tile);
    }).catch((err) => {
      logger$1.error(err);
      done(err, tile);
    });
    return tile;
  },
  onTileLoad(event) {
    const mesh = event.tile.mesh;
    if (!mesh) return;
    mesh.zoomLevel = event.coords.z;
    mesh.visible = mesh.zoomLevel === this._map.getZoom();
    this.pixiRoot.addChild(mesh);
    if (this.conf.render.showWireframe) {
      const wireframe = event.tile.wireframe;
      wireframe.zoomLevel = mesh.zoomLevel;
      wireframe.visible = mesh.visible;
      this.pixiRoot.addChild(wireframe);
    }
    if (mesh.visible) {
      this.pixiLayer.redraw();
    }
  },
  onTileUnload(event) {
    if (event.tile.fetchController) {
      event.tile.fetchController.abort();
      event.tile.fetchController = null;
    }
    if (event.tile.mesh) {
      this.pixiRoot.removeChild(event.tile.mesh);
      if (this.conf.render.showWireframe) {
        this.pixiRoot.removeChild(event.tile.wireframe);
        event.tile.wireframe.destroy();
        event.tile.wireframe = null;
      }
      if (event.tile.mesh.visible) {
        this.pixiLayer.redraw();
      }
      event.tile.mesh.destroy();
      event.tile.mesh = null;
    }
  },
  onZoomStart(event) {
    const zoomLevel = this._map.getZoom();
    for (const child of this.pixiRoot.children) {
      if (child.zoomLevel === zoomLevel) child.visible = false;
    }
  },
  onZoomEnd(event) {
    const zoomLevel = this._map.getZoom();
    for (const child of this.pixiRoot.children) {
      if (child.zoomLevel === zoomLevel) child.visible = true;
    }
    this.pixiLayer.redraw();
  },
  onDataChanged() {
    const bbox2 = this.gridSource.getBBox();
    if (bbox2) {
      const c1 = L$1.latLng(bbox2[0], bbox2[1]);
      const c2 = L$1.latLng(bbox2[2], bbox2[3]);
      this.options.bounds = L$1.latLngBounds(c1, c2);
    }
    this.updateColorMap();
    this.updateShader();
    this.redraw();
    if (this.colorMap) {
      this.fire("data");
      this.hasData = true;
    }
  },
  updateColorMap() {
    const chromajs = this.conf.chromajs;
    if (_$1.isNil(chromajs)) return;
    this.colorMap = null;
    this.colorMapShaderCode = null;
    const classes = chromajs.classes;
    let domain;
    if (!classes) {
      domain = chromajs.domain;
      if (!domain) {
        domain = this.gridSource.getDataBounds();
      }
    }
    const scale2 = chroma.scale(chromajs.colors);
    const glcolors = scale2.colors().map((c) => chroma(c).gl());
    this.colorMap = buildColorScale(chromajs);
    if (domain) {
      this.colorMapShaderCode = buildColorMapShaderCodeFromDomain(domain, glcolors);
    } else if (classes) {
      this.colorMapShaderCode = buildColorMapShaderCodeFromClasses(classes, glcolors);
    }
  },
  updateShader() {
    const features = [
      // feature projecting layer position
      {
        name: "layerCoord",
        varyings: ["vec2 frg_layerCoord"],
        vertex: {
          attributes: ["vec2 in_layerCoord"],
          uniforms: ["mat3 translationMatrix", "mat3 projectionMatrix", "float in_zoomLevel", "vec4 in_layerOffsetScale"],
          functions: [WEBGL_FUNCTIONS.latLonToWebMercator, WEBGL_FUNCTIONS.unpack2],
          code: `  frg_layerCoord = unpack2(in_layerCoord, in_layerOffsetScale);
  vec2 projected = latLonToWebMercator(vec3(frg_layerCoord, in_zoomLevel));
  gl_Position = vec4((projectionMatrix * translationMatrix * vec3(projected, 1.0)).xy, 0.0, 1.0);
  ${this.conf.debug.meshAsPoints ? "gl_PointSize = 10.0;" : ""}`
        },
        fragment: {
          uniforms: ["vec4 in_layerBounds"],
          code: `  bvec4 outside = bvec4(lessThan(frg_layerCoord, in_layerBounds.xy), greaterThan(frg_layerCoord, in_layerBounds.zw));
  if (any(outside)) discard;`
        }
      },
      // feature defining layer's scalar value
      {
        name: "layerValue",
        varyings: ["float frg_layerValue"],
        vertex: {
          attributes: ["float in_layerValue"],
          code: "  frg_layerValue = in_layerValue;"
        }
      }
    ];
    if (this.conf.render.cutOver) {
      features.push({
        name: "cutOver",
        fragment: {
          uniforms: ["float in_cutOver"],
          code: "  if (frg_layerValue > in_cutOver) discard;"
        }
      });
    }
    if (this.conf.render.cutUnder) {
      features.push({
        name: "cutUnder",
        fragment: {
          uniforms: ["float in_cutUnder"],
          code: "  if (frg_layerValue < in_cutUnder) discard;"
        }
      });
    }
    if (this.gridSource.supportsNoData()) {
      features.push({
        name: "nodata",
        varyings: ["float frg_validValue"],
        vertex: {
          uniforms: ["float in_nodata"],
          code: "  frg_validValue = (in_layerValue == in_nodata ? 0.0 : 1.0);"
        },
        fragment: {
          code: "  if (frg_validValue != 1.0) discard;"
        }
      });
    }
    if (this.colorMapShaderCode) {
      if (this.conf.render.pixelColorMapping) {
        features.push({
          name: "colormap",
          fragment: {
            functions: [this.colorMapShaderCode],
            code: "  vec4 color = ColorMap(frg_layerValue);"
          }
        });
      } else {
        features.push({
          name: "colormap",
          varyings: ["vec4 frg_color"],
          vertex: {
            functions: [this.colorMapShaderCode],
            code: "  frg_color = ColorMap(frg_layerValue);"
          },
          fragment: {
            code: "  vec4 color = frg_color;"
          }
        });
      }
    } else {
      features.push({
        name: "colormap",
        varyings: ["vec4 frg_color"],
        vertex: {
          functions: [WEBGL_FUNCTIONS.rgbFromFloat],
          code: "  frg_color = rgbFromFloat(frg_layerValue);"
        },
        fragment: {
          code: "  vec4 color = frg_color;"
        }
      });
    }
    features.push({
      name: "tail",
      fragment: {
        uniforms: ["float in_layerAlpha"],
        code: "  outColor = vec4(color.rgb * in_layerAlpha, in_layerAlpha);"
      }
    });
    const [vtxCode, frgCode] = buildShaderCode(features);
    this.program = new PIXI.Program(vtxCode, frgCode);
    if (this.conf.render.showWireframe) {
      const [vtxWireframe, frgWireframe] = buildShaderCode([features[0], {
        name: "tail",
        fragment: {
          uniforms: ["float in_layerAlpha"],
          code: "  outColor = vec4(0.0, 0.0, 0.0, in_layerAlpha);"
        }
      }]);
      this.wireframeProgram = new PIXI.Program(vtxWireframe, frgWireframe);
    }
    if (this.conf.debug.showShader) {
      console.log("Generated vertex shader:");
      console.log(vtxCode);
      console.log("Generated fragment shader:");
      console.log(frgCode);
    }
  },
  renderPixiLayer(utils) {
    const renderer = utils.getRenderer();
    renderer.render(this.pixiRoot);
  },
  setLevel(value) {
    if (this.cutValueUniform) {
      this.layerUniforms.uniforms[this.cutValueUniform] = value;
      this.pixiLayer.redraw();
    } else if (typeof this.gridSource.setLevel === "function") {
      this._resetView();
      this.gridSource.setLevel(value);
    }
  },
  setTime(time) {
    if (typeof this.gridSource.setTime === "function") {
      this._resetView();
      this.gridSource.setTime(time);
    }
  },
  setModel(model) {
    if (typeof this.gridSource.setModel === "function") {
      this._resetView();
      this.gridSource.setModel(model);
    }
  },
  getBounds() {
    const bounds = this.options.bounds ? this.options.bounds : L$1.latLngBounds(L$1.latLng(-90, -180), L$1.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(bounds) : bounds;
  }
});
const tiledMeshLayers = {
  methods: {
    async createLeafletTiledMeshLayer(options) {
      const layerOptions = options.leaflet || options;
      if (layerOptions.type !== "tiledMeshLayer") return;
      const colorMap = _$1.get(options, "variables[0].chromajs", null);
      if (colorMap) Object.assign(layerOptions, { chromajs: colorMap });
      const [gridKey, gridConf] = extractGridSourceConfig(options);
      const weacastApi = typeof options.getPlanetApi === "function" ? options.getPlanetApi() : this.getWeacastApi();
      const apiToken = weacastApi.hasConfig("gatewayJwt") ? await weacastApi.get("storage").getItem(weacastApi.getConfig("gatewayJwt")) : null;
      const gridSource = makeGridSource(gridKey, { weacastApi, apiToken });
      gridSource.setup(gridConf);
      if (gridSource.updateCtx) {
        if (apiToken) gridSource.updateCtx.jwtToken = apiToken;
        gridSource.updateCtx.meteoElements = _$1.get(options, "meteoElements");
      }
      return new TiledMeshLayer(layerOptions, gridSource);
    },
    updateTiledMeshLayerZoomBounds(layer2, model) {
      const minZoom = _$1.get(layer2, `leaflet.meteoModelMinZoom[${model.name}]`);
      const maxZoom = _$1.get(layer2, `leaflet.meteoModelMaxZoom[${model.name}]`);
      if (minZoom) layer2.leaflet.minZoom = minZoom;
      else delete layer2.leaflet.minZoom;
      if (maxZoom) layer2.leaflet.maxZoom = maxZoom;
      else delete layer2.leaflet.maxZoom;
      this.updateLayerDisabled(layer2);
      const engineLayer = this.getLeafletLayerByName(layer2.name);
      if (engineLayer) {
        if (minZoom) engineLayer.options.minZoom = minZoom;
        else delete engineLayer.options.minZoom;
        if (maxZoom) engineLayer.options.maxZoom = maxZoom;
        else delete engineLayer.options.maxZoom;
      }
    },
    onAddTiledMeshLayer(layer2) {
      if (!this.forecastModel || _$1.get(layer2, "leaflet.type") !== "tiledMeshLayer") return;
      this.updateTiledMeshLayerZoomBounds(layer2, this.forecastModel);
    },
    onShowTiledMeshLayer(layer2, engineLayer) {
      const isTiledMeshLayer = engineLayer instanceof TiledMeshLayer;
      if (!isTiledMeshLayer) return;
      this.tiledMeshLayers.set(layer2._id, engineLayer);
      engineLayer.setModel(this.forecastModel);
      engineLayer.setTime(Time.getCurrentTime());
    },
    onHideTiledMeshLayer(layer2, engineLayer) {
      const isTiledMeshLayer = engineLayer instanceof TiledMeshLayer;
      if (!isTiledMeshLayer) return;
      this.tiledMeshLayers.delete(layer2._id);
    },
    onSelectedLevelChangedTiledMeshLayer(value) {
      if (!this.selectableLevelsLayer) return;
      const layer2 = this.tiledMeshLayers.get(this.selectableLevelsLayer._id);
      if (!layer2) return;
      layer2.setLevel(value);
    },
    onForecastModelChangedTiledMeshLayer(model) {
      const tiledMeshLayers2 = _$1.filter(this.layers, (layer2) => _$1.get(layer2, "leaflet.type") === "tiledMeshLayer");
      for (const layer2 of tiledMeshLayers2) this.updateTiledMeshLayerZoomBounds(layer2, model);
      this.tiledMeshLayers.forEach((engineLayer) => {
        engineLayer.setModel(model);
      });
    },
    onCurrentTimeChangedTiledMeshLayer(time) {
      this.tiledMeshLayers.forEach((engineLayer) => {
        engineLayer.setTime(time);
      });
    }
  },
  created() {
    this.tiledMeshLayers = /* @__PURE__ */ new Map();
    this.registerLeafletConstructor(this.createLeafletTiledMeshLayer);
    this.$engineEvents.on("layer-added", this.onAddTiledMeshLayer);
    this.$engineEvents.on("layer-shown", this.onShowTiledMeshLayer);
    this.$engineEvents.on("layer-hidden", this.onHideTiledMeshLayer);
    this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer);
    this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledMeshLayer);
    this.$engineEvents.off("layer-shown", this.onShowTiledMeshLayer);
    this.$engineEvents.off("layer-hidden", this.onHideTiledMeshLayer);
    this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledMeshLayer);
    this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledMeshLayer);
    Events.off("time-current-time-changed", this.onCurrentTimeChangedTiledMeshLayer);
  }
};
const TiledWindLayer = L$1.GridLayer.extend({
  initialize(options, uSource, vSource) {
    this.conf = {};
    this.conf.enableDebug = _$1.get(options, "enabledDebug", false);
    this.conf.resolutionScale = _$1.get(options, "resolutionScale", [1, 1]);
    this.conf.meteoModelOverride = _$1.get(options, "meteoModelOverride");
    L$1.GridLayer.prototype.initialize.call(this, options);
    this.userIsDragging = false;
    this.pendingFetchs = 0;
    this.loadedTiles = /* @__PURE__ */ new Set();
    const chromajs = _$1.get(options, "chromajs");
    this.colorMap = buildColorScale(chromajs);
    this.uSource = uSource;
    this.vSource = vSource;
    this.onDataChangedCallback = this.onDataChanged.bind(this);
    this.uSource.on("data-changed", this.onDataChangedCallback);
    this.vSource.on("data-changed", this.onDataChangedCallback);
    this.numDataChanged = 0;
    const velocityOptions = Object.assign({
      displayValues: false,
      minVelocity: this.colorMap.domain()[0],
      maxVelocity: this.colorMap.domain()[1],
      velocityScale: 0.01,
      colorScale: this.colorMap.colors(),
      data: null
    }, options);
    this.velocityLayer = L$1.velocityLayer(velocityOptions);
    this.velocityLayer.onDrawLayer = (overlay, params) => {
      if (!this._map) return;
      if (this.velocityLayer._windy) {
        let allowedZoom = true;
        const zoom = this._map.getZoom();
        if (this.options.maxZoom && zoom > this.options.maxZoom) allowedZoom = false;
        if (this.options.minZoom && zoom < this.options.minZoom) allowedZoom = false;
        if (this.pendingFetchs === 0 && !this.userIsDragging && allowedZoom) {
          this.velocityLayer._clearAndRestart();
        } else {
          this.velocityLayer._clearWind();
        }
      }
    };
    this.uFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 2
      },
      data: []
    };
    this.vFlow = {
      header: {
        parameterCategory: 2,
        parameterNumber: 3
      },
      data: []
    };
  },
  getEvents() {
    const events = L$1.GridLayer.prototype.getEvents.call(this);
    const onDragStart = events.dragstart;
    events.dragstart = (event) => {
      this.userIsDragging = true;
      if (onDragStart) onDragStart.call(this, event);
    };
    const onDragEnd = events.dragend;
    events.dragend = (event) => {
      this.userIsDragging = false;
      if (onDragEnd) onDragEnd.call(this, event);
    };
    return events;
  },
  setTime(time) {
    const applyU = typeof this.uSource.setTime === "function";
    const applyV = typeof this.vSource.setTime === "function";
    if (applyU || applyV) {
      if (!this.pendingAdd) {
        this._resetView();
      }
      if (applyU) {
        this.uSource.setTime(time);
      }
      if (applyV) {
        this.vSource.setTime(time);
      }
    }
  },
  setLevel(level) {
    const applyU = typeof this.uSource.setLevel === "function";
    const applyV = typeof this.vSource.setLevel === "function";
    if (applyU || applyV) {
      if (!this.pendingAdd) {
        this._resetView();
      }
      if (applyU) {
        this.uSource.setLevel(level);
      }
      if (applyV) {
        this.vSource.setLevel(level);
      }
    }
  },
  setModel(model) {
    const modelHeader = {
      nx: model.size[0],
      ny: model.size[1],
      lo1: model.origin[0],
      la1: model.origin[1],
      dx: model.resolution[0],
      dy: model.resolution[1]
    };
    if (this.conf.meteoModelOverride) {
      const override = this.conf.meteoModelOverride[model.name];
      if (override) Object.assign(modelHeader, override);
    }
    Object.assign(this.uFlow.header, modelHeader);
    Object.assign(this.vFlow.header, modelHeader);
    const size = modelHeader.nx * modelHeader.ny;
    this.uFlow.data = new Array(size);
    this.vFlow.data = new Array(size);
    for (let i = 0; i < size; ++i) this.uFlow.data[i] = this.vFlow.data[i] = 0;
    const applyU = typeof this.uSource.setModel === "function";
    const applyV = typeof this.vSource.setModel === "function";
    if (applyU || applyV) {
      if (!this.pendingAdd) {
        this._resetView();
      }
      if (applyU) {
        this.uSource.setModel(model);
      }
      if (applyV) {
        this.vSource.setModel(model);
      }
    }
  },
  onDataChanged() {
    ++this.numDataChanged;
    if (this.numDataChanged !== 2) return;
    this.numDataChanged = 0;
    this.loadedTiles.clear();
    const points = [];
    const vbbox = this.vSource.getBBox();
    if (vbbox) {
      points.push(L$1.latLng(vbbox[0], vbbox[1]));
      points.push(L$1.latLng(vbbox[2], vbbox[3]));
    }
    const ubbox = this.uSource.getBBox();
    if (ubbox) {
      points.push(L$1.latLng(ubbox[0], ubbox[1]));
      points.push(L$1.latLng(ubbox[2], ubbox[3]));
    }
    this.options.bounds = points.length ? L$1.latLngBounds(points) : null;
    if (this.pendingAdd) {
      this.onPendingAdd();
    } else {
      this.redraw();
    }
    this.fire("data");
    this.hasData = true;
  },
  onAdd(map) {
    this.pendingAdd = map;
  },
  onPendingAdd() {
    const map = this.pendingAdd;
    this.loadedTiles.clear();
    L$1.GridLayer.prototype.onAdd.call(this, map);
    map.addLayer(this.velocityLayer);
    this.velocityLayer.setData([this.uFlow, this.vFlow]);
    this.velocityLayer._initWindy(this.velocityLayer);
    this._map.off("dragstart", this.velocityLayer._windy.stop);
    this._map.off("dragend", this.velocityLayer._clearAndRestart);
    this.pendingAdd = null;
  },
  onRemove(map) {
    if (this.pendingAdd) {
      this.pendingAdd = null;
    } else {
      map.removeLayer(this.velocityLayer);
      L$1.GridLayer.prototype.onRemove.call(this, map);
    }
    this.uSource.invalidate();
    this.vSource.invalidate();
    this.loadedTiles.clear();
  },
  updateWindArray(grid2, element, reqBBox, debug2) {
    const [iminlat, iminlon, imaxlat, imaxlon] = grid2.getBestFit(reqBBox);
    const startlat = grid2.getLat(iminlat);
    const startlon = grid2.getLon(iminlon);
    const istartx = Math.round((startlon - element.header.lo1) / element.header.dy);
    const istarty = Math.round((element.header.la1 - startlat) / element.header.dx);
    for (let ilon = iminlon; ilon <= imaxlon; ++ilon) {
      for (let ilat = iminlat; ilat <= imaxlat; ++ilat) {
        const val = grid2.getValue(ilat, ilon);
        let ix = istartx + (ilon - iminlon);
        let iy = istarty - (ilat - iminlat);
        if (ix < 0) ix += element.header.nx;
        if (iy < 0) iy += element.header.ny;
        const idx = ix + iy * element.header.nx;
        element.data[idx] = val;
      }
    }
  },
  createTile(coords) {
    const tile = document.createElement("div");
    const skipTile = tileSetContainsParent(this.loadedTiles, coords);
    if (this.conf.enableDebug) {
      tile.style.outline = "1px solid blue";
      tile.innerHTML = `${coords.x} ${coords.y} ${coords.z} :`;
    }
    if (!skipTile) {
      if (this.conf.enableDebug) {
        tile.innerHTML += " requested";
      }
      const bounds = this._tileCoordsToBounds(coords);
      const reqBBox = [bounds.getSouth(), bounds.getWest(), bounds.getNorth(), bounds.getEast()];
      const tileSize = this.getTileSize();
      const resolution = [
        this.conf.resolutionScale[0] * ((reqBBox[2] - reqBBox[0]) / (tileSize.y - 1)),
        this.conf.resolutionScale[1] * ((reqBBox[3] - reqBBox[1]) / (tileSize.x - 1))
      ];
      const uPromise = this.uSource.fetch(null, reqBBox, resolution);
      const vPromise = this.vSource.fetch(null, reqBBox, resolution);
      ++this.pendingFetchs;
      const doFinally = () => {
        --this.pendingFetchs;
        if (this.pendingFetchs === 0 && !this.userIsDragging) {
          this.velocityLayer._clearAndRestart();
          if (this.conf.enableDebug) {
            tile.innerHTML += ", triggered wind restart";
          }
        }
      };
      Promise.all([uPromise, vPromise]).then((grids) => {
        const uGrid = grids[0];
        const vGrid = grids[1];
        if (uGrid && vGrid) {
          if (uGrid.sourceKey === this.uSource.sourceKey && vGrid.sourceKey === this.vSource.sourceKey) {
            this.updateWindArray(uGrid, this.uFlow, reqBBox);
            this.updateWindArray(vGrid, this.vFlow, reqBBox);
            this.loadedTiles.add(tile2key$1(coords));
            if (this.conf.enableDebug) {
              tile.style.outline = "1px solid green";
              tile.innerHTML += ", added to loadedTiles";
            }
          } else {
            if (this.conf.enableDebug) {
              tile.style.outline = "1px solid red";
              tile.innerHTML += ", discarded (out of date)";
            }
          }
        } else {
          if (this.conf.enableDebug) {
            tile.style.outline = "1px solid green";
            tile.innerHTML += ", empty";
          }
        }
        doFinally();
      }).catch((err) => {
        if (this.conf.enableDebug) {
          tile.style.outline = "1px solid red";
          tile.innerHTML += `, failed (${err})`;
        }
        doFinally();
        throw err;
      });
    } else {
      if (this.conf.enableDebug) {
        tile.style.outline = "1px solid green";
        tile.innerHTML += " skipped";
      }
    }
    return tile;
  },
  redraw() {
    this.loadedTiles.clear();
    this.velocityLayer._clearWind();
    this.uFlow.data.fill(0);
    this.vFlow.data.fill(0);
    L$1.GridLayer.prototype.redraw.call(this);
  },
  getBounds() {
    const bounds = this.options.bounds ? this.options.bounds : L$1.latLngBounds(L$1.latLng(-90, -180), L$1.latLng(90, 180));
    return this._map ? this._map.wrapLatLngBounds(bounds) : bounds;
  }
});
const tiledWindLayers = {
  methods: {
    async createLeafletTiledWindLayer(options) {
      const layerOptions = options.leaflet || options;
      if (layerOptions.type !== "tiledWindLayer") return;
      const colorMap = _$1.get(options, "variables[0].chromajs", null);
      if (colorMap) Object.assign(layerOptions, { chromajs: colorMap });
      const [gridKey, gridConf] = extractGridSourceConfig(options);
      const weacastApi = typeof options.getPlanetApi === "function" ? options.getPlanetApi() : this.getWeacastApi();
      const uSource = makeGridSource(gridKey, { weacastApi });
      const vSource = makeGridSource(gridKey, { weacastApi });
      uSource.setup(gridConf);
      vSource.setup(gridConf);
      if (uSource.updateCtx) {
        const gatewayToken = weacastApi.hasConfig("gatewayJwt") ? await weacastApi.get("storage").getItem(weacastApi.getConfig("gatewayJwt")) : null;
        if (gatewayToken) {
          uSource.updateCtx.jwtToken = gatewayToken;
          vSource.updateCtx.jwtToken = gatewayToken;
        }
        uSource.updateCtx.windComponent = _$1.get(options, "meteoElements[0]");
        vSource.updateCtx.windComponent = _$1.get(options, "meteoElements[1]");
      }
      return new TiledWindLayer(layerOptions, uSource, vSource);
    },
    updateTiledWindLayerZoomBounds(layer2, model) {
      const minZoom = _$1.get(layer2, `leaflet.meteoModelMinZoom[${model.name}]`);
      const maxZoom = _$1.get(layer2, `leaflet.meteoModelMaxZoom[${model.name}]`);
      if (minZoom) layer2.leaflet.minZoom = minZoom;
      else delete layer2.leaflet.minZoom;
      if (maxZoom) layer2.leaflet.maxZoom = maxZoom;
      else delete layer2.leaflet.maxZoom;
      this.updateLayerDisabled(layer2);
      const engineLayer = this.getLeafletLayerByName(layer2.name);
      if (engineLayer) {
        if (minZoom) engineLayer.options.minZoom = minZoom;
        else delete engineLayer.options.minZoom;
        if (maxZoom) engineLayer.options.maxZoom = maxZoom;
        else delete engineLayer.options.maxZoom;
      }
    },
    onAddTiledWindLayer(layer2) {
      if (!this.forecastModel || _$1.get(layer2, "leaflet.type") !== "tiledWindLayer") return;
      this.updateTiledWindLayerZoomBounds(layer2, this.forecastModel);
    },
    onShowTiledWindLayer(layer2, engineLayer) {
      const isTiledWindLayer = engineLayer instanceof TiledWindLayer;
      if (!isTiledWindLayer) return;
      this.tiledWindLayers.set(layer2._id, engineLayer);
      engineLayer.setModel(this.forecastModel);
      engineLayer.setTime(Time.getCurrentTime());
    },
    onHideTiledWindLayer(layer2, engineLayer) {
      const isTiledWindLayer = engineLayer instanceof TiledWindLayer;
      if (!isTiledWindLayer) return;
      this.tiledWindLayers.delete(layer2._id);
    },
    onForecastModelChangedTiledWindLayer(model) {
      const tiledWindLayers2 = _$1.filter(this.layers, (layer2) => _$1.get(layer2, "leaflet.type") === "tiledWindLayer");
      for (const layer2 of tiledWindLayers2) this.updateTiledWindLayerZoomBounds(layer2, model);
      this.tiledWindLayers.forEach((engineLayer) => {
        engineLayer.setModel(model);
      });
    },
    onCurrentTimeChangedTiledWindLayer(time) {
      this.tiledWindLayers.forEach((engineLayer) => {
        engineLayer.setTime(time);
      });
    },
    onSelectedLevelChangedTiledWindLayer(value) {
      if (!this.selectableLevelsLayer) return;
      const layer2 = this.tiledWindLayers.get(this.selectableLevelsLayer._id);
      if (!layer2) return;
      layer2.setLevel(value);
    }
  },
  created() {
    this.tiledWindLayers = /* @__PURE__ */ new Map();
    this.registerLeafletConstructor(this.createLeafletTiledWindLayer);
    this.$engineEvents.on("layer-added", this.onAddTiledWindLayer);
    this.$engineEvents.on("layer-shown", this.onShowTiledWindLayer);
    this.$engineEvents.on("layer-hidden", this.onHideTiledWindLayer);
    this.$engineEvents.on("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer);
    this.$engineEvents.on("forecast-model-changed", this.onForecastModelChangedTiledWindLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  },
  beforeUnmount() {
    this.$engineEvents.off("layer-added", this.onAddTiledWindLayer);
    this.$engineEvents.off("layer-shown", this.onShowTiledWindLayer);
    this.$engineEvents.off("layer-hidden", this.onHideTiledWindLayer);
    this.$engineEvents.off("selected-level-changed", this.onSelectedLevelChangedTiledWindLayer);
    this.$engineEvents.off("forecast-model-changed", this.onForecastModelChangedTiledWindLayer);
    Events.off("time-current-time-changed", this.onCurrentTimeChangedTiledWindLayer);
  }
};
const heatmapLayers = {
  methods: {
    async createLeafletHeatmapLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "heatmap") return;
      const layer2 = this.createLeafletLayer(options);
      const source = _$1.get(leafletOptions, "url");
      const sourceTemplate = _$1.get(leafletOptions, "urlTemplate");
      if (sourceTemplate) layer2.sourceCompiler = _$1.template(sourceTemplate);
      const valueTemplate = _$1.get(leafletOptions, "valueTemplate");
      if (valueTemplate) layer2.valueCompiler = _$1.template(valueTemplate);
      if (options.service) {
        layer2.lastUpdateTime = Time.getCurrentTime().clone();
        const geoJson = await this.getFeatures(options);
        this.updateLeafletHeatmap(layer2, geoJson);
      } else if (!_$1.isNil(source)) {
        const geoJson = await fetchGeoJson(source, options);
        this.updateLeafletHeatmap(layer2, geoJson);
      } else if (!_$1.isNil(sourceTemplate)) {
        const sourceToFetch = layer2.sourceCompiler({ time: Time.getCurrentTime() });
        layer2.lastFetchedSource = sourceToFetch;
        const geoJson = await fetchGeoJson(sourceToFetch, options);
        this.updateLeafletHeatmap(layer2, geoJson);
      }
      return layer2;
    },
    updateLeafletHeatmap(layer2, geoJson) {
      const valueField = _$1.get(layer2, "cfg.valueField", "value");
      const min = _$1.get(layer2, "cfg.min");
      const max = _$1.get(layer2, "cfg.max");
      const values = layer2.valueCompiler ? geoJson.features.map((feature2) => _$1.toNumber(layer2.valueCompiler({ properties: feature2.properties, feature: feature2 }))) : geoJson.features.map((feature2) => _$1.toNumber(_$1.get(feature2, `properties.${valueField}`, 1)));
      layer2.setData({
        min: min || (valueField ? _$1.min(values) : 0),
        max: max || (valueField ? _$1.max(values) : 1),
        data: geoJson.features.map((feature2, index2) => {
          const location2 = centroid(feature2);
          return {
            lng: _$1.get(location2, "geometry.coordinates[0]"),
            lat: _$1.get(location2, "geometry.coordinates[1]"),
            [valueField]: values[index2]
          };
        })
      });
    },
    updateHeatmap(name, geoJson) {
      const layer2 = this.getLeafletLayerByName(name);
      if (!layer2) return;
      this.updateLeafletHeatmap(layer2, geoJson);
    },
    onCurrentTimeChangedHeatmapLayers(time) {
      const heatmaps = _$1.values(this.layers).filter(sift({
        "leaflet.type": "heatmap",
        $or: [
          // Supported by template URL or time-based features
          { "leaflet.urlTemplate": { $exists: true } },
          { service: { $exists: true } }
        ],
        isVisible: true
      }));
      heatmaps.forEach(async (options) => {
        const layer2 = this.getLeafletLayerByName(options.name);
        if (options.service) {
          if (!layer2.lastUpdateTime || !this.shouldSkipFeaturesUpdate(layer2.lastUpdateTime, options)) {
            layer2.lastUpdateTime = Time.getCurrentTime().clone();
            const geoJson = await this.getFeatures(options);
            this.updateLeafletHeatmap(layer2, geoJson);
          }
        } else if (layer2.sourceCompiler) {
          const sourceToFetch = layer2.sourceCompiler({ time: Time.getCurrentTime() });
          if (!layer2.lastFetchedSource || layer2.lastFetchedSource !== sourceToFetch) {
            layer2.lastFetchedSource = sourceToFetch;
            const geoJson = await fetchGeoJson(sourceToFetch, options);
            this.updateLeafletHeatmap(layer2, geoJson);
          }
        }
      });
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletHeatmapLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  },
  beforeUnmount() {
    Events.off("time-current-time-changed", this.onCurrentTimeChangedHeatmapLayers);
  }
};
L$1.heatmap = function(options) {
  return new HeatmapOverlay(options);
};
const mapillaryLayers = {
  methods: {
    async createLeafletMapillaryLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "mapillary") return;
      const layer2 = await this.createLeafletLayer(_$1.merge(options, {
        leaflet: {
          type: "vectorGrid.protobuf",
          source: "https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=" + this.mapillaryToken,
          interactive: true,
          minZoom: 13,
          maxNativeZoom: 14,
          vectorTileLayerStyles: {
            sequence: function(properties, zoom) {
              return {
                weight: zoom > 13 ? 1 : 2,
                color: "#44BB44",
                opacity: zoom > 13 ? 0.5 : 1
              };
            },
            image: []
          }
        }
      }));
      bindLeafletEvents(layer2, LeafletEvents.Feature, this, options);
      return layer2;
    }
  },
  created() {
    this.mapillaryToken = Store.get("capabilities.api.mapillary.token");
    if (!this.mapillaryToken) {
      logger$1.warn("You must provide a client token to use Mapillary");
      return;
    }
    this.registerLeafletConstructor(this.createLeafletMapillaryLayer);
  }
};
const GSMaPLayer = L$1.TileLayer.extend({
  initialize(options) {
    this.product = options.product || "rain";
    const url = this.makeUrl(options.time);
    const updatedOptions = Object.assign({ tms: true }, options);
    L$1.TileLayer.prototype.initialize.call(this, url, updatedOptions);
    const colorMapOptions = options.chromajs;
    if (colorMapOptions) {
      this.colorMap = buildColorScale(colorMapOptions);
      if (this.colorMap) {
        this.on("tileload", (event) => {
          if (!this.hasData) {
            this.fire("data");
            this.hasData = true;
          }
        });
      }
    }
  },
  makeUrl(time) {
    const t = time || moment();
    const halfHour = moment.duration(30, "minutes");
    const stepTime = moment(Math.trunc(t / halfHour) * halfHour).utc();
    const baseUrl = "https://sharaku.eorc.jaxa.jp/cgi-bin/trmm/GSMaP_NOW/tilemap/";
    const timeQuery = `year=${stepTime.year()}&month=${stepTime.month() + 1}&day=${stepTime.date()}&hour=${stepTime.hour()}&min=${stepTime.minute()}&z={z}&x={x}&y={y}`;
    if (this.product === "rain12" || this.product === "rain24" || this.product === "rain72") {
      return baseUrl + `tile_total.py?prod=${this.product}&` + timeQuery;
    }
    if (this.product === "ir") {
      return baseUrl + `gsmapnow_tile_ir.py?prod=${this.product}&` + timeQuery;
    }
    return baseUrl + "tile_rain.py?prod=rain&" + timeQuery;
  },
  setCurrentTime(time) {
    const url = this.makeUrl(time);
    this.setUrl(url, false);
  }
});
const gsmapLayers = {
  methods: {
    async createLeafletGSMaPLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "gsmapLayer") return;
      const colorMap = _$1.get(options, "variables[0].chromajs", null);
      if (colorMap) Object.assign(leafletOptions, { chromajs: colorMap });
      leafletOptions.time = Time.getCurrentTime();
      return new GSMaPLayer(leafletOptions);
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletGSMaPLayer);
  }
};
const CanvasDrawContext = {
  initialize() {
    if (this.ctx) return;
    this.ctx = {};
  },
  get() {
    return this.ctx;
  },
  merge(ctx) {
    this.ctx = Object.assign({}, this.ctx, ctx);
  }
};
CanvasDrawContext.initialize();
function forwardEventBehindPane(e, pane) {
  const removed = { node: e.target, display: e.target.style.display };
  removed.node.style.display = "none";
  const target2 = document.elementFromPoint(e.clientX, e.clientY);
  if (target2 && target2 !== pane) {
    const ev = new MouseEvent(e.type, e);
    const stopped = !target2.dispatchEvent(ev);
    if (stopped || ev._stopped) L$1.DomEvent.stop(e);
  }
  removed.node.style.display = removed.display;
}
L$1.KanvasLayer = (L$1.Layer ? L$1.Layer : L$1.Class).extend({
  // -- initialized is called on prototype
  initialize: function(options) {
    this._map = null;
    this._mapPaneOffset = null;
    this._canvas = null;
    this._frame = null;
    this._delegate = null;
    L$1.setOptions(this, options);
    this.clickableFeatures = [];
    this.mousePosition = null;
    this.highlighting = false;
    this.autoRedraw = false;
    if (options.tooltip) {
      this._tooltip = L$1.tooltip({});
      this._tooltipContent = "";
      if (options.tooltip.html) {
        this._getTooltipContent = (feature2) => {
          return options.tooltip.html;
        };
      } else if (options.tooltip.property) {
        this._getTooltipContent = (feature2) => {
          const val = _$1.get(feature2, options.tooltip.property);
          return `${val}`;
        };
      } else if (options.tooltip.template) {
        const compiler = _$1.template(options.tooltip.template);
        this._getTooltipContent = (feature2) => {
          return compiler({ feature: feature2, properties: feature2.properties });
        };
      }
    }
  },
  delegate: function(del) {
    this._delegate = del;
  },
  setAutoRedraw: function(enable) {
    this.autoRedraw = enable;
    if (enable && this._frame === null) this.needRedraw();
  },
  needRedraw: function() {
    if (this._frame !== null || this._canvas === null) return;
    this._frame = L$1.Util.requestAnimFrame(this.drawLayer, this);
  },
  redrawNow: function() {
    const frame = this._frame;
    const autoRedraw = this.autoRedraw;
    this.autoRedraw = false;
    this.drawLayer();
    this._frame = frame;
    this.autoRedraw = autoRedraw;
  },
  latLonToCanvas: function(coords) {
    let p = this._map.latLngToLayerPoint(L$1.latLng(coords.lat, coords.lon));
    if (this._map._rotate) {
      p = p.add(this._map._getRotatePanePos()).rotateFrom(this._map._bearing, this._map._getRotatePanePos());
    }
    return p.add(this._mapPaneOffset);
  },
  clearClickableFeatures: function() {
    this.clickableFeatures.length = 0;
  },
  addClickableFeature: function(feature2, clickablePath, { clickableStrokeWidth = 0, highlightPath = void 0, highlightAsStroke = false, highlightStyle = {} }) {
    this.clickableFeatures.push({
      feature: feature2,
      click: { path: clickablePath, strokeWidth: clickableStrokeWidth }
    });
    if (highlightPath) {
      this.clickableFeatures[this.clickableFeatures.length - 1].highlight = {
        path: highlightPath,
        asStroke: highlightAsStroke,
        style: highlightStyle
      };
    }
  },
  hasClickableFeaturesAt: function(latlng) {
    if (!latlng || this.clickableFeatures.length === 0) return false;
    const pt = this.latLonToCanvas({ lat: latlng.lat, lon: latlng.lng });
    const ctx = this._canvas.getContext("2d");
    let inFeature = false;
    for (const feature2 of this.clickableFeatures) {
      ctx.save();
      if (feature2.click.strokeWidth) {
        ctx.lineWidth = feature2.click.strokeWidth;
        inFeature = ctx.isPointInStroke(feature2.click.path, pt.x, pt.y);
      } else {
        inFeature = ctx.isPointInPath(feature2.click.path, pt.x, pt.y);
      }
      ctx.restore();
      if (inFeature) return true;
    }
    return false;
  },
  getClickableFeaturesAt: function(latlng) {
    if (!latlng || this.clickableFeatures.length === 0) return [];
    const pt = this.latLonToCanvas({ lat: latlng.lat, lon: latlng.lng });
    const indexes = [];
    const ctx = this._canvas.getContext("2d");
    this.clickableFeatures.forEach((feature2, index2) => {
      ctx.save();
      if (feature2.click.strokeWidth) {
        ctx.lineWidth = feature2.click.strokeWidth;
        if (ctx.isPointInStroke(feature2.click.path, pt.x, pt.y)) indexes.push(index2);
      } else {
        if (ctx.isPointInPath(feature2.click.path, pt.x, pt.y)) indexes.push(index2);
      }
      ctx.restore();
    });
    return indexes;
  },
  // -------------------------------------------------------------
  _onLayerDidResize: function(resizeEvent) {
    this._canvas.width = resizeEvent.newSize.x;
    this._canvas.height = resizeEvent.newSize.y;
  },
  // -------------------------------------------------------------
  _onLayerDidMove: function() {
    this._mapPaneOffset = this._map._getMapPanePos();
    if (this._map._rotate) {
      const offset = this._mapPaneOffset.add(this._map._getRotatePanePos());
      this._canvas.style[L$1.DomUtil.TRANSFORM] = // TODO: zoomAnimation is currently always off on the layer beacause of rotate plugin
      // this._map.options.zoomAnimation ?
      "translate(-50%, -50%) rotate(" + -this._map._bearing + "rad) translate(50%, 50%) translate3d(" + -offset.x + "px," + -offset.y + "px, 0)";
    } else {
      L$1.DomUtil.setPosition(this._canvas, L$1.point(0, 0).subtract(this._mapPaneOffset));
    }
    this.redrawNow();
  },
  // -------------------------------------------------------------
  _onLayerClick: function(event) {
    if (event.originalEvent.target !== this._canvas) return;
    const indexes = this.getClickableFeaturesAt(event.latlng);
    if (indexes.length) {
      this.fire("click", Object.assign({}, event, { feature: this.clickableFeatures[indexes[0]].feature }));
    } else if (this.options.clickThroughEnabled) {
      const pane = this.options.pane ? this._map._panes[this.options.pane] : this._map._panes.overlayPane;
      forwardEventBehindPane(event.originalEvent, pane);
    }
  },
  // -------------------------------------------------------------
  _onLayerContextMenu: function(event) {
    if (event.originalEvent.target !== this._canvas) return;
    const indexes = this.getClickableFeaturesAt(event.latlng);
    if (indexes.length === 0) return;
    this.fire("contextmenu", Object.assign({}, event, { feature: this.clickableFeatures[indexes[0]].feature }));
  },
  // -------------------------------------------------------------
  _onMouseMove: function(event) {
    if (event.originalEvent.target !== this._canvas) return;
    this.mousePosition = event.latlng;
    let hoveringFeatures = false;
    if (this._tooltip) {
      const indexes = this.getClickableFeaturesAt(event.latlng);
      if (indexes.length === 0 && this._map.hasLayer(this._tooltip)) {
        this._map.closeTooltip(this._tooltip);
        this._tooltipContent = "";
      } else if (indexes.length) {
        const content = this._getTooltipContent(this.clickableFeatures[indexes[0]].feature);
        if (content !== this._tooltipContent) {
          this._tooltip.setLatLng(event.latlng);
          this._tooltip.setContent(content);
          this._tooltipContent = content;
        }
        if (!this._map.hasLayer(this._tooltip)) this._map.openTooltip(this._tooltip);
        hoveringFeatures = true;
      }
    } else {
      hoveringFeatures = this.hasClickableFeaturesAt(event.latlng);
    }
    if (!hoveringFeatures && !this.highlighting) {
      this._canvas.style.cursor = "";
      return;
    } else {
      this._canvas.style.cursor = "pointer";
      this.needRedraw();
    }
  },
  // -------------------------------------------------------------
  _onLayerDidRotate: function(event) {
    this._onLayerDidMove();
  },
  // -------------------------------------------------------------
  getEvents: function() {
    const events = {
      resize: this._onLayerDidResize,
      moveend: this._onLayerDidMove,
      zoom: this._onLayerDidMove,
      rotate: this._onLayerDidRotate
    };
    if (this._map.options.zoomAnimation && L$1.Browser.any3d) {
      events.zoomanim = this._animateZoom;
    }
    if (this.options.pointerEventsEnabled) {
      events.click = this._onLayerClick;
      events.contextmenu = this._onLayerContextMenu;
      events.mousemove = this._onMouseMove;
    }
    return events;
  },
  // -------------------------------------------------------------
  onAdd: function(map) {
    this._map = map;
    this._canvas = L$1.DomUtil.create("canvas", "leaflet-layer");
    if (!this.options.pointerEventsEnabled) this._canvas.style.pointerEvents = "none";
    const size = this._map.getSize();
    this._canvas.width = size.x;
    this._canvas.height = size.y;
    this._mapPaneOffset = map._getMapPanePos();
    L$1.DomUtil.setPosition(this._canvas, L$1.point(0, 0).subtract(this._mapPaneOffset));
    L$1.DomUtil.addClass(this._canvas, "leaflet-zoom-hide");
    const pane = this.options.pane ? map._panes[this.options.pane] : map._panes.overlayPane;
    pane.appendChild(this._canvas);
    map.on(this.getEvents(), this);
    const del = this._delegate || this;
    del.onLayerDidMount && del.onLayerDidMount();
    this.needRedraw();
  },
  // -------------------------------------------------------------
  onRemove: function(map) {
    const del = this._delegate || this;
    del.onLayerWillUnmount && del.onLayerWillUnmount();
    if (this._frame !== null) {
      L$1.Util.cancelAnimFrame(this._frame);
    }
    const pane = this.options.pane ? map._panes[this.options.pane] : map._panes.overlayPane;
    pane.removeChild(this._canvas);
    map.off(this.getEvents(), this);
    this._canvas = null;
    this._frame = null;
  },
  // ---------- --------------------------------------------------
  addTo: function(map) {
    map.addLayer(this);
    return this;
  },
  // --------------------------------------------------------------------------------
  LatLonToMercator: function(latlon) {
    return {
      x: latlon.lng * 6378137 * Math.PI / 180,
      y: Math.log(Math.tan((90 + latlon.lat) * Math.PI / 360)) * 6378137
    };
  },
  // ------------------------------------------------------------------------------
  drawLayer: function() {
    const size = this._map.getSize();
    const bounds = this._map.getBounds();
    const zoom = this._map.getZoom();
    const center2 = this.LatLonToMercator(this._map.getCenter());
    const corner = this.LatLonToMercator(this._map.containerPointToLatLng(this._map.getSize()));
    const del = this._delegate || this;
    del.onDrawLayer && del.onDrawLayer({
      layer: this,
      canvas: this._canvas,
      bounds,
      size,
      zoom,
      center: center2,
      corner
    });
    const highlightIndexes = this.getClickableFeaturesAt(this.mousePosition);
    this.highlighting = highlightIndexes.length > 0;
    if (this.highlighting) {
      const ctx = this._canvas.getContext("2d");
      for (const index2 of highlightIndexes) {
        const feature2 = this.clickableFeatures[index2];
        ctx.save();
        ctx.globalAlpha = 0.5;
        for (const prop in feature2.highlight.style) ctx[prop] = feature2.highlight.style[prop];
        if (feature2.highlight.asStroke) ctx.stroke(feature2.highlight.path);
        else ctx.fill(feature2.highlight.path);
        ctx.restore();
      }
    }
    this._frame = null;
    if (this.autoRedraw) this.needRedraw();
  },
  // -- L.DomUtil.setTransform from leaflet 1.0.0 to work on 0.0.7
  // ------------------------------------------------------------------------------
  _setTransform: function(el, offset, scale2) {
    const pos = offset || new L$1.Point(0, 0);
    el.style[L$1.DomUtil.TRANSFORM] = (L$1.Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
  },
  // ------------------------------------------------------------------------------
  _animateZoom: function(e) {
    const scale2 = this._map.getZoomScale(e.zoom);
    const offset = L$1.Layer ? this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), e.zoom, e.center).min : this._map._getCenterOffset(e.center)._multiplyBy(-scale2).subtract(this._map._getMapPanePos());
    L$1.DomUtil.setTransform(this._canvas, offset, scale2);
  }
});
L$1.kanvasLayer = function(options) {
  return new L$1.KanvasLayer(options);
};
const canvasLayers = {
  methods: {
    createLeafletCanvasLayer(options) {
      const layerOptions = options.leaflet || options;
      if (layerOptions.type !== "kanvasLayer") return;
      const layer2 = this.createLeafletLayer(options);
      this.setCanvasLayerDrawCode(layer2, layerOptions.draw);
      if (layerOptions.userData) this.setCanvasLayerUserData(layer2, layerOptions.userData);
      if (layerOptions.autoRedraw) this.setCanvasLayerAutoRedraw(layer2, layerOptions.autoRedraw);
      bindLeafletEvents(layer2, ["click", "contextmenu"], this, options);
      return layer2;
    },
    setCanvasLayerDrawCode(layer2, drawCode, autoRedraw = false) {
      const leafletLayer = typeof layer2 === "string" ? this.getLeafletLayerByName(layer2) : layer2;
      if (!leafletLayer) return;
      const updateListeners = (canvasLayer, listen) => {
        for (const layerName in canvasLayer.listenedLayers) {
          const state = canvasLayer.listenedLayers[layerName];
          if (state === listen) continue;
          const listenedLayer = this.getLeafletLayerByName(layerName);
          if (!listenedLayer) continue;
          if (listen) listenedLayer.on("update", canvasLayer.needRedraw, canvasLayer);
          else listenedLayer.off("update", canvasLayer.needRedraw, canvasLayer);
          canvasLayer.listenedLayers[layerName] = listen;
        }
      };
      updateListeners(leafletLayer, false);
      leafletLayer.listenedLayers = {};
      leafletLayer.drawCalls = [];
      if (leafletLayer.userData === void 0) leafletLayer.userData = {};
      if (leafletLayer.compatContext === void 0) leafletLayer.compatContext = {};
      leafletLayer.clearClickableFeatures();
      for (const d of drawCode) {
        const drawCode2 = Function(`
// define visible variables
const ctx = this;
with(this.proxy) { ${d.code} }
`);
        if (d.feature) {
          const [srcLayer, srcFeature] = d.feature.split("?");
          leafletLayer.drawCalls.push((context2) => {
            const layer3 = this.getLeafletLayerByName(srcLayer);
            if (!layer3) return;
            const feature2 = layer3._features ? layer3._features[srcFeature] : void 0;
            if (!feature2) return;
            context2.feature = feature2;
            drawCode2.call(context2);
          });
          if (!_$1.has(leafletLayer.listenedLayers, srcLayer)) leafletLayer.listenedLayers[srcLayer] = false;
        } else if (d.layer) {
          leafletLayer.drawCalls.push((context2) => {
            const layer3 = this.getLeafletLayerByName(d.layer);
            if (!layer3) return;
            for (const feature2 of Object.values(layer3._features)) {
              context2.feature = feature2;
              drawCode2.call(context2);
            }
          });
          if (!_$1.has(leafletLayer.listenedLayers, d.layer)) leafletLayer.listenedLayers[d.layer] = false;
        }
      }
      if (!leafletLayer.onDrawLayer) {
        leafletLayer.onDrawLayer = (info) => {
          updateListeners(leafletLayer, true);
          const ctx = info.canvas.getContext("2d");
          const context2 = Object.assign(
            // current state context
            {
              canvas: ctx,
              now: Date.now(),
              zoom: info.zoom,
              latLonToCanvas: leafletLayer.latLonToCanvas.bind(leafletLayer),
              clearClickableFeatures: leafletLayer.clearClickableFeatures.bind(leafletLayer),
              addClickableFeature: leafletLayer.addClickableFeature.bind(leafletLayer),
              userData: leafletLayer.userData
            },
            leafletLayer.compatContext,
            // global context
            this.canvasLayerDrawContext
          );
          ctx.save();
          ctx.clearRect(0, 0, info.canvas.width, info.canvas.height);
          for (const draw of leafletLayer.drawCalls) draw(context2);
          ctx.restore();
        };
      }
      leafletLayer.setAutoRedraw(autoRedraw);
      leafletLayer.needRedraw();
    },
    setCanvasLayerUserData(layer2, userData) {
      const leafletLayer = typeof layer2 === "string" ? this.getLeafletLayerByName(layer2) : layer2;
      if (!leafletLayer) return;
      leafletLayer.userData = Object.assign(leafletLayer.userData, userData);
      leafletLayer.needRedraw();
    },
    setCanvasLayerAutoRedraw(layer2, autoRedraw) {
      const leafletLayer = typeof layer2 === "string" ? this.getLeafletLayerByName(layer2) : layer2;
      if (!leafletLayer) return;
      leafletLayer.setAutoRedraw(autoRedraw);
    },
    /* Compatibility methods */
    updateCanvasLayerDrawCode(layerName, newDrawCode, autoRedraw = false) {
      this.setCanvasLayerDrawCode(layerName, newDrawCode, autoRedraw);
    },
    setCanvasLayerContext(layerName, context2) {
      const leafletLayer = this.getLeafletLayerByName(layerName);
      if (!leafletLayer) return;
      leafletLayer.compatContext = context2;
      leafletLayer.needRedraw();
    }
  },
  created() {
    this.canvasLayerDrawProxy = new Proxy(window, {
      get: (target2, prop, receiver) => {
        return void 0;
      }
    });
    this.canvasLayerDrawContext = Object.assign({
      proxy: this.canvasLayerDrawProxy,
      // Math constants
      Math,
      // a few handy helpers for draw code
      vec2: (pointA, pointB) => {
        return { x: pointA.x - pointB.x, y: pointA.y - pointB.y };
      },
      len2: (vec2) => {
        return Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
      },
      scale2: (vec2, value) => {
        return { x: vec2.x * value, y: vec2.y * value };
      },
      norm2: (vec2) => {
        const len = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
        return { x: vec2.x / len, y: vec2.y / len };
      }
    }, CanvasDrawContext.get());
    this.registerLeafletConstructor(this.createLeafletCanvasLayer);
  },
  beforeUnmount() {
  }
};
const pmtilesLayers = {
  methods: {
    async createLeafletPMTilesLayer(options) {
      const leafletOptions = options.leaflet || options;
      if (leafletOptions.type !== "pmtiles") return;
      const planetApi = typeof options.getPlanetApi === "function" ? options.getPlanetApi() : api;
      const apiJwt = planetApi.hasConfig("apiJwt") ? await planetApi.get("storage").getItem(planetApi.getConfig("apiJwt")) : null;
      const gatewayJwt = planetApi.hasConfig("gatewayJwt") ? await planetApi.get("storage").getItem(planetApi.getConfig("gatewayJwt")) : null;
      const urlTemplate = _$1.get(leafletOptions, "urlTemplate");
      if (urlTemplate) leafletOptions.url = _$1.template(urlTemplate)({ apiJwt, gatewayJwt });
      const styleTemplate = _$1.get(leafletOptions, "styleTemplate");
      if (styleTemplate) leafletOptions.style = _$1.template(styleTemplate)({ apiJwt, gatewayJwt });
      const layerStyleTemplate = _$1.get(leafletOptions, "template");
      if (layerStyleTemplate) {
        leafletOptions.template = layerStyleTemplate.map((property) => ({
          property,
          compiler: _$1.template(_$1.get(leafletOptions, property))
        }));
      }
      let rules = {};
      let style2 = _$1.get(leafletOptions, "style");
      if (typeof style2 === "string") {
        const response = await fetch(style2);
        if (response.status !== 200) {
          throw new Error(`Impossible to fetch style ${style2}: ` + response.status);
        }
        style2 = await response.json();
        const backgroundLayer = style2.layers.find((layer2) => layer2.type === "background");
        if (backgroundLayer) leafletOptions.backgroundColor = backgroundLayer.paint["fill-color"];
        rules = mapbox_style(style2, {});
      } else {
        _$1.get(leafletOptions, "template", []).forEach((entry) => {
          const f = (zoom, feature2) => {
            const context2 = Object.assign({ properties: feature2.props, feature: feature2, chroma, moment, Units, Time, level: this.selectedLevel }, TemplateContext.get());
            return entry.property.endsWith("filter") ? entry.compiler(context2) === "true" : entry.compiler(context2);
          };
          _$1.set(leafletOptions, entry.property, f);
        });
        if (style2) {
          const styleRules = _$1.map(
            style2,
            (rule) => Object.assign(_$1.omit(rule, ["symbolizer"]), {
              symbolizer: new protomaps[rule.symbolizer.type](rule.symbolizer)
            })
          );
          const isLabelSymbolizer = (rule) => typeof rule.symbolizer.place === "function";
          const isNotLabelSymbolizer = (rule) => !isLabelSymbolizer(rule);
          rules.paint_rules = rules.paintRules = _$1.filter(styleRules, isNotLabelSymbolizer);
          rules.label_rules = rules.labelRules = _$1.filter(styleRules, isLabelSymbolizer);
        }
      }
      return this.createLeafletLayer({
        ...leafletOptions,
        ...rules
        //debug: true,
        //levelDiff: 2
      });
    },
    onCurrentTimeChangedPMTilesLayers(time) {
      const pmtileslayers = _$1.values(this.layers).filter(sift({
        "leaflet.type": "pmtiles",
        // Skip invisible layers
        isVisible: true
      }));
      pmtileslayers.forEach(async (pmtileslayer) => {
        const layer2 = this.getLeafletLayerByName(pmtileslayer.name);
        layer2.redraw();
      });
    },
    onCurrentLevelChangedPMTilesLayers(level) {
      let layer2 = this.selectableLevelsLayer;
      if (layer2) {
        const type = _$1.get(layer2, `${this.engine}.type`);
        if (type === "pmtiles") {
          layer2 = this.getLeafletLayerByName(layer2.name);
          layer2.redraw();
        }
      }
    }
  },
  created() {
    this.registerLeafletConstructor(this.createLeafletPMTilesLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers);
    this.$engineEvents.on("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  },
  beforeUnmount() {
    Events.off("time-current-time-changed", this.onCurrentTimeChangedPMTilesLayers);
    this.$engineEvents.off("selected-level-changed", this.onCurrentLevelChangedPMTilesLayers);
  }
};
L$1.pmtiles = function(options) {
  return protomaps.leafletLayer(options);
};
const mapMixins = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity: activity$1,
  baseMap,
  canvasLayers,
  editLayers,
  fileLayers: fileLayers$1,
  geojsonLayers: geojsonLayers$1,
  gsmapLayers,
  heatmapLayers,
  mapillaryLayers,
  pmtilesLayers,
  popup: popup$1,
  style: style$1,
  tiledMeshLayers,
  tiledWindLayers,
  tooltip: tooltip$1
}, Symbol.toStringTag, { value: "Module" }));
function createWallGeometry(positions, minimumHeights = [], maximumHeights = []) {
  if (!positions || positions.length < 2) return;
  minimumHeights = minimumHeights || Array(positions.length).fill(0);
  minimumHeights = Array.isArray(minimumHeights) ? minimumHeights : Array(positions.length).fill(minimumHeights);
  if (!maximumHeights) {
    maximumHeights = [];
    for (let i = 0, j = positions.length; i < j; ++i) {
      const cartographic = Cesium.Cartographic.fromCartesian(positions[i]);
      maximumHeights.push(cartographic.height);
    }
  }
  maximumHeights = Array.isArray(maximumHeights) ? maximumHeights : Array(positions.length).fill(maximumHeights);
  const setHeight = (cartesian, height) => {
    const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
    cartographic.height = height;
    return Cesium.Cartographic.toCartesian(cartographic);
  };
  const indices = [];
  const distances = [0];
  const times = (positions.length - 1) * 2;
  let lineLength = 0;
  let minHeight = -1;
  for (let i = 0; i < times; i++) {
    if (i % 2) {
      indices.push(i + 2, i - 1, i + 1);
    } else {
      indices.push(i + 1, i, i + 3);
    }
    if (positions[i + 1]) {
      const distance2 = Cesium.Cartesian3.distance(positions[i], positions[i + 1]);
      distances.push(distance2);
      lineLength += distance2;
    }
  }
  let percent = 0;
  const st = [];
  const wallPositions = [];
  for (let i = 0; i < positions.length; i++) {
    percent += distances[i] / lineLength;
    if (i === positions.length - 1) percent = 1;
    st.push(1 - percent, 0, 1 - percent, 1);
    const position2 = positions[i];
    const bottomPoint = setHeight(position2, minimumHeights[i]);
    const topPoint = setHeight(position2, maximumHeights[i]);
    wallPositions.push(
      bottomPoint.x,
      bottomPoint.y,
      bottomPoint.z,
      topPoint.x,
      topPoint.y,
      topPoint.z
    );
    const currentHeight = Math.abs(maximumHeights[i] - minimumHeights[i]);
    if (minHeight === -1 || currentHeight < minHeight) minHeight = currentHeight;
  }
  return {
    geometry: new Cesium.Geometry({
      attributes: {
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: wallPositions
        }),
        st: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 2,
          values: new Float64Array(st)
        })
      },
      indices: new Uint16Array(indices),
      primitiveType: Cesium.PrimitiveType.TRIANGLES,
      boundingSphere: Cesium.BoundingSphere.fromVertices(wallPositions)
    }),
    dimensions: {
      minHeight,
      lineLength
    }
  };
}
function createCorridorGeometry(positions, width, height) {
  if (!positions || positions.length < 2) return;
  const setHeight = (cartesian, height2) => {
    const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
    cartographic.height = height2;
    return Cesium.Cartographic.toCartesian(cartographic);
  };
  const angleBetweenThreePoints = (A, B, C) => {
    const AB = Cesium.Cartesian3.subtract(B, A, new Cesium.Cartesian3());
    const AC = Cesium.Cartesian3.subtract(C, A, new Cesium.Cartesian3());
    const dot = Cesium.Cartesian3.dot(AB, AC);
    const lengthAB = Cesium.Cartesian3.magnitude(AB);
    const lengthAC = Cesium.Cartesian3.magnitude(AC);
    return Math.acos(dot / (lengthAB * lengthAC));
  };
  const computeOffset = (current, previous, next, offset, normal2) => {
    let direction;
    if (!previous) {
      direction = Cesium.Cartesian3.subtract(next, current, new Cesium.Cartesian3());
    } else if (!next) {
      direction = Cesium.Cartesian3.subtract(current, previous, new Cesium.Cartesian3());
    } else {
      const forward = Cesium.Cartesian3.subtract(next, current, new Cesium.Cartesian3());
      const backward = Cesium.Cartesian3.subtract(current, previous, new Cesium.Cartesian3());
      direction = Cesium.Cartesian3.add(forward, backward, new Cesium.Cartesian3());
    }
    Cesium.Cartesian3.normalize(direction, direction);
    const up = normal2 || Cesium.Cartesian3.UNIT_Z;
    const perpendicular = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());
    Cesium.Cartesian3.normalize(perpendicular, perpendicular);
    const offsetVector = Cesium.Cartesian3.multiplyByScalar(perpendicular, offset, new Cesium.Cartesian3());
    return { direction, position: Cesium.Cartesian3.add(current, offsetVector, new Cesium.Cartesian3()) };
  };
  for (let i = 0; i < positions.length; i++) {
    positions[i] = setHeight(positions[i], height);
  }
  const normal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(positions[0]);
  const distances = [0];
  let lineLength = 0;
  const corridorPositions = [];
  let lastLeftPoint = null;
  let lastRightPoint = null;
  let lastDirection = null;
  for (let i = 0; i < positions.length; i++) {
    const left = computeOffset(positions[i], positions[i - 1], positions[i + 1], -width / 2, normal);
    const right = computeOffset(positions[i], positions[i - 1], positions[i + 1], width / 2, normal);
    if (i > 0) {
      const turnLeft = Cesium.Cartesian3.cross(left.direction, lastDirection, new Cesium.Cartesian3()).z < 0;
      const previousAngle = angleBetweenThreePoints(positions[i - 1], positions[i], turnLeft ? lastLeftPoint : lastRightPoint);
      const currentAngle = angleBetweenThreePoints(positions[i - 1], positions[i], turnLeft ? left.position : right.position);
      if (currentAngle > previousAngle) {
        if (turnLeft) left.position = lastLeftPoint;
        else right.position = lastRightPoint;
      }
      const distance2 = Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
      distances.push(distance2);
      lineLength += distance2;
    }
    corridorPositions.push(
      left.position.x,
      left.position.y,
      left.position.z,
      right.position.x,
      right.position.y,
      right.position.z
    );
    lastLeftPoint = left.position;
    lastRightPoint = right.position;
    lastDirection = left.direction;
  }
  let percent = 0;
  const st = [];
  const indices = [];
  for (let i = 0; i < positions.length; i++) {
    percent += distances[i] / lineLength;
    if (i === positions.length - 1) percent = 1;
    st.push(1 - percent, 0, 1 - percent, 1);
    if (i < positions.length - 1) {
      const baseIndex = i * 2;
      indices.push(
        baseIndex,
        baseIndex + 1,
        baseIndex + 2,
        baseIndex + 1,
        baseIndex + 3,
        baseIndex + 2
      );
    }
  }
  return {
    geometry: new Cesium.Geometry({
      attributes: {
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: corridorPositions
        }),
        st: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 2,
          values: new Float64Array(st)
        })
      },
      indices: new Uint16Array(indices),
      primitiveType: Cesium.PrimitiveType.TRIANGLES,
      boundingSphere: Cesium.BoundingSphere.fromVertices(corridorPositions)
    }),
    dimensions: {
      lineLength,
      width
    }
  };
}
function createMaterialWithMovingTexture(options) {
  if (!options.image) return;
  let material = null;
  try {
    material = Cesium.Material.fromType("MovingMaterial");
    material.uniforms.image = options.image;
    material.uniforms.repeat = new Cesium.Cartesian2(1, 1);
    material.uniforms.offset = new Cesium.Cartesian2(0, 0);
    material.translucent = options.translucent;
    throw new Error("Load material from type is not working");
  } catch (e) {
    const shaderSource = `
      czm_material czm_getMaterial(czm_materialInput materialInput) {
          czm_material material = czm_getDefaultMaterial(materialInput);

          vec2 st = materialInput.st * repeat + offset;

          // Loop texture with fract
          st = fract(st);

          vec4 color = texture(image, st);
          material.${options.useAsDiffuse ? "diffuse" : "emission"} = color.rgb;
          material.alpha = color.a * opacity;
          return material;
      }`;
    material = new Cesium.Material({
      fabric: {
        type: "MovingMaterial",
        source: shaderSource,
        uniforms: {
          image: options.image,
          repeat: new Cesium.Cartesian2(1, 1),
          offset: new Cesium.Cartesian2(0, 0),
          opacity: 0
        }
      },
      translucent: _$1.get(options, "translucent", false)
    });
  }
  return material;
}
function createPrimitiveWithMovingTexture(type, options) {
  if (!options.positions || !_$1.get(options, "material.image", false)) return;
  const geometryOptions = {
    positions: options.material.reverseAnimation === true ? options.positions.reverse() : options.positions
  };
  let geometry = null;
  switch (type) {
    case "wall":
      geometryOptions.minimumHeights = _$1.get(options, "minimumHeights", 0);
      geometryOptions.maximumHeights = _$1.get(options, "maximumHeights", null);
      geometry = createWallGeometry(geometryOptions.positions, geometryOptions.minimumHeights, geometryOptions.maximumHeights);
      break;
    case "corridor":
      geometryOptions.width = _$1.get(options, "width", 10);
      geometryOptions.height = _$1.get(options, "height", 0);
      geometry = createCorridorGeometry(geometryOptions.positions, geometryOptions.width, geometryOptions.height);
      break;
  }
  if (!geometry) return;
  const dimensions = geometry.dimensions;
  geometry = geometry.geometry;
  const material = createMaterialWithMovingTexture(_$1.get(options, "material"));
  if (!material) return;
  material.uniforms.repeat.x = dimensions.lineLength / (dimensions.minHeight || dimensions.width);
  const scale2 = _$1.get(options, "material.scale");
  let animationSpeedScale = 1;
  if (scale2) {
    if (Array.isArray(scale2)) {
      material.uniforms.repeat.x *= scale2[0];
      material.uniforms.repeat.y *= scale2[1];
      animationSpeedScale = scale2[0];
    } else {
      material.uniforms.repeat.x *= scale2;
      material.uniforms.repeat.y *= scale2;
      animationSpeedScale = scale2;
    }
  }
  return {
    primitive: new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({
        geometry
      }),
      appearance: new Cesium.MaterialAppearance({
        material,
        translucent: material.translucent
      }),
      asynchronous: false
    }),
    material: {
      material,
      animationSpeed: _$1.get(options, "material.animationSpeed") * animationSpeedScale,
      length: dimensions.lineLength
    }
  };
}
function getPrimitivesForEntity(entityId, viewer) {
  const pickObjects = viewer.scene.context._pickObjects;
  const primitives = [];
  for (const k in pickObjects) {
    const object = pickObjects[k];
    const id = _$1.get(object, "id._id");
    if (!id) continue;
    if (entityId.toString() === id) {
      const primitive = _$1.get(object, "primitive");
      if (primitive && !primitives.includes(primitive)) primitives.push(primitive);
    }
  }
  return primitives;
}
function convertCesiumHandlerEvent(type) {
  const buttonMapping = {
    left: 0,
    middle: 1,
    right: 2
  };
  const buttonMovement = type.split("_");
  const movement = buttonMovement[1].toLowerCase();
  let button = buttonMovement[0].toLowerCase();
  let name;
  if (type.startsWith("PINCH")) name = "pinch";
  else if (type.endsWith("CLICK")) name = "click";
  else if (type.endsWith("DOUBLE_CLICK")) name = "dblclick";
  else if (type.startsWith("WHEEL")) name = "wheel";
  else name = "mouse";
  if (name === "mouse") {
    name += movement;
    button = buttonMapping[button];
  } else if (name.endsWith("click")) {
    button = buttonMapping[button];
  } else if (name === "pinch") {
    name += movement;
    button = void 0;
  } else {
    button = 1;
  }
  return { name, button };
}
const GeoJsonCesiumLayerFilters = {
  // Filter to identify layers that require an update at a given frequency
  TimeUpdate: {
    // Possible for realtime layers only
    "cesium.type": "geoJson",
    "cesium.realtime": true,
    $or: [
      // Supported by template URL or time-based features service
      { "cesium.sourceTemplate": { $exists: true } },
      { service: { $exists: true } }
    ],
    // Skip layers powered by realtime service events
    serviceEvents: { $ne: true },
    // Skip invisible layers
    isVisible: true
  },
  // Filter to identify layers with variables affected by a unit change
  UnitUpdate: {
    "cesium.type": "geoJson",
    "cesium.realtime": true,
    // Not sure why but this does not seem to work with sift
    //'variables': { $elemMatch: { unit: { $in: units } } },
    "variables": { $exists: true },
    isVisible: true,
    $or: [{
      "cesium.style": { $exists: true },
      "cesium.template": { $exists: true }
    }, {
      "cesium.tooltip.template": { $exists: true }
    }]
  }
};
function updateCesiumGeoJsonEntity(source, destination2) {
  destination2.position = source.position;
  destination2.orientation = source.orientation;
  destination2.properties = source.properties;
  destination2.description = source.description;
  if (source.billboard) destination2.billboard = source.billboard;
  if (source.polyline) destination2.polyline = source.polyline;
  if (source.polygon) destination2.polygon = source.polygon;
}
function hasUnitInCesiumLayerTemplate(units, layer2) {
  const unit = _$1.intersection(units, _$1.map(layer2.variables, "unit"));
  if (_$1.isEmpty(unit)) return false;
  if (_$1.get(layer2, "cesium.tooltip.template", "").includes("Units")) return true;
  for (const template of layer2.cesium.template) {
    if (template.startsWith("style.")) {
      const style2 = _$1.get(layer2.cesium, template);
      if (typeof style2 === "string" && style2.includes("Units")) return true;
    }
  }
  return false;
}
function getTextTable(properties) {
  properties = dotify(properties);
  properties = _$1.pickBy(properties, (value) => !_$1.isNil(value));
  const keys = _$1.keys(properties);
  let text;
  if (keys.length === 0) return null;
  else if (keys.length === 1) text = _$1.get(properties, keys[0]);
  else {
    text = keys.map((key) => key + ": " + _$1.get(properties, key)).join("\n");
  }
  return text;
}
const CesiumStyleMappings = {
  stroke: "stroke",
  "stroke-color": "stroke",
  "stroke-opacity": "stroke.alpha",
  "stroke-width": "strokeWidth",
  fill: "fill",
  "fill-color": "fill",
  "fill-opacity": "fill.alpha",
  "marker-size": "markerSize",
  "marker-symbol": "markerSymbol",
  "marker-color": "markerColor"
};
const CesiumStyleOptions = _$1.values(CesiumStyleMappings);
const CesiumEntityTypes = [
  "billboard",
  "box",
  "corridor",
  "cylinder",
  "ellipse",
  "ellipsoid",
  "label",
  "model",
  "path",
  "plane",
  "point",
  "polygon",
  "polyline",
  "rectangle",
  "wall"
];
const GeoJsonGeometryTypesToCesiumEntityMappings = {
  Point: "point",
  LineString: "polyline",
  Polygon: "polygon"
};
const StyleToCesiumEntityStyleMappings = {
  altitudeMode: "heightReference",
  width: "width",
  color: "material"
};
const AltitudeModesMappings = {
  clampToGround: "Cesium.HeightReference.CLAMP_TO_GROUND",
  relativeToGround: "Cesium.HeightReference.RELATIVE_TO_GROUND",
  absolute: "Cesium.HeightReference.NONE"
};
function convertToCesiumFromSimpleStyle(style2, inPlace) {
  if (!style2) return {};
  const convertedStyle = inPlace ? style2 : {};
  _$1.forOwn(style2, (value, key) => {
    if (_$1.has(CesiumStyleMappings, key)) {
      const mapping = _$1.get(CesiumStyleMappings, key);
      if (typeof value === "string" && ["markerColor", "fill", "stroke"].includes(mapping)) {
        value = getHtmlColor(value);
        _$1.set(convertedStyle, mapping, Color.fromCssColorString(chroma(value).alpha(_$1.get(convertedStyle, [mapping, "alpha"], 1)).css()));
      } else {
        _$1.set(convertedStyle, mapping, value);
      }
      if (inPlace) _$1.unset(style2, key);
    }
  });
  return convertedStyle;
}
function convertToCesiumFromStyle(feature2, options) {
  let style2 = _$1.get(feature2, "style", false);
  if (!style2 || !_$1.get(feature2, "geometry")) return {};
  let geometryType = _$1.get(GeoJsonGeometryTypesToCesiumEntityMappings, _$1.get(feature2, "geometry.type"));
  if (!geometryType) return {};
  const kdkStyle = geometryType === "point" ? convertSimpleStyleToPointStyle(feature2.properties) : geometryType === "polyline" ? convertSimpleStyleToLineStyle(feature2.properties) : convertSimpleStyleToPolygonStyle(feature2.properties);
  style2 = Object.assign({}, style2, kdkStyle);
  const convertedStyle = {};
  const entityStyle = {};
  if (_$1.get(options, "cesium.minZoom") || _$1.get(options, "cesium.maxZoom")) {
    entityStyle.distanceDisplayCondition = {
      type: "Cesium.DistanceDisplayCondition",
      options: [
        _$1.get(options, "cesium.minZoom", 0) || 0,
        _$1.get(options, "cesium.maxZoom", Number.MAX_VALUE) || Number.MAX_VALUE
      ]
    };
  }
  _$1.forOwn(style2, (value, key) => {
    if (typeof value === "string" && ["color"].includes(key)) {
      let cesiumColor = Color.fromCssColorString(getColorFromPalette(value));
      if (_$1.has(style2, "opacity")) {
        cesiumColor = Color.fromAlpha(cesiumColor, _$1.get(style2, "opacity"));
      }
      _$1.set(entityStyle, _$1.get(StyleToCesiumEntityStyleMappings, key), cesiumColor);
    } else if (key === "altitudeMode") {
      _$1.set(entityStyle, _$1.get(StyleToCesiumEntityStyleMappings, key), _$1.get(AltitudeModesMappings, value));
      _$1.set(entityStyle, "clampToGround", value === "clampToGround");
    } else if (key === "extrude") {
      switch (geometryType) {
        case "polygon":
          _$1.set(entityStyle, "extrudedHeight", 0);
          _$1.set(entityStyle, "perPositionHeight", true);
          break;
        case "polyline":
          geometryType = "wall";
          break;
      }
    } else if (key === "icon") {
      geometryType = "billboard";
      _$1.set(entityStyle, "image", _$1.get(value, "url"));
    } else {
      const target2 = _$1.get(StyleToCesiumEntityStyleMappings, key);
      if (target2) _$1.set(entityStyle, target2, value);
    }
  });
  if (geometryType === "polygon" && !_$1.has(style2, "extrude") && (!_$1.has(style2, "altitudeMode") || style2.altitudeMode === "clampToGround")) {
    _$1.set(entityStyle, "perPositionHeight", false);
    if (_$1.get(feature2, "geometry.coordinates[0][0]", []).length < 3) {
      _$1.forEach(_$1.get(feature2, "geometry.coordinates", []), (coordinates, index2) => {
        feature2.geometry.coordinates[index2] = _$1.map(coordinates, (coord) => {
          return [coord[0], coord[1], 0];
        });
      });
    }
    if (_$1.get(style2, "opacity") === 0) {
      geometryType = "polyline";
      _$1.set(convertedStyle, "geometry.type", "LineString");
      _$1.set(convertedStyle, "geometry.coordinates", _$1.get(feature2, "geometry.coordinates[0]"));
      _$1.set(convertedStyle, "style.opacity", _$1.get(style2, "stroke.opacity", 1));
      _$1.set(entityStyle, "clampToGround", true);
    }
  }
  _$1.set(convertedStyle, ["properties", "entityStyle", geometryType], entityStyle);
  _$1.defaultsDeep(convertedStyle.properties.entityStyle, _$1.get(feature2, "properties.entityStyle", {}));
  return convertedStyle;
}
function processStyle(style2, feature2, options, mappings) {
  if (!options) return;
  const cesiumOptions = options.cesium || options;
  const context2 = Object.assign({ properties: feature2.properties, feature: feature2, chroma, moment, Units, Time }, TemplateContext.get());
  if (cesiumOptions.template) {
    if (options.variables) context2.variables = _$1.reduce(
      options.variables,
      (result, variable) => Object.assign(result, { [variable.name]: variable }),
      {}
    );
    cesiumOptions.template.forEach((entry) => {
      _$1.set(style2, _$1.get(mappings, _$1.kebabCase(entry.property), entry.property), entry.compiler(context2));
    });
  }
  const type = getFeatureStyleType(feature2);
  _$1.get(style2, `style.${type}.visibility`, _$1.get(style2, "style.visibility", true));
  return style2;
}
function getPointSimpleStyle(feature2, options, engine, engineStylePath = "style.point") {
  const engineStyle = _$1.get(engine, engineStylePath, {});
  const layerStyle = options ? _$1.get(options.cesium || options, "layerPointStyle") : {};
  const templateStyle = processStyle({ style: { point: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, PointStyleTemplateMappings);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : _$1.get(feature2, "style", {});
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.point : {}, featureStyle);
  return convertSimpleStyleColors(convertPointStyleToSimpleStyle(style2));
}
function getLineSimpleStyle(feature2, options, engine, engineStylePath = "style.line") {
  const engineStyle = _$1.get(engine, engineStylePath, {});
  const layerStyle = options ? _$1.get(options.cesium || options, "layerLineStyle") : {};
  const templateStyle = processStyle({ style: { line: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, LineStyleTemplateMappings);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : _$1.get(feature2, "style", {});
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.line : {}, featureStyle);
  return convertSimpleStyleColors(convertLineStyleToSimpleStyle(style2));
}
function getPolygonSimpleStyle(feature2, options, engine, engineStylePath = "style.polygon") {
  const engineStyle = _$1.get(engine, engineStylePath, {});
  const layerStyle = options ? _$1.get(options.cesium || options, "layerPolygonStyle") : {};
  const templateStyle = processStyle({ style: { polygon: _$1.merge({}, engineStyle, layerStyle) } }, feature2, options, PolygonStyleTemplateMappings);
  const featureStyle = _$1.get(options, "ignoreFeatureStyle") ? {} : _$1.get(feature2, "style", {});
  const style2 = _$1.merge({}, engineStyle, layerStyle, templateStyle ? templateStyle.style.polygon : {}, featureStyle);
  return convertSimpleStyleColors(convertPolygonStyleToSimpleStyle(style2));
}
function createCesiumObject() {
  const args = Array.from(arguments);
  const constructor = args[0];
  args.shift();
  const Class = _$1.get(Cesium$1, constructor);
  let object;
  if (typeof Class === "function") {
    try {
      object = Class(...args);
    } catch (error) {
    }
    try {
      object = new Class(...args);
    } catch (error) {
    }
  } else object = Class;
  return object;
}
function convertToCesiumObjects(style2) {
  const mapValue = (value) => {
    if (typeof value === "object") {
      const type = value.type;
      const options = value.options;
      if (type && options) {
        const constructor = type.replace("Cesium.", "");
        let args;
        if (options.type) {
          args = convertToCesiumObjects({ object: options });
          args = args.object;
        } else {
          args = convertToCesiumObjects(options);
        }
        if (Array.isArray(options)) return createCesiumObject(constructor, ...args);
        else return createCesiumObject(constructor, args);
      } else return convertToCesiumObjects(value);
    } else if (typeof value === "string") {
      if (value.startsWith("Cesium.")) {
        const constructor = value.replace("Cesium.", "");
        return createCesiumObject(constructor);
      }
      const n = _$1.toNumber(value);
      if (_$1.isFinite(n)) value = n;
    }
    return value;
  };
  if (typeof style2 === "object") {
    if (Array.isArray(style2)) return style2.map(mapValue);
    else return _$1.mapValues(style2, mapValue);
  } else {
    return _$1.mapValues({ value: style2 }, mapValue).value;
  }
}
async function convertEntitiesToGeoJson(entities) {
  const features = [];
  if (entities.values.length === 0) return { type: "FeatureCollection", features };
  _$1.forEach(entities.values, (entity) => {
    if (entity.feature) features.push(entity.feature);
  });
  if (features.length > 0) return { type: "FeatureCollection", features };
  const kmlEntities = await exportKml({ entities, modelCallback: () => "" });
  const parser2 = new DOMParser();
  return kml(parser2.parseFromString(kmlEntities.kml, "application/xml"));
}
window.CESIUM_BASE_URL = "/Cesium/";
buildModuleUrl.setBaseUrl("/Cesium/");
const baseGlobe = {
  emits: [
    "globe-ready",
    "layer-added",
    "layer-removed",
    "layer-shown",
    "layer-hidden"
  ],
  data() {
    return {
      layers: {}
    };
  },
  methods: {
    refreshGlobe() {
    },
    setupGlobe(domEl, token, options = {}) {
      this.viewerOptions = _$1.defaults(options, _$1.get(this, "activityOptions.engine.viewer", {}), {
        sceneMode: 3,
        // SceneMode.COLUMBUS_VIEW = 1, SceneMode.SCENE3D = 3,
        sceneModePicker: false,
        infoBox: false,
        scene3DOnly: true,
        homeButton: false,
        geocoder: false,
        navigationHelpButton: false,
        baseLayer: false,
        baseLayerPicker: false,
        vrButton: false,
        fullscreenButton: false,
        animation: false,
        timeline: false,
        depthTestAgainstTerrain: false,
        cameraMoveEventPercentage: 0.2,
        entityLoadTextureDelay: 24
      });
      if (token) Ion.defaultAccessToken = token;
      else Ion.defaultAccessToken = "";
      Object.assign(this.viewerOptions, {
        imageryProviderViewModels: [],
        terrainProviderViewModels: []
      });
      this.viewer = new Viewer(domEl, this.viewerOptions);
      this.viewer.scene.globe.depthTestAgainstTerrain = _$1.get(this.viewerOptions, "depthTestAgainstTerrain", false);
      const backgroundColor = _$1.get(this.viewerOptions, "backgroundColor");
      this.viewer.scene.backgroundColor = backgroundColor ? createCesiumObject("Color", ...backgroundColor) : Color.BLACK;
      if (this.viewer.scene.globe) {
        const baseColor = _$1.get(this.viewerOptions, "baseColor");
        this.viewer.scene.globe.baseColor = baseColor ? createCesiumObject("Color", ...baseColor) : Color.BLACK;
        const undergroundColor = _$1.get(this.viewerOptions, "undergroundColor");
        this.viewer.scene.globe.undergroundColor = undergroundColor ? createCesiumObject("Color", ...undergroundColor) : Color.BLACK;
      }
      if (!_$1.has(Cesium$1.Primitive.prototype, "pickIds")) {
        Object.defineProperties(Cesium$1.Primitive.prototype, {
          pickIds: {
            get: function() {
              return this._pickIds;
            },
            set: function(value) {
              this._pickIds = value;
            }
          }
        });
      }
      this.viewer.scene.preRender.addEventListener(() => {
        if (!this.cesiumMaterials) return;
        _$1.forEach(this.cesiumMaterials, (m) => {
          if (!m.material.uniforms.offset) return;
          if (!m.startTime) m.startTime = Date.now();
          const elapsed = (Date.now() - m.startTime) * 1e-3;
          if (m.animationSpeed) {
            const loopDuration = m.length / m.material.uniforms.repeat.x / m.animationSpeed;
            m.material.uniforms.offset.x = elapsed % loopDuration / loopDuration;
          }
        });
      });
      if (this.viewerOptions.debug) this.viewer.extend(viewerCesiumInspectorMixin);
      if (this.viewer.scene.imageryLayers) this.viewer.scene.imageryLayers.removeAll();
      this.registerCesiumHandler(this.getDefaultPickHandler, "MOUSE_MOVE");
      this.registerCesiumHandler(this.getDefaultPickHandler, "LEFT_CLICK");
      this.registerCesiumHandler(this.getDefaultPickHandler, "RIGHT_CLICK");
      this.viewer.camera.moveStart.addEventListener(this.onCameraMoveStart);
      this.viewer.camera.moveEnd.addEventListener(this.onCameraMoveEnd);
      this.viewer.camera.percentageChanged = this.viewerOptions.cameraMoveEventPercentage;
      this.viewer.camera.changed.addEventListener(this.onCameraChanged);
      this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_CLICK);
      this.viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
      this.viewBounds = new Rectangle();
      this.onGlobeReady();
    },
    onGlobeReady() {
      this.$emit("globe-ready", "cesium");
      this.$engineEvents.emit("globe-ready", "cesium");
    },
    processCesiumLayerOptions(options) {
      const processedOptions = _$1.cloneDeep(options);
      processedOptions.cesium.iconUrl = buildModuleUrl(processedOptions.iconUrl);
      processedOptions.cesium.name = processedOptions.name;
      processedOptions.cesium.attribution = processedOptions.attribution;
      return processedOptions;
    },
    async createCesiumLayer(options) {
      let cesiumOptions = options.cesium || options;
      cesiumOptions = this.convertToCesiumObjects(cesiumOptions);
      let args = [cesiumOptions];
      let provider, createFunction, isImageryProvider;
      if (cesiumOptions.type === "3DTileset") {
        provider = createFunction = "Cesium3DTileset.fromUrl";
        args = [cesiumOptions.url].concat([_$1.omit(cesiumOptions, ["url", "style"])]);
      } else if (isTerrainLayer(cesiumOptions)) {
        if (cesiumOptions.type === "Ellipsoid") {
          provider = "EllipsoidTerrainProvider";
        } else if (cesiumOptions.url || cesiumOptions.assetId) {
          provider = createFunction = cesiumOptions.url ? "CesiumTerrainProvider.fromUrl" : "CesiumTerrainProvider.fromIonAssetId";
          args = [cesiumOptions.url || cesiumOptions.assetId].concat([_$1.omit(cesiumOptions, ["url", "assetId"])]);
        } else {
          provider = createFunction = "createWorldTerrainAsync";
        }
      } else {
        provider = cesiumOptions.type;
        createFunction = `create${provider}Async`;
        if (_$1.get(Cesium$1, createFunction)) {
          provider = createFunction;
        } else {
          isImageryProvider = true;
          provider += "ImageryProvider";
          createFunction = `${provider}.fromUrl`;
          if (_$1.get(Cesium$1, createFunction)) {
            provider = createFunction;
            args = [cesiumOptions.url].concat([_$1.omit(cesiumOptions, ["url"])]);
          }
        }
      }
      const Constructor = _$1.get(Cesium$1, provider);
      if (!Constructor) return;
      if (provider === createFunction) provider = await Constructor(...args);
      else provider = new Constructor(...args);
      if (cesiumOptions.type === "3DTileset" && _$1.has(cesiumOptions, "style")) provider.style = _$1.get(cesiumOptions, "style");
      return isImageryProvider ? new ImageryLayer(provider) : provider;
    },
    registerCesiumConstructor(constructor) {
      this.cesiumFactory.push(constructor);
    },
    registerCesiumHandler(handler, eventType) {
      if (!this.cesiumHandler) this.cesiumHandler = new ScreenSpaceEventHandler(this.viewer.scene.canvas);
      const originalEvent = convertCesiumHandlerEvent(eventType);
      this.cesiumHandler.setInputAction(
        (event) => handler(Object.assign(event, { originalEvent })),
        ScreenSpaceEventType[eventType]
      );
    },
    unregisterCesiumHandler(eventType) {
      this.cesiumHandler.removeInputAction(ScreenSpaceEventType[eventType]);
    },
    async createLayer(options) {
      const processedOptions = this.processCesiumLayerOptions(options);
      let layer2;
      for (let i = 0; i < this.cesiumFactory.length; i++) {
        const constructor = this.cesiumFactory[i];
        layer2 = await constructor(processedOptions);
        if (layer2) break;
      }
      layer2 = layer2 || await this.createCesiumLayer(processedOptions);
      layer2.processedOptions = processedOptions;
      return layer2;
    },
    hasLayer(name) {
      return _$1.has(this.layers, name);
    },
    isLayerVisible(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return false;
      const cesiumLayer = this.getCesiumLayerByName(name);
      if (isTerrainLayer(layer2)) {
        return this.viewer.terrainProvider === cesiumLayer;
      } else if (cesiumLayer instanceof ImageryLayer) {
        return this.viewer.scene.imageryLayers.contains(cesiumLayer);
      } else if (cesiumLayer instanceof Cesium3DTileset) {
        return this.viewer.scene.primitives.contains(cesiumLayer) && cesiumLayer.show;
      } else {
        return this.viewer.dataSources.contains(cesiumLayer);
      }
    },
    isLayerDisabled(layer2) {
      return false;
    },
    getLayerByName(name) {
      return this.layers[name];
    },
    getCesiumLayerByName(name) {
      return this.cesiumLayers[name];
    },
    getLayerById(id) {
      const layers = this.getLayers({ _id: id });
      return _$1.get(layers, "[0]");
    },
    getLayers(filter = {}) {
      return _$1.values(this.layers).filter(sift(filter));
    },
    hasLayers(filter = {}) {
      return _$1.values(this.layers).filter(sift(filter)).length > 0;
    },
    async showLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      if (this.isLayerVisible(name)) return;
      let cesiumLayer = this.getCesiumLayerByName(name);
      if (!cesiumLayer) {
        try {
          cesiumLayer = await this.createLayer(layer2);
        } catch (error) {
          logger$1.error(error);
          return;
        }
      }
      this.cesiumLayers[name] = cesiumLayer;
      if (isTerrainLayer(layer2)) {
        this.viewer.terrainProvider = cesiumLayer;
      } else if (cesiumLayer instanceof ImageryLayer) {
        this.viewer.scene.imageryLayers.add(cesiumLayer);
      } else if (cesiumLayer instanceof Cesium3DTileset) {
        cesiumLayer.show = true;
        if (!this.viewer.scene.primitives.contains(cesiumLayer)) this.viewer.scene.primitives.add(cesiumLayer);
      } else {
        for (const [id, custom] of cesiumLayer.primitives)
          custom.primitive.show = true;
        this.viewer.dataSources.add(cesiumLayer);
      }
      layer2.isVisible = true;
      this.onLayerShown(layer2, cesiumLayer);
    },
    onLayerShown(layer2, cesiumLayer) {
      this.$emit("layer-shown", layer2, cesiumLayer);
      this.$engineEvents.emit("layer-shown", layer2, cesiumLayer);
    },
    hideLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      if (!this.isLayerVisible(name)) return;
      layer2.isVisible = false;
      const cesiumLayer = this.cesiumLayers[name];
      delete this.cesiumLayers[name];
      if (isTerrainLayer(layer2)) {
        this.viewer.terrainProvider = null;
      } else if (cesiumLayer instanceof ImageryLayer) {
        this.viewer.scene.imageryLayers.remove(cesiumLayer, false);
      } else if (cesiumLayer instanceof Cesium3DTileset) {
        cesiumLayer.show = false;
      } else {
        for (const [id, custom] of cesiumLayer.primitives)
          custom.primitive.show = false;
        this.viewer.dataSources.remove(cesiumLayer, true);
      }
      this.onLayerHidden(layer2, cesiumLayer);
    },
    onLayerHidden(layer2, cesiumLayer) {
      this.$emit("layer-hidden", layer2, cesiumLayer);
      this.$engineEvents.emit("layer-hidden", layer2, cesiumLayer);
    },
    async addLayer(layer2) {
      if (layer2 && !this.hasLayer(layer2.name)) {
        layer2.isVisible = false;
        layer2.isDisabled = this.isLayerDisabled(layer2);
        this.layers[layer2.name] = layer2;
        this.onLayerAdded(layer2);
        if (_$1.get(layer2, "cesium.isVisible", false)) await this.showLayer(layer2.name);
      }
      return layer2;
    },
    onLayerAdded(layer2) {
      this.$emit("layer-added", layer2);
      this.$engineEvents.emit("layer-added", layer2);
    },
    async addGeoJsonLayer(layerSpec, geoJson, zoom) {
      if (!generateLayerDefinition(layerSpec, geoJson)) return;
      await this.addLayer(layerSpec);
      await this.updateLayer(layerSpec.name, geoJson);
      if (zoom) {
        if (geoJson.bbox) this.zoomToBBox(geoJson.bbox);
        else this.zoomToLayer(layerSpec.name);
      }
    },
    renameLayer(previousName, newName) {
      const layer2 = this.getLayerByName(previousName);
      const cesiumLayer = this.getCesiumLayerByName(previousName);
      if (!layer2) return;
      if (cesiumLayer) {
        this.cesiumLayers[newName] = cesiumLayer;
        delete this.cesiumLayers[previousName];
      }
      this.layers[newName] = layer2;
      delete this.layers[previousName];
    },
    removeLayer(name) {
      const layer2 = this.getLayerByName(name);
      if (!layer2) return;
      this.hideLayer(name);
      const cesiumLayer = this.cesiumLayers[name];
      if (cesiumLayer instanceof Cesium3DTileset) {
        this.viewer.scene.primitives.remove(cesiumLayer);
      }
      delete this.layers[layer2.name];
      delete this.cesiumLayers[name];
      this.onLayerRemoved(layer2);
    },
    onLayerRemoved(layer2) {
      this.$emit("layer-removed", layer2);
      this.$engineEvents.emit("layer-removed", layer2);
    },
    clearLayers() {
      Object.keys(this.layers).forEach((layer2) => this.removeLayer(layer2));
    },
    async toGeoJson(name) {
      if (!this.isLayerVisible(name)) {
        const cachedGeojson = this.geojsonCache[name];
        if (cachedGeojson) return cachedGeojson;
      }
      const layer2 = this.getCesiumLayerByName(name);
      if (!layer2.entities) return;
      const geoJson = await convertEntitiesToGeoJson(layer2.entities);
      return geoJson;
    },
    zoomToBounds(bounds, heading = 0, pitch = -90, roll = 0, duration = 0) {
      this.viewer.camera.flyTo({
        destination: Array.isArray(bounds) ? Rectangle.fromDegrees(bounds[0][1], bounds[0][0], bounds[1][1], bounds[1][0]) : bounds,
        orientation: {
          heading: Math$1.toRadians(heading),
          pitch: Math$1.toRadians(pitch),
          roll: Math$1.toRadians(roll)
        },
        duration
      });
    },
    zoomToBBox(bbox2, heading = 0, pitch = -90, roll = 0, duration = 0) {
      this.zoomToBounds([[bbox2[1], bbox2[0]], [bbox2[3], bbox2[2]]], heading, pitch, roll, duration);
    },
    zoomToLayer(name) {
      const layer2 = this.getCesiumLayerByName(name);
      if (!layer2) return;
      if (layer2.entities) {
        this.viewer.flyTo(layer2.entities, { duration: 0 });
      } else {
        const bbox2 = _$1.get(layer2, "bbox");
        if (bbox2) {
          this.zoomToBBox(bbox2);
        } else {
          const bounds = _$1.get(layer2, "cesium.rectangle", [[-90, -180], [90, 180]]);
          this.zoomToBounds(bounds);
        }
      }
    },
    center(longitude, latitude, altitude2, heading = 0, pitch = -90, roll = 0, options = {}) {
      const center2 = this.viewer.camera.positionCartographic;
      const duration = _$1.get(options, "duration", 0);
      const destination2 = Cartesian3.fromDegrees(longitude, latitude, altitude2 || center2.height);
      const orientation = new HeadingPitchRoll(
        Math$1.toRadians(heading),
        Math$1.toRadians(pitch),
        Math$1.toRadians(roll)
      );
      const destinationOffset = new Cartesian3(
        _$1.get(options, "offset.x", 0),
        _$1.get(options, "offset.y", 0),
        _$1.get(options, "offset.z", 0)
      );
      const orientationOffset = new HeadingPitchRoll(
        Math$1.toRadians(_$1.get(options, "offset.heading", 0)),
        Math$1.toRadians(_$1.get(options, "offset.pitch", 0)),
        Math$1.toRadians(_$1.get(options, "offset.roll", 0))
      );
      const target2 = {
        destination: destination2,
        orientation: {
          heading: orientation.heading,
          pitch: orientation.pitch,
          roll: orientation.roll
        },
        duration
      };
      if (duration) this.viewer.camera.flyTo(target2);
      else this.viewer.camera.setView(target2);
      this.viewer.camera.move(this.viewer.camera.right, destinationOffset.x);
      this.viewer.camera.move(this.viewer.camera.direction, destinationOffset.y);
      this.viewer.camera.move(this.viewer.camera.up, destinationOffset.z);
      this.viewer.camera.look(this.viewer.camera.up, orientationOffset.heading);
      this.viewer.camera.look(this.viewer.camera.direction, orientationOffset.pitch);
      this.viewer.camera.look(this.viewer.camera.right, orientationOffset.roll);
      if (this.viewerOptions.debug) {
        const baseQuaternion = Transforms.headingPitchRollQuaternion(destination2, orientation, Ellipsoid.WGS84, Transforms.eastNorthUpToFixedFrame);
        const cameraQuaternion = Transforms.headingPitchRollQuaternion(
          this.viewer.camera.positionWC,
          new HeadingPitchRoll(this.viewer.camera.heading, this.viewer.camera.pitch, this.viewer.camera.roll),
          Ellipsoid.WGS84,
          Transforms.eastNorthUpToFixedFrame
        );
        if (this.baseFrameDebug) {
          this.baseFrameDebug.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(baseQuaternion), destination2);
          this.finalFrameDebug.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(cameraQuaternion), this.viewer.camera.positionWC);
        } else {
          this.baseFrameDebug = new DebugModelMatrixPrimitive({
            modelMatrix: Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(baseQuaternion), destination2),
            length: 25,
            width: 5
          });
          this.viewer.scene.primitives.add(this.baseFrameDebug);
          this.finalFrameDebug = new DebugModelMatrixPrimitive({
            modelMatrix: Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(cameraQuaternion), this.viewer.camera.positionWC),
            length: 25,
            width: 5
          });
          this.viewer.scene.primitives.add(this.finalFrameDebug);
        }
        if (this.cameraDebug) this.viewer.scene.primitives.remove(this.cameraDebug);
        this.cameraDebug = new DebugCameraPrimitive({
          camera: this.viewer.camera,
          color: Cesium$1.Color.YELLOW,
          updateOnChange: false
        });
        this.viewer.scene.primitives.add(this.cameraDebug);
      }
    },
    getCenter() {
      const center2 = this.viewer.camera.positionCartographic;
      return {
        longitude: Math$1.toDegrees(center2.longitude),
        latitude: Math$1.toDegrees(center2.latitude),
        altitude: center2.height
      };
    },
    getBounds() {
      const bounds = this.viewer.camera.computeViewRectangle(this.viewer.scene.globe.ellipsoid, this.viewBounds);
      const south = Math$1.toDegrees(bounds.south);
      const west = Math$1.toDegrees(bounds.west);
      const north = Math$1.toDegrees(bounds.north);
      const east = Math$1.toDegrees(bounds.east);
      return [[south, west], [north, east]];
    },
    getCamera() {
      const position2 = this.viewer.camera.positionCartographic;
      return {
        longitude: Math$1.toDegrees(position2.longitude),
        latitude: Math$1.toDegrees(position2.latitude),
        altitude: position2.height,
        heading: Math$1.toDegrees(this.viewer.camera.heading),
        pitch: Math$1.toDegrees(this.viewer.camera.pitch),
        roll: Math$1.toDegrees(this.viewer.camera.roll),
        fovy: this.viewer.camera.frustum.fovy,
        viewMatrix: this.viewer.camera.viewMatrix,
        inverseViewMatrix: this.viewer.camera.inverseViewMatrix
      };
    },
    getAnimatedHeading(timestamp) {
      if (!this.headingAnimation.startTime) this.headingAnimation.startTime = timestamp;
      const { duration, startTime, easing, startHeading, endHeading } = this.headingAnimation;
      const elapsed = timestamp - startTime;
      const percent = Math.abs(elapsed / (1e3 * duration));
      if (percent > 1) {
        return endHeading;
      }
      const easingFunction = _$1.get(easing, "function", "cubicBezier");
      const easingParameters = _$1.get(easing, "parameters", []);
      const percentHeading = maths[easingFunction](percent, ...easingParameters);
      return Math$1.lerp(
        startHeading,
        endHeading,
        percentHeading
      );
    },
    onEntityTracked(time) {
      const getSmallestAngle = (start, end) => {
        let diff = (end - start + Math.PI) % (2 * Math.PI);
        if (diff < 0) diff += 2 * Math.PI;
        return diff - Math.PI;
      };
      if (this.viewerOptions.debug) {
        if (this.trackedFrameDebug) {
          this.trackedFrameDebug.modelMatrix = this.viewer.trackedEntity.computeModelMatrix(time);
        } else {
          this.trackedFrameDebug = new DebugModelMatrixPrimitive({
            modelMatrix: this.viewer.trackedEntity.computeModelMatrix(time),
            length: 25,
            width: 5
          });
          this.viewer.scene.primitives.add(this.trackedFrameDebug);
        }
      }
      if (!this.viewer.trackedEntity || !_$1.get(this.entityTrackingOptions, "mode")) return;
      const mode = this.entityTrackingOptions.mode;
      const currentTime = Date.now();
      if (mode === "freeLook" && !_$1.get(this.entityTrackingOptions, "resetHeading")) return;
      const targetPosition = this.viewer.trackedEntity.position.getValue(time);
      const orientation = this.viewer.trackedEntity.orientation.getValue(time);
      if (!orientation) return;
      const distance2 = _$1.get(this.entityTrackingOptions, "distance", 10);
      const headingOffset = Math$1.toRadians(_$1.get(this.entityTrackingOptions, "offset.heading", 0));
      const pitchOffset = Math$1.toRadians(_$1.get(this.entityTrackingOptions, "offset.pitch", 0));
      const headingPitchRoll = HeadingPitchRoll.fromQuaternion(orientation);
      if (_$1.get(this.entityTrackingOptions, "animate")) {
        if (!this.headingAnimation) {
          this.headingAnimation = {
            ...this.entityTrackingOptions,
            startTime: currentTime,
            startHeading: this.viewer.camera.heading - headingOffset,
            endHeading: mode === "freeLook" ? 0 - headingOffset : headingPitchRoll.heading
          };
          this.headingAnimation.endHeading = this.headingAnimation.startHeading + getSmallestAngle(this.headingAnimation.startHeading, this.headingAnimation.endHeading);
        } else if (mode === "followOrientation") {
          this.headingAnimation.endHeading = this.headingAnimation.startHeading + getSmallestAngle(this.headingAnimation.startHeading, headingPitchRoll.heading);
        }
      }
      let heading = 0;
      if (_$1.get(this.entityTrackingOptions, "animate")) {
        heading = this.getAnimatedHeading(currentTime);
        if (heading === this.headingAnimation.endHeading) {
          _$1.set(this.entityTrackingOptions, "animate", false);
          _$1.set(this.entityTrackingOptions, "resetHeading", false);
          this.headingAnimation = null;
        }
      } else if (mode === "followOrientation") {
        heading = headingPitchRoll.heading;
      }
      const position2 = new Cartesian3(
        targetPosition.x + _$1.get(this.entityTrackingOptions, "offset.x", 0),
        targetPosition.y + _$1.get(this.entityTrackingOptions, "offset.y", 0),
        targetPosition.z + _$1.get(this.entityTrackingOptions, "offset.z", 0)
      );
      const cameraOffset = new HeadingPitchRange(
        heading + headingOffset,
        pitchOffset,
        distance2
      );
      this.viewer.camera.lookAt(new Cartesian3(position2.x, position2.y, position2.z), cameraOffset);
    },
    trackEntity(entityId, options = {}) {
      let newEntity = null;
      this.viewer.entities.values.forEach((entity) => {
        if (entityId === entity.id) {
          newEntity = entity;
        }
      });
      for (let i = 0; i < this.viewer.dataSources.length; i++) {
        const source = this.viewer.dataSources.get(i);
        source.entities.values.forEach((entity) => {
          if (entityId === entity.id) {
            newEntity = entity;
          }
        });
      }
      if (!newEntity) return;
      this.entityTrackingOptions = options;
      _$1.set(this.entityTrackingOptions, "animate", true);
      if (newEntity === this.viewer.trackedEntity) return;
      this.untrackEntity();
      this.viewer.trackedEntity = newEntity;
      this.viewer.clock.onTick.addEventListener(this.onEntityTracked);
    },
    untrackEntity() {
      if (this.viewer.trackedEntity) {
        if (this.trackedFrameDebug) this.viewer.scene.primitives.remove(this.trackedFrameDebug);
        this.viewer.clock.onTick.removeEventListener(this.onEntityTracked);
      }
      this.viewer.trackedEntity = null;
    },
    async showUserLocation() {
      if (Geolocation.hasLocation()) {
        const longitude = Geolocation.getLongitude();
        const latitude = Geolocation.getLatitude();
        this.center(longitude, latitude);
        const pinBuilder = new PinBuilder();
        const canvas = await pinBuilder.fromMakiIconId("marker", Color.fromCssColorString(getCssVar("primary")), 48);
        this.userLocationEntity = this.viewer.entities.add({
          name: "user-location",
          position: Cartesian3.fromDegrees(longitude, latitude),
          billboard: {
            image: canvas.toDataURL(),
            verticalOrigin: VerticalOrigin.BOTTOM
          }
        });
        this.viewer.selectedEntity = this.userLocationEntity;
        this.userLocation = true;
      }
    },
    hideUserLocation() {
      if (this.userLocationEntity) {
        this.viewer.entities.remove(this.userLocationEntity);
        this.userLocationEntity = null;
      }
      this.userLocation = false;
    },
    isUserLocationVisible() {
      return this.userLocation;
    },
    setCursor(className) {
      this.viewer.container.classList.add(className);
    },
    isCursor(className) {
      return this.viewer.container.classList.contains(className);
    },
    unsetCursor(className) {
      this.viewer.container.classList.remove(className);
    },
    getLayerNameForEntity(entity) {
      let layerName;
      _$1.forOwn(this.cesiumLayers, (value, key) => {
        if (!layerName && value.entities) {
          if (value.entities.contains(entity)) layerName = key;
        }
      });
      return layerName;
    },
    getNbChildrenForEntity(entity) {
      if (entity._children) return entity._children.length;
      else return 0;
    },
    getChildForEntity(entity, index2) {
      if (this.getNbChildrenForEntity(entity) > 0) return entity._children[index2 || 0];
    },
    getPositionForEntity(entity) {
      let position2 = entity.position;
      if (!position2) {
        if (entity.polygon) {
          position2 = BoundingSphere.fromPoints(entity.polygon.hierarchy.getValue().positions).center;
        } else if (entity.polyline) {
          position2 = BoundingSphere.fromPoints(entity.polyline.positions.getValue()).center;
        } else if (entity.wall) {
          position2 = BoundingSphere.fromPoints(entity.wall.positions.getValue()).center;
        }
        if (position2) Ellipsoid.WGS84.scaleToGeodeticSurface(position2, position2);
      }
      return position2;
    },
    async getDefaultPickHandler(event) {
      const emittedEvent = {};
      let options;
      let pickedPosition = this.viewer.camera.pickEllipsoid(event.endPosition || event.position, this.viewer.scene.globe.ellipsoid);
      if (pickedPosition) {
        emittedEvent.pickedPosition = pickedPosition;
        pickedPosition = Cartographic.fromCartesian(pickedPosition);
        const longitude = Math$1.toDegrees(pickedPosition.longitude);
        const latitude = Math$1.toDegrees(pickedPosition.latitude);
        emittedEvent.latlng = [latitude, longitude];
        emittedEvent.latlng.lng = longitude;
        emittedEvent.latlng.lat = latitude;
      }
      const pickedObject = this.viewer.scene.pick(event.endPosition || event.position);
      if (pickedObject) {
        emittedEvent.target = pickedObject.id || pickedObject.primitive.id;
        if (emittedEvent.target instanceof Entity) {
          if (!emittedEvent.target.feature) {
            let feature2 = {
              _id: emittedEvent.target.id,
              type: "Feature"
            };
            if (typeof exportKml === "function") {
              const selection = new EntityCollection();
              selection.add(emittedEvent.target);
              const geoJson = await convertEntitiesToGeoJson(selection);
              if (geoJson.features.length > 0) {
                Object.assign(feature2, geoJson.features[0]);
              }
            }
            if (!feature2.geometry) {
              const position2 = Cartographic.fromCartesian(emittedEvent.target.position ? emittedEvent.target.position.getValue(0) : emittedEvent.pickedPosition);
              feature2.geometry = {
                type: "Point",
                coordinates: [Math$1.toDegrees(position2.longitude), Math$1.toDegrees(position2.latitude)]
              };
            }
            feature2.properties = emittedEvent.target.properties ? emittedEvent.target.properties.getValue(0) : {};
            emittedEvent.target.feature = feature2;
          }
          let layer2 = this.getLayerNameForEntity(emittedEvent.target);
          if (layer2) layer2 = this.getCesiumLayerByName(layer2);
          if (layer2) options = layer2.processedOptions;
        }
      }
      this.$engineEvents.emit(event.originalEvent.name, options, emittedEvent);
    },
    getCameraEllipsoidTarget() {
      const windowPosition = new Cesium$1.Cartesian2(this.viewer.container.clientWidth / 2, this.viewer.container.clientHeight / 2);
      const pickedPosition = this.viewer.camera.pickEllipsoid(windowPosition);
      if (!pickedPosition) return null;
      const pickedPositionCartographic = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(pickedPosition);
      return {
        longitude: Math$1.toDegrees(pickedPositionCartographic.longitude),
        latitude: Math$1.toDegrees(pickedPositionCartographic.latitude),
        altitude: pickedPositionCartographic.height
      };
    },
    onCameraMoveStart() {
      let target2 = this.getCameraEllipsoidTarget();
      if (target2) {
        target2 = { latlng: { lng: target2.longitude, lat: target2.latitude }, altitude: target2.altitude };
      }
      this.$engineEvents.emit("movestart", this.viewerOptions, target2);
    },
    onCameraMoveEnd() {
      let target2 = this.getCameraEllipsoidTarget();
      if (target2) {
        target2 = { latlng: { lng: target2.longitude, lat: target2.latitude }, altitude: target2.altitude };
      }
      this.$engineEvents.emit("moveend", this.viewerOptions, target2);
    },
    onCameraChanged() {
      let target2 = this.getCameraEllipsoidTarget();
      if (target2) {
        target2 = { latlng: { lng: target2.longitude, lat: target2.latitude }, altitude: target2.altitude };
      }
      this.$engineEvents.emit("move", this.viewerOptions, target2);
    },
    getPostProcessStage(effect) {
      return this.cesiumPostProcessStages[effect];
    },
    setupPostProcess(effect, options = { enabled: true }) {
      let stage = this.cesiumPostProcessStages[effect];
      if (options.enabled) {
        if (!stage) {
          if (effect === "desaturation") {
            const fs = `
    uniform sampler2D colorTexture;
    in vec2 v_textureCoordinates;
    void main() {
        vec4 color = texture(colorTexture, v_textureCoordinates);
        if (czm_selected()) {
            out_FragColor = color;
        } else {
            out_FragColor = vec4(czm_saturation(color.rgb, 0.0), color.a);
        }
    }
    `;
            stage = this.viewer.scene.postProcessStages.add(new Cesium$1.PostProcessStage({ fragmentShader: fs }));
            stage.selected = [];
            this.cesiumPostProcessStages[effect] = stage;
          }
        }
      } else {
        if (stage) {
          this.viewer.scene.postProcessStages.remove(stage);
          delete this.cesiumPostProcessStages[effect];
        }
      }
    }
  },
  created() {
    this.cesiumLayers = {};
    this.cesiumFactory = [];
    this.cesiumMaterials = [];
    this.cesiumPostProcessStages = {};
    this.userLocation = false;
    this.$engineEvents = new EventBus();
  },
  beforeUnmount() {
    this.clearLayers();
    this.viewer.camera.moveStart.removeEventListener(this.onCameraMoveStart);
    this.viewer.camera.moveEnd.removeEventListener(this.onCameraMoveEnd);
    this.unregisterCesiumHandler("MOUSE_MOVE");
    this.unregisterCesiumHandler("LEFT_CLICK");
    this.unregisterCesiumHandler("RIGHT_CLICK");
  },
  unmounted() {
    this.viewer.destroy();
  }
};
const CustomTypes = ["wall", "corridor", "stroke"];
function getCustomEntityId(id, type) {
  return `${id}-${type}`;
}
function getOriginalEntityId(customId, type) {
  const suffix = `-${type}`;
  return customId.endsWith(suffix) ? customId.slice(0, -suffix.length) : "";
}
function addCustomPrimitive(activity2, dataSource, id, primitive, material) {
  const oldCustom = dataSource.primitives.get(id);
  if (oldCustom) {
    setTimeout(() => {
      activity2.viewer.scene.primitives.remove(oldCustom.primitive);
      const index2 = activity2.cesiumMaterials.indexOf(oldCustom.material);
      activity2.cesiumMaterials.splice(index2, 1);
    }, activity2.viewerOptions.entityLoadTextureDelay);
  }
  dataSource.primitives.set(id, { primitive, material });
  activity2.viewer.scene.primitives.add(primitive);
  activity2.cesiumMaterials.push(material);
  setTimeout(() => {
    material.material.uniforms.opacity = 1;
  }, activity2.viewerOptions.entityLoadTextureDelay);
}
function removeCustomPrimitiveById(activity2, dataSource, id) {
  const custom = dataSource.primitives.get(id);
  if (custom) {
    activity2.viewer.scene.primitives.remove(custom.primitive);
    const index2 = activity2.cesiumMaterials.indexOf(custom.material);
    activity2.cesiumMaterials.splice(index2, 1);
    dataSource.primitives.delete(id);
  }
}
const geojsonLayers = {
  emits: [
    "layer-updated"
  ],
  methods: {
    convertFromSimpleStyleOrDefaults(properties) {
      let { stroke, strokeWidth, fill } = convertToCesiumFromSimpleStyle(properties);
      if (!stroke) stroke = GeoJsonDataSource.stroke;
      if (!strokeWidth) strokeWidth = GeoJsonDataSource.strokeWidth;
      if (!fill) fill = GeoJsonDataSource.fill;
      return { stroke, strokeWidth, fill };
    },
    async loadGeoJson(dataSource, geoJson, options, updateOptions = {}) {
      const cesiumOptions = options.cesium;
      const features = getGeoJsonFeatures(geoJson);
      if (_$1.get(updateOptions, "remove", false)) {
        features.forEach((feature2) => {
          const id = getFeatureId(feature2, options);
          CustomTypes.forEach((type) => {
            const customId = getCustomEntityId(id, type);
            if (dataSource.entities.getById(id)) dataSource.entities.removeById(id);
            if (dataSource.entities.getById(customId)) dataSource.entities.removeById(customId);
            removeCustomPrimitiveById(this, dataSource, customId);
          });
        });
        return;
      }
      const loadingDataSource = new GeoJsonDataSource();
      loadingDataSource.notFromDrop = true;
      await loadingDataSource.load(geoJson, cesiumOptions);
      let entities = loadingDataSource.entities.values;
      entities.forEach((entity) => {
        entity.feature = features.find((feature2) => getFeatureId(feature2, options) === entity.id);
        const previousEntity = dataSource.entities.getById(entity.id);
        if (previousEntity) updateCesiumGeoJsonEntity(entity, previousEntity);
        else dataSource.entities.add(entity);
      });
      if (_$1.get(updateOptions, "removeMissing", cesiumOptions.removeMissing)) {
        const entitiesToRemove2 = [];
        dataSource.entities.values.forEach((entity) => {
          const id = entity.id;
          if (!loadingDataSource.entities.getById(id)) entitiesToRemove2.push(id);
          CustomTypes.forEach((type) => {
            const customId = getCustomEntityId(id, type);
            if (dataSource.entities.getById(customId)) entitiesToRemove2.push(customId);
          });
        });
        entitiesToRemove2.forEach((id) => dataSource.entities.removeById(id));
        for (const id of dataSource.primitives.keys()) {
          CustomTypes.forEach((type) => {
            const entityId = getOriginalEntityId(id, type);
            if (entityId && !loadingDataSource.entities.contains(entityId))
              removeCustomPrimitiveById(this, dataSource, id);
          });
        }
      }
      entities = dataSource.entities.values;
      const entitiesToAdd = [];
      const entitiesToRemove = [];
      for (let i = 0; i < entities.length; i++) {
        const entity = entities[i];
        const properties = entity.properties.getValue(0);
        const radius = _$1.get(properties, "radius");
        const geodesic = _$1.get(properties, "geodesic");
        if (radius && geodesic) {
          const { stroke, strokeWidth, fill } = this.convertFromSimpleStyleOrDefaults(properties);
          entitiesToAdd.push({
            id: entity.id,
            position: entity.position.getValue(0),
            name: entity.name ? entity.name : entity.id,
            description: entity.description.getValue(0),
            properties: entity.properties.getValue(0),
            ellipse: {
              semiMinorAxis: radius,
              semiMajorAxis: radius,
              material: new ColorMaterialProperty(fill),
              outlineColor: new ConstantProperty(stroke),
              outlineWidth: strokeWidth,
              outline: new ConstantProperty(true)
            },
            feature: entity.feature
          });
          entitiesToRemove.push(entity);
        }
        const wall = _$1.get(properties, "wall") || _$1.get(properties, "entityStyle.wall");
        if (wall && entity.polyline) {
          const { stroke, strokeWidth, fill } = this.convertFromSimpleStyleOrDefaults(properties);
          const wallId = getCustomEntityId(entity.id, "wall");
          const texture = _$1.get(properties, "entityStyle.wall.material.image");
          if (texture && _$1.get(properties, "entityStyle.wall.animateMaterialAlongPath", false)) {
            const options2 = _$1.get(properties, "entityStyle.wall");
            options2.positions = entity.polyline.positions.getValue(0);
            const { primitive, material } = createPrimitiveWithMovingTexture("wall", options2);
            if (primitive) {
              addCustomPrimitive(this, dataSource, wallId, primitive, material);
            }
            entitiesToRemove.push(entity);
          } else {
            entitiesToAdd.push({
              id: wallId,
              parent: entity,
              name: entity.name ? entity.name : wallId,
              description: entity.description.getValue(0),
              properties: entity.properties.getValue(0),
              wall: {
                positions: entity.polyline.positions.getValue(0),
                material: new ColorMaterialProperty(fill),
                outlineColor: new ConstantProperty(stroke),
                outlineWidth: strokeWidth,
                outline: new ConstantProperty(true)
              },
              feature: entity.feature
            });
            entitiesToRemove.push(entity);
          }
        }
        const corridor = _$1.get(properties, "corridor") || _$1.get(properties, "entityStyle.corridor");
        if (corridor && entity.polyline) {
          const { stroke, strokeWidth, fill } = this.convertFromSimpleStyleOrDefaults(properties);
          const corridorId = getCustomEntityId(entity.id, "corridor");
          const texture = _$1.get(properties, "entityStyle.corridor.material.image");
          if (texture && _$1.get(properties, "entityStyle.corridor.animateMaterialAlongPath", false)) {
            const options2 = _$1.get(properties, "entityStyle.corridor");
            options2.positions = entity.polyline.positions.getValue(0);
            const { primitive, material } = createPrimitiveWithMovingTexture("corridor", options2);
            if (primitive) {
              addCustomPrimitive(this, dataSource, corridorId, primitive, material);
            }
            entitiesToRemove.push(entity);
          } else {
            entitiesToAdd.push({
              id: corridorId,
              parent: entity,
              name: entity.name ? entity.name : corridorId,
              description: entity.description.getValue(0),
              properties: entity.properties.getValue(0),
              corridor: {
                positions: entity.polyline.positions.getValue(0),
                material: new ColorMaterialProperty(fill),
                outlineColor: new ConstantProperty(stroke),
                outlineWidth: strokeWidth,
                outline: new ConstantProperty(true)
              },
              feature: entity.feature
            });
            entitiesToRemove.push(entity);
          }
        }
        if (entity.billboard && _$1.get(properties, "marker-symbol") === "none") {
          entitiesToRemove.push(entity);
        }
        const text = _$1.get(properties, "icon-text") || _$1.get(properties, "entityStyle.label.text");
        const billboardImage = _$1.get(properties, "entityStyle.billboard.image");
        if (text) {
          const { stroke, strokeWidth, fill } = this.convertFromSimpleStyleOrDefaults(properties);
          entitiesToAdd.push({
            id: entity.id,
            position: entity.position.getValue(0),
            name: entity.name ? entity.name : entity.id,
            description: entity.description.getValue(0),
            properties: entity.properties.getValue(0),
            label: {
              text,
              fillColor: new ConstantProperty(fill),
              outlineColor: new ConstantProperty(stroke),
              outlineWidth: strokeWidth
            },
            billboard: billboardImage ? { image: billboardImage } : void 0,
            feature: entity.feature
          });
          entitiesToRemove.push(entity);
        }
        if (_$1.get(entity, "polygon") && _$1.get(properties, "entityStyle.polygon.perPositionHeight") === false) {
          const strokeId = getCustomEntityId(entity.id, "stroke");
          const { stroke, strokeWidth } = this.convertFromSimpleStyleOrDefaults(properties);
          const nullAltitude = _$1.every(_$1.get(entity, "feature.geometry.coordinates[0]", []), (coord) => {
            return coord.length > 2 && coord[2] === 0;
          });
          if (nullAltitude) {
            const strokeEntity = {
              id: strokeId,
              name: entity.name ? entity.name : strokeId,
              description: entity.description.getValue(0),
              properties: entity.properties.getValue(0),
              polyline: {
                positions: entity.polygon.hierarchy.getValue().positions,
                width: strokeWidth,
                material: stroke,
                clampToGround: true
              },
              feature: entity.feature
            };
            entitiesToAdd.push(strokeEntity);
            if (dataSource.entities.getById(strokeEntity.id)) {
              entitiesToRemove.push(strokeEntity);
            }
          }
        }
      }
      entitiesToRemove.forEach((entity) => dataSource.entities.remove(entity));
      entitiesToAdd.forEach((entity) => dataSource.entities.add(entity));
    },
    async updateGeoJsonData(dataSource, options, geoJson, updateOptions = {}) {
      const cesiumOptions = options.cesium;
      const source = _$1.get(cesiumOptions, "source");
      const sourceTemplate = _$1.get(cesiumOptions, "sourceTemplate");
      try {
        if (geoJson) {
          if (options.processor) processFeatures(geoJson, options.processor);
          await this.loadGeoJson(dataSource, geoJson, options, updateOptions);
        } else if (options.probeService) {
          await this.loadGeoJson(dataSource, this.getProbeFeatures(options), options, updateOptions);
          await this.loadGeoJson(dataSource, this.getFeatures(options), options, updateOptions);
        } else if (options.service) {
          await this.loadGeoJson(dataSource, this.getFeatures(Object.assign({}, options, this.getLayerByName(options.name))), options, updateOptions);
        } else if (sourceTemplate) {
          const sourceToFetch = dataSource.sourceCompiler({ time: Time.getCurrentTime() });
          if (!dataSource.lastFetchedSource || dataSource.lastFetchedSource !== sourceToFetch) {
            dataSource.lastFetchedSource = sourceToFetch;
            await this.loadGeoJson(dataSource, fetchGeoJson(sourceToFetch, options), options, updateOptions);
          }
        } else if (!_$1.isNil(source)) {
          await this.loadGeoJson(dataSource, fetchGeoJson(source, options), options, updateOptions);
        }
        this.applyStyle(dataSource.entities, options);
        if (typeof this.applyTooltips === "function") this.applyTooltips(dataSource.entities, options);
      } catch (error) {
        logger$1.error(error);
      }
    },
    async createCesiumRealtimeGeoJsonLayer(dataSource, options) {
      const cesiumOptions = options.cesium;
      dataSource.updateGeoJson = async (geoJson, updateOptions) => {
        await this.updateGeoJsonData(dataSource, options, geoJson, updateOptions);
      };
      if (_$1.has(cesiumOptions, "sourceTemplate")) {
        dataSource.sourceCompiler = _$1.template(_$1.get(cesiumOptions, "sourceTemplate"));
      }
    },
    async createCesiumGeoJsonLayer(options) {
      const cesiumOptions = options.cesium;
      if (cesiumOptions.type !== "geoJson") return;
      const engine = _$1.get(this, "activityOptions.engine");
      options.processor = (feature2) => {
        if (!options.featureId && !feature2._id) feature2._id = uid$2().toString();
        feature2.id = getFeatureId(feature2, options);
        let type = getFeatureStyleType(feature2);
        if (_$1.has(feature2, "properties.entityStyle")) {
          if (_$1.has(feature2, "properties.entityStyle.wall")) type = "polygon";
          else if (_$1.has(feature2, "properties.entityStyle.corridor")) type = "polygon";
        }
        if (_$1.get(feature2, "style.extrude")) type = "polygon";
        if (!_$1.has(feature2, "style")) {
          const style2 = type === "point" ? convertSimpleStyleToPointStyle(feature2.properties) : type === "line" ? convertSimpleStyleToLineStyle(feature2.properties) : convertSimpleStyleToPolygonStyle(feature2.properties);
          _$1.set(feature2, "style", style2);
        }
        const stylePerType = {
          point: getPointSimpleStyle(feature2, options, engine),
          line: getLineSimpleStyle(feature2, options, engine),
          polygon: getPolygonSimpleStyle(feature2, options, engine)
        };
        const simpleStyle = Object.assign(...Object.values(stylePerType), stylePerType[type]);
        const text = _$1.get(feature2, "style.text.label");
        if (text) simpleStyle["icon-text"] = text;
        if (!feature2.properties) feature2.properties = simpleStyle;
        else Object.assign(feature2.properties, simpleStyle);
        const cesiumStyle = convertToCesiumFromStyle(feature2, options);
        _$1.mergeWith(feature2, cesiumStyle, (objValue, srcValue) => {
          if (_$1.isArray(objValue)) return srcValue;
        });
      };
      if (_$1.has(this, "activityOptions.engine.cluster")) {
        if (cesiumOptions.cluster) Object.assign(cesiumOptions.cluster, _$1.get(this, "activityOptions.engine.cluster"));
        else cesiumOptions.cluster = Object.assign({}, _$1.get(this, "activityOptions.engine.cluster"));
      }
      const layerStyleTemplate = _$1.get(cesiumOptions, "template");
      if (layerStyleTemplate) {
        cesiumOptions.template = layerStyleTemplate.map((property) => ({
          property,
          compiler: _$1.template(_$1.get(cesiumOptions, property))
        }));
      }
      const entityStyleTemplate = _$1.get(cesiumOptions, "entityStyle.template");
      if (entityStyleTemplate) {
        _$1.set(cesiumOptions, "entityStyleTemplate", entityStyleTemplate.map((property) => ({
          property,
          compiler: _$1.template(_$1.get(cesiumOptions, `entityStyle.${property}`))
        })));
      }
      const popupTemplate = _$1.get(cesiumOptions, "popup.template");
      if (popupTemplate) {
        cesiumOptions.popup.compiler = _$1.template(popupTemplate);
      }
      const tooltipTemplate = _$1.get(cesiumOptions, "tooltip.template");
      if (tooltipTemplate) {
        cesiumOptions.tooltip.compiler = _$1.template(tooltipTemplate);
      }
      if (cesiumOptions.style) {
        cesiumOptions.layerPointStyle = _$1.get(cesiumOptions.style, "point");
        cesiumOptions.layerLineStyle = _$1.get(cesiumOptions.style, "line");
        cesiumOptions.layerPolygonStyle = _$1.get(cesiumOptions.style, "polygon");
      } else {
        cesiumOptions.layerPointStyle = convertSimpleStyleToPointStyle(cesiumOptions);
        cesiumOptions.layerLineStyle = convertSimpleStyleToLineStyle(cesiumOptions);
        cesiumOptions.layerPolygonStyle = convertSimpleStyleToPolygonStyle(cesiumOptions);
      }
      if (cesiumOptions.entityStyle && !entityStyleTemplate) cesiumOptions.entityStyle = this.convertToCesiumObjects(cesiumOptions.entityStyle);
      if (cesiumOptions.clusterStyle) cesiumOptions.clusterStyle = this.convertToCesiumObjects(cesiumOptions.clusterStyle);
      if (cesiumOptions.tooltip) cesiumOptions.tooltip = this.convertToCesiumObjects(cesiumOptions.tooltip);
      if (cesiumOptions.popup) cesiumOptions.popup = this.convertToCesiumObjects(cesiumOptions.popup);
      const source = _$1.get(cesiumOptions, "source");
      let dataSource = source;
      if (dataSource) {
        for (let i = 0; i < this.viewer.dataSources.length; i++) {
          const currentSource = this.viewer.dataSources.get(i);
          if (currentSource.name === dataSource) {
            dataSource = currentSource;
            this.viewer.dataSources.remove(currentSource, false);
            break;
          }
        }
      }
      if (!dataSource || !dataSource.name) {
        dataSource = new GeoJsonDataSource();
        dataSource.notFromDrop = true;
        dataSource.primitives = /* @__PURE__ */ new Map();
        if (cesiumOptions.realtime) {
          await this.createCesiumRealtimeGeoJsonLayer(dataSource, options);
        }
        this.updateGeoJsonData(dataSource, options);
      } else {
        this.applyStyle(dataSource.entities, options);
        if (typeof this.applyTooltips === "function") this.applyTooltips(dataSource.entities, options);
      }
      if (cesiumOptions.cluster) {
        _$1.assign(dataSource.clustering, {
          enabled: true,
          pixelRange: 100,
          minimumClusterSize: 3,
          clusterBillboards: true,
          clusterLabels: true,
          clusterPoints: true
        }, cesiumOptions.cluster);
        dataSource.clustering.clusterEvent.addEventListener(
          (entities, cluster) => this.applyClusterStyle(entities, cluster, options)
        );
      }
      return dataSource;
    },
    getGeoJsonOptions(options) {
      return _$1.get(this, "activityOptions.engine.featureStyle", {});
    },
    async updateLayer(name, geoJson, updateOptions = {}) {
      const layer2 = this.getCesiumLayerByName(name);
      if (!layer2) return;
      if (typeof layer2.updateGeoJson === "function") await layer2.updateGeoJson(geoJson, updateOptions);
      const baseLayer = this.getLayerByName(name);
      if (isInMemoryLayer(baseLayer)) {
        this.geojsonCache[name] = await this.toGeoJson(name);
      }
      this.onLayerUpdated(baseLayer, layer2, { features: geoJson ? geoJson.features || [geoJson] : [] });
    },
    onLayerUpdated(layer2, cesiumLayer, data) {
      this.$emit("layer-updated", layer2, cesiumLayer, data);
      this.$engineEvents.emit("layer-updated", layer2, cesiumLayer, data);
    },
    onCurrentTimeChangedGeoJsonLayers(time) {
      const geoJsonlayers = _$1.values(this.layers).filter(sift(GeoJsonCesiumLayerFilters.TimeUpdate));
      geoJsonlayers.forEach(async (geoJsonlayer) => {
        const dataSource = this.getCesiumLayerByName(geoJsonlayer.name);
        if (!dataSource.lastUpdateTime || !this.shouldSkipFeaturesUpdate(dataSource.lastUpdateTime, geoJsonlayer)) {
          dataSource.lastUpdateTime = Time.getCurrentTime().clone();
          dataSource.updateGeoJson();
        }
      });
    },
    onDefaultUnitChangedGeoJsonLayers(units) {
      _$1.forOwn(units.default, (unit, quantity) => {
        const units2 = _$1.map(Units.getUnits(quantity), "name");
        let geoJsonlayers = _$1.values(this.layers).filter(sift(GeoJsonCesiumLayerFilters.UnitUpdate));
        geoJsonlayers = geoJsonlayers.filter((layer2) => {
          return hasUnitInCesiumLayerTemplate(units2, layer2);
        });
        geoJsonlayers.forEach((layer2) => {
          const dataSource = this.getCesiumLayerByName(layer2.name);
          dataSource.updateGeoJson();
        });
      });
    },
    onLayerShownGeoJsonLayers(layer2, engineLayer) {
      const cachedGeojson = this.geojsonCache[layer2.name];
      if (cachedGeojson) {
        if (isInMemoryLayer(layer2)) {
          this.updateLayer(layer2.name, cachedGeojson);
        } else {
          delete this.geojsonCache[layer2.name];
        }
      }
    },
    onLayerRemovedGeoJsonLayers(layer2) {
      if (_$1.has(this.geojsonCache, layer2.name)) {
        delete this.geojsonCache[layer2.name];
      }
    },
    selectFeaturesForPostProcess(effect, layerNames, featureIds) {
      const stage = this.getPostProcessStage(effect);
      if (!stage) return;
      let primitives = [];
      const multipleLayers = Array.isArray(layerNames);
      if (!multipleLayers) {
        layerNames = [layerNames];
        featureIds = [featureIds];
      }
      for (let i = 0; i < layerNames.length; i++) {
        const layerName = layerNames[i];
        const layerIds = featureIds[i];
        const layer2 = this.getCesiumLayerByName(layerName);
        if (!layer2) return;
        if (!layer2.entities && !layer2.primitives.size) return;
        const ids = Array.isArray(layerIds) ? layerIds : [layerIds];
        ids.forEach((id) => {
          let entity = layer2.entities.getById(id);
          let primitive = layer2.primitives.get(id);
          CustomTypes.forEach((type) => {
            if (entity || primitive) return;
            const customId = getCustomEntityId(id, type);
            entity = layer2.entities.getById(customId);
            primitive = layer2.primitives.get(customId);
          });
          if (entity) {
            primitive = getPrimitivesForEntity(id, this.viewer);
          } else {
            primitive = _$1.get(primitive, "primitive");
          }
          if (!primitive) return;
          primitives = _$1.concat(primitives, _$1.isArray(primitive) ? primitive : [primitive]);
        });
      }
      stage.selected = primitives;
    }
  },
  created() {
    this.registerCesiumConstructor(this.createCesiumGeoJsonLayer);
    Events.on("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers);
    Events.on("units-changed", this.onDefaultUnitChangedGeoJsonLayers);
    this.$engineEvents.on("layer-shown", this.onLayerShownGeoJsonLayers);
    this.$engineEvents.on("layer-removed", this.onLayerRemovedGeoJsonLayers);
    this.updatingGeoJsonData = {};
    this.geojsonCache = {};
  },
  beforeUnmount() {
    Events.off("time-current-time-changed", this.onCurrentTimeChangedGeoJsonLayers);
    Events.off("units-changed", this.onDefaultUnitChangedGeoJsonLayers);
    this.$engineEvents.off("layer-shown", this.onLayerShownGeoJsonLayers);
    this.$engineEvents.off("layer-removed", this.onLayerRemovedGeoJsonLayers);
    this.geojsonCache = {};
  }
};
const fileLayers = {
  mounted() {
    this.$engineEvents.on("globe-ready", () => {
      const fileLayersOptions = _$1.defaults(_$1.get(this, "activityOptions.engine.fileLayers", {}), {
        clearOnDrop: false,
        flyToOnDrop: true,
        clampToGround: true
      });
      this.viewer.extend(viewerDragDropMixin, fileLayersOptions);
      this.viewer.dropError.addEventListener((viewerArg, source, error) => {
        logger$1.error(error);
      });
      this.viewer.dataSources.dataSourceAdded.addEventListener((collection, source) => {
        if (source.notFromDrop) return;
        if (!source.name) source.name = this.$t("mixins.fileLayers.IMPORTED_DATA_NAME");
        logger$1.debug("[KDK] processing dropped file: ", source.name);
        this.addLayer({
          name: source.name,
          label: source.name,
          type: "OverlayLayer",
          icon: "insert_drive_file",
          cesium: {
            type: "geoJson",
            isVisible: true,
            cluster: _$1.get(fileLayersOptions, "cluster", { pixelRange: 50 }),
            entityStyle: _$1.get(fileLayersOptions, "entityStyle"),
            source: source.name
            // Set the data source name instead of URL in this case
          }
        });
      });
    });
  }
};
const style = {
  methods: {
    applyStyle(entities, options) {
      for (let i = 0; i < entities.values.length; i++) {
        const entity = entities.values[i];
        const style2 = this.generateStyle("entityStyle", entity, options);
        CesiumEntityTypes.forEach((type) => {
          if (entity[type] && style2[type]) {
            _$1.merge(entity[type], style2[type]);
          }
        });
        if (style2.model && entity.billboard) {
          entity.billboard = void 0;
          entity.model = style2.model;
        }
        if (style2.orientation) entity.orientation = style2.orientation;
        if (_$1.has(style2, "visibility")) entity.show = style2.visibility;
      }
    },
    applyClusterStyle(entities, cluster, options) {
      const style2 = this.generateStyle("clusterStyle", entities, cluster, options);
      const featureTypes = ["billboard", "label", "point"];
      featureTypes.forEach((type) => {
        if (_$1.has(cluster, type)) {
          _$1.merge(cluster[type], style2[type]);
        }
      });
    },
    // Alias to ease development
    convertFromSimpleStyle(style2, inPlace) {
      return convertToCesiumFromSimpleStyle(style2, inPlace);
    },
    // Alias to ease development
    convertToCesiumObjects(style2) {
      return convertToCesiumObjects(style2);
    },
    getDefaultEntityStyle(entity, options) {
      const properties = entity.properties ? entity.properties.getValue(0) : null;
      const cesiumOptions = options.cesium || options;
      let style2 = _$1.merge({}, _$1.get(this, "activityOptions.engine.entityStyle"));
      const entityStyleTemplate = _$1.get(cesiumOptions, "entityStyleTemplate");
      if (entityStyleTemplate) {
        const entityStyle = _$1.cloneDeep(cesiumOptions.entityStyle);
        entityStyleTemplate.forEach((entry) => {
          let value = entry.compiler({ feature: entity.feature || { properties }, properties, chroma, moment, Units, Time });
          const property = entry.property;
          if (property === "orientation" && entity.position) {
            const localFrameAxes = _$1.get(entityStyle, "localFrameAxes", ["east", "north"]);
            const localFrame = Transforms.localFrameToFixedFrameGenerator(...localFrameAxes);
            const position2 = entity.position.getValue(this.viewer.clock.currentTime);
            value = value.split(",").map((angle2) => Math$1.toRadians(parseFloat(angle2)));
            value = new HeadingPitchRoll(...value);
            value = Transforms.headingPitchRollQuaternion(position2, value, Ellipsoid.WGS84, localFrame);
          }
          _$1.set(entityStyle, property, value);
        });
        style2 = _$1.merge(style2, this.convertToCesiumObjects(entityStyle));
      } else {
        style2 = _$1.merge(style2, cesiumOptions.entityStyle || {});
      }
      if (properties && properties.entityStyle) _$1.merge(style2, this.convertToCesiumObjects(properties.entityStyle));
      return style2;
    },
    getDefaultClusterStyle(entities, cluster, options) {
      const cesiumOptions = options.cesium || options;
      const style2 = _$1.merge(
        {},
        _$1.get(this, "activityOptions.engine.clusterStyle"),
        cesiumOptions.clusterStyle || {}
      );
      if (_$1.has(style2, "label.text")) {
        const compiler = _$1.template(_$1.get(style2, "label.text"));
        const labelStyle = _$1.cloneDeep(_$1.get(style2, "label"));
        _$1.set(labelStyle, "text", compiler({ entities, cluster, $t: this.$t }));
        _$1.set(style2, "label", labelStyle);
      }
      return style2;
    }
  },
  created() {
    this.registerStyle("entityStyle", this.getDefaultEntityStyle);
    this.registerStyle("clusterStyle", this.getDefaultClusterStyle);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    if (_$1.has(this, "activityOptions.engine.entityStyle")) {
      _$1.set(this, "activityOptions.engine.entityStyle", this.convertToCesiumObjects(_$1.get(this, "activityOptions.engine.entityStyle")));
    }
    if (_$1.has(this, "activityOptions.engine.clusterStyle")) {
      _$1.set(this, "activityOptions.engine.clusterStyle", this.convertToCesiumObjects(_$1.get(this, "activityOptions.engine.clusterStyle")));
    }
  }
};
const tooltip = {
  methods: {
    applyTooltips(entities, options) {
      for (let i = 0; i < entities.values.length; i++) {
        const entity = entities.values[i];
        const tooltip2 = this.generateStyle("tooltip", entity, options);
        if (tooltip2) {
          const position2 = this.getPositionForEntity(entity);
          if (position2) {
            const tooltipEntity = this.viewer.entities.add({ parent: entity, position: position2, label: tooltip2 });
            if (tooltip2.sticky) tooltipEntity.sticky = true;
          }
        }
      }
    },
    getDefaultTooltip(entity, options) {
      let tooltip2;
      if (entity.properties) {
        const properties = entity.properties.getValue(0);
        const cesiumOptions = options.cesium || options;
        if (_$1.has(cesiumOptions, "tooltip") && !_$1.get(cesiumOptions, "tooltip")) return;
        if (_$1.has(properties, "tooltip") && !_$1.get(properties, "tooltip")) return;
        const tooltipStyle = _$1.merge(
          {},
          _$1.get(this, "activityOptions.engine.tooltip", {}),
          cesiumOptions.tooltip,
          properties.tooltip
        );
        let text = tooltipStyle.text;
        if (!text) {
          if (tooltipStyle.property) {
            text = _$1.get(properties, tooltipStyle.property);
            if (text && typeof text.toString === "function") text = text.toString();
          } else if (tooltipStyle.template) {
            const compiler = tooltipStyle.compiler;
            text = compiler({ feature: entity.feature || { properties }, properties, $t: this.$t, Units, Time, moment });
          }
        }
        if (text) {
          tooltip2 = Object.assign({
            text,
            show: !!_$1.get(tooltipStyle, "options.permanent")
          }, tooltipStyle.options);
        }
      }
      return tooltip2;
    },
    isTooltipOpen(entity) {
      if (this.getNbChildrenForEntity(entity) > 0) {
        return _$1.get(entity, "label.show", false);
      } else return false;
    },
    openTooltip(entity, position2) {
      if (this.getNbChildrenForEntity(entity) > 0) {
        const tooltip2 = this.getChildForEntity(entity);
        if (tooltip2.label) tooltip2.label.show = true;
        if (tooltip2.sticky) tooltip2.position = position2;
      }
    },
    closeTooltip(entity) {
      if (this.getNbChildrenForEntity(entity) > 0) {
        const tooltip2 = this.getChildForEntity(entity);
        if (tooltip2.label) tooltip2.label.show = false;
      }
    },
    onTooltip(options, event) {
      if (options) {
        const cesiumOptions = options.cesium || options;
        const tooltipStyle = cesiumOptions.tooltip;
        if (_$1.get(tooltipStyle, "options.permanent")) return;
      }
      const entity = event.target;
      if (this.overEntity) {
        this.closeTooltip(this.overEntity);
        this.overEntity = null;
      }
      if (options && entity) {
        this.overEntity = entity;
        this.openTooltip(this.overEntity, event.pickedPosition);
      }
    }
  },
  created() {
    this.registerStyle("tooltip", this.getDefaultTooltip);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    if (_$1.has(this, "activityOptions.engine.tooltip")) {
      _$1.set(this, "activityOptions.engine.tooltip", this.convertToCesiumObjects(_$1.get(this, "activityOptions.engine.tooltip")));
    }
  },
  mounted() {
    this.$engineEvents.on("mousemove", this.onTooltip);
  },
  beforeUnmount() {
    this.$engineEvents.off("mousemove", this.onTooltip);
  }
};
const popup = {
  methods: {
    getDefaultPopup(entity, options) {
      let popup2;
      if (entity.properties) {
        let properties = entity.properties.getValue(0);
        const cesiumOptions = options.cesium || options;
        if (_$1.has(cesiumOptions, "popup") && !_$1.get(cesiumOptions, "popup")) return;
        if (_$1.has(properties, "popup") && !_$1.get(properties, "popup")) return;
        const popupStyle = _$1.merge(
          {},
          _$1.get(this, "activityOptions.engine.popup"),
          cesiumOptions.popup,
          properties.popup
        );
        let text = popupStyle.text;
        if (!text) {
          if (popupStyle.template) {
            const compiler = popupStyle.compiler;
            text = compiler({ feature: entity.feature || { properties }, properties, $t: this.$t, Units, Time, moment });
          } else if (popupStyle.pick) {
            properties = _$1.pick(properties, popupStyle.pick);
          } else if (popupStyle.omit) {
            properties = _$1.omit(properties, popupStyle.omit);
          }
        }
        if (!text) text = getTextTable(properties);
        if (!text) return null;
        popup2 = Object.assign({
          text,
          show: true
        }, popupStyle.options);
      }
      return popup2;
    },
    onPopup(options, event) {
      const entity = event.target;
      if (this.popupEntity) {
        this.viewer.entities.remove(this.popupEntity);
        this.popupEntity = null;
      }
      if (this.clickedEntity === entity) {
        this.clickedEntity = null;
      } else {
        this.clickedEntity = entity;
      }
      if (!this.clickedEntity || !options) return;
      const popup2 = this.generateStyle("popup", this.clickedEntity, options);
      if (popup2) {
        const position2 = event.pickedPosition ? event.pickedPosition : this.getPositionForEntity(this.clickedEntity);
        this.popupEntity = this.viewer.entities.add({ position: position2, label: popup2 });
      }
    }
  },
  created() {
    this.registerStyle("popup", this.getDefaultPopup);
  },
  // Need to be done after created as the activity mixin initializes options in it
  beforeMount() {
    if (_$1.has(this, "activityOptions.engine.popup")) {
      _$1.set(this, "activityOptions.engine.popup", this.convertToCesiumObjects(_$1.get(this, "activityOptions.engine.popup")));
    }
  },
  mounted() {
    this.$engineEvents.on("click", this.onPopup);
  },
  beforeUnmount() {
    this.$engineEvents.off("click", this.onPopup);
  }
};
const activity = {
  methods: {
    async initializeGlobe(container, token) {
      if (this.viewer) return;
      this.setupGlobe(container, token);
      await this.initialize();
      this.viewer.camera.moveEnd.addEventListener(this.storeView);
    },
    finalizeGlobe() {
      this.viewer.camera.moveEnd.removeEventListener(this.storeView);
    },
    storeView() {
      if (typeof this.storeContext === "function") this.storeContext("view");
    },
    onGlobeResized(size) {
      if (this.observe) {
        this.refreshGlobe();
        if (this.globeContainer) {
          this.engineContainerWidth = this.globeContainer.getBoundingClientRect().width;
          this.engineContainerHeight = this.globeContainer.getBoundingClientRect().height;
        }
      }
    },
    onToggleVr() {
      if (this.viewer.scene.useWebVR) {
        if (Fullscreen$1.fullscreen) Fullscreen$1.exitFullscreen();
        this.viewer.scene.useWebVR = false;
      } else {
        if (!Fullscreen$1.fullscreen) Fullscreen$1.requestFullscreen(document.body);
        this.viewer.scene.useWebVR = true;
      }
    }
  },
  created() {
    this.engine = "cesium";
    this.observe = true;
  },
  mounted() {
  },
  beforeUnmount() {
    this.observe = false;
    this.finalizeGlobe();
  }
};
const opendapLayers = {
  methods: {
    createCesiumOpendapLayer(options) {
      const cesiumOptions = options.cesium;
      if (cesiumOptions.type !== "opendap") return;
      const urlPromise = async () => {
        const accessToken = await api.passport.getJWT();
        const url = new Resource({
          url: "http://localhost:8081/api/daptiles/tileset.json",
          headers: {
            Authorization: `Bearer ${accessToken}`
          },
          queryParameters: {
            file: "mf-arpege-01/2019/06/15/11360000000.20190615180000.grib",
            query: "Temperature_height_above_ground",
            dimensions: JSON.stringify({ time2: 0, height_above_ground1: 0 }),
            latitude: "lat",
            longitude: "lon"
          }
        });
        return url;
      };
      const tileset = new Cesium3DTileset({
        url: urlPromise
        // url: 'http://127.0.0.1:3000/tileset.json?file=mf-arpege-05/2019/06/16/18/T6086_G_T_Sol_20190616180000.grib&variable=Temperature_surface&time=0',
        // shadows: Cesium.ShadowMode.DISABLED,
        // classificationType: Cesium.ClassificationType.CESIUM_3D_TILE,
        // url: Cesium.IonResource.f ffromAssetId(5741)
        // debugShowBoundingVolume: true,
        // debugShowUrl: true
      });
      return tileset;
    }
  },
  created() {
    this.registerCesiumConstructor(this.createCesiumOpendapLayer);
  }
};
const globeMixins = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activity,
  baseGlobe,
  fileLayers,
  geojsonLayers,
  opendapLayers,
  popup,
  style,
  tooltip
}, Symbol.toStringTag, { value: "Module" }));
const utils_all = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CesiumEntityTypes,
  CesiumStyleMappings,
  CesiumStyleOptions,
  DefaultStyle,
  GeoJsonCesiumLayerFilters,
  GeoJsonLeafletLayerFilters,
  IconStyleToSimpleStyle,
  LeafletEvents,
  LeafletStyleMappings,
  LineStyleTemplateMappings,
  LineStyleToSimpleStyle,
  PointStyleTemplateMappings,
  PointStyleToSimpleStyle,
  PolygonStyleTemplateMappings,
  PolygonStyleToSimpleStyle,
  SimpleStyleNumbers,
  SimpleStyleToLineStyle,
  SimpleStyleToPointStyle,
  SimpleStyleToPolygonStyle,
  TouchEvents,
  bindLeafletEvents,
  buildGradientPath,
  cacheView,
  capture,
  checkFeatures,
  computeIdealMaxNativeZoom,
  convertCesiumHandlerEvent,
  convertEntitiesToGeoJson,
  convertLineStyleToLeafletPath,
  convertLineStyleToSimpleStyle,
  convertPointStyleToSimpleStyle,
  convertPolygonStyleToLeafletPath,
  convertPolygonStyleToSimpleStyle,
  convertSimpleStyleColors,
  convertSimpleStyleToLineStyle,
  convertSimpleStyleToPointStyle,
  convertSimpleStyleToPolygonStyle,
  convertStyle,
  convertToCesiumFromSimpleStyle,
  convertToCesiumFromStyle,
  convertToCesiumObjects,
  convertToLeafletFromSimpleStyleSpec,
  coordinatesToGeoJSON,
  createCesiumObject,
  createFeatures,
  createMarkerFromPointStyle,
  createOfflineServices,
  createPrimitiveWithMovingTexture,
  editFeaturesGeometry,
  editFeaturesProperties,
  editFeaturesStyle,
  editFilterStyle,
  editLayerStyle,
  fetchGeoJson,
  filterGeocoders,
  filterQueryToConditions,
  formatForwardGeocodingResult,
  formatUserCoordinates,
  generateLayerDefinition,
  generatePropertiesSchema,
  generateStyleTemplates,
  getBaseQueryForFeatures,
  getCatalogProjectQuery,
  getCategories,
  getDefaultLineStyle,
  getDefaultPointStyle,
  getDefaultPolygonStyle,
  getDefaultStyleFromTemplates,
  getFeatureId,
  getFeatureLabel,
  getFeatureStyleType,
  getFeaturesFromQuery,
  getFeaturesQuery,
  getFeaturesQueryInterval,
  getFeaturesUpdateInterval,
  getFilterQueryForFeatures,
  getForecastTimeSeries,
  getGeoJsonFeatures,
  getHtmlTable,
  getLayers,
  getLayersByCategory,
  getLayersBySublegend,
  getLineSimpleStyle,
  getMeasureForFeature,
  getMeasureForFeatureBaseQuery,
  getMeasureForFeatureFromQuery,
  getMeasureForFeatureQuery,
  getMeasureTimeSeries,
  getNearestTime,
  getOrphanLayers,
  getParentTileInTileSet,
  getPointSimpleStyle,
  getPolygonSimpleStyle,
  getPrimitivesForEntity,
  getProbeFeatures,
  getShapeFromLineStyle,
  getShapeFromPointStyle,
  getShapeFromPolygonStyle,
  getSortQueryForFeatures,
  getSublegends,
  getTextTable,
  getTimeInterval,
  getUpdateFeatureFunction,
  getUpdatedLayerLegend,
  getViews,
  hasFeatureSchema,
  hasUnitInCesiumLayerTemplate,
  hasUnitInLeafletLayerTemplate,
  isFeatureInQueryInterval,
  isFeatureLayer,
  isInMemoryLayer,
  isLayerCachable,
  isLayerCached,
  isLayerDataEditable,
  isLayerEditable,
  isLayerFilterEditable,
  isLayerHighlightable,
  isLayerProbable,
  isLayerRemovable,
  isLayerSelectable,
  isLayerStorable,
  isLayerStyleEditable,
  isMeasureLayer,
  isTerrainLayer,
  isUserLayer,
  key2tile: key2tile$1,
  listenToFeaturesServiceEventsForLayer,
  parseCoordinates,
  processFeatures,
  removeFeatures,
  removeLayer,
  saveGeoJsonLayer,
  saveLayer,
  setBaseLayerCached,
  setEngineJwt,
  setGeojsonLayerCached,
  setLayerCached,
  setLayerUncached,
  setPMTilesLayerCached,
  setUrlJwt,
  shouldSkipFeaturesUpdate,
  tile2key: tile2key$1,
  tileSetContainsParent,
  transformFeatures,
  unbindLeafletEvents,
  uncacheView,
  unlistenToFeaturesServiceEventsForLayer,
  updateCesiumGeoJsonEntity,
  updateLayerWithFiltersStyle
}, Symbol.toStringTag, { value: "Module" }));
function distance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
function length(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return segmentReduce(geojson, function(previousValue, segment) {
    var coords = segment.geometry.coordinates;
    return previousValue + distance(coords[0], coords[1], options);
  }, 0);
}
function flatten(geojson) {
  if (!geojson) throw new Error("geojson is required");
  var results = [];
  flattenEach(geojson, function(feature2) {
    results.push(feature2);
  });
  return featureCollection(results);
}
function fetchProfileDataset(feature2, distanceUnit, altitudeUnit) {
  const geometry = _$1.get(feature2, "geometry.type");
  if (geometry !== "LineString" && geometry !== "MultiLineString") {
    return [];
  }
  const linestrings = geometry === "MultiLineString" ? flatten(feature2).features : [feature2];
  const dataset = [];
  const segments = [];
  let allCoordsHaveAltitude = true;
  let curvilinearOffset = 0;
  let curvilinearIndex = 0;
  for (let i = 0; i < linestrings.length && allCoordsHaveAltitude; ++i) {
    const currentLine = linestrings[i];
    const dataUnit = _$1.get(currentLine, "properties.altitudeUnit", "m");
    segments.push({ numPoints: currentLine.geometry.coordinates.length });
    coordEach(currentLine, (coord, coordIdx) => {
      if (dataset.length && coordIdx === 0) return;
      if (coord.length > 2) dataset.push({ x: 0, y: Units.convert(coord[2], dataUnit, altitudeUnit) });
      else allCoordsHaveAltitude = false;
    });
    if (allCoordsHaveAltitude) {
      segmentEach(currentLine, (segment) => {
        if (curvilinearIndex === 0) dataset[0].x = 0;
        curvilinearOffset += length(segment, { units: "kilometers" }) * 1e3;
        curvilinearIndex += 1;
        dataset[curvilinearIndex].x = Units.convert(curvilinearOffset, "m", distanceUnit);
      });
    }
  }
  return { dataset: allCoordsHaveAltitude ? dataset : [], segments };
}
function asArray(val) {
  return Array.isArray(val) || val === void 0 ? val : [val];
}
async function queryElevation(endpoint, feature2, distanceUnit, altitudeUnit, { additionalHeaders, defaultResolution, defaultResolutionUnit, noCorridor } = {}) {
  const geometry = _$1.get(feature2, "geometry.type");
  if (geometry !== "LineString" && geometry !== "MultiLineString") {
    return [];
  }
  const queries = [];
  const resolution = asArray(_$1.get(feature2, "properties.elevationProfile.resolution", defaultResolution));
  const resolutionUnit = _$1.get(feature2, "properties.elevationProfile.resolutionUnit", defaultResolutionUnit);
  const corridor = noCorridor ? void 0 : asArray(_$1.get(feature2, "properties.elevationProfile.corridorWidth"));
  const corridorUnit = noCorridor ? void 0 : _$1.get(feature2, "properties.elevationProfile.corridorWidthUnit", "m");
  if (geometry === "MultiLineString") {
    flatten(feature2).features.forEach((feat, index2) => {
      queries.push({
        profile: feat,
        resolution: Units.convert(resolution[index2], resolutionUnit, "m"),
        corridorWidth: corridor ? Units.convert(corridor[index2], corridorUnit, "m") : void 0
      });
    });
  } else {
    queries.push({
      profile: feature2,
      resolution: Units.convert(resolution[0], resolutionUnit, "m"),
      corridorWidth: corridor ? Units.convert(corridor[0], corridorUnit, "m") : void 0
    });
  }
  const fetchs = [];
  for (const query of queries) {
    fetchs.push(fetch(endpoint + `?resolution=${query.resolution}` + (query.corridorWidth !== void 0 ? `&corridorWidth=${query.corridorWidth}` : ""), {
      method: "POST",
      mode: "cors",
      body: JSON.stringify(query.profile),
      headers: Object.assign({ "Content-Type": "application/json" }, additionalHeaders)
    }));
  }
  let responses;
  try {
    responses = await Promise.all(fetchs);
    for (const res of responses) {
      if (!res.ok) throw new Error("Fetch failed");
    }
  } catch (error) {
    return [];
  }
  for (let i = 0; i < queries.length; ++i) {
    const q = queries[i];
    q.elevation = await responses[i].json();
    q.length = length(q.profile, { units: "kilometers" }) * 1e3;
    q.resolution = Units.convert(resolution[i], resolutionUnit, distanceUnit);
    q.corridorWidth = corridor ? Units.convert(corridor[i], corridorUnit, distanceUnit) : void 0;
    q.length = Units.convert(q.length, "m", distanceUnit);
    for (const point2 of q.elevation.features) {
      point2.properties.z = Units.convert(point2.properties.z, "m", altitudeUnit);
      point2.properties.t = Units.convert(point2.properties.t, "m", distanceUnit);
    }
  }
  return queries;
}
function addSecurityMargin(feature2, queries, altitudeUnit) {
  if (queries.length === 0) return;
  const securityMargin = _$1.get(feature2, "properties.elevationProfile.securityMargin");
  if (securityMargin === void 0) return;
  const securityMarginUnit = _$1.get(feature2, "properties.elevationProfile.securityMarginUnit", "m");
  const geometry = _$1.get(feature2, "geometry.type");
  if (geometry === "MultiLineString") {
    flatten(feature2).features.forEach((feat, index2) => {
      queries[index2].securityMargin = Units.convert(securityMargin[index2], securityMarginUnit, altitudeUnit);
    });
  } else {
    queries[0].securityMargin = Units.convert(securityMargin, securityMarginUnit, altitudeUnit);
  }
}
async function fetchElevation(endpoint, feature2, distanceUnit, altitudeUnit, { additionalHeaders, defaultResolution, defaultResolutionUnit, noCorridor, noSecurityMargin, minElevationValue } = {}) {
  const queries = await queryElevation(endpoint, feature2, distanceUnit, altitudeUnit, { additionalHeaders, defaultResolution, defaultResolutionUnit, noCorridor });
  if (!noSecurityMargin) {
    addSecurityMargin(feature2, queries, altitudeUnit);
  }
  if (minElevationValue !== void 0) {
    for (let i = 0; i < queries.length; ++i) {
      const q = queries[i];
      for (const point2 of q.elevation.features) {
        if (point2.properties.z < minElevationValue) {
          point2.properties.z = 0;
        }
      }
    }
  }
  return queries;
}
function extractElevation(queries, { noDataset, noGeojson, queryParametersInDataset, queryParametersInGeojson } = {}) {
  const dataset = [];
  const allPoints = [];
  let curvilinearOffset = 0;
  for (let i = 0; i < queries.length; ++i) {
    const zOffset = queries[i].securityMargin ? queries[i].securityMargin : 0;
    const r = queries[i].resolution;
    const w = queries[i].corridorWidth;
    const s = queries[i].securityMargin;
    queries[i].elevation.features.forEach((p, index2) => {
      if (i !== 0 && index2 === 0) return;
      const t = curvilinearOffset + p.properties.t;
      const e = zOffset + p.properties.z;
      if (!noDataset) {
        const datasetPoint = { x: t, y: e };
        if (queryParametersInDataset) {
          datasetPoint.elevation = { resolution: r };
          if (w !== void 0) datasetPoint.elevation.corridorWidth = w;
          if (s !== void 0) datasetPoint.elevation.securityMargin = s;
        }
        dataset.push(datasetPoint);
      }
      if (!noGeojson) {
        const props2 = { z: e, t };
        if (queryParametersInDataset) {
          props2.resolution = r;
          if (w !== void 0) props2.corridorWidth = w;
          if (s !== void 0) props2.securityMargin = s;
        }
        allPoints.push(point(p.geometry.coordinates, props2));
      }
    });
    curvilinearOffset += queries[i].length;
  }
  const geojson = noGeojson ? {} : featureCollection(allPoints);
  return { dataset, geojson };
}
const elevationUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extractElevation,
  fetchElevation,
  fetchProfileDataset
}, Symbol.toStringTag, { value: "Module" }));
const Capture = {
  processing: false,
  async process(values) {
    if (this.processing) Notify.create({ type: "negative", message: i18n.t("KCapture.ERROR_MESSAGE") });
    else {
      this.processing = true;
      await capture(values);
      this.processing = false;
    }
  }
};
const mixins = Object.assign({}, commonMixins, { map: mapMixins, globe: globeMixins });
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CanvasDrawContext,
  Capture,
  Geolocation,
  Navigator,
  Planets,
  composables: index$1,
  dap: opendapUtils,
  default: init,
  elevationUtils,
  errors,
  grid,
  hooks: index$2,
  mixins,
  permissions,
  setupApi,
  utils: utils_all
}, Symbol.toStringTag, { value: "Module" }));
const kdk = { core: initialize, map: init };
export {
  kdk as default,
  index$3 as kdkCore,
  index as kdkMap
};
